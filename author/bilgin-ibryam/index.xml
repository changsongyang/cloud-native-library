<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bilgin Ibryam | 云原生资料库</title>
    <link>https://lib.jimmysong.io/author/bilgin-ibryam/</link>
      <atom:link href="https://lib.jimmysong.io/author/bilgin-ibryam/index.xml" rel="self" type="application/rss+xml" />
    <description>Bilgin Ibryam</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 16 Oct 2023 11:00:00 +0800</lastBuildDate>
    <image>
      <url>https://lib.jimmysong.io/media/sharing.png</url>
      <title>Bilgin Ibryam</title>
      <link>https://lib.jimmysong.io/author/bilgin-ibryam/</link>
    </image>
    
    <item>
      <title>软件堆栈的商品化：应用为先的云服务如何改变游戏规则</title>
      <link>https://lib.jimmysong.io/blog/dapr-cloud-services/</link>
      <pubDate>Mon, 16 Oct 2023 11:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/dapr-cloud-services/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://www.infoq.com/presentations/dapr-cloud-services/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.infoq.com/presentations/dapr-cloud-services/&lt;/a&gt;，是 Ibryam 今年三月在 QCon London 的分享。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;摘要：软件堆栈的商品化是如何改变应用为先的云服务的游戏规则。通过使用开源项目和 API 将应用程序与集成逻辑绑定在一起，可以实现更高级别的抽象。Dapr 是一组作为 API 公开的分布式基元，可以作为 Sidecar 部署。应用程序云服务将计算和集成能力作为 SaaS 提供，开发人员可以将核心应用程序逻辑绑定到云服务上。这种应用程序优先云服务的出现使得应用程序可以更加专业化，并且可以在不同的云提供商之间灵活迁移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ibryam: 我叫 Bilgin Ibryam。我在这里要告诉大家我对云服务的演变以及这将如何影响我们正在构建的分布式应用的看法。这将是一个快节奏的演讲，我们没有时间深入研究每个技术和模式，而是快速概述架构的演变，并试图分析这对云原生应用的未来可能意味着什么。我是 Diagrid 的产品经理，我们正在为开发人员构建 API。在此之前，我是红帽公司的顾问、架构师和产品经理，在那里我使用了一些项目，比如集成框架 Apache Camel，并对其进行了贡献并撰写了一本书。同样，我也使用过 Kubernetes 作为开发人员，并撰写了一本关于 Kubernetes 的书，您可以从提供的 URL 中免费获得赞助。我们将看看应用是如何从单体应用变成微服务、函数以及即将到来的其他形式的。同时，我们还将看看基础架构是如何演变为云服务的形式，并且它如何塑造应用架构。&lt;/p&gt;
&lt;h2 id=&#34;早期云时代&#34;&gt;早期云时代&lt;/h2&gt;
&lt;p&gt;让我们从回顾云之前和云早期时代开始。在我看过的时间线上，这是微服务运动之前的时代。那是云成为主流之前的时代。这主要是指本地和早期云时代，如早期的 EC2 实例。如果我们看一下当时代表性的应用架构，比如构建在 ESB 平台之上的应用，我们会发现开发人员不得不自己实现或从 ESB 中使用所有东西。这包括与应用程序打包、部署在 SOAR 平台上、甚至在 VM 上放置应用程序等相关的内容。新更新的部署和发布流程。处理基于 SOAP 和 Web 服务甚至 RPC 的同步交互的应用程序的配置和扩展方面。所有这些都是在应用程序内部控制的。当时，我们还没有像断路器模式、mTLS 这样的东西。开发人员负责服务发现、重试、超时、身份验证、授权。在异步交互类别下，我包括通过消息传递的任何形式的交互，这涉及到消息转换、从一种协议连接到另一种协议、连接到各种系统、死信队列。最后，在有状态的模式和工作流程下，通常需要持久状态，包括业务工作流编排或更简单的 Saga 模式实现。幂等消费者、共享分布式日志、定时器、Cron 作业，所有这些模式都需要在应用层内部由开发人员实现。在这个时代，所有这些责任都由应用程序处理。&lt;/p&gt;
&lt;p&gt;那基础设施呢？作为当时的开发人员，我会将基础设施视为一个薄薄的层次，并且对它的期望并不是很高。基础设施会以虚拟机的形式为开发人员提供计算能力，以关系数据库和消息代理的形式提供网络和存储。即使这些也有时会成为 ESB 平台提供的应用层的一部分。那么界面和这两个层次和团队之间的边界是怎样的呢？它以操作系统抽象的形式存在。运维团队会为您提供特定容量的虚拟机，可能还会安装 Java 或某个应用服务器，然后就完成了。会有一张列有静态 IP 和端口号的清单，用来引用其他服务和数据库。这基本上就是在云计算和早期云计算时代的情况了。那时还没有被广泛接受的可用于不同语言和环境的应用格式和 API。从应用开发人员的角度来看，这是一个智能单体和愚蠢静态基础设施的时代。&lt;/p&gt;
&lt;h2 id=&#34;内部架构&#34;&gt;内部架构&lt;/h2&gt;
&lt;p&gt;虽然这是 2010 年之前的最新技术，但随着接下来几年里发生的一些重大软件开发趋势，对应用开发产生了复兴和新的兴趣。这些趋势至今仍然具有影响力。让我们看看它们。软件架构有不同的方面和不同的可视化方式。在流行的方式中，有一种被称为“4+1 架构模型”，它包括逻辑视图、物理视图、过程视图和开发视图。这种技术主要依赖于使用 UML 和图表来可视化这些不同的视图。后来，还出现了另一种流行的软件架构可视化方式，它被称为 C4，由 Simon Brown 创建，它采用更简化的方法，从系统上下文、运行应用程序的容器、构成应用程序的组件、以及类和包的代码级别等层次来看待软件。&lt;/p&gt;
&lt;p&gt;对于这次演讲，我想采用更简单的方式，只谈论应用程序架构的两个层次，我将其称为内部架构和外部架构。内部架构是由开发人员完全控制的一切，包括类、函数、包、应用程序内部的不同层次，甚至是外部系统的抽象。我们可以说内部架构就是放入容器镜像中的所有内容，并且从运维和平台的角度来看，它被视为一个黑盒子。外部架构是应用程序与之交互的一切的集合。这是构成整个系统的其他服务、数据库和云服务。作为运维人员，您必须了解这些外部交互，并确保连接可靠、安全、可观察。与 C4 模型相比，内部架构基本上是级别 1 和 2，即系统上下文和容器，而外部架构基本上是级别 3 和 4，即组件和代码。&lt;/p&gt;
&lt;p&gt;在放置此免责声明后，让我们来看看一些在单体应用程序中发生的值得记忆的影响以及它们如何改变应用程序的内部架构。第一个是域驱动设计，这个术语是由埃里克·埃文斯在他的书《领域驱动设计》中创造的。域驱动设计是一组原则和模式，帮助开发人员封装复杂的业务逻辑，并弥合业务现实与代码之间的差距。虽然这本书是在微服务出现近十年之前写的，但它为微服务奠定了基础，并成为后来微服务的基石，通过帮助开发人员将单体应用程序拆分为代表不同业务领域的较小的松散耦合模块，这些模块由有界上下文表示。我认为下一个重大转变是六边形架构，由阿利斯泰·科克伯恩提出，旨在避免面向对象软件设计中的结构陷阱。这些陷阱包括层之间的不必要的依赖关系以及用户界面与业务逻辑的相互污染。基本上，这种方法通过解耦组件并提供一种标准化的与外部依赖进行交互的方法，改进了三层应用程序的灵活性和可维护性。还有一些相关的思想，如洋葱架构、干净架构，由阿姨鲍勃提出。这些设计模式基本上强调应用程序层内的关注点分离，并将应用程序代码库组织成具有特定职责的不同层。所有这些架构风格都有助于将应用程序的业务逻辑与基础架构分离，并允许开发人员对基础架构进行更改而不影响业务逻辑，反之亦然。&lt;/p&gt;
&lt;p&gt;然后出现了微服务和 12 因素应用程序。基于域驱动设计的思想，如有界上下文、聚合和六边形架构，构建了微服务。微服务基本上允许每个服务独立发布和扩展，以满足不断变化的业务需求。12 因素应用程序方法代表了开发微服务基础应用程序和现代可扩展云应用程序的一组最佳实践。这些想法都建立在前一个想法的基础上，但可能也稍微改变了它。由于这些应用程序开发趋势的结果，在过去的十年中，应用程序的内部架构发生了显着变化。我们之前看到的单体架构变得禁忌，几乎成为反模式，并开始向微服务和函数过渡。&lt;/p&gt;
&lt;h2 id=&#34;计算优先的云时代&#34;&gt;计算优先的云时代&lt;/h2&gt;
&lt;p&gt;当应用程序开发人员忙于从单体架构过渡到微服务时，让我们看看此时基础架构层发生了什么。由于应用程序内部架构和云迁移的所有变化，我们开始看到为微服务提供独立中间件的出现。无论是用于集成中间件（如 Apache Camel、Spring Integration）还是用于工作流编排的项目（如 Conductor、Cadence、Camunda），这些专门的框架开始提供一些微服务的需求，无论是部署在本地还是在云端，它们仍然留在开发人员的领域内。这种转变代表了将集成责任从单体应用程序中分离出来，但由开发人员管理的独立组件。更有趣的是在计算和低级网络层发生了什么。Docker 于 2013 年宣布发布，这在计算抽象层面解锁了巨大的创新。这基本上为运维团队提供了云和计算，例如 Kubernetes 和 lambda。所有这些都意味着运行时责任开始转移到底层平台，并成为运维团队和云服务的责任。对于开发人员来说，它们不再是关注点。&lt;/p&gt;
&lt;p&gt;基于容器的打包意味着可以统一编排使用任何语言编写的应用程序，即执行诸如放置、部署、扩展、配置管理之类的操作，从开发人员的责任转移到运维团队和云服务。它们不再需要开发人员关注。网络也变得更加动态和应用程序化。一些可靠性、服务发现、故障转移、可观察性、路由等职责转移到了平台级别，成为运维团队的责任。我认为这种迅速转变的主要原因之一是我们首次拥有了多语言应用程序特定格式，例如 Docker 和 Kubernetes。这些基本上是在图表上表示的红色框。这些技术弥合了开发人员和运维团队之间的鸿沟，并使用两个团队都使用的共同语言、共同模式、抽象和工具，实现了 DevOps 和 GitOps 等实践。&lt;/p&gt;
&lt;p&gt;我想深入探讨一下在这种情况下应用程序与计算之间的合同。无论您是在 Kubernetes 上将微服务作为容器运行，还是在纯容器服务上运行，或者将其作为无服务器函数运行，应用程序与运行时平台之间都有一定的合同。为了与我们将在后面看到的其他类型的平台区分开，并强调这通常是托管服务或 SaaS 提供的，我将其称为计算云。应用程序与计算云之间的合同是通过 API 交互、配置甚至实践（例如滚动部署）形式存在的。所有这些，我们将其称为计算绑定。让我们看看如何将应用程序与计算层绑定，以及这些 API 是什么。&lt;/p&gt;
&lt;p&gt;假设我们有一个在容器中有一些应用逻辑的微服务。该应用程序有自己的数据库、内部状态，并且可能与其他系统和服务进行通信。这些是外部依赖项。然后，当我们在计算平台上运行这样的应用程序时，最初这两者之间存在一些合同。通过配置界面，无论是 YAML 文件还是其他格式，我们将某些资源需求传递给计算平台，即 Kubernetes 中的 CPU 和内存请求和限制。在 AWS Lambda 的情况下，这是内存请求。我们将使用这两个运行时平台进行比较。我们使用其他配置策略来定义应用程序应该在哪里运行。对于 Lambda 来说，选择区域或在边缘部署 Lambda 的选项。在 Kubernetes 中，有更丰富的配置选项，例如污点、容忍度、亲和性、反亲和性等。还可以有其他元数据，例如标签、环境变量，我们将其传递给计算平台，以便它知道如何配置我们的应用程序。甚至有一定的合同，如何将此配置从平台传递到应用程序，通常是通过环境变量，但也可以通过特定位置的已挂载文件以特定格式传递。还存在生命周期挂钩。平台现在知道如何启动和停止我们的应用程序，并在启动期间触发某些事件，或在关闭之前或其他重要的生命周期阶段触发事件，应用程序可以与之交互。对于 Kubernetes，有启动后事件和停止前事件。对于 Lambda，也有类似的扩展 API，允许应用程序拦截初始化、调用和关闭阶段。然后，平台还有 API 来检查应用程序的健康状况。API 来检查应用程序是否已启动，以及是否需要平台采取任何纠正措施。对于 Kubernetes 来说，这基本上是平台执行的各种健康探测。对于 Lambda 来说，由于 Lambda 运行时间非常短，基本上健康状况是由响应状态决定的，并且决定平台是否应该重试请求。&lt;/p&gt;
&lt;p&gt;然后，每个计算平台还提供了收集日志、指标和跟踪的方式，现在主要基于结构化日志格式、Prometheus 和 OpenTelemetry 基于度量和跟踪。无论您是否意识到这一点，这些都是一些明确和不明确的合同、约定和实践，称为应用程序与计算云之间的计算绑定，无论您使用哪种平台。我将计算云包括在内，还包括了各种服务网格和透明的 mTLS、可靠性和可观察性问题。如果您看看应用程序与平台之间的所有这些 API，我们作为开发人员几乎不需要做什么。也许我们需要实现健康探测 API，确保应用程序被正确地容器化，并且可以启动和关闭。就这些而言，大部分绑定是由运维团队在运行时操作应用程序使用的。所有这些绑定的好处是，如今它们大多受到容器、Kubernetes 和其他开源项目和格式的影响。它们在大多数计算平台、云提供商甚至不同的应用程序架构中都是相当通用的。整体而言，云原生主要关注计算和计算绑定，并且其影响力如此之大。&lt;/p&gt;
&lt;h2 id=&#34;外部架构&#34;&gt;外部架构&lt;/h2&gt;
&lt;p&gt;总而言之，我们研究了应用程序的内部架构是如何从单体架构演变为微服务架构的，并且计算中心的应用程序服务诞生，为应用程序和计算平台之间创建了一种绑定，目前主要由运维团队使用。接下来，我们将看到应用程序的外部架构如何发生变化，也转向云端。我们将研究集成绑定，在本次演讲中，这些是应用程序与其他应用程序云服务、存储层之间的交互集合。这些主要是在应用程序的外部架构中使用的绑定。与计算绑定用于运维团队的情况不同，集成绑定是开发人员在实现应用程序时使用的。同样，我们有我们的容器化应用程序，具有一些内部状态。请注意，当我们查看应用程序的外部架构时，还可以存在应用程序正在与其他第三方系统和服务进行交互的情况。此外，如果您熟悉外部数据的概念，可能还有尚未到达应用程序的状态。该状态可以在工作流引擎中、在 DLQ 中或在重试中。它为此服务指定，但尚未被接受。这是图表上的外部状态，与内部状态一样重要，当我们查看端到端请求流时。这些集成绑定可以是与外部系统的连接器形式。它可以是消息传递和事件逻辑，例如消息重试、过滤器、死信队列、消息延迟、基于内容的路由、处理有毒消息等。所有这些都是集成绑定。它们还可以是服务编排和工作流、Web 钩子和触发器，在特定时间触发应用程序执行特定操作。甚至可以是用于单例组件的分布式日志。基本上，我将开发人员在实现分布式应用程序时必须使用的所有分布式系统模式都归类到此类别中。这些基本上是一系列无差别的技术特性，您必须使用它们来实现应用程序的定制业务逻辑。&lt;/p&gt;
&lt;p&gt;我发现更有趣的是这些集成能力可以存在的位置。与计算绑定类似，借助容器和 Kubernetes，普遍格式，甚至 lambda，运行时管理和网络责任已从应用程序、ESB 转移到由运维或云提供商管理的计算层。同样，我们可以看到一些集成责任正在从应用程序层移动到其自己的层，作为独立的中间件，甚至移动到无服务器云服务中。对于这些集成能力的部署选项，传统方法是将所有这些集成逻辑放在应用程序层内。例如，可以使用 Apache Camel 和 Spring Integration 等项目。Camel 提供了数十种消息模式、连接器的实现，这些都被很好地封装在一个漂亮的 Java DSL 中。这种方法提供了最大的灵活性，但不适用于所有流行的语言，并且将应用程序与集成逻辑或生命周期紧密耦合。另一种极端是将所有集成需求全部转移到类似 AWS EventBridge 的框架中，并将应用程序与其耦合。这些框架，如 EventBridge，基本上是现代无服务器基于云的 ESB。如果使用它，您基本上将应用程序与该提供商的整个生态系统和工具耦合在一起。&lt;/p&gt;
&lt;p&gt;第三种选择是使用事实上的标准、开源项目和 API 来将应用程序与集成逻辑绑定在一起，类似于容器和 Kubernetes 用于计算绑定的方式。这些开放 API 的示例包括 Apache Kafka，其 API 用于流处理。Redis 用于缓存，甚至 AWS S3 用于文件访问，Dapr 用于分布式系统。这些可以部署在本地，因为通常在应用程序本地有一个开源实现，或者它们可以作为云服务使用，并且您甚至可以改变主意来回移动。某些事实上的标准的限制是它们缺乏我在本次演讲中所描述的更高级别抽象。它们主要关注存储访问层。例如，Kafka 用于消息访问，Redis 仅为键值访问，S3 用于云访问。在本次演讲中，我描述的集成绑定不仅仅是存储访问。它们涵盖了高级开发者关注的内容，例如 Dapr 提供的内容。&lt;/p&gt;
&lt;p&gt;我将简要介绍一下 Dapr 是什么。Dapr 是由微软创立并于 2021 年捐赠给 CNCF 的。本质上，Dapr 是一组作为 API 公开的分布式基元，以及作为 Sidecar 部署的。在 Dapr 中，这些能力被称为构建块。它们只是多个实现的 API。例如，有一个状态管理构建块，类似于 Redis API，但它可以有不同的状态存储实现。还有一个类似于 Kafka 的发布/订阅 API，但它有多个实现，比如基于 Kafka、Redis、Amazon SQS、GCP Pub/Sub、RabbitMQ 等。不仅如此，例如发布/订阅 API 可能具有一些其他消息系统所没有的高级功能，但 Dapr 实现了它。例如，DLQs 和过滤，延迟消息传递。基本上，Dapr 实现了我之前讨论的大多数配置绑定，有了有状态的编排模式，这是一个名为 Workflows 的新的 Dapr API。有了 Dapr 中的发布/订阅 API，我之前描述的异步交互。有了 Dapr 中的同步交互，这是 Dapr 中的状态调用 API，等等。在架构方面，Dapr 通常作为 Sidecar 部署，但我们的工作是使其作为 SaaS 工具可用。通过定义良好的 HTTP 和 gRPC API 来使用 Dapr API，无需了解这些 API 的后端实现，这些实现可以由云服务提供商、本地部署或用于开发目的的内存实现提供。&lt;/p&gt;
&lt;p&gt;如果我要将 Dapr 与 Camel 和 EventBridge 进行比较，那么它们之间有很多区别。在耦合方面，Camel 是一个与云无关，但非常与编程语言相关的框架。而 EventBridge 则仅适用于 AWS。Dapr 可以被多种语言在不同的云提供商上使用。它可以作为 Sidecar 与您的应用程序共同部署，并最终作为 SaaS 工具进行使用。某个东西是否与语言和云特定相关不仅仅是关于应用程序的可移植性。一个与云和语言无关的框架允许模式、工具、实践和知识的可移植性，甚至可以在不同的项目、团队和云中共享，从而成为通用知识和事实上的标准。&lt;/p&gt;
&lt;h2 id=&#34;应用优先云&#34;&gt;应用优先云&lt;/h2&gt;
&lt;p&gt;最后，让我们看看这些应用程序云服务是什么，以及它们如何影响我们正在构建的应用程序。我们看到计算云接管了来自开发人员到运维的运行时管理和网络的责任，甚至是托管的云服务。有趣的是，新的计算服务都是关于个别应用程序的。这里我列举了一些 AWS 的服务，但其他云提供商也有类似的服务。这个列表还在不断增长，甚至扩展到边缘。网络服务也变得更加注重应用程序。它们能够理解 HTTP、gRPC 甚至应用程序协议，并为您提供应用层的控制。以类似的方式，我看到了集成云的诞生。集成云基本上是一组托管服务，将集成责任从开发人员身上剥离，并将其作为无服务器能力提供。除了纯存储服务，如 Postgres、MySQL、Kafka、Redis、文件存储外，我还看到了用于处理事件的服务，如 AWS EventBridge、Google Eventarc、Azure Event Grid，以及其他各种变体。还有更多用于有状态编排的服务，如 Step Functions、Temporal Cloud。用于发布/订阅的服务，如 Ably，定时任务服务、Webhooks、数据虚拟化服务、GraphQL 服务等等。所有这些都代表了一个集成云。&lt;/p&gt;
&lt;p&gt;所有这些服务首先是为开发人员创建的，而不是为运维创建的，并且通常是完全托管和无服务器的。在结果架构中，核心应用程序逻辑可以绑定到一个或多个云服务，通过计算和集成 API 进行。其中一些 API 基于开源项目，而一些则是特定于供应商的。开发人员仍然负责在其应用程序中暴露某些 API，并调用集成云的 API，并将其应用程序业务逻辑与该云连接起来。理想情况下，这应该是遵循六边形架构原则完成的，但从更现代的视角来看，使用开放的 API 和格式，而不是原始的进程内方法调用和接口。在这种架构中，计算和集成能力作为 SaaS 进行消费，委托给值得信赖的第三方公司。运维的角色更多地涉及对这些云服务进行管理、安全配置。运维负责实现区分业务逻辑，并重复使用无差异的集成能力作为服务。&lt;/p&gt;
&lt;p&gt;在这里，我们看到更多专业化的应用程序优先云服务，应用程序可以绑定到这些服务。不同的无服务器计算服务、无服务器流量路由服务、事件处理服务、有状态编排服务，理想情况下，一个应用程序不应该绑定到所有这些服务。应用程序应该在同一云区域和云提供商内使用少数服务，并通过开放的 API 进行使用，这样如果需要的话，就可以灵活地迁移到其他地方。在我看来，我们将看到更多的应用程序在云上运行，不仅仅绑定到计算层，也不仅仅绑定到存储层，还绑定到集成层。如果您相信云提供商能够处理数据和计算，为什么不相信它也能处理集成层，只要它具有标准化的边界，实现应用程序和开发人员的可移植性。&lt;/p&gt;
&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;p&gt;最后，为什么所有这些都很重要，这次演讲有哪些主要收获。首先，本次演讲的目标之一是概述应用程序和基础设施在过去二十年的演变。也许这是对未来变化方向的一个指示。就收获而言。首先，您应该使用开放的计算绑定封装应用程序的内部架构，无论是微服务、函数、模块化的单体应用程序，使用容器作为基础。如果您理解容器、它们的生命周期事件、资源约束和健康检查，您就可以快速理解许多计算平台并使用它们，从而受益于整个工具和知识生态系统，而无需重新发明轮子。其次，专注于在应用程序中实现差异化的业务功能，并尝试通过 API 重用无差异的重复分布式功能，就像我们今天对计算和存储所做的那样。归根结底，这归结为可移植性。它很少涉及将应用程序从一个云迁移到另一个云。更多的是关于人员和工具的可移植性。它是从一个项目到另一个项目的可移植性，从一个云到另一个云的可移植性，从一个雇主到另一个雇主的可移植性。我们对于计算层具有这种可移植性，我认为我们也需要对集成层具有同样的可移植性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生绑定应用：一种让开发者专注于业务逻辑的新架构</title>
      <link>https://lib.jimmysong.io/blog/cloud-bound-applications/</link>
      <pubDate>Thu, 16 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/cloud-bound-applications/</guid>
      <description>&lt;p&gt;本文作者 Bilgin Ibryam 是 Diagrid 的技术产品经理，致力于开发人员生产力工具。在此之前，他曾在 Red Hat 担任顾问和架构师，同时也是 Apache 软件基金会的提交者和成员。Bilgin 还与人合著了两本关于 Kubernetes 模式和 Camel 设计模式的书。在业余时间，Bilgin 喜欢通过博客和其他方式写作和分享他的知识。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：本文的原标题是《什么是云原生绑定应用》。本文介绍了云绑定应用程序的概念，并探讨了在使用云绑定应用程序时需要考虑的几个关键因素。首先，作者解释了云绑定应用程序是指在构建应用程序时使用云提供的服务和资源。作者强调了使用云绑定应用程序可以带来很多好处，例如降低成本和提高可靠性。然而，作者也指出了在使用云绑定应用程序时需要考虑的几个关键因素，包括云供应商锁定、数据隐私和网络连接可靠性等。最后，作者提供了一些建议，帮助企业在使用云绑定应用程序时避免潜在的风险。例如，选择具有高可用性的云服务提供商，并在使用云绑定应用程序时加强数据安全措施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;关键要点&#34;&gt;关键要点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;云提供商将重点从基础设施服务转移到开发人员直接使用的应用程序优先服务，从而产生了新的应用程序架构。&lt;/li&gt;
&lt;li&gt;这种架构允许开发人员将集成逻辑和管理责任卸载到云服务，并专注于实现业务逻辑。&lt;/li&gt;
&lt;li&gt;“云绑定”代表了云原生从解决以计算为中心的问题向管理应用集成问题的演进。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放 API 和事实标准将应用程序的内部架构与其外部依赖项分离。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放的 API 和数据格式将应用程序绑定到计算基础设施，并将状态编排、事件驱动的交互和可靠的同步交互等集成责任卸载到云服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序优先云服务的日益普及导致应用程序和云服务的集成比以前更深入。应用程序和云之间的运行时边界正在从虚拟机转移到容器和函数。在这个最终架构中，应用程序是“云绑定”的，通过将更多应用程序逻辑和管理责任卸载到云服务，开发人员可以专注于业务逻辑。&lt;/p&gt;
&lt;p&gt;本文通过使用保持灵活性和可移植性的开放 API 和标准将应用程序绑定到云服务来检查整个软件堆栈的商品化。&lt;/p&gt;
&lt;h2 id=&#34;内部架构演变&#34;&gt;内部架构演变&lt;/h2&gt;
&lt;p&gt;应用程序的内部架构通常由一个团队拥有和控制。根据所选的语言和运行时，包、模块、接口、类和函数等工具和抽象可帮助开发人员控制内部边界。领域驱动设计 (DDD) 帮助开发人员设计领域模型，这些模型作为抽象来封装复杂的业务逻辑并调解业务现实与代码之间的差距。&lt;/p&gt;
&lt;p&gt;Hexagonal，Onion 和 Clean 架构可以补充  DDD 并安排具有不同边界和外部化基础设施依赖性的应用程序代码。尽管这些方法在开始时是创新的并且在今天仍然适用，但它们最初是为三层 Java 应用程序开发的，该应用程序由部署在共享应用程序运行时中的 JSP、Servlet 和 EJB 组成。当时的主要焦点是将应用程序逻辑与 UI 和数据库分离，并启用隔离测试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1内部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1：内部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_df15796544d3641c41413a7e0762e87c.webp 400w,
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_bda3f593a1aeeaa7aefc5304f3419808.webp 760w,
               /blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_df15796544d3641c41413a7e0762e87c.webp&#34;
               width=&#34;760&#34;
               height=&#34;619&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1：内部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从那时起，微服务和十二因素应用程序等新挑战和概念不断涌现，并影响了我们设计应用程序的方式。微服务的核心是将应用程序逻辑分离到由单个团队拥有的可独立部署的单元中。十二因素应用程序方法旨在创建在动态云环境中运行和扩展的分布式、无状态应用程序。所有这些架构都引入了原则和最佳实践，这些原则和最佳实践塑造了我们构建应用程序内部架构的方式以及我们管理它的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2应用程序架构演进时间表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2：应用程序架构演进时间表&#34; srcset=&#34;
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_bf3b668a3da2548818f7d4950c79bb55.webp 400w,
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_4547c53e895ffe872f72f0ba59a89e94.webp 760w,
               /blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/2_hu40b71820fd7baf24807d72301013b030_29518_bf3b668a3da2548818f7d4950c79bb55.webp&#34;
               width=&#34;760&#34;
               height=&#34;278&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2：应用程序架构演进时间表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;后来在应用程序架构演变时间表中，容器的主流采用和 Kubernetes 的引入彻底改变了应用程序的打包和编排方式。AWS Lambda 引入了高度可扩展的函数即服务 (FaaS) 的概念，将应用程序粒度的概念提升到一个新的水平，并将完整的基础设施管理责任卸载给云提供商。其他技术趋势，例如服务网格和多运行时微服务架构，也已经出现并将非功能方面商品化，例如网络和分布式开发原语，分别将它们提取到 sidecar 中。受微服务的启发，数据网格架构旨在将应用程序的分析数据架构分解为更小、独立的数据域，每个域都有自己的产品和团队。这些以及最近的趋势，例如应用程序优先的云服务，正在开始重塑应用程序的外部架构，我在本文中将其统称为“云绑定应用程序”。&lt;/p&gt;
&lt;h2 id=&#34;外部架构演化&#34;&gt;外部架构演化&lt;/h2&gt;
&lt;p&gt;外部架构是应用程序与其他团队和组织拥有的其他应用程序和基础设施相交的地方，通常以专用的本地中间件、存储系统或云服务的形式出现。应用程序连接到外部系统并卸载其部分职责的方式形成了外部架构。为了从基础架构中受益，应用程序需要绑定到该基础架构并强制执行清晰的边界以保持其敏捷性。一个应用程序的内部架构和实现应该能够在不改变另一个应用程序的情况下进行更改，外部依赖关系（例如云服务）可以在不改变内部结构的情况下进行交换。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3外部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3：外部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_20a9750e727f34d326372f52c0225b9b.webp 400w,
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_4956fef84911f343eb2add80f4d827f7.webp 760w,
               /blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/3_huf37fbf5460b713081b06bb34dc5f650c_50572_20a9750e727f34d326372f52c0225b9b.webp&#34;
               width=&#34;622&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3：外部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从广义上讲，我们可以将应用程序与其周围环境绑定的方式分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算绑定是在计算平台（例如 Kubernetes、容器服务，甚至是 AWS Lambda 等无服务器函数）上运行应用程序所需的所有绑定、配置、API 和合约。大多数情况下，这些绑定对内部架构是透明的，并且由运营团队而非开发人员配置和使用。容器抽象是当今应用程序计算绑定最广泛的“API”。&lt;/li&gt;
&lt;li&gt;集成绑定是对应用程序所依赖的外部依赖项的所有其他绑定的总称。云服务还使用这些绑定与应用程序交互，通常是通过定义明确的 HTTP“API”或专门的消息传递和存储访问协议，例如 AWS S3、Apache Kafka、Redis API 等。集成绑定不像运行时绑定那样透明。开发人员需要围绕它们实现额外的逻辑，例如重试、TTL、延迟、死信队列 (DLQ) 等，并将它们绑定到应用程序的业务逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序在云上运行并通过使用这些绑定来使用其他服务。让我们更详细地了解这些绑定背后的内容。&lt;/p&gt;
&lt;h2 id=&#34;计算绑定&#34;&gt;计算绑定&lt;/h2&gt;
&lt;p&gt;对于运营团队来说，理想情况下，每个应用程序都是一个需要在计算平台上运行的黑盒单元。计算绑定用于管理 Kubernetes、AWS Lambda 和其他服务等平台上应用程序的生命周期。这些绑定以应用程序和应用程序运行平台之间的配置和 API 交互集合的形式形式化和定义。这些交互中的大部分对应用程序是透明的，只有少数 API 需要开发人员实现，例如健康端点和指标 API。这是目前 CNCF 对“云原生”定义  和范围的扩展，只要开发者实现云原生应用，他们可以在云计算平台上绑定运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4应用程序和平台计算绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4：应用程序和平台计算绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_8757d39fa9a483b002667b7270c9d101.webp 400w,
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_ec0ac96c3ed0af4f5f841d784cc309c8.webp 760w,
               /blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_8757d39fa9a483b002667b7270c9d101.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4：应用程序和平台计算绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要在云平台上可靠地运行，应用程序必须在从规范到最佳实践的多个层面上与之绑定。这是通过一组行业标准规范（例如容器 API、指标 API）实现的，例如基于 Prometheus、健康端点或云提供商规范（例如 AWS Lambda 或 AWS ECS 规范）。此外，通过云原生最佳技术和共享知识，例如健康检查、部署策略和放置策略。让我们看看当今使用的常见计算绑定。&lt;/p&gt;
&lt;h3 id=&#34;资源需求&#34;&gt;资源需求&lt;/h3&gt;
&lt;p&gt;包括微服务和函数在内的应用程序需要 CPU、内存和存储等资源。这些资源的定义因所使用的平台而异。例如，在 Kubernetes 上，CPU 和内存是通过请求和限制定义的，而在 AWS Lambda 上，用户 指定运行时分配的内存量，以及对应的 CPU 分配。存储在这些平台上的处理方式也不同，Kubernetes 使用临时存储和卷，而 Lambda 提供临时暂存资源和基于 Amazon EFS 挂载的持久存储。&lt;/p&gt;
&lt;h3 id=&#34;生命周期钩子&#34;&gt;生命周期钩子&lt;/h3&gt;
&lt;p&gt;由平台管理的应用程序通常需要了解重要的生命周期事件。例如，在 Kubernetes 上，init 容器等概念和 PostStart 和 PreStop 等钩子允许应用程序对这些事件做出反应。同样，Lambda 的 extensions API 允许应用程序拦截 Init、Invoke 和 Shutdown 阶段。处理生命周期事件的其他选项包括包装器脚本或特定于语言的运行时修改选项，例如 JVM 的关闭钩子。这些机制形成了平台和应用程序之间的契约，使其能够响应和管理自己的生命周期。&lt;/p&gt;
&lt;h3 id=&#34;健康检查&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;运行状况探测是平台监控应用程序运行状况并在必要时采取纠正措施（例如重新启动应用程序）的一种方式。由于请求的生命周期较短，Lambda 函数没有健康探测，而容器化应用程序和编排器（如 Kubernetes、AWS EKS 和 GCP Cloud Run）确实在其定义中包含 健康探测。这使平台能够确保应用程序平稳运行，并在应用程序运行不平稳时采取措施。&lt;/p&gt;
&lt;h3 id=&#34;部署和放置策略&#34;&gt;部署和放置策略&lt;/h3&gt;
&lt;p&gt;一旦知道所需的资源，计算平台就可以开始管理应用程序的生命周期。要以不损害业务逻辑完整性的方式执行此操作，平台必须了解扩展约束。有些应用程序被设计为单例。例如，它们需要维护已处理事件的顺序并且不能扩展到多个实例。其他有状态应用程序可能是仲裁驱动的，并且需要特定数量的最小实例连续运行才能正常运行。还有一些函数，例如无状态函数，可能有利于快速扩展以解决不断增加的负载峰值问题。一旦建立了应用程序的缩放指南，平台就会控制应用程序实例的启动和终止。&lt;/p&gt;
&lt;p&gt;计算还提供滚动、蓝绿、金丝雀、一次等多种部署策略，来控制服务更新的顺序。除了部署顺序之外，这些平台还允许用户指定放置首选项。例如，Kubernetes 提供标签、污点和容忍度、亲和力和反亲和力等选项，而 Lambda 允许用户在区域和边缘放置类型之间进行选择。这些首选项可确保部署应用程序并满足合规性和性能要求。&lt;/p&gt;
&lt;h3 id=&#34;网络流量&#34;&gt;网络流量&lt;/h3&gt;
&lt;p&gt;计算平台还负责将低级网络流量引导至服务实例。这是因为它负责部署排序、放置和自动缩放，这些都会影响流量如何定向到服务实例。健康检查也可以在流量管理中发挥作用，例如 GCP Cloud Run 和 Kubernetes 中的准备情况检查。通过处理这些任务，计算平台有助于确保流量高效且有效地路由到适当的服务实例。&lt;/p&gt;
&lt;h3 id=&#34;监控和报告&#34;&gt;监控和报告&lt;/h3&gt;
&lt;p&gt;任何用于分布式应用程序的计算平台都必须以日志、指标和跟踪的形式提供深入的应用程序洞察力。目前该领域几乎没有被广泛接受的事实标准：日志最好以结构化格式使用，例如 JSON 或其他行业特定标准。计算平台通常收集日志或为专门的日志提取和分析服务提供扩展点以访问日志。这可以是 Kubernetes 上的 DaemonSet，用于监控的 Lambda 合作伙伴扩展，或 Vercel 边缘功能日志 Drainer。计算平台必须支持指标和追踪数据的收集和分析，以全面了解分布式应用程序的性能和行为。有几种行业标准格式和工具可用于处理此数据 OpenTelemetry (OTEL) for Tracking 计算平台可以提供内置工具来收集和分析这些数据，或者为专门服务提供扩展点来访问数据。无论代码粒度（微服务或函数）或位置（边缘或非边缘）如何，计算平台都必须允许捕获日志、指标和追踪数据，并导出到其他同类最佳的云服务。例如 Honeycomb、DataDog、Grafana 等。&lt;/p&gt;
&lt;h3 id=&#34;计算绑定趋势&#34;&gt;计算绑定趋势&lt;/h3&gt;
&lt;p&gt;计算绑定与语言和应用程序运行时无关，主要由运营团队用于在运行时管理应用程序，而不是开发人员实现它们。&lt;/p&gt;
&lt;p&gt;虽然应用程序的大小和复杂性可能因整体和功能而异，但它们通常打包在具有健康检查端点、实施的生命周期挂钩和公开指标的容器中。了解这些计算绑定将帮助你有效地使用任何基于容器的计算平台，无论是本地 Kubernetes 集群、托管容器服务（例如 AWS ECS、Google Cloud Run、Azure Container App），还是基于函数的运行时（例如作为 AWS Lambda、GCP 函数或边缘运行时，例如 Vercel 边缘函数、CloudFlare worker 或 Netlify edge functions 等。使用开放的事实上的标准 API 不仅可以帮助你创建可移植的应用程序，还可以通过使用可跨云供应商和服务提供商移植的操作实践和工具来限制供应商锁定。&lt;/p&gt;
&lt;h2 id=&#34;集成绑定&#34;&gt;集成绑定&lt;/h2&gt;
&lt;p&gt;另一方面，集成绑定旨在供开发人员而不是运营团队使用。它们以常见的分布式系统实现领域为中心，例如服务调用、事件驱动交互、任务调度和有状态工作流编排。它们通过基于云的类似中间件的服务帮助将应用程序与专用存储系统和外部系统连接起来，在本文中统称为集成云。与容器提供计算抽象的方式相同，集成云服务提供与语言无关的集成抽象作为服务。这些原语独立于用例、应用程序实现、运行时和计算环境。例如重试模式、DLQ 模式、Saga 模式、服务发现和 断路器模式都可以集成为服务使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5应用程序和平台集成绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5：应用程序和平台集成绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_d8bf9e364f58b2f09b5f0902a734a2a2.webp 400w,
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_36cc25a7a9c022f4b9694728d36a7cb2.webp 760w,
               /blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/5_hufb20aa7c61dad71a4c335dca460c4126_61270_d8bf9e364f58b2f09b5f0902a734a2a2.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5：应用程序和平台集成绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天不存在将所有主要模式公开为独立功能的纯集成云。早期的云服务正在提供其中一些集成原语作为存储系统（如 Kafka、Redis 等）的功能，但这些功能很少单独使用或与其他功能结合使用。这里值得注意的例外是 AWS EventBridge 和 Azure Event Grid 等服务，你可以将它们与来自同一提供商的多个云服务一起使用，但不能直接与其他提供商一起使用。这是一个快速发展的领域，有一些很好的例子和一些尚未填补的空白，但我相信它们会在未来出现。应用程序必须绑定到集成的云服务并卸载其中的一些开发人员职责才能运行。以下是集成云服务的主要类型和绑定方面。&lt;/p&gt;
&lt;h3 id=&#34;集成要求&#34;&gt;集成要求&lt;/h3&gt;
&lt;p&gt;与应用程序可以请求资源并向计算平台表达部署和放置偏好的方式相同，应用程序也可以请求和激活特定的集成绑定。这些绑定可以通过以声明方式传递给平台的配置来激活，或者在运行时通过编程交互来激活。例如，应用程序可以使用声明式和编程式订阅 pub/sub 主题。AWS Lambda 函数事件源可以通过配置以声明方式订阅，也可以通过客户端库或 SDK 请求集成平台注册或注销特定绑定以编程方式订阅。应用程序可以订阅 cron 作业触发器、激活外部系统的连接器、进行配置更改等等，所有这些都在集成云上运行。&lt;/p&gt;
&lt;h3 id=&#34;工作流程编排&#34;&gt;工作流程编排&lt;/h3&gt;
&lt;p&gt;持久服务编排逻辑是一种非常普遍的必需品，也是作为服务进行外部化和消费的主要候选者。因此，工作流编排是当今最著名的集成绑定类型之一。该服务的常见用途包括为服务和业务流程编排实施 Saga 模式、使用 AWS Step Functions、Google Stateful Functions、Azure Durable Functions 进行函数编排、使用 Google Workflow 进行任务分配等等。当使用这样的绑定时，部分应用程序编排状态和逻辑被卸载到另一个服务中。虽然应用程序服务具有内部状态和管理该状态的逻辑，但其他部分是外部的，可能在其他一些云服务中。这代表了当今应用程序作为一个独立的单元进行设计和操作的方式的转变。未来的应用程序不仅数据是外部的，而且集成也将是外部的。随着越来越多地采用集成云，更多的集成数据和逻辑将开始存在于外部。&lt;/p&gt;
&lt;h3 id=&#34;时间触发器&#34;&gt;时间触发器&lt;/h3&gt;
&lt;p&gt;时间绑定表示编排绑定的时间限制专业化。它只有一个目标，即根据给定的策略在特定时间触发各种服务。此类别中的示例包括 AWS EventBridge Scheduler、Google Cloud Scheduler、Upstash Qstack 服务等。&lt;/p&gt;
&lt;h3 id=&#34;事件驱动和消息服务&#34;&gt;事件驱动和消息服务&lt;/h3&gt;
&lt;p&gt;这些绑定充当事件存储来卸载请求和解耦应用程序，但它们越来越不限于存储和扩展以提供消息处理模式。它们在事件存储之上提供开发者原语，例如死信队列、重试、延迟传递和消息处理模式，例如过滤、聚合、重新排序、基于内容的路由、窃听等。这种绑定的例子有 Confluent Cloud kSQL、AWS EventBridge、Decodable Data Pipeline 等。&lt;/p&gt;
&lt;h3 id=&#34;外部连接器&#34;&gt;外部连接器&lt;/h3&gt;
&lt;p&gt;这些绑定有助于连接到外部系统。它们还执行数据规范化、错误处理、协议转换和数据转换。示例包括 Knative 源导入器、AWS EventBridge 连接器、Confluent Cloud 连接器、可解码的 Kafka 连接器、AWS Lambda 源和目标。&lt;/p&gt;
&lt;h3 id=&#34;健康检查-1&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;健康检查对于计算连接至关重要，失败的健康检查通常会导致应用程序重启。集成绑定也需要健康检查，但目的不同：集成健康检查不会影响应用程序的运行时，但它会告诉集成云应用程序是否能够处理集成驱动的交互。失败的集成状态检查会停止集成绑定，直到应用程序返回正常状态并且集成绑定恢复。通常，你可以使用相同的应用程序端点进行计算和集成绑定测试。一个很好的例子是 Dapr 应用程序 健康检查，它可以暂时阻止消费者和连接器。将数据插入不健康的应用程序。&lt;/p&gt;
&lt;h3 id=&#34;其他绑定&#34;&gt;其他绑定&lt;/h3&gt;
&lt;p&gt;还有更多的绑定，属于集成绑定的范畴。例如，Kubernetes Downward API 和 Lambda 环境变量等为应用程序提供内省数据，它为应用程序自省和元数据注入提供了一种简单的机制。配置和秘密绑定，其中秘密不仅在启动时注入到应用程序中，而且任何配置更新都通过 sidecars 推送到应用程序，例如 Hashicorp Vault Sidecar Injector 或者 Dapr 的 Configuration API, Kubernetes 的 Service Binding 设置 规范。和不太常见的模式，例如分布式锁，这也是一个集成绑定提供对共享资源的互斥访问。&lt;/p&gt;
&lt;h3 id=&#34;集成绑定趋势&#34;&gt;集成绑定趋势&lt;/h3&gt;
&lt;p&gt;容器正在成为最流行和广泛使用的可移植格式，用于打包和运行应用程序，无论它们是长期运行的微服务还是短期功能。另一方面，集成绑定可以分为不同的问题域，例如事件驱动的交互、有状态的编排和状态访问，并且在底层存储和使用模式方面有所不同。例如，Apache Kafka 是 事实上的标准、用于文档访问的 AWS S3 API、用于键值缓存的 Redis、用于关系数据访问的 PostgreSQL 等等。使它们成为标准的是围绕它们构建的库、工具和服务的不断增长的生态系统，为成熟度、稳定性和未来的向后兼容性提供了很大程度的保证。但这些 API 本质上仅限于存储访问，并且通常需要开发人员解决应用程序代码中的分布式系统挑战。与堆栈上层软件的商品化一致，集成绑定作为服务提供。越来越多的无服务器云服务提供了额外的集成功能，除了数据访问之外，应用程序代码还可以绑定这些功能。&lt;/p&gt;
&lt;p&gt;在此模型中，云绑定应用程序通常在无服务器计算基础设施上运行，遵循云原生原语。它与其他无服务器云服务绑定，用于服务编排、事件处理或同步交互，如下所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6云绑定应用程序生态系统&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6：云绑定应用程序生态系统&#34; srcset=&#34;
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_00bb2daef51a9f499f02107b5b006301.webp 400w,
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_2a597427cb8ea2d710a43b0d2a9fe03a.webp 760w,
               /blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_00bb2daef51a9f499f02107b5b006301.webp&#34;
               width=&#34;760&#34;
               height=&#34;638&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6：云绑定应用程序生态系统
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CNCF 的 Dapr 是一个将大部分集成绑定和开发人员关注点整合到一个开源 API 中的项目。它提供同步服务调用、有状态服务编排、异步事件驱动交互和特定技术连接器作为 API。类似于容器和 Kubernetes 如何充当计算抽象，Dapr 充当外部服务的抽象。Dapr 还提供了独立于底层云服务且往往必须在应用层实现的集成能力，例如弹性策略、死信队列、延迟交付、跟踪、细粒度授权等。Dapr 被设计为多语言并在应用程序外部运行，从而可以轻松交换外部依赖项而无需更改应用程序的内部架构，如 Hexagon Architecture 中所述。虽然 Dapr 主要由实施应用程序的开发人员使用，但一旦引入，Dapr 就会增强分布式应用程序的可靠性和可见性，为运营和架构师团队提供 整体利益。要了解有关此主题的更多信息，请在今年晚些时候亲自或以虚拟方式参加 QConLondon，我将在那里讨论“应用程序优先的云服务如何改变游戏规则”。&lt;/p&gt;
&lt;h2 id=&#34;后云原生应用&#34;&gt;后云原生应用&lt;/h2&gt;
&lt;p&gt;云绑定应用代表了云原生的进步，从只解决计算问题到管理应用层需求。应用程序堆栈中的云服务从基础设施扩展到应用程序优先服务，加速了这一趋势。我们可以在以开发人员为中心的云服务的爆炸式增长中观察到这种转变，包括状态协调、事件驱动的应用程序基础架构、同步交互、基于云的开发和测试环境以及无服务运行时。这种向应用程序优先的云服务的转变正在产生一种新的应用程序架构，越来越多的应用程序逻辑在云服务中运行。应用程序与第三方云服务的这种混合允许开发人员分担更多责任，但是，它可能会限制不断变化的业务需求所需的灵活性和敏捷性。为了保持应用程序的内部和外部架构独立，应用程序和云服务需要在开发时通过清晰的边界解耦，并在运行时使用定义良好的开放 API 和格式进行深度绑定。正如容器和 Kubernetes 为计算提供了开放的 API，我们需要为应用程序集成抽象提供开放的 API。这将使操作实践和工具以及开发模式、功能和实践的可移植性和重用成为可能。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
