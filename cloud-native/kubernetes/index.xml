<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes | 云原生资料库</title>
    <link>https://jimmysong.io/docs/cloud-native/kubernetes/</link>
      <atom:link href="https://jimmysong.io/docs/cloud-native/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <description>Kubernetes</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 03 May 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://jimmysong.io/docs/media/logo.svg</url>
      <title>Kubernetes</title>
      <link>https://jimmysong.io/docs/cloud-native/kubernetes/</link>
    </image>
    
    <item>
      <title>Kubernetes 的历史</title>
      <link>https://jimmysong.io/docs/cloud-native/kubernetes/history/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://jimmysong.io/docs/cloud-native/kubernetes/history/</guid>
      <description>&lt;p&gt;众所周知，&lt;a href=&#34;http://kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 是 Google 于 2014 年 6 月基于其内部使用的 &lt;a href=&#34;https://research.google.com/pubs/pub43438.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg&lt;/a&gt; 系统开源出来的容器编排调度引擎。其实从 2000 年开始，Google 就开始基于容器研发三个容器管理系统，分别是 Borg、Omega 和 Kubernetes。这篇由 Google 工程师 Brendan Burns、Brian Grant、David Oppenheimer、Eric Brewer 和 John Wilkes 几人在 2016 年发表的&lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Borg, Omega, and Kubernetes》&lt;/a&gt;论文里，阐述了 Google 从 Borg 到 Kubernetes 这个旅程中所获得知识和经验教训。&lt;/p&gt;
&lt;h2 id=&#34;borgomega-和-kubernetes&#34;&gt;Borg、Omega 和 Kubernetes&lt;/h2&gt;
&lt;p&gt;Google 从 2000 年初就开始使用容器（Linux 容器）系统，Google 开发出来的第一个统一的容器管理系统在内部称之为 “Borg”，用来管理长时间运行的生产服务和批处理服务。由于 Borg 的规模、功能的广泛性和超高的稳定性，一直到现在 Borg 在 Google 内部依然是主要的容器管理系统。&lt;/p&gt;
&lt;p&gt;Google 的第二套容器管理系统叫做 Omega，作为 Borg 的延伸，它的出现是出于提升 Borg 生态系统软件工程的愿望。Omega 应用到了很多在 Borg 内已经被认证的成功的模式，但是是从头开始来搭建以期更为一致的构架。由于越来越多的应用被开发并运行在 Borg 上，Google 开发了一个广泛的工具和服务的生态系统。它被应用到了很多在 Borg 内已经被认证的成功的模式，但是是从头开始来搭建以期更为一致的构架。这些系统提供了配置和更新 job 的机制，能够预测资源需求，动态地对在运行中的程序推送配置文件、服务发现、负载均衡、自动扩容、机器生命周期管理、额度管理等。许多 Omega 的创新（包括多个调度器）都被收录进了 Borg。&lt;/p&gt;
&lt;p&gt;Google 的第三套容器管理系统就是我们所熟知的 Kubernetes，它是针对在 Google 外部的对 Linux 容器感兴趣的开发者以及 Google 在公有云底层商业增长的考虑而研发的。和 Borg、Omega 完全是谷歌内部系统相比，Kubernetes 是开源的。像 Omega 一样，Kubernetes 在其核心有一个被分享的持久存储，有组件来检测相关 object 的变化。跟 Omega 不同的是，Omega 把存储直接暴露给信任的控制平面的组件，而在 Kubernete 中，提供了完全由特定领域更高层面的版本控制、认证、语义、策略的 REST API 接口，以服务更多的用户。更重要的是，Kubernetes 是由一群底层开发能力更强的开发者开发的，他们主要的设计目标是用更容易的方法去部署和管理复杂的分布式系统，同时仍能从容器提升的效率中受益。&lt;/p&gt;
&lt;p&gt;2014 年 Kubernetes 正式开源，2015 年被作为初创项目贡献给了云原生计算基金会（CNCF），从此开启了 Kubernetes 及云原生化的大潮。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://queue.acm.org/detail.cfm?id=2898444&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg, Omega, and Kubernetes: Lessons learned from three container-management systems over a decade - queue.acm.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dockone.io/article/1153&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg、Omega 和 Kubernetes：谷歌十几年来从这三个容器管理系统中得到的经验教训 - dockone.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Sidecar 模式</title>
      <link>https://jimmysong.io/docs/cloud-native/kubernetes/sidecar-pattern/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://jimmysong.io/docs/cloud-native/kubernetes/sidecar-pattern/</guid>
      <description>&lt;p&gt;将应用程序的功能划分为单独的进程运行在同一个最小调度单元中（例如 Kubernetes 中的 Pod）可以被视为 &lt;strong&gt;sidecar 模式&lt;/strong&gt;。如下图所示，sidecar 模式允许您在应用程序旁边添加更多功能，而无需额外第三方组件配置或修改应用程序代码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sidecar-模式示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jimmysong.io/kubernetes-handbook/images/sidecar-pattern.jpg&#34; alt=&#34;Sidecar 模式示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Sidecar 模式示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;就像连接了 Sidecar 的三轮摩托车一样，在软件架构中， Sidecar 连接到父应用并且为其添加扩展或者增强功能。Sidecar 应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观察性、监控、日志记录、配置、断路器等功能。&lt;/p&gt;
&lt;h3 id=&#34;使用-sidecar-模式的优势&#34;&gt;使用 Sidecar 模式的优势&lt;/h3&gt;
&lt;p&gt;使用 sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 sidecar 副本。在 sidecar 部署方式中，每个应用的容器旁都会部署一个伴生容器，这个容器称之为 sidecar 容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边注入一个 Sidecar 容器，两个容器共享存储、网络等资源，可以广义的将这个包含了 sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。&lt;/p&gt;
&lt;p&gt;因其独特的部署结构，使得 sidecar 模式具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度。&lt;/li&gt;
&lt;li&gt;因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。&lt;/li&gt;
&lt;li&gt;Sidecar 可独立升级，降低应用程序代码和底层平台的耦合度。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
