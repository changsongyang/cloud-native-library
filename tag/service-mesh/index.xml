<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Service Mesh | 云原生资料库</title>
    <link>https://jimmysong.io/docs/tag/service-mesh/</link>
      <atom:link href="https://jimmysong.io/docs/tag/service-mesh/index.xml" rel="self" type="application/rss+xml" />
    <description>Service Mesh</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Thu, 09 Dec 2021 21:03:00 +0800</lastBuildDate>
    <image>
      <url>https://jimmysong.io/docs/media/logo.svg</url>
      <title>Service Mesh</title>
      <link>https://jimmysong.io/docs/tag/service-mesh/</link>
    </image>
    
    <item>
      <title>告别 Sidecar——使用 eBPF 解锁内核级服务网格</title>
      <link>https://jimmysong.io/docs/translation/ebpf-solve-service-mesh-sidecar/</link>
      <pubDate>Thu, 09 Dec 2021 21:03:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/translation/ebpf-solve-service-mesh-sidecar/</guid>
      <description>&lt;p&gt;译者注：本文作者是 Isovalent 联合创始人&amp;amp;CTO，原文标题 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How eBPF will solve Service Mesh - Goodbye Sidecars&lt;/a&gt;，作者回顾了Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;随着分布式应用的引入，额外的可见性、连接性和安全性要求也浮出水面。应用程序组件通过不受信任的网络跨越云和集群边界进行通信，负载均衡、弹性变得至关重要，安全必须发展到发送者和接收者都可以验证彼此的身份的模式。在分布式应用的早期，这些要求是通过直接将所需的逻辑嵌入到应用中来解决的。服务网格将这些功能从应用程序中提取出来，作为基础设施的一部分提供给所有应用程序使用，因此不再需要修改每个应用程序。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务网格示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务网格示意图&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_2f4c949f5635907beff63e8337d6f76c.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_17137669c2ea72adc4c86b6f1c92847f.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_2f4c949f5635907beff63e8337d6f76c.webp&#34;
               width=&#34;760&#34;
               height=&#34;253&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务网格示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;纵观今天服务网格的功能设置，可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;弹性连接&lt;/strong&gt;：服务与服务之间的通信必须能够跨越边界，如云、集群和场所。通信必须是有弹性的和容错的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L7 流量管理&lt;/strong&gt;：负载均衡、速率限制和弹性必须是 L7 感知的（HTTP、REST、gRPC、WebSocket 等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于身份的安全&lt;/strong&gt;：依靠网络标识符来实现安全已经不够了，发送和接收服务都必须能够根据身份而不是网络标识符来验证对方。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可观察性和跟踪&lt;/strong&gt;：追踪和指标形式的可观察性对于理解、监控和排除应用程序的稳定性、性能和可用性至关重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明&lt;/strong&gt;：该功能必须以透明的方式提供给应用程序，即不需要改变应用程序代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在早期，服务网格的功能通常是以库的形式实现的，要求网格中的每个应用程序都要链接到以应用程序的语言框架编写的库。类似的事情也发生在互联网的早期：曾几何时，应用程序还需要运行自己的 TCP/IP 协议栈！正如我们将在这篇文章中讨论的那样，服务网格正在发展成为一种内核责任，就像网络堆栈一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于库的服务网格模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于库的服务网格模型&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_dc28956fcdaa8533c1e80646c297a1af.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_95551f04e0dbe65f3378e151db58034e.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_dc28956fcdaa8533c1e80646c297a1af.webp&#34;
               width=&#34;760&#34;
               height=&#34;247&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于库的服务网格模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天，服务网格通常使用一种叫做 sidecar 模型的架构来实现。这种架构将实现上述功能的代码封装到第四层代理中，服务间的流量被重定向到这个所谓的 sidecar 代理。它之所以被称为 “挎斗”，是因为每个应用程序都有一个代理，就像挎斗附着在摩托车上一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-sidecar-的服务网格模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 Sidecar 的服务网格模型&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_0d600138e96a481444eae67391d42740.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_a407f59981107c732d11d0d70af1a165.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_0d600138e96a481444eae67391d42740.webp&#34;
               width=&#34;760&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 Sidecar 的服务网格模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种架构的优点是，服务不再需要自己实现服务网格的功能。如果许多服务是用不同的语言编写部署的，或者如果你正在运行不可变的第三方应用程序，这就很有好处。&lt;/p&gt;
&lt;p&gt;这种模式的缺点是有大量的代理，许多额外的网络连接，以及复杂的重定向逻辑，将网络流量输入代理。除此之外，在什么类型的网络流量可以被重定向到第四层代理上也有限制。代理（Proxy）在其能支持的网络协议方面是有限的。&lt;/p&gt;
&lt;h2 id=&#34;连接性转移到内核中的历史&#34;&gt;连接性转移到内核中的历史&lt;/h2&gt;
&lt;p&gt;几十年来，在应用程序之间提供安全可靠的连接一直是操作系统的责任。有些人可能还记得早期 Unix 和 Linux 时代的 &lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_Wrappers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCP 包装器&lt;/a&gt;和 tcpd。tcpd 允许用户在不修改应用程序的情况下透明地添加日志、访问控制、主机名验证和欺骗保护。它使用了 libwrap，而且，在一个有趣的平行于服务网格的故事中，这个库也是以前应用程序提供这些功能的链接对象。tcpd 所带来的是能够在不修改现有应用程序的情况下将这些功能透明地添加到现有应用程序中。最终，所有这些功能都进入了 Linux 本身，并以一种更有效、更强大的方式提供给所有应用程序。今天，这已经发展到了我们所知道的 iptables。&lt;/p&gt;
&lt;p&gt;然而，iptables 显然不适合解决现代应用的连接性、安全性和可观察性要求，因为它只在网络层面上操作，对应用协议层缺乏任何了解。自然，阻力最小的路径是回到库模型，然后是 sidecar 模型。现在，我们正处于这样一个阶段：为了最佳的透明度、效率和安全性，在操作系统中原生地支持这种模式是有意义的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务网格的进化&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务网格的进化&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_9bd5af9f2b4e222bd3c4020df3f9c9da.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_8944ed8b5c9c12d06d4e019d777f3674.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_9bd5af9f2b4e222bd3c4020df3f9c9da.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务网格的进化
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 tcpd 时代，曾经的连接记录现在是追踪。IP 层面的访问控制已经演变成应用协议层面的授权，例如使用 JWT。主机名验证已被更强大的认证所取代，如 mTLS。网络负载均衡已经扩展到 L7 流量管理。HTTP 重试是新的 TCP 重传。过去用黑洞路由解决的问题今天被称为断路。这些都不是根本性的新问题，但所需的环境和控制已经发生了变化。&lt;/p&gt;
&lt;h2 id=&#34;扩展内核命名空间概念&#34;&gt;扩展内核命名空间概念&lt;/h2&gt;
&lt;p&gt;Linux 内核已经有一个概念，可以共享共同的功能，并使其对系统上运行的许多应用程序可用。这个概念被称为命名空间（Namespace），它构成了我们今天所知的容器技术的基础。命名空间（内核的那种，不是 Kubernetes 的命名空间）存在于各种抽象中，包括文件系统、用户管理、挂载设备、进程、网络等。这就是允许单个容器呈现不同的文件系统视图、不同的用户集，以及允许多个容器绑定到单个主机上的同一网络端口。在 cgroups 的帮助下，这个概念得到了扩展，可以对 CPU、内存和网络等资源进行管理和优先排序。从云原生应用开发者的角度来看，cgroups 和资源被紧密地整合到我们所知的 &amp;ldquo;容器&amp;rdquo; 概念中。&lt;/p&gt;
&lt;p&gt;符合逻辑的是，如果我们认为服务网格是操作系统的责任，那么它必须符合并整合命名空间和 cgroup 的概念。这看起来会是这样的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-service-mesh-namespace&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Service Mesh Namespace&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_16f30dbdeb4ebf1dd12714c687c97308.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_ca4f06178231f71ce281e8690fd8ece5.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_16f30dbdeb4ebf1dd12714c687c97308.webp&#34;
               width=&#34;760&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Mesh Namespace
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;不出所料，这看起来非常自然，而且可能是大多数用户从简单的角度所期望的。应用程序保持不变，它们继续使用套接字进行通信，就像以前那样。理想的服务网格是作为 Linux 的一部分透明地提供的。它就在那里，就像今天的 TCP 一样。&lt;/p&gt;
&lt;h3 id=&#34;注入-sidecar-的成本&#34;&gt;注入 Sidecar 的成本&lt;/h3&gt;
&lt;p&gt;如果我们仔细研究一下 sidecar 模型，我们会发现它实际上是在试图模仿这种模型。应用程序继续使用套接字，一切都被塞进 Linux 内核的网络命名空间。然而，这比它看起来要复杂得多，需要许多额外的步骤来透明地注入 sidecar 代理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-注入-sidecar-的成本&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;注入 Sidecar 的成本&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_73d4c803cb891797200a45777fbad536.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_230fa8022744b20b7f78ac0299625e07.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_73d4c803cb891797200a45777fbad536.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      注入 Sidecar 的成本
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种额外的复杂性在延迟和额外资源消耗方面付出了巨大的代价。早期的基准测试表明，这对延迟的影响高达 3-4 倍，而且所有代理都需要大量的额外内存。在这篇文章的后面，我们将研究这两点，因为我们将其与基于 eBPF 的模型进行比较。&lt;/p&gt;
&lt;h2 id=&#34;用-ebpf-解锁内核服务网格&#34;&gt;用 eBPF 解锁内核服务网格&lt;/h2&gt;
&lt;p&gt;为什么我们以前没有在内核中创建一个服务网格？有些人半开玩笑地说，kube-proxy 是最初的服务网格（见&lt;a href=&#34;https://www.youtube.com/watch?v=lUF88T16YqY&amp;amp;ab_channel=CloudNativeRejekts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们已经构建了相当多的服务网格 - Tim Hockin, Google&lt;/a&gt;）。这句话是有一定道理的。Kube-proxy 是一个很好的例子，说明了 Linux 内核在依靠传统的基于网络的 iptables 功能实现服务网格时，可以达到多么接近。然而，这还不够，L7 上下文是缺失的。Kube-proxy 完全在网络数据包层面运作。现代应用需要 L7 流量管理、跟踪、认证和额外的可靠性保证。Kube-proxy 不能在网络层面上提供这些。&lt;/p&gt;
&lt;p&gt;eBPF 改变了这个模式。它允许动态地扩展 Linux 内核的功能。我们一直在使用 eBPF 为 Cilium 建立一个高效的网络、安全和可观察性数据通路，并将其直接嵌入到 Linux 内核。应用这个相同的概念，我们也可以在内核层面上解决服务网格的要求。事实上，Cilium 已经实现了各种所需的概念，如基于身份的安全、L3-L7 可观察性和授权、加密和负载均衡。缺少的部分现在正在向 Cilium 涌来。在本博客的末尾，你会发现如何加入由 Cilium 社区推动的 Cilium 服务网格测试项目的细节。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-服务网格架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF 服务网格架构&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_ec64207fe64f13ddab54f26766098829.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_0b120b1c08842e3408423ebcee010fc8.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_ec64207fe64f13ddab54f26766098829.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 服务网格架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有人可能想知道为什么 Linux 内核社区不直接解决这些需求&lt;/strong&gt;。eBPF 有一个巨大的优势，eBPF 代码可以在运行时插入到现有的 Linux 内核中，类似于 Linux 内核模块，但与内核模块不同，它可以以安全和可移植的方式进行。这使得 eBPF 的实现能够随着服务网格社区的发展而继续发展。&lt;strong&gt;新的内核版本需要几年时间才能进入用户手中&lt;/strong&gt;。eBPF 是一项关键技术，它使 Linux 内核能够跟上快速发展的云原生技术栈。&lt;/p&gt;
&lt;h2 id=&#34;无-sidecar-的基于-ebpf-的-l7-追踪和度量&#34;&gt;无 Sidecar 的基于 eBPF 的 L7 追踪和度量&lt;/h2&gt;
&lt;p&gt;让我们看看 L7 追踪和指标可观察性，作为一个具体的例子，说明基于 eBPF 的服务网格对保持低延迟和提高观察性有巨大的影响。应用程序团队依靠应用程序的可见性和监控作为基本要求这些，这包括请求跟踪、HTTP 响应率和服务延迟信息等能力。然而，这种可观察性应该没有明显的成本（延迟、复杂性、资源…）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的可视性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的可视性&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_3c5ffec4c37ab13904b7ad3f8850c40b.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_9df96ff7ec97749415a91faf059c43e6.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_3c5ffec4c37ab13904b7ad3f8850c40b.webp&#34;
               width=&#34;760&#34;
               height=&#34;241&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的可视性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在下面的基准测试中，我们可以看到早期的测量结果，即通过 eBPF 或 sidecar 方法实现 HTTP 可见性对延迟的影响。该设置是在两个不同节点上运行的两个 pod 之间通过固定数量的连接每秒稳定运行 10K 个 HTTP 请求，并测量请求的平均延时。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的延迟基准测试-vs-基于-sidecar-的-l7-可视性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_7cf7567252f38f870003e2bdc6cfef48.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_9a381eb32592d94bdcc1720e2bf4a21c.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_7cf7567252f38f870003e2bdc6cfef48.webp&#34;
               width=&#34;760&#34;
               height=&#34;347&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们故意不提这些测量中使用的具体代理，因为它并不重要。对于我们测试过的所有代理，结果几乎都是一样的。要明确的是，这不是关于 Envoy、Linkerd、Nginx 或其他代理是否更快。所提到的代理有差异，但与首先注入代理的成本相比，它们是微不足道的。&lt;strong&gt;几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些早期的测量结果表明，基于 eBPF 的内核方法是非常有前途的，可以实现完全透明的服务网格的愿望，而且没有明显的开销。&lt;/p&gt;
&lt;h2 id=&#34;使用-ebpf-加速的-per-node-代理&#34;&gt;使用 eBPF 加速的 per-node 代理&lt;/h2&gt;
&lt;p&gt;越来越多的用例可以用这种仅有 eBPF 的方法来覆盖，从而完全取消 L4 代理。有些用例，仍然需要代理。例如，当连接需要拼接时，当 TLS 终止被执行时，或对于某些形式的 HTTP 授权。&lt;/p&gt;
&lt;p&gt;我们的 eBPF 服务网格工作将继续关注那些从性能角度可以获得最大收益的领域。如果你必须执行 TLS 终止，你可能不介意在流量流入集群时用代理终止一次连接。然而，你会更关心在每个连接的路径中注入两个代理的影响，以提取 HTTP 指标和跟踪数据。&lt;/p&gt;
&lt;p&gt;当一个用例不能用纯 eBPF 的方法来实现时，网格可以回退到每个节点的代理模型，直接将代理与内核的套接字层结合起来。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-per-node-proxy&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF per-node Proxy&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_cae09a072642115218e86546c57c2871.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_bd76ad40fcfd5a162be8d7e6e709f964.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_cae09a072642115218e86546c57c2871.webp&#34;
               width=&#34;760&#34;
               height=&#34;337&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF per-node Proxy
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 不依赖网络级的重定向，而是直接在套接字级别注入代理，保持路径短。在 Cilium 的案例中，正在使用 Envoy 代理，尽管从架构的角度来看，任何代理都可以被整合到这个模型。从概念上讲，这允许将 Linux 内核网络命名空间的概念直接扩展到 Envoy 监听器配置的概念，并将 Envoy 变成一个多用户代理。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-与-per-node-代理&#34;&gt;Sidecar 与 per-Node 代理&lt;/h2&gt;
&lt;p&gt;即使需要代理，代理的成本也会根据部署的架构而有所不同。让我们来看看每个节点的代理模式与 sidecar 模式的比较。&lt;/p&gt;
&lt;h3 id=&#34;每个连接的代理&#34;&gt;每个连接的代理&lt;/h3&gt;
&lt;p&gt;所需的网络连接数将因是否有代理而不同。最简单的情况是无 sidecar 模式，这意味着网络连接的数量没有变化。一个单一的连接将为请求提供服务，eBPF 将提供服务网格功能，如跟踪或现有连接上的负载均衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的模型&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_b1bb728478bd4a1d987e48d14e04251b.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_a955581f54b7ac14d5395e3d87b55296.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_b1bb728478bd4a1d987e48d14e04251b.webp&#34;
               width=&#34;760&#34;
               height=&#34;191&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;用 sidecar 模型提供同样的功能需要在连接中注入两次代理，这导致需要维护三个连接。这导致了开销的增加和所有额外的套接字缓冲区所需内存的倍增，表现为更高的服务间延迟。这就是我们之前在无 sidecar L7 可见性部分看到的 sidecar 开销。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-sidecar-代理的模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 Sidecar 代理的模型&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_47704abc0bc4ccd15f3e324e29995d3e.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_186ea6bca077e39bf5fb3791fc9b7d14.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_47704abc0bc4ccd15f3e324e29995d3e.webp&#34;
               width=&#34;760&#34;
               height=&#34;203&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 Sidecar 代理的模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;切换到 per-node 的代理模式使我们能够摆脱其中一个代理，因为我们不再依赖在每个工作负载中运行一个 sidecar。比起不需要额外的连接，这还是不够理想，但比起总是需要两个额外的连接要好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-per-node-代理模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Per-node 代理模式&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7bde5738f26376430d21264bb186b5f0.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7ce78a2664dc15bb076096454262f429.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7bde5738f26376430d21264bb186b5f0.webp&#34;
               width=&#34;760&#34;
               height=&#34;225&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Per-node 代理模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;所需的代理总数&#34;&gt;所需的代理总数&lt;/h3&gt;
&lt;p&gt;在每个工作负载中运行一个 sidecar 会导致大量的代理。即使每个单独的代理实例在其内存占用方面是相当优化的，但实例的数量之多将导致总的影响很大。此外，每个代理维护的数据结构，如路由和端点表，随着集群的增长而增长，所以集群越大，每个代理的内存消耗就越高。今天，一些服务网格试图通过将部分路由表推送给单个代理来解决这个问题，限制它们可以路由到哪里。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-代理数量&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;代理数量&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_e5e6f2c7d1de4f5108e2f0c65c63633b.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_2648ed10ae21eaef48205e7b5665caec.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_e5e6f2c7d1de4f5108e2f0c65c63633b.webp&#34;
               width=&#34;760&#34;
               height=&#34;262&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      代理数量
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;让我们假设在一个 500 个节点的集群中，每一个节点有 30 个 pod，一个基于 sidecar 的架构将需要运行 15K 个代理。在每个代理消耗 70MB 内存的情况下（假设已经经过极致优化过的路由表），这仍然导致集群中所有 sidecar 消耗 1.5TB 的内存。在 per-node 模型中，假设每个代理的内存足迹相同，500 个代理将消耗不超过 34GB 的内存。&lt;/p&gt;
&lt;h3 id=&#34;多租户&#34;&gt;多租户&lt;/h3&gt;
&lt;p&gt;当我们从 sidecar 模型转向 per-node 模型时，代理将为多个应用程序提供连接。代理必须具有多租户感知。这与我们从使用单个虚拟机转向使用容器时发生的过渡完全相同。由于我们不再使用在每个虚拟机中运行的完全独立的操作系统副本，而开始与多个应用程序共享操作系统，Linux 必须具有多租户感知。这就是命名空间和 cgroup 存在的原因。如果没有它们，一个容器可能会消耗一个系统的所有资源，容器可能会以不受控制的方式访问对方的文件系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-namespace&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Envoy Namespace&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_4c59051f9b916a64e84a2f5ffc02b30e.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_ea1a9152506ca77c4c47844ffafb9563.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_4c59051f9b916a64e84a2f5ffc02b30e.webp&#34;
               width=&#34;760&#34;
               height=&#34;423&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Envoy Namespace
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果这在服务网格级别的网络资源上表现得完全一样，那不是很好吗？Envoy 已经有了命名空间的初步概念，它们被称为监听器。监听器可以携带单独的配置并独立运行。这将开启全新的可能性：突然间，我们可以很容易地控制资源消耗，建立公平的排队规则，并将可用的资源平等地分配给所有的应用程序，或者按照指定的规则分配。这可以而且应该与我们今天在 Kubernetes 中定义应用程序的 CPU 和内存约束的方式完全一样。如果你想了解这个话题，我曾在 EnvoyCon 上讲过这个问题（&lt;a href=&#34;https://www.youtube.com/watch?v=08opgZkdYIw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;想参与其中吗--加入-cilium-服务网格测试版&#34;&gt;想参与其中吗？- 加入 Cilium 服务网格测试版&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-测试版&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;测试版&#34; srcset=&#34;
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_e129888b36894c5dfc6f5bdbaa5f88c3.webp 400w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_5fa12c343403dc5a4a5172ebff80348b.webp 760w,
               /docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_e129888b36894c5dfc6f5bdbaa5f88c3.webp&#34;
               width=&#34;760&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      测试版
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;伴随着即将发布的 Cilium 1.11 版本，Cilium 社区正在举办一个新的 Cilium Service Mesh 测试计划。它的特点是一个新的构建，将使以下功能可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L7 流量管理和负载均衡（HTTP，gRPC，…）&lt;/li&gt;
&lt;li&gt;跨集群、云和集群的拓扑感知路由&lt;/li&gt;
&lt;li&gt;TLS 终止&lt;/li&gt;
&lt;li&gt;通过 Envoy 配置的金丝雀发布、重试、速率限制、断路等&lt;/li&gt;
&lt;li&gt;用 OpenTelemetry 和 Jaeger 集成进行追踪&lt;/li&gt;
&lt;li&gt;内置 Kubernetes Ingress 支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述所有功能都可以在 &lt;a href=&#34;https://github.com/cilium/cilium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github.com/cilium/cilium&lt;/a&gt; 功能分支中找到。测试计划允许 Cilium 维护者直接与用户接触，了解他们的需求。要注册，你可以直接填写 &lt;a href=&#34;https://forms.gle/j9fwhAC6HnHRJQKeA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个表格&lt;/a&gt;，或者你可以在 Cilium 社区的&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公告&lt;/a&gt;中阅读更多关于该计划的信息。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;eBPF 是提供本地和高效的服务网格实现的答案。它将把我们从 sidecar 模型中解放出来，并允许将现有的代理技术整合到现有的内核命名概念中，使它们成为我们每天都在使用的容器抽象的一部分。除此之外，eBPF 将能够卸载越来越多的目前由代理执行的功能，以进一步减少开销和复杂性。通过整合几乎任何现有的代理，该架构也允许与大多数现有的服务网格控制平面（Istio、SMI、Linkerd…）整合。这可以将 eBPF 的好处提供给广大的终端用户，同时将数据通路的效率和开销的讨论与控制平面方面相分离。&lt;/p&gt;
&lt;p&gt;如果你有兴趣探索这个话题，我们很想听到你的意见。请随时通过 &lt;a href=&#34;https://twitter.com/tgraf__&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt; 或 &lt;a href=&#34;http://ebpf.io/slack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF &amp;amp; Cilium Slack 联系我们&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;进一步阅读&#34;&gt;进一步阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/docs/blog/how-ebpf-streamlines-the-service-mesh/&#34;&gt;eBPF 如何简化服务网格&lt;/a&gt;，Liz Rice，The New Stack&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 服务网格测试计划&lt;/a&gt;，Cilium 社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/learn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;了解更多关于 Cilium 的信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>基于 gRPC 和 Istio 的无 sidecar 代理的服务网格</title>
      <link>https://jimmysong.io/docs/translation/grpc-proxyless-service-mesh/</link>
      <pubDate>Tue, 23 Nov 2021 10:03:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/translation/grpc-proxyless-service-mesh/</guid>
      <description>&lt;p&gt;译者注：本文译自 Istio 官方博客，博客原标题 &lt;a href=&#34;https://istio.io/latest/blog/2021/proxyless-grpc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC Proxyless Service Mesh&lt;/a&gt;，其实是 Istio 1.11 版本中支持的实验特性，可以直接将 gRPC 服务添加到 Istio 中，而不需要再向 Pod 中注入 Envoy 代理。本文中还给出了一个 Demo 性能测试数据，这种做法可以极大的提升应用性能，降低网络延迟。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Istio 使用一组发现 API（统称为 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS API&lt;/a&gt; 来动态配置其 Envoy sidecar 代理。这些 API 的目标是成为一个 &lt;a href=&#34;https://blog.envoyproxy.io/the-universal-data-plane-api-d15cec7a?gi=64aa2eea0283&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通用的数据平面 API&lt;/a&gt;。gRPC 项目对 xDS API 有很好的支持，也就是说你可以管理 gRPC 工作负载，而不需要同时部署 Envoy sidecar。你可以在 &lt;a href=&#34;https://www.youtube.com/watch?v=cGJXkZ7jiDk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Megan Yahya 的 KubeCon EU 2021 演讲&lt;/a&gt;中了解更多关于该集成的信息。关于 gRPC 支持的最新情况，可以在他们的&lt;a href=&#34;https://github.com/grpc/proposal/search?q=xds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;提案&lt;/a&gt;中找到，还有实现状态。&lt;/p&gt;
&lt;p&gt;Istio 1.11 增加了实验性支持，可以直接将 gRPC 服务添加到网格中。我们支持基本的服务发现，一些基于 VirtualService 的流量策略，以及双向 TLS。&lt;/p&gt;
&lt;h2 id=&#34;支持的功能&#34;&gt;支持的功能&lt;/h2&gt;
&lt;p&gt;与 Envoy 相比，目前 gRPC 内的 xDS API 的实现在某些方面是有限的。以下功能应该可以使用，尽管这不是一个详尽的列表，其他功能可能部分可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本的服务发现。你的 gRPC 服务可以接触到在网格中注册的其他 pod 和虚拟机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DestinationRule&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Subset&lt;/code&gt;：你的 gRPC 服务可以根据标签选择器将流量分割到不同的实例组。&lt;/li&gt;
&lt;li&gt;目前唯一支持的 Istio &lt;code&gt;loadBalancer&lt;/code&gt; 是 &lt;code&gt;ROUND_ROBIN&lt;/code&gt;，&lt;code&gt;consistentHash&lt;/code&gt; 将在未来的 Istio 版本中加入（支持 gRPC）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tls&lt;/code&gt; 设置被限制为 &lt;code&gt;DISABLE&lt;/code&gt; 或 &lt;code&gt;ISTIO_MUTUAL&lt;/code&gt;。其他模式将被视为 &lt;code&gt;DISABLE&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VirtualService&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Header 匹配和 URI 匹配的格式为 &lt;code&gt;/ServiceName/RPCName&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;覆盖目标主机和子集。&lt;/li&gt;
&lt;li&gt;加权的流量转移。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PeerAuthentication&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;只支持 &lt;code&gt;DISABLE&lt;/code&gt; 和 &lt;code&gt;STRICT&lt;/code&gt;。其他模式将被视为 &lt;code&gt;DISABLE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在未来的版本中可能会有对 auto-mTLS 的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他功能包括故障、重试、超时、镜像和重写规则，可能会在未来的版本中支持。其中一些功能正等待在 gRPC 中实现，而其他功能则需要在 Istio 中支持。gRPC 中 xDS 功能的状态可以&lt;a href=&#34;https://github.com/grpc/grpc/blob/master/doc/grpc_xds_features.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在这里&lt;/a&gt;找到。Istio 的支持状况将存在于未来的官方文档中。&lt;/p&gt;
&lt;p&gt;这个功能是&lt;a href=&#34;https://istio.io/latest/docs/releases/feature-stages/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;实验性的&lt;/a&gt;。标准的 Istio 功能将随着时间的推移和整体设计的改进而得到支持。&lt;/p&gt;
&lt;h2 id=&#34;架构概述&#34;&gt;架构概述&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-grpc服务如何与istiod通信的示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;gRPC服务如何与istiod通信的示意图&#34; srcset=&#34;
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp3lh9za5j311q0hm75n_hub13183ce8bf635668b5180d6a8999e71_59258_93b5fc3be37bb2885005a55419c3b69e.webp 400w,
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp3lh9za5j311q0hm75n_hub13183ce8bf635668b5180d6a8999e71_59258_865bf197a56648593ab7bcb88c72344f.webp 760w,
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp3lh9za5j311q0hm75n_hub13183ce8bf635668b5180d6a8999e71_59258_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp3lh9za5j311q0hm75n_hub13183ce8bf635668b5180d6a8999e71_59258_93b5fc3be37bb2885005a55419c3b69e.webp&#34;
               width=&#34;760&#34;
               height=&#34;355&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      gRPC服务如何与istiod通信的示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;虽然不使用 proxy 进行数据面通信，但它仍然需要一个 agent 来进行初始化和与控制面的通信。首先，agent 在启动时生成一个&lt;a href=&#34;https://github.com/grpc/proposal/blob/master/A27-xds-global-load-balancing.md#xdsclient-and-bootstrap-file&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;引导文件&lt;/a&gt;，与为 Envoy 生成引导文件的方式相同。这告诉 gRPC 库如何连接到 istiod，在哪里可以找到数据面通信的证书，以及向控制面发送什么元数据。接下来，agent 作为一个 xDS proxy，代表应用程序与 istiod 进行连接和认证。最后，agent 获取并轮换数据平面通信中使用的证书。&lt;/p&gt;
&lt;h2 id=&#34;对应用程序代码的修改&#34;&gt;对应用程序代码的修改&lt;/h2&gt;
&lt;p&gt;本节介绍了 gRPC 在 Go 中的 xDS 支持。其他语言也有类似的 API。&lt;/p&gt;
&lt;p&gt;为了启用 gRPC 中的 xDS 功能，你的应用程序必须做一些必要的修改。你的 gRPC 版本应该至少是 1.39.0。&lt;/p&gt;
&lt;h3 id=&#34;客户端&#34;&gt;客户端&lt;/h3&gt;
&lt;p&gt;下面的导入将在 gRPC 中注册 xDS 解析器和均衡器。它应该被添加到你的主包或调用 &lt;code&gt;grpc.Dial&lt;/code&gt; 的同一个包中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;google.golang.org/grpc/xds&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当创建一个 gRPC 连接时，URL 必须使用 &lt;code&gt;xds:///&lt;/code&gt; scheme。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DialContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;xds:///foo.ns.svc.cluster.local:7070&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此外，为了支持（m）TLS，必须向 &lt;code&gt;DialContext&lt;/code&gt; 传递一个特殊的 &lt;code&gt;TransportCredentials&lt;/code&gt; 选项。&lt;code&gt;FallbackCreds&lt;/code&gt; 允许我们在 istiod 不发送安全配置时成功。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;google.golang.org/grpc/credentials/xds&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;creds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewClientCredentials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;xds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ClientOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;FallbackCreds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;insecure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewCredentials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// handle err
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;DialContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;xds:///foo.ns.svc.cluster.local:7070&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithTransportCredentials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;creds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;服务端&#34;&gt;服务端&lt;/h3&gt;
&lt;p&gt;为了支持服务器端的配置，如 mTLS，必须做一些修改。&lt;/p&gt;
&lt;p&gt;首先，我们使用一个特殊的构造函数来创建 &lt;code&gt;GRPCServer&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;google.golang.org/grpc/xds&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewGRPCServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;RegisterFooServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fooServerImpl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你的 &lt;code&gt;protoc&lt;/code&gt; 生成的 Go 代码已经过期，你可能需要重新生成，以便与 xDS 服务器兼容。你生成的 &lt;code&gt;RegisterFooServer&lt;/code&gt; 函数应该像下面这样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RegisterFooServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServiceRegistrar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FooServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RegisterService&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;FooServer_ServiceDesc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，与客户端的变化一样，我们必须启用安全支持。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;creds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewServerCredentials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;xdscreds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServerOptions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;FallbackCreds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;insecure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewCredentials&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// handle err
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewGRPCServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;grpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Creds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;creds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;在你的-kubernetes-部署中&#34;&gt;在你的 Kubernetes 部署中&lt;/h3&gt;
&lt;p&gt;假设你的应用代码是兼容的，Pod 只需要注释 &lt;code&gt;inject.istio.io/templates：grpc-agent&lt;/code&gt;。这增加了一个运行上述代理的 sidecar 容器，以及一些环境变量，gRPC 使用这些变量来寻找引导文件并启用某些功能。&lt;/p&gt;
&lt;p&gt;对于 gRPC 服务端，你的 Pod 也应该用 &lt;code&gt;proxy.istio.io/config: &#39;{&amp;quot;holdApplicationUntilProxyStarts&amp;quot;: true}&#39;&lt;/code&gt; 来注释，以确保在你的 gRPC 服务端初始化之前，代理中的 xDS 代理和引导文件已经准备就绪。&lt;/p&gt;
&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;
&lt;p&gt;在本指南中，你将部署 echo，一个已经支持服务器端和客户端无代理的 gRPC 的应用。通过这个应用程序，你可以尝试一些支持的流量策略，启用 mTLS。&lt;/p&gt;
&lt;h3 id=&#34;先决条件&#34;&gt;先决条件&lt;/h3&gt;
&lt;p&gt;本指南要求在进行之前&lt;a href=&#34;https://istio.io/latest/docs/setup/install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安装&lt;/a&gt; Istio（1.11+）控制平面。&lt;/p&gt;
&lt;h3 id=&#34;部署应用程序&#34;&gt;部署应用程序&lt;/h3&gt;
&lt;p&gt;创建一个支持注入的命名空间 &lt;code&gt;echo-grpc&lt;/code&gt;。接下来部署两个 &lt;code&gt;echo&lt;/code&gt; 应用程序的实例以及服务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl create namespace echo-grpc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl label namespace echo-grpc istio-injection&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;enabled
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl -n echo-grpc apply -f samples/grpc-echo/grpc-echo.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;确保两个 Pod 正在运行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl -n echo-grpc get pods
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME                       READY   STATUS    RESTARTS   AGE
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;echo-v1-69d6d96cb7-gpcpd   2/2     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          58s
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;echo-v2-5c6cbf6dc7-dfhcb   2/2     Running   &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;          58s
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;测试-grpc-解析器&#34;&gt;测试 gRPC 解析器&lt;/h3&gt;
&lt;p&gt;首先，将 17171 端口转发到其中一个 Pod 上。这个端口是一个非 xDS 支持的 gRPC 服务端，允许从端口转发的 Pod 发出请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ kubectl -n echo-grpc port-forward &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;kubectl -n echo-grpc get pods -l &lt;span class=&#34;nv&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;v1 -ojsonpath&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;{.items[0].metadata.name}&amp;#39;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;17171&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，我们可以发送一批 5 个请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ grpcurl -plaintext -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;xds:///echo.echo-grpc.svc.cluster.local:7070&amp;#34;, &amp;#34;count&amp;#34;: 5}&amp;#39;&lt;/span&gt; :17171 proto.EchoTestService/ForwardEcho &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r &lt;span class=&#34;s1&#34;&gt;&amp;#39;.output | join(&amp;#34;&amp;#34;)&amp;#39;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep Hostname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Handling connection &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;17171&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v1-7cf5b76586-bgn6t
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v2-cf97bd94d-qf628
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v1-7cf5b76586-bgn6t
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v2-cf97bd94d-qf628
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v1-7cf5b76586-bgn6t
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你也可以使用类似 Kubernetes 名称解析的短名称。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ grpcurl -plaintext -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;xds:///echo:7070&amp;#34;}&amp;#39;&lt;/span&gt; :17171 proto.EchoTestService/ForwardEcho &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r &lt;span class=&#34;s1&#34;&gt;&amp;#39;.output | join
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;(&amp;#34;&amp;#34;)&amp;#39;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep Hostname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v1-7cf5b76586-ltr8q
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ grpcurl -plaintext -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;xds:///echo.echo-grpc:7070&amp;#34;}&amp;#39;&lt;/span&gt; :17171 proto.EchoTestService/ForwardEcho &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;.output | join(&amp;#34;&amp;#34;)&amp;#39;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep Hostname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v1-7cf5b76586-ltr8q
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ grpcurl -plaintext -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;xds:///echo.echo-grpc.svc:7070&amp;#34;}&amp;#39;&lt;/span&gt; :17171 proto.EchoTestService/ForwardEcho &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;.output | join(&amp;#34;&amp;#34;)&amp;#39;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep Hostname
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v2-cf97bd94d-jt5mf
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;用目的地规则创建子集&#34;&gt;用目的地规则创建子集&lt;/h3&gt;
&lt;p&gt;首先，为每个版本的工作负载创建一个子集。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF | kubectl apply -f -
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: networking.istio.io/v1alpha3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: DestinationRule
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: echo-versions
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: echo-grpc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  host: echo.echo-grpc.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  subsets:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  - name: v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    labels:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      version: v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  - name: v2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    labels:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      version: v2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;流量转移&#34;&gt;流量转移&lt;/h3&gt;
&lt;p&gt;使用上面定义的子集，你可以把 80% 的流量发送到一个特定的版本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF | kubectl apply -f -
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: networking.istio.io/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: VirtualService
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: echo-weights
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: echo-grpc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  hosts:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  - echo.echo-grpc.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  http:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  - route:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    - destination:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        host: echo.echo-grpc.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        subset: v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      weight: 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    - destination:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        host: echo.echo-grpc.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;        subset: v2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      weight: 80
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，发送一组 10 个请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;grpcurl -plaintext -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;xds:///echo.echo-grpc.svc.cluster.local:7070&amp;#34;, &amp;#34;count&amp;#34;: 10}&amp;#39;&lt;/span&gt; :17171 proto.EchoTestService/ForwardEcho &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r &lt;span class=&#34;s1&#34;&gt;&amp;#39;.output | join(&amp;#34;&amp;#34;)&amp;#39;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep ServiceVersion
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;响应应主要包含 v2 响应。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[0 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[1 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[2 body] ServiceVersion=v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[3 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[4 body] ServiceVersion=v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[5 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[6 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[7 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[8 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[9 body] ServiceVersion=v2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;启用-mtls&#34;&gt;启用 mTLS&lt;/h3&gt;
&lt;p&gt;由于在 gRPC 中启用安全所需的应用程序本身的变化，Istio 的自动检测 mTLS 支持的传统方法是不可靠的。出于这个原因，初始版本需要在客户端和服务端上明确启用 mTLS。&lt;/p&gt;
&lt;p&gt;要启用客户端的 mTLS，请应用带有 &lt;code&gt;tls&lt;/code&gt; 设置的 &lt;code&gt;DestinationRule&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF | kubectl apply -f -
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: networking.istio.io/v1alpha3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: DestinationRule
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: echo-mtls
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: echo-grpc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  host: echo.echo-grpc.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  trafficPolicy:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    tls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;      mode: ISTIO_MUTUAL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，试图调用尚未配置 mTLS 的服务器将会失败。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ grpcurl -plaintext -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;xds:///echo.echo-grpc.svc.cluster.local:7070&amp;#34;}&amp;#39;&lt;/span&gt; :17171 proto.EchoTestService/ForwardEcho &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r &lt;span class=&#34;s1&#34;&gt;&amp;#39;.output | join(&amp;#34;&amp;#34;)&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Handling connection &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;17171&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ERROR:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Code: Unknown
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Message: 1/1 requests had errors&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; first error: rpc error: &lt;span class=&#34;nv&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; Unavailable &lt;span class=&#34;nv&#34;&gt;desc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; all SubConns are in TransientFailure
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了启用服务器端的 mTLS，应用一个 &lt;code&gt;PeerAuthentication&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以下策略对整个命名空间强制采用 STRICT mTLS。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cat &lt;span class=&#34;s&#34;&gt;&amp;lt;&amp;lt;EOF | kubectl apply -f -
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;apiVersion: security.istio.io/v1beta1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;kind: PeerAuthentication
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  name: echo-mtls
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  namespace: echo-grpc
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;  mtls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;    mode: STRICT
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s&#34;&gt;EOF&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应用该政策后，请求将开始成功。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ grpcurl -plaintext -d &lt;span class=&#34;s1&#34;&gt;&amp;#39;{&amp;#34;url&amp;#34;: &amp;#34;xds:///echo.echo-grpc.svc.cluster.local:7070&amp;#34;}&amp;#39;&lt;/span&gt; :17171 proto.EchoTestService/ForwardEcho &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; jq -r &lt;span class=&#34;s1&#34;&gt;&amp;#39;.output | join(&amp;#34;&amp;#34;)&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Handling connection &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;17171&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;0&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; grpcecho.Echo&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;xds:///echo.echo-grpc.svc.cluster.local:7070 map&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;  5s &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; x-request-id&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Host&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo.echo-grpc.svc.cluster.local:7070
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; content-type&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;application/grpc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; user-agent&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;grpc-go/1.39.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;StatusCode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;200&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ServiceVersion&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;v1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;ServicePort&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;17070&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Cluster&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;IP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;10.68.1.18
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;IstioVersion&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Echo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; body&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;Hostname&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;echo-v1-7cf5b76586-z5p8l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;限制条件&#34;&gt;限制条件&lt;/h2&gt;
&lt;p&gt;最初的版本有几个限制，可能会在未来的版本中修复。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持自动 mTLS，也不支持许可模式。相反，我们需要在服务器上使用 &lt;code&gt;STRICT&lt;/code&gt;，在客户端使用 &lt;code&gt;ISTIO_MUTUAL&lt;/code&gt; 的明确 mTLS 配置。在迁移到 &lt;code&gt;STRICT&lt;/code&gt; 的过程中，可以使用 Envoy。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grpc.Serve(listener)&lt;/code&gt; 或 &lt;code&gt;grpc.Dial(&amp;quot;xds://...&amp;quot;)&lt;/code&gt; 在 bootstrap 被写入或 xDS 代理准备好之前被调用会导致失败。 &lt;code&gt;holdApplicationUntilProxyStarts&lt;/code&gt; 可以用来解决这个问题，或者应用程序可以对这些失败更加稳健。&lt;/li&gt;
&lt;li&gt;如果支持 xDS 的 gRPC 服务器使用 mTLS，那么你将需要确保你的健康检查可以绕过这个问题。要么使用一个单独的端口，要么你的健康检查客户端需要一种方法来获得适当的客户端证书。&lt;/li&gt;
&lt;li&gt;gRPC 中 xDS 的实现与 Envoy 不一致。某些行为可能不同，某些功能可能缺失。&lt;a href=&#34;https://github.com/grpc/grpc/blob/master/doc/grpc_xds_features.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC 的功能状态&lt;/a&gt;提供了更多细节。请确保测试任何 Istio 配置是否真正适用于你的无代理的 gRPC 应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能&lt;/h2&gt;
&lt;h3 id=&#34;实验设置&#34;&gt;实验设置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 Fortio，一个基于 Go 的负载测试应用程序
&lt;ul&gt;
&lt;li&gt;稍作修改，以支持 gRPC 的 XDS 功能 (PR)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源：
&lt;ul&gt;
&lt;li&gt;GKE 1.20 集群有 3 个 &lt;code&gt;e2-standard-16&lt;/code&gt; 节点（每个节点有 16 个 CPU+64GB 内存）&lt;/li&gt;
&lt;li&gt;Fortio 客户端和服务器应用程序：1.5 vCPU，1000 MiB 内存&lt;/li&gt;
&lt;li&gt;Sidecar（istio-agent 和可能的 Envoy 代理）：1 vCPU，512 MiB 内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试的工作负载类型：
&lt;ul&gt;
&lt;li&gt;基线：常规的 gRPC，没有使用 Envoy 代理或 Proxyless xDS&lt;/li&gt;
&lt;li&gt;Envoy：标准的 istio-agent + Envoy proxy sidecar&lt;/li&gt;
&lt;li&gt;无代理：使用 xDS gRPC 服务器实现的 gRPC 和客户端的 &lt;code&gt;xds:///&lt;/code&gt; 解析器。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;PeerAuthentication&lt;/code&gt; 和 &lt;code&gt;DestinationRule&lt;/code&gt; 启用 / 停用 mTLS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;延迟&#34;&gt;延迟&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-p50延迟对比图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;P50延迟对比图&#34; srcset=&#34;
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp512szlvj31260rgq57_hud5c09da40d95e95911a10d442fdf1c43_91356_f0c76512696b26ddd8e19da497734612.webp 400w,
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp512szlvj31260rgq57_hud5c09da40d95e95911a10d442fdf1c43_91356_da37d4b02ce09f50eb75aed6f535dd18.webp 760w,
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp512szlvj31260rgq57_hud5c09da40d95e95911a10d442fdf1c43_91356_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp512szlvj31260rgq57_hud5c09da40d95e95911a10d442fdf1c43_91356_f0c76512696b26ddd8e19da497734612.webp&#34;
               width=&#34;760&#34;
               height=&#34;547&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      P50延迟对比图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-p99-延迟对比图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;P99延迟对比图&#34; srcset=&#34;
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp51zjxqaj312q0r2jtl_hu547659c633be4fb1b9f48f5325ea357d_89875_1e2c0a5a55cdc024ed19cf1769a16061.webp 400w,
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp51zjxqaj312q0r2jtl_hu547659c633be4fb1b9f48f5325ea357d_89875_bad6ddf9387104a5bc25014ce56eaeee.webp 760w,
               /docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp51zjxqaj312q0r2jtl_hu547659c633be4fb1b9f48f5325ea357d_89875_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/grpc-proxyless-service-mesh/008i3skNly1gwp51zjxqaj312q0r2jtl_hu547659c633be4fb1b9f48f5325ea357d_89875_1e2c0a5a55cdc024ed19cf1769a16061.webp&#34;
               width=&#34;760&#34;
               height=&#34;531&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      P99 延迟对比图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在使用无代理的 gRPC 解析器时，延迟会有微小的增加。与 Envoy 相比，这是一个巨大的改进，仍然可以实现先进的流量管理功能和 mTLS。&lt;/p&gt;
&lt;h3 id=&#34;istio-proxy-容器的资源使用情况&#34;&gt;istio-proxy 容器的资源使用情况&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;客户端 mCPU&lt;/th&gt;
&lt;th&gt;客户端内存 (MiB)&lt;/th&gt;
&lt;th&gt;服务端 mCPU&lt;/th&gt;
&lt;th&gt;服务端内存 (MiB)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Envoy 明文&lt;/td&gt;
&lt;td&gt;320.44&lt;/td&gt;
&lt;td&gt;66.93&lt;/td&gt;
&lt;td&gt;243.78&lt;/td&gt;
&lt;td&gt;64.91&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Envoy mTLS&lt;/td&gt;
&lt;td&gt;340.87&lt;/td&gt;
&lt;td&gt;66.76&lt;/td&gt;
&lt;td&gt;309.82&lt;/td&gt;
&lt;td&gt;64.82&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无代理明文&lt;/td&gt;
&lt;td&gt;0.72&lt;/td&gt;
&lt;td&gt;23.54&lt;/td&gt;
&lt;td&gt;0.84&lt;/td&gt;
&lt;td&gt;24.31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无代理 mTLS&lt;/td&gt;
&lt;td&gt;0.73&lt;/td&gt;
&lt;td&gt;25.05&lt;/td&gt;
&lt;td&gt;0.78&lt;/td&gt;
&lt;td&gt;25.43&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;尽管我们仍然需要一个代理，但代理使用的内存不到完整 vCPU 的 0.1%，而且只有 25 MiB，这还不到运行 Envoy 所需内存的一半。&lt;/p&gt;
&lt;p&gt;这些指标不包括应用容器中 gRPC 的额外资源使用量，但有助于展示 istio-agent 在此模式下运行时的资源使用影响。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>eBPF 如何简化服务网格</title>
      <link>https://jimmysong.io/docs/translation/how-ebpf-streamlines-the-service-mesh/</link>
      <pubDate>Wed, 27 Oct 2021 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/translation/how-ebpf-streamlines-the-service-mesh/</guid>
      <description>&lt;p&gt;今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观察性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对&lt;a href=&#34;https://nowei.github.io/projects/svc_mesh_measurement_final_report.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;额外的&lt;/a&gt;&lt;a href=&#34;https://engineering.hellofresh.com/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;复杂性&lt;/a&gt;和&lt;a href=&#34;https://pklinker.medium.com/performance-impacts-of-an-istio-service-mesh-63957a0000b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开销的&lt;/a&gt;实际&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;担忧所抑制&lt;/a&gt;。让我们来探讨一下 &lt;a href=&#34;https://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是如何让我们精简&lt;a href=&#34;https://thenewstack.io/category/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;，使服务网格的数据平面更有效率，更容易部署。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-问题&#34;&gt;Sidecar 问题&lt;/h2&gt;
&lt;p&gt;今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 或 &lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd-proxy&lt;/a&gt;。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。&lt;/p&gt;
&lt;p&gt;每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;经验&lt;/a&gt;，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-来自redhatcomarchitectwhy-when-service-meshhttpsredhatcomarchitectwhy-when-service-mesh每个微服务都有自己的代理sidecar&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;来自&amp;lt;a href=&amp;#34;https://redhat.com/architect/why-when-service-mesh&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;redhat.com/architect/why-when-service-mesh&amp;lt;/a&amp;gt;——每个微服务都有自己的代理sidecar&#34; srcset=&#34;
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_e82772dc16b0798bb43fb88f2ac134cc.webp 400w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_fb23a1ea63de7ecc49e5bdb7fd35317a.webp 760w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_e82772dc16b0798bb43fb88f2ac134cc.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      来自&lt;a href=&#34;https://redhat.com/architect/why-when-service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;redhat.com/architect/why-when-service-mesh&lt;/a&gt;——每个微服务都有自己的代理sidecar
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。&lt;/p&gt;
&lt;h2 id=&#34;引入-ebpf&#34;&gt;引入 eBPF&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。&lt;/p&gt;
&lt;p&gt;重要的是，&lt;strong&gt;每个节点只有一个内核&lt;/strong&gt;；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-每台主机一个内核&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;每台主机一个内核&#34; srcset=&#34;
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_847d0bf365ee18cfcdd849278134a758.webp 400w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_db8f980112e5dfb449eac44c9bb97115.webp 760w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_847d0bf365ee18cfcdd849278134a758.webp&#34;
               width=&#34;760&#34;
               height=&#34;453&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      每台主机一个内核
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation ，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观察性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 &lt;a href=&#34;http://cilium.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt; 项目（最近 &lt;a href=&#34;https://www.cncf.io/blog/2021/10/13/cilium-joins-cncf-as-an-incubating-project/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以孵化级别加入云计算基金会&lt;/a&gt;）将这种 “无 sidecar&amp;quot; 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-用无sidecar代理模式减少代理实例&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;用无sidecar代理模式减少代理实例&#34; srcset=&#34;
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_b7de8ef9d83f49c194072ed86daeb771.webp 400w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_df1496e3029f185d02ebf3eb8de2416b.webp 760w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_b7de8ef9d83f49c194072ed86daeb771.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      用无sidecar代理模式减少代理实例
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;减少-yaml&#34;&gt;减少 YAML&lt;/h2&gt;
&lt;p&gt;在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。&lt;/p&gt;
&lt;p&gt;以 Istio 为例，这需要&lt;a href=&#34;https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#controlling-the-injection-policy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标记&lt;/a&gt; Kubernetes 命名空间和 / 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。&lt;/p&gt;
&lt;p&gt;但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。&lt;/p&gt;
&lt;p&gt;相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。&lt;/p&gt;
&lt;p&gt;如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-支持的网络效率&#34;&gt;eBPF 支持的网络效率&lt;/h2&gt;
&lt;p&gt;支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的&lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能得到显著改善&lt;/a&gt;。让我们看看这在服务网格数据平面中是如何应用的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-在ebpf加速无sidecar的服务网格模型中网络数据包通过的路径要短得多&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;在eBPF加速、无sidecar的服务网格模型中，网络数据包通过的路径要短得多&#34; srcset=&#34;
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_7a9a484930ac06c27ab63979ee78513d.webp 400w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_f6be66e36d0a6d7b08ee504b51dfc6b7.webp 760w,
               /docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_7a9a484930ac06c27ab63979ee78513d.webp&#34;
               width=&#34;760&#34;
               height=&#34;366&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      在eBPF加速、无sidecar的服务网格模型中，网络数据包通过的路径要短得多
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的&lt;a href=&#34;https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/#latency-at-20-rps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;显著增加&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。&lt;/p&gt;
&lt;h2 id=&#34;网络中的加密&#34;&gt;网络中的加密&lt;/h2&gt;
&lt;p&gt;如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。&lt;/p&gt;
&lt;p&gt;通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。&lt;/p&gt;
&lt;p&gt;但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 &lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPSec 或 WireGuard&lt;/a&gt;。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-是服务网格的数据平面&#34;&gt;eBPF 是服务网格的数据平面&lt;/h2&gt;
&lt;p&gt;现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。&lt;/p&gt;
&lt;p&gt;去年，我代表 &lt;a href=&#34;https://cncf.io/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt; 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 &lt;a href=&#34;https://youtu.be/bESogtuHwX0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;预测&lt;/a&gt;。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>服务网格终极指南第二版——下一代微服务开发</title>
      <link>https://jimmysong.io/docs/translation/service-mesh-ultimate-guide-e2/</link>
      <pubDate>Mon, 11 Oct 2021 10:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/translation/service-mesh-ultimate-guide-e2/</guid>
      <description>&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;了解采用服务网格技术的新兴架构趋势，特别是多云、多集群和多租户模式，如何在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案，以及从边缘计算层到网格的应用 / 服务连接。&lt;/li&gt;
&lt;li&gt;了解服务网格生态系统中的一些新模式，如多集群服务网格、媒体服务网格（Media Service Mesh）和混沌网格，以及经典的微服务反模式，如 “死星（Death Star） “架构。&lt;/li&gt;
&lt;li&gt;获取最新的关于在部署领域使用服务网格的创新总结，在 Pod（K8s 集群）和 VM（非 K8s 集群）之间进行快速实验、混乱工程和金丝雀部署。&lt;/li&gt;
&lt;li&gt;探索服务网格扩展领域的创新，包括：增强身份管理，以确保微服务连接的安全性，包括自定义证书授权插件，自适应路由功能，以提高服务的可用性和可扩展性，以及增强 sidecar 代理。&lt;/li&gt;
&lt;li&gt;了解操作方面即将出现的情况，如配置多集群功能和将 Kubernetes 工作负载连接到托管在虚拟机基础设施上的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在过去的几年里，服务网格技术有了长足的发展。服务网格在各组织采用云原生技术方面发挥着重要作用。通过提供四种主要能力 —— 连接性、可靠性、可观察性和安全性，服务网格已经成为 IT 组织的技术和基础设施现代化工作的核心组成部分。服务网格使开发和运维团队能够在基础设施层面实现这些能力，因此，当涉及到跨领域的非功能需求时，应用团队不需要重新发明轮子。&lt;/p&gt;
&lt;p&gt;自本文&lt;a href=&#34;https://www.infoq.com/articles/service-mesh-ultimate-guide/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;第一版&lt;/a&gt;于 2020 年 2 月发表以来，服务网格技术经历了重大创新，在不断发展的服务网格领域出现了一些新的架构趋势、技术能力和服务网格项目。&lt;/p&gt;
&lt;p&gt;在过去的一年里，服务网格产品的发展远远超过了原有的 Kubernetes 解决方案，没有托管在 Kubernetes 平台上的应用无法利用服务网格。并非所有的组织都将其所有的业务和 IT 应用程序过渡到 Kubernetes 云平台。因此，自服务网格诞生以来，一直需要这项技术在不同的 IT 基础设施环境中工作。&lt;/p&gt;
&lt;p&gt;随着微服务架构的不断采用，应用系统在云供应商、基础设施（Kubernetes、虚拟机、裸机服务器）、地域，甚至在服务网格集成环境中要管理的工作负载类型方面，都已实现解耦和分布式。&lt;/p&gt;
&lt;p&gt;让我们从服务网格的历史开始说起，了解服务网格是如何产生的。&lt;/p&gt;
&lt;p&gt;2016 年前后，“服务网格 &amp;quot; 这个词出现在微服务、云计算和 DevOps 的领域。Buoyant 团队在 2016 年用&lt;a href=&#34;https://twitter.com/wm/status/1383061764938469377?s=20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个&lt;/a&gt;词来解释他们的产品 Linkerd。和云计算领域的许多概念一样，相关的模式和技术其实有很长的历史。&lt;/p&gt;
&lt;p&gt;服务网格的到来主要是由于 IT 领域内的一场风暴。开发人员开始使用多语言（polyglot）方法构建分布式系统，并需要动态服务发现。运维部门开始使用短暂的基础设施，并希望优雅地处理不可避免的通信故障和执行网络策略。平台团队开始接受像 Kubernetes 这样的容器编排系统，并希望使用现代 API 驱动的网络代理（如 Envoy）在系统中和周围动态地路由流量。&lt;/p&gt;
&lt;p&gt;本文旨在回答软件架构师和技术负责人的相关问题，如：什么是服务网格？我是否需要服务网格？如何评估不同的服务网格产品？&lt;/p&gt;
&lt;h2 id=&#34;服务网格模式&#34;&gt;服务网格模式&lt;/h2&gt;
&lt;p&gt;服务网格模式专注于管理分布式软件系统中所有服务之间的通信。&lt;/p&gt;
&lt;h3 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h3&gt;
&lt;p&gt;该模式的背景有两个方面。首先，工程师们已经采用了微服务架构模式，并通过将多个（理想情况下是单一用途且可独立部署的）服务组合在一起构建他们的应用。第二，组织已经接受了云原生平台技术，如容器（如 Docker）、编排器（如 Kubernetes）和网关。&lt;/p&gt;
&lt;h3 id=&#34;意图&#34;&gt;意图&lt;/h3&gt;
&lt;p&gt;服务网格模式试图解决的问题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除了将特定语言的通信库编译到单个服务中的需求，以处理服务发现、路由和应用层（第 7 层）非功能通信要求。&lt;/li&gt;
&lt;li&gt;外部化服务通信配置，包括外部服务的网络位置、安全凭证和服务质量目标。&lt;/li&gt;
&lt;li&gt;提供对其他服务的被动和主动监测。&lt;/li&gt;
&lt;li&gt;在整个分布式系统中分布式地执行策略。&lt;/li&gt;
&lt;li&gt;提供可观察性的默认值，并使相关数据的收集标准化。
&lt;ul&gt;
&lt;li&gt;启用请求记录&lt;/li&gt;
&lt;li&gt;配置分布式追踪&lt;/li&gt;
&lt;li&gt;收集指标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;结构&#34;&gt;结构&lt;/h3&gt;
&lt;p&gt;服务网格模式主要侧重于处理传统上被称为 “东西向 “的基于远程过程调用（RPC）的流量：请求 / 响应类型的通信，源自数据中心内部，在服务之间传播。这与 API 网关或边缘代理相反，后者被设计为处理 “南北 “流量。来自外部的通信，进入数据中心内的一个终端或服务。&lt;/p&gt;
&lt;h2 id=&#34;服务网格的特点&#34;&gt;服务网格的特点&lt;/h2&gt;
&lt;p&gt;服务网格的实施通常会提供以下一个或多个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规范化命名并增加逻辑路由，（例如，将代码级名称 “用户服务 &amp;quot; 映射到平台特定位置 “AWS-us-east-1a/prod/users/v4”。&lt;/li&gt;
&lt;li&gt;提供流量整形和流量转移&lt;/li&gt;
&lt;li&gt;保持负载均衡，通常采用可配置的算法&lt;/li&gt;
&lt;li&gt;提供服务发布控制（例如，金丝雀释放和流量分割）&lt;/li&gt;
&lt;li&gt;提供按请求的路由（例如，影子流量、故障注入和调试重新路由）。&lt;/li&gt;
&lt;li&gt;增加基线可靠性，如健康检查、超时 / 截止日期、断路和重试（预算）。&lt;/li&gt;
&lt;li&gt;通过透明的双向传输级安全（TLS）和访问控制列表（ACL）等策略，提高安全性&lt;/li&gt;
&lt;li&gt;提供额外的可观察性和监测，如顶线指标（请求量、成功率和延迟），支持分布式追踪，以及 &amp;ldquo;挖掘&amp;rdquo; 和检查实时服务间通信的能力。&lt;/li&gt;
&lt;li&gt;使得平台团队能够配置 &amp;quot; 理智的默认值”，以保护系统免受不良通信的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务网格的能力可分为以下四个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接性&lt;/li&gt;
&lt;li&gt;可靠性&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;li&gt;可观察性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们看看服务网格技术在这些领域都能提供哪些功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量控制（路由，分流）&lt;/li&gt;
&lt;li&gt;网关（入口、出口）&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;A/B 测试、金丝雀&lt;/li&gt;
&lt;li&gt;服务超时、重试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;断路器&lt;/li&gt;
&lt;li&gt;故障注入 / 混沌测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务间认证（mTLS）&lt;/li&gt;
&lt;li&gt;证书管理&lt;/li&gt;
&lt;li&gt;用户认证（JWT）&lt;/li&gt;
&lt;li&gt;用户授权（RBAC）&lt;/li&gt;
&lt;li&gt;加密&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;可观察性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监测&lt;/li&gt;
&lt;li&gt;遥测、仪表、计量&lt;/li&gt;
&lt;li&gt;分布式追踪&lt;/li&gt;
&lt;li&gt;服务图表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务网格架构内部原理&#34;&gt;服务网格架构：内部原理&lt;/h2&gt;
&lt;p&gt;服务网格由两部分组成：数据平面和控制平面。Matt Klein，&lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Proxy&lt;/a&gt; 的作者，写了一篇关于 “ &lt;a href=&#34;https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格数据平面与控制平面 &lt;/a&gt;“的深入探讨。&lt;/p&gt;
&lt;p&gt;广义上讲，数据平面 “执行工作”，负责 “有条件地翻译、转发和观察流向和来自 [网络终端] 的每个网络数据包”。在现代系统中，数据平面通常以代理的形式实现，（如 Envoy、&lt;a href=&#34;http://www.haproxy.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAProxy&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/mosn/mosn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MOSN&lt;/a&gt;），它作为 &amp;ldquo;sidecar&amp;rdquo; 与每个服务一起在进程外运行。Linkerd 使用了一种 &lt;a href=&#34;https://linkerd.io/2020/12/03/why-linkerd-doesnt-use-envoy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微型代理&lt;/a&gt;方法，该方法针对服务网格的使用情况进行了优化。&lt;/p&gt;
&lt;p&gt;控制平面 “监督工作”，并将数据平面的所有单个实例 —— 一组孤立的无状态 sidecar 代理变成一个分布式系统。控制平面不接触系统中的任何数据包 / 请求，相反，它允许人类运维人员为网格中所有正在运行的数据平面提供策略和配置。控制平面还能够收集和集中数据平面的遥测数据，供运维人员使用。&lt;/p&gt;
&lt;p&gt;控制平面和数据平面的结合提供了两方面的优势，即策略可以集中定义和管理，同时，同样的政策可以以分散的方式，在 Kubernetes 集群的每个 pod 中本地执行。这些策略可以与安全、路由、断路器或监控有关。&lt;/p&gt;
&lt;p&gt;下图取自 Istio 架构文档，虽然标注的技术是 Istio 特有的，但这些组件对所有服务网格的实现都是通用的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Istio 架构&#34; srcset=&#34;
               /docs/translation/service-mesh-ultimate-guide-e2/arch_hu649180fa1fdd766ef9a9fb265f9f683c_96072_42d3413582627a153c287b8a99601f69.webp 400w,
               /docs/translation/service-mesh-ultimate-guide-e2/arch_hu649180fa1fdd766ef9a9fb265f9f683c_96072_e124a62615957f94d8058c3f26e57206.webp 760w,
               /docs/translation/service-mesh-ultimate-guide-e2/arch_hu649180fa1fdd766ef9a9fb265f9f683c_96072_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://jimmysong.io/docs/docs/translation/service-mesh-ultimate-guide-e2/arch_hu649180fa1fdd766ef9a9fb265f9f683c_96072_42d3413582627a153c287b8a99601f69.webp&#34;
               width=&#34;760&#34;
               height=&#34;538&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Istio 架构，展示了控制平面和代理数据平面的交互方式（由 &lt;a href=&#34;https://istio.io/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档提供&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;使用案例&#34;&gt;使用案例&lt;/h2&gt;
&lt;p&gt;服务网格可以实现或支持多种用例。&lt;/p&gt;
&lt;h3 id=&#34;动态服务发现和路由&#34;&gt;动态服务发现和路由&lt;/h3&gt;
&lt;p&gt;服务网格提供动态服务发现和流量管理，包括用于测试的流量影子（复制），以及用于金丝雀发布和 A/B 实验的流量分割。&lt;/p&gt;
&lt;p&gt;服务网格中使用的代理通常是 “应用层 &amp;quot; 感知的（在 OSI 网络堆栈的第 7 层运行）。这意味着流量路由决策和指标的标记可以利用 HTTP 头或其他应用层协议元数据。&lt;/p&gt;
&lt;h3 id=&#34;服务间通信可靠性&#34;&gt;服务间通信可靠性&lt;/h3&gt;
&lt;p&gt;服务网格支持跨领域的可靠性要求的实施和执行，如请求重试、超时、速率限制和断路。服务网格经常被用来补偿（或封装）处理&lt;a href=&#34;https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分布式计算的八个谬误&lt;/a&gt;。应该注意的是，服务网格只能提供 wire-level 的可靠性支持（如重试 HTTP 请求），最终服务应该对相关的业务影响负责，如避免多个（非幂等的）HTTP POST 请求。&lt;/p&gt;
&lt;h3 id=&#34;流量的可观察性&#34;&gt;流量的可观察性&lt;/h3&gt;
&lt;p&gt;由于服务网格处于系统内处理的每个请求的关键路径上，它还可以提供额外的 “可观察性”，例如请求的分布式追踪、HTTP 错误代码的频率以及全局和服务间的延迟。虽然在企业领域是一个被过度使用的短语，但服务网格经常被提议作为一种方法来捕获所有必要的数据，以实现整个系统内流量的统一界面视图。&lt;/p&gt;
&lt;h3 id=&#34;通信安全&#34;&gt;通信安全&lt;/h3&gt;
&lt;p&gt;服务网格还支持跨领域安全要求的实施和执行，如提供服务身份（通过 x509 证书），实现应用级服务 / 网络分割（例如，“服务 A&amp;quot; 可以与 “服务 B “通信，但不能与 “服务 C “通信），确保所有通信都经过加密（通过 TLS），并确保存在有效的用户级身份令牌或 “&lt;a href=&#34;https://qconsf.com/sf2019/presentation/user-device-identity-microservices-netflix-scale&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;护照&lt;/a&gt; &amp;ldquo;。&lt;/p&gt;
&lt;h2 id=&#34;反模式&#34;&gt;反模式&lt;/h2&gt;
&lt;p&gt;当反模式的使用出现时，这往往是一个技术成熟的标志。服务网格也不例外。&lt;/p&gt;
&lt;h3 id=&#34;太多的流量管理层次&#34;&gt;太多的流量管理层次&lt;/h3&gt;
&lt;p&gt;当开发人员不与平台或运维团队协商，并在现在通过服务网格实现的代码中重复现有的通信处理逻辑时，就会出现这种反模式。例如，除了服务网格提供的 wire-level 重试策略外，应用程序还在代码中还实现了重试策略。这种反模式会导致重复的事务等问题。&lt;/p&gt;
&lt;h3 id=&#34;服务网格银弹&#34;&gt;服务网格银弹&lt;/h3&gt;
&lt;p&gt;在 IT 领域没有 “银弹 “这样的东西，但供应商有时会被诱惑给新技术贴上这个标签。服务网格不会解决微服务、Kubernetes 等容器编排器或云网络的所有通信问题。服务网格的目的只是促进服务件（东西向）的通信，而且部署和运行服务网格有明显的运营成本。&lt;/p&gt;
&lt;h3 id=&#34;企业服务总线esb20&#34;&gt;企业服务总线（ESB）2.0&lt;/h3&gt;
&lt;p&gt;在前微服务面向服务架构（SOA）时代，企业服务总线（ESB）实现了软件组件之间的通信系统。有些人担心 ESB 时代的许多错误会随着服务网格的使用而重演。&lt;/p&gt;
&lt;p&gt;通过 ESB 提供的集中的通信控制显然有价值。然而，这些技术的发展是由供应商推动的，这导致了多种问题，例如：ESB 之间缺乏互操作性，行业标准的定制扩展（例如，将供应商的特定配置添加到 WS-* 兼容模式中），以及高成本。ESB 供应商也没有做任何事情来阻止业务逻辑与通信总线的集成和紧耦合。&lt;/p&gt;
&lt;h3 id=&#34;大爆炸部署&#34;&gt;大爆炸部署&lt;/h3&gt;
&lt;p&gt;在整个 IT 界有一种诱惑，认为大爆炸式的部署方法是最容易管理的方法，但正如 &lt;a href=&#34;https://itrevolution.com/book/accelerate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Accelerate&lt;/a&gt; 和 &lt;a href=&#34;https://puppet.com/resources/report/state-of-devops-report/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DevOps 报告&lt;/a&gt;的研究，事实并非如此。由于服务网格的全面推广意味着这项技术处于处理所有终端用户请求的关键路径上，大爆炸式的部署是非常危险的。&lt;/p&gt;
&lt;h3 id=&#34;死星建筑&#34;&gt;死星建筑&lt;/h3&gt;
&lt;p&gt;当企业采用微服务架构，开发团队开始创建新的微服务或在应用中利用现有的服务时，服务间的通信成为架构的一个关键部分。如果没有一个良好的治理模式，这可能会导致不同服务之间的紧密耦合。当整个系统在生产中出现问题时，也将很难确定哪个服务出现了问题。&lt;/p&gt;
&lt;p&gt;如果缺乏服务沟通战略和治理模式，该架构就会变成所谓的 “死星架构”。&lt;/p&gt;
&lt;p&gt;关于这种架构反模式的更多信息，请查看关于云原生架构采用的&lt;a href=&#34;https://www.infoq.com/articles/cloud-native-architecture-adoption-part1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;第一部分&lt;/a&gt;、&lt;a href=&#34;https://www.infoq.com/articles/cloud-native-architecture-adoption-part2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;第二部分&lt;/a&gt;和&lt;a href=&#34;https://www.infoq.com/articles/cloud-native-architecture-adoption-part3/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;第三部分的&lt;/a&gt;文章。&lt;/p&gt;
&lt;h3 id=&#34;特定领域的服务网格&#34;&gt;特定领域的服务网格&lt;/h3&gt;
&lt;p&gt;服务网格的本地实现和过度优化有时会导致服务网格部署范围过窄。开发人员可能更喜欢针对自己的业务领域的服务网格，但这种方法弊大于利。我们不希望实现过于细化的服务网格范围，比如为组织中的每个业务或功能域（如财务、人力资源、会计等）提供专用的服务网格。这就违背了拥有像服务网格这样的通用服务协调解决方案的目的，即企业级服务发现或跨域服务路由等功能。&lt;/p&gt;
&lt;h2 id=&#34;服务网格的实现和产品&#34;&gt;服务网格的实现和产品&lt;/h2&gt;
&lt;p&gt;以下是一份非详尽的当前服务网格实施清单。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd &lt;/a&gt;(CNCF 毕业项目)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kuma.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuma&lt;/a&gt;（CNCF 沙盒项目）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/app-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS App Mesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nginx.com/products/nginx-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX Service Mesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aspenmesh.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AspenMesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://konghq.com/kong-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.solo.io/products/gloo-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo Gloo Mesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://traefik.io/traefik-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Traefik Mesh&lt;/a&gt;（原名 Maesh）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://layer5.io/meshery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Meshery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://openservicemesh.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Service MEsh&lt;/a&gt;（CNCF 沙盒项目）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，像 &lt;a href=&#34;https://www.datadoghq.com/blog/tag/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DataDog&lt;/a&gt; 这样的其他产品也开始提供与 &lt;a href=&#34;https://docs.datadoghq.com/integrations/linkerd/?tab=host&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt;、Istio、Consul Connect 和 AWS App Mesh 等服务网格技术的集成。&lt;/p&gt;
&lt;h2 id=&#34;服务网格对比&#34;&gt;服务网格对比&lt;/h2&gt;
&lt;p&gt;服务网格领域的发展极为迅速，因此任何试图创建比较的努力都可能很快变得过时。然而，确实存在一些比较。应该注意了解来源的偏见（如果有的话）和进行比较的日期。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://layer5.io/landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://layer5.io/landscape&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubedex.com/istio-vs-linkerd-vs-linkerd2-vs-consul/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubedex.com/istio-vs-linkerd-vs-linkerd2-vs-consul/&lt;/a&gt;（截至 2021 年 8 月的正确数据）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://platform9.com/blog/kubernetes-service-mesh-a-comparison-of-istio-linkerd-and-consul/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://platform9.com/blog/kubernetes-service-mesh-a-comparison-of-istio-linkerd-and-consul/&lt;/a&gt;（截至 2019 年 10 月的最新情况）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://servicemesh.es/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://servicemesh.es/ &lt;/a&gt;(最后发表于 2021 年 8 月)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InfoQ 一直建议服务网格的采用者对每个产品进行自己的尽职调查和试验。&lt;/p&gt;
&lt;h2 id=&#34;服务网格教程&#34;&gt;服务网格教程&lt;/h2&gt;
&lt;p&gt;对于希望试验多服务网格的工程师或建筑师来说，可以使用以下教程、游戏场和工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://layer5.io/meshery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Layer 5 Meshery&lt;/a&gt;—— 多网格管理平面&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/solo-io/supergloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Solo 的 Gloo Mesh&lt;/a&gt;—— 服务网格编排平台&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.katacoda.com/courses/istio/deploy-istio-on-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KataCoda Istio 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.hashicorp.com/consul&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul 服务网格教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://linkerd.io/2/getting-started/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.nginx.com/nginx-service-mesh/tutorials/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NGINX 服务网格教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tetrate-academy.thinkific.com/courses/istio-fundamentals-zh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 基础教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务网格的历史&#34;&gt;服务网格的历史&lt;/h2&gt;
&lt;p&gt;自 2013 年底 Airbnb 发布 &lt;a href=&#34;https://medium.com/airbnb-engineering/smartstack-service-discovery-in-the-cloud-4b8a080de619&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SmartStack&lt;/a&gt;，为新兴的 “ &lt;a href=&#34;https://www.infoq.com/microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务 &lt;/a&gt;“风格架构提供进程外服务发现机制（使用 &lt;a href=&#34;http://www.haproxy.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HAProxy&lt;/a&gt;）以来，InfoQ 一直在跟踪这个我们现在称之为 &lt;a href=&#34;https://www.infoq.com/servicemesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;的话题。许多之前被贴上 “独角兽 “标签的组织在此之前就在研究类似的技术。从 21 世纪初开始，谷歌就在开发其 &lt;a href=&#34;https://grpc.io/blog/principles/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stubby &lt;/a&gt;RPC 框架，该框架演变成了 &lt;a href=&#34;https://cloud.google.com/blog/products/gcp/grpc-a-true-internet-scale-rpc-framework-is-now-1-and-ready-for-production-deployments&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC&lt;/a&gt;，以及 &lt;a href=&#34;https://landing.google.com/sre/sre-book/chapters/production-environment/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谷歌前端（GFE）&lt;/a&gt;和全局软件负载均衡器（GSLB），在 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 中可以看到它们的特质。在 2010 年代早期，Twitter 开始了 Scala 驱动的 &lt;a href=&#34;https://twitter.github.io/finagle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Finagle&lt;/a&gt; 的工作，&lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 服务网格由此产生。&lt;/p&gt;
&lt;p&gt;2014 年底，Netflix 发布了&lt;a href=&#34;https://netflix.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一整套基于 JVM 的实用程序&lt;/a&gt;，包括 &lt;a href=&#34;https://www.infoq.com/news/2014/12/netflix-prana/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prana&lt;/a&gt;，一个 “sidecar “程序，允许用任何语言编写的应用服务通过 HTTP 与库的独立实例进行通信。2016 年，NGINX 团队开始谈论 “&lt;a href=&#34;https://www.nginx.com/blog/microservices-reference-architecture-nginx-fabric-model/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fabric 模型&lt;/a&gt; &amp;ldquo;，这与服务网格非常相似，但需要使用他们的商业 NGINX Plus 产品来实现。另外，Linkerd v0.2 在 2016 年 2 月&lt;a href=&#34;https://linkerd.io/2016/02/18/linkerd-twitter-style-operability-for-microservices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;发布&lt;/a&gt;，尽管该团队直到后来才开始称它为服务网格。&lt;/p&gt;
&lt;p&gt;服务网格历史上的其他亮点包括 2017 年 5 月的 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt;、2018 年 7 月的 &lt;a href=&#34;https://linkerd.io/2018/09/18/announcing-linkerd-2-0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd 2.0&lt;/a&gt;、2018 年 11 月的 &lt;a href=&#34;https://www.hashicorp.com/products/consul/service-mesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul Connect&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/solo-io/supergloo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gloo Mesh&lt;/a&gt;、2019 年 5 月的 &lt;a href=&#34;https://smi-spec.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格接口（SMI）&lt;/a&gt;，以及 2019 年 9 月的 Maesh（现在叫 Traefik Mesh）和 Kuma。&lt;/p&gt;
&lt;p&gt;即使是在独角兽企业之外出现的服务网格，如 HashiCorp 的 &lt;a href=&#34;https://www.consul.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Consul&lt;/a&gt;，也从上述技术中获得了灵感，通常旨在实现 CoreOS 提出的 “&lt;a href=&#34;https://github.com/linearregression/GIFEE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GIFEE &lt;/a&gt;“概念；所有人可用的 Google 基础设施（Google infrastructure for everyone else）。&lt;/p&gt;
&lt;p&gt;为了深入了解现代服务网格概念的演变历史，&lt;a href=&#34;https://philcalcado.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Phil Calçado&lt;/a&gt; 写了一篇全面的文章 “ &lt;a href=&#34;https://philcalcado.com/2017/08/03/pattern_service_mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;模式：服务网格&lt;/a&gt; &amp;ldquo;。&lt;/p&gt;
&lt;h2 id=&#34;服务网格标准&#34;&gt;服务网格标准&lt;/h2&gt;
&lt;p&gt;尽管在过去的几年里，服务网格技术年复一年地发生着重大转变，但服务网格的标准还没有跟上创新的步伐。&lt;/p&gt;
&lt;p&gt;使用服务网格解决方案的主要标准是&lt;a href=&#34;https://smi-spec.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格接口&lt;/a&gt;（SMI）。服务网格接口是在 &lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 上运行的服务网格的一个规范。它本身并没有实现服务网格，而是定义了一个通用的标准，可以由各种服务网格供应商来实现。&lt;/p&gt;
&lt;p&gt;SMI API 的目标是提供一套通用的、可移植的服务网格 API，Kubernetes 用户可以以一种与提供者无关的方式使用。通过这种方式，人们可以定义使用服务网格技术的应用程序，而不需要与任何特定的实现紧密结合。&lt;/p&gt;
&lt;p&gt;SMI 基本上是一个 Kubernetes 自定义资源定义（&lt;a href=&#34;https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CRD&lt;/a&gt;）和扩展 API 服务器的集合。这些 API 可以安装到任何 Kubernetes 集群，并使用标准工具进行操作。为了激活这些 API，需要在 Kubernetes 集群中运行一个 SMI 提供者。&lt;/p&gt;
&lt;p&gt;SMI 规范既允许终端用户的标准化，也允许服务网格技术提供商的创新。SMI 实现了灵活性和互操作性，并涵盖了最常见的服务网格功能。目前的&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec/tree/main/apis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;规范组件&lt;/a&gt;集中在服务网格能力的连接方面。API 规范包括以下内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量访问控制&lt;/li&gt;
&lt;li&gt;流量指标&lt;/li&gt;
&lt;li&gt;流量规格&lt;/li&gt;
&lt;li&gt;流量分割&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前的 SMI &lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生态系统&lt;/a&gt;包括广泛的服务网格，包括 Istio、Linkerd、Consul Connect、Gloo Mesh 等。&lt;/p&gt;
&lt;p&gt;SMI 规范是在 &lt;a href=&#34;http://www.apache.org/licenses/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache License 2.0 版本下&lt;/a&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec/blob/main/LICENSE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许可的&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果你想了解更多关于 SMI 规范及其 API 细节，请查看以下链接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec/blob/main/SPEC_LATEST_STABLE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;核心规范&lt;/a&gt;（当前版本：0.6.0）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;规范 Github 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec/blob/main/CONTRIBUTING.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何贡献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;服务网格基准测试&#34;&gt;服务网格基准测试&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://smp-spec.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格性能&lt;/a&gt;是一个捕捉基础设施容量、服务网配置和工作负载元数据细节的标准。SMP 规范用于捕捉以下细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境和基础设施细节&lt;/li&gt;
&lt;li&gt;节点的数量和规模，编排器&lt;/li&gt;
&lt;li&gt;服务网格和它的配置&lt;/li&gt;
&lt;li&gt;工作量 / 应用细节&lt;/li&gt;
&lt;li&gt;进行统计分析以确定性能特征&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来自 Linkerd 团队的 William Morgan &lt;a href=&#34;https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;写了&lt;/a&gt;关于 Linkerd 和 Istio 的性能基准测试。还有一篇来自 2019 年的&lt;a href=&#34;https://istio.io/latest/blog/2019/performance-best-practices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文章&lt;/a&gt;，介绍了 Istio 关于服务网格性能基准测试的最佳实践。&lt;/p&gt;
&lt;p&gt;重要的是要记住，就像其他性能基准测试一样，你不应该对任何这些外部出版物投入过多的注意力，特别是产品供应商发表的文章。该在你的服务器环境中设计和执行你自己的性能测试，以验证哪个具体产品适合你的应用程序的业务和非功能要求。&lt;/p&gt;
&lt;h2 id=&#34;探索服务网格的未来&#34;&gt;探索服务网格的未来&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.infoq.com/profile/Kasun-Indrasiri/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kasun Indrasiri&lt;/a&gt; 探讨了 “ &lt;a href=&#34;https://www.infoq.com/articles/service-mesh-event-driven-messaging/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为事件驱动的消息传递使用服务网格的潜力&lt;/a&gt; &amp;ldquo;，他在其中讨论了在服务网格中实现消息传递支持的两种主要的新兴架构模式：协议代理 sidecar 和 HTTP 桥接 sidecar。这是服务网格社区中一个活跃的发展领域，在 &lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/2852&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 中&lt;/a&gt;支持 &lt;a href=&#34;https://github.com/envoyproxy/envoy/issues/2852&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache Kafka 的&lt;/a&gt;工作引起了相当多的关注。&lt;/p&gt;
&lt;p&gt;Christian Posta 之前在 “&lt;a href=&#34;https://www.infoq.com/articles/service-mesh-api-federating/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Towards a Unified, Standard API for Consolidating Service Meshes &lt;/a&gt;中写过关于服务网格使用标准化的尝试。这篇文章还讨论了 2019 年微软和合作伙伴在 KubeCon EU 上宣布的&lt;a href=&#34;https://cloudblogs.microsoft.com/opensource/2019/05/21/service-mesh-interface-smi-release/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格接口（SMI）&lt;/a&gt;。SMI 定义了一套通用和可移植的 API，旨在为开发人员提供不同服务网格技术的互操作性，包括 Istio、Linkerd 和 Consul Connect。&lt;/p&gt;
&lt;p&gt;将服务网格与平台结构整合的主题可以进一步分为两个子主题。&lt;/p&gt;
&lt;p&gt;首先，正在进行的工作是减少由服务网格数据平面引入的网络开销。这包括&lt;a href=&#34;https://www.dpdk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据平面开发工具包（DPDK）&lt;/a&gt;，它是一个&lt;a href=&#34;https://www.linuxjournal.com/content/userspace-networking-dpdk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用户空间应用程序&lt;/a&gt;，“绕过了 Linux 内核网络堆栈，直接与网络硬件对话”。还有 &lt;a href=&#34;https://www.infoq.com/news/2018/03/cilium-linux-bpf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 团队的&lt;/a&gt;基于 Linux 的 BPF 解决方案，它利用 Linux 内核中的扩展&lt;a href=&#34;https://cilium.io/blog/istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;伯克利包过滤器（eBPF）功能&lt;/a&gt;来实现 “非常有效的网络、策略执行和负载均衡功能”。另一个团队正在用&lt;a href=&#34;https://github.com/networkservicemesh/networkservicemesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络服务网格（Network Service Mesh）&lt;/a&gt;将服务网格的概念映射到 L2/L3 有效载荷，试图 “以云原生的方式重新想象网络功能虚拟化（NFV）&amp;quot;。&lt;/p&gt;
&lt;p&gt;其次，有多项举措将服务网格与公共云平台更紧密地结合在一起，从 &lt;a href=&#34;https://www.infoq.com/news/2019/01/aws-app-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS App Mesh&lt;/a&gt;、&lt;a href=&#34;https://www.infoq.com/news/2019/04/google-traffic-director/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GCP Traffic Director&lt;/a&gt; 和 &lt;a href=&#34;https://www.infoq.com/articles/azure-service-fabric-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Azure Service Fabric Mesh 的&lt;/a&gt;发布可见端倪。&lt;/p&gt;
&lt;p&gt;Buoyant 团队致力于为服务网格技术开发有效的以人为本的控制平面。他们最近发布了 &lt;a href=&#34;https://buoyant.io/cloud/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Buoyant Cloud&lt;/a&gt;，一个基于 SaaS 的 “团队控制平面”，用于平台团队操作 Kubernetes。这个产品将在下面的章节中详细讨论。&lt;/p&gt;
&lt;p&gt;自去年以来，在服务网格领域也有一些创新。&lt;/p&gt;
&lt;h3 id=&#34;多云多集群多租户服务网格&#34;&gt;多云、多集群、多租户服务网格&lt;/h3&gt;
&lt;p&gt;近年来，不同组织对云的采用已经从单一的云解决方案（私有云或公共云）转变为由多个不同供应商（AWS、谷歌、微软 Azure 等）支持的基于多云（私有、公共和混合）的新基础设施。同时，需要支持不同的工作负载（交易、批处理和流媒体），这对实现统一的云架构至关重要。&lt;/p&gt;
&lt;p&gt;这些业务和非功能需求反过来又导致需要在异构基础设施（裸机、虚拟机和 Kubernetes）中部署服务网格解决方案。服务网格需要相应转变，以支持这些不同的工作负载和基础设施。&lt;/p&gt;
&lt;p&gt;像 &lt;a href=&#34;https://konghq.com/blog/multi-cluster-multi-cloud-service-meshes-with-cncfs-kuma-and-envoy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuma&lt;/a&gt; 和 &lt;a href=&#34;https://www.tetrate.io/tetrate-service-bridge/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate Service Bridge&lt;/a&gt; 这样的技术支持多网格控制平面，以使业务应用在多集群和多云服务网格环境中工作。这些解决方案抽象出跨多个区域的服务网格策略的同步以及跨这些区域的服务连接（和服务发现）。&lt;/p&gt;
&lt;p&gt;多集群服务网格技术的另一个新趋势是需要从边缘计算层（物联网设备）到网格层的应用 / 服务连接。&lt;/p&gt;
&lt;h3 id=&#34;媒体服务网格&#34;&gt;媒体服务网格&lt;/h3&gt;
&lt;p&gt;思科系统公司开发的&lt;a href=&#34;https://www.ciscotechblog.com/blog/introducing-media-streaming-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;媒体流网格（Media Streaming Mesh）&lt;/a&gt;或媒体服务网格，用于协调实时应用程序，如多人游戏、多方视频会议或在 Kubernetes 云平台上使用服务网格技术的 CCTV 流。这些应用正越来越多地从单体应用转向微服务架构。服务网格可以通过提供负载均衡、加密和可观察性等功能来帮助应用程序。&lt;/p&gt;
&lt;h3 id=&#34;混沌网格&#34;&gt;混沌网格&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://chaos-mesh.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chaos Mesh&lt;/a&gt; 是 &lt;a href=&#34;https://community.cncf.io/chaos-mesh-community/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF 托管的项目&lt;/a&gt;，是一个开源的、云原生的混沌工程平台，用于托管在 Kubernetes 上的应用程序。虽然不是直接的服务网格实现，但 Chaos Mesh 通过协调应用程序中的故障注入行为来实现混沌工程实验。故障注入是服务网格技术的一个关键能力。&lt;/p&gt;
&lt;p&gt;Chaos Mesh 隐藏了底层的实现细节，因此应用开发者可以专注于实际的混沌实验。Chaos Mesh &lt;a href=&#34;https://chaos-mesh.org/blog/chaos-mesh-q&amp;amp;a/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可以和服务网格一起使用&lt;/a&gt;。请看这个&lt;a href=&#34;https://github.com/sergioarmgpl/operating-systems-usac-course/blob/master/lang/en/projects/project1v3/project1.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用例&lt;/a&gt;，该团队如何使用 Linkerd 和 Chaos Mesh 来为他们的项目进行混沌实验。&lt;/p&gt;
&lt;h3 id=&#34;服务网格作为一种服务&#34;&gt;服务网格作为一种服务&lt;/h3&gt;
&lt;p&gt;一些服务网格供应商，如 Buoyant，正在提供管理服务网格或 “服务网格作为一种服务 “的解决方案。今年早些时候，Buoyant &lt;a href=&#34;https://buoyant.io/newsroom/buoyant-cloud-offers-managed-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宣布&lt;/a&gt;公开测试发布一个名为 &lt;a href=&#34;http://buoyant.io/cloud&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Buoyant Cloud 的&lt;/a&gt; SaaS 应用程序，允许客户组织利用 Linkerd 服务网格的按需支持功能来管理服务网格。&lt;/p&gt;
&lt;p&gt;Buoyant Cloud 解决方案提供的一些功能包括如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动跟踪 Linkerd 数据平面和控制平面的健康状况&lt;/li&gt;
&lt;li&gt;在 Kubernetes 平台上管理跨 pod、代理和集群的服务网格生命周期和版本&lt;/li&gt;
&lt;li&gt;以 SRE 为重点的工具，包括服务水平目标（SLO）、工作负荷黄金指标跟踪和变更跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;网络服务网格nsm&#34;&gt;网络服务网格（NSM）&lt;/h3&gt;
&lt;p&gt;网络服务网格（&lt;a href=&#34;https://networkservicemesh.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NSM&lt;/a&gt;）是云原生计算基金会的另一个沙盒项目，提供了一个混合的、多云的 IP 服务网格。NSM 实现了网络服务连接、安全和可观察性等功能，这些都是服务网格的核心特征。NSM 与现有的容器网络接口（&lt;a href=&#34;https://github.com/containernetworking/cni&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNI&lt;/a&gt;）实现协同工作。&lt;/p&gt;
&lt;h3 id=&#34;服务网格扩展&#34;&gt;服务网格扩展&lt;/h3&gt;
&lt;p&gt;服务网格扩展是另一个已经看到很多创新的领域。服务网格扩展的一些发展包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增强的身份管理，以确保微服务连接的安全，包括自定义证书授权插件&lt;/li&gt;
&lt;li&gt;自适应路由功能，以提高服务的可用性和可扩展性&lt;/li&gt;
&lt;li&gt;加强 sidecar 代理权&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;服务网格业务&#34;&gt;服务网格业务&lt;/h3&gt;
&lt;p&gt;采用服务网格的另一个重要领域是服务网格生命周期的运维方面。操作方面 —— 如配置多集群功能和将 Kubernetes 工作负载连接到虚拟机基础设施上托管的服务器，以及管理多集群服务网格中所有功能和 API 的开发者门户 —— 将在生产中服务网格解决方案的整体部署和支持方面发挥重要作用。&lt;/p&gt;
&lt;h2 id=&#34;常见问题&#34;&gt;常见问题&lt;/h2&gt;
&lt;h3 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h3&gt;
&lt;p&gt;服务网格是一种在分布式（可能是基于微服务的）软件系统内管理所有服务对服务（东西向）流量的技术。它既提供以业务为重点的功能操作，如路由，也提供非功能支持，如执行安全策略、服务质量和速率限制。它通常（尽管不是唯一的）使用 sidecar 代理来实现，所有服务都通过 sidecar 代理进行通信。&lt;/p&gt;
&lt;h3 id=&#34;服务网格与-api-网关有什么不同&#34;&gt;服务网格与 API 网关有什么不同？&lt;/h3&gt;
&lt;p&gt;关于服务网格的定义，见上文。&lt;/p&gt;
&lt;p&gt;另一方面，API 网关管理进入集群的所有入口（南北）流量，并为跨功能的通信要求提供额外支持。它作为进入系统的单一入口点，使多个 API 或服务凝聚在一起，为用户提供统一的体验。&lt;/p&gt;
&lt;h3 id=&#34;如果我正在部署微服务我是否需要服务网格&#34;&gt;如果我正在部署微服务，我是否需要服务网格？&lt;/h3&gt;
&lt;p&gt;不一定。服务网格增加了技术栈的操作复杂性，因此通常只有在组织在扩展服务与服务之间的通信方面遇到困难，或者有特定的用例需要解决时才会部署。&lt;/p&gt;
&lt;h3 id=&#34;我是否需要服务网格来实现微服务的服务发现&#34;&gt;我是否需要服务网格来实现微服务的服务发现？&lt;/h3&gt;
&lt;p&gt;不，服务网格提供了实现服务发现的一种方式。其他解决方案包括特定语言的库（如 Ribbon 和 &lt;a href=&#34;https://www.infoq.com/news/2012/09/Eureka/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Eureka&lt;/a&gt; 或 &lt;a href=&#34;https://www.infoq.com/finagle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Finagle&lt;/a&gt;）。&lt;/p&gt;
&lt;h3 id=&#34;服务网格是否会给我的服务之间的通信增加开销--延迟&#34;&gt;服务网格是否会给我的服务之间的通信增加开销 / 延迟？&lt;/h3&gt;
&lt;p&gt;是的，当一个服务与另一个服务进行通信时，服务网格至少会增加两个额外的网络跳数（第一个是来自处理源的出站连接的代理，第二个是来自处理目的地的入站连接的代理）。然而，这个额外的网络跳转通常发生在 &lt;a href=&#34;https://en.wikipedia.org/wiki/Localhost&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;localhost 或 loopback 网络接口&lt;/a&gt;上，并且只增加了少量的延迟（在毫秒级）。实验和了解这对目标用例是否是一个问题，应该是服务网格分析和评估的一部分。&lt;/p&gt;
&lt;h3 id=&#34;服务网格不应该是-kubernetes-或应用程序被部署到的-云原生平台-的一部分吗&#34;&gt;服务网格不应该是 Kubernetes 或应用程序被部署到的 &amp;ldquo;云原生平台&amp;rdquo; 的一部分吗？&lt;/h3&gt;
&lt;p&gt;潜在的。有一种说法是在云原生平台组件内保持关注点的分离（例如，Kubernetes 负责提供容器编排，而服务网格负责服务间的通信）。然而，正在进行的工作是将类似服务网格的功能推向现代平台即服务（PaaS）产品。&lt;/p&gt;
&lt;h3 id=&#34;我如何实施部署或推广服务网格&#34;&gt;我如何实施、部署或推广服务网格？&lt;/h3&gt;
&lt;p&gt;最好的方法是分析各种服务网格产品（见上文），并遵循所选网格特有的实施准则。一般来说，最好是与所有利益相关者合作，逐步将任何新技术部署到生产中。&lt;/p&gt;
&lt;h3 id=&#34;我可以建立自己的服务网格吗&#34;&gt;我可以建立自己的服务网格吗？&lt;/h3&gt;
&lt;p&gt;是的，但更相关的问题是，你应该吗？建立一个服务网格是你组织的核心竞争力吗？你能否以更有效的方式为你的客户提供价值？你是否也致力于维护你自己的网络，为安全问题打补丁，并不断更新它以利用新技术？由于现在有一系列的开源和商业服务网格产品，使用现有的解决方案很可能更有效。&lt;/p&gt;
&lt;h3 id=&#34;在一个软件交付组织内哪个团队拥有服务网格&#34;&gt;在一个软件交付组织内，哪个团队拥有服务网格？&lt;/h3&gt;
&lt;p&gt;通常，平台或运维团队拥有服务网格，以及 Kubernetes 和持续交付管道基础设施。然而，开发人员将配置服务网格的属性，因此这两个团队应该紧密合作。许多企业正在追随云计算先锋的脚步，如 Netflix、Spotify 和谷歌，并正在创建内部平台团队，为&lt;a href=&#34;https://www.infoq.com/news/2018/06/netflix-full-cycle-developers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以产品为重点的全周期开发团队&lt;/a&gt;提供工具和服务。&lt;/p&gt;
&lt;h3 id=&#34;envoy-是一个服务网格吗&#34;&gt;Envoy 是一个服务网格吗？&lt;/h3&gt;
&lt;p&gt;Envoy 是一个云原生代理，最初是由 Lyft 团队设计和构建的。Envoy 经常被用作服务网格的数据平面。然而，为了被认为是一个服务网格，Envoy 必须与控制平面一起使用，这样才能使这些技术集合成为一个服务网格。控制平面可以是简单的集中式配置文件库和指标收集器，也可以是全面 / 复杂的 Istio。&lt;/p&gt;
&lt;h3 id=&#34;istio-和-服务网格--这两个词可以互换使用吗&#34;&gt;Istio 和 “服务网格 &amp;quot; 这两个词可以互换使用吗？&lt;/h3&gt;
&lt;p&gt;不，Istio 是服务网格的一种。由于 Istio 在服务网格类别出现时很受欢迎，一些人将 Istio 和服务网格混为一谈。这个混淆的问题并不是服务网格所独有的，同样的挑战发生在 Docker 和容器技术上。&lt;/p&gt;
&lt;h3 id=&#34;我应该使用哪个服务网格&#34;&gt;我应该使用哪个服务网格？&lt;/h3&gt;
&lt;p&gt;这个问题没有唯一的答案。工程师必须了解他们当前的需求，以及他们的实施团队的技能、资源和时间。上面的服务网格比较链接将提供一个良好的探索起点，但我们强烈建议企业至少尝试两个网格，以了解哪些产品、技术和工作流程最适合他们。&lt;/p&gt;
&lt;h3 id=&#34;我可以在-kubernetes-之外使用服务网吗&#34;&gt;我可以在 Kubernetes 之外使用服务网吗？&lt;/h3&gt;
&lt;p&gt;是的。许多服务网格允许在各种基础设施上安装和管理数据平面代理和相关控制平面。&lt;a href=&#34;https://www.hashicorp.com/resources/consul-service-mesh-kubernetes-and-beyond&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HashiCorp 的 Consul&lt;/a&gt; 是最知名的例子，Istio 也被实验性地用于 Cloud Foundry。&lt;/p&gt;
&lt;h2 id=&#34;其他资源&#34;&gt;其他资源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/servicemesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ 服务网格主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/minibooks/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InfoQ eMag：服务网格的过去、现在和未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://servicemesh.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格：每位软件工程师都需要了解的世界上最容易被滥用的技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://servicemesh.es/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格的比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://softwareengineeringdaily.com/2020/01/07/service-meshes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.com/articles/cloud-native-architecture-adoption-part3/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;采用云原生架构，第三部分：服务协调和服务网格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #9 杭州站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-09/</link>
      <pubDate>Tue, 24 Dec 2019 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-09/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;h3 id=&#34;蚂蚁集团-api-gateway-mesh-的思考与实践&#34;&gt;蚂蚁集团 API Gateway Mesh 的思考与实践&lt;/h3&gt;
&lt;p&gt;主讲人: 贾岛&lt;/p&gt;
&lt;p&gt;在 Service Mesh 微服务架构中，我们常常会听到东西流量和南北流量两个术语。蚂蚁集团开源的Service Mesh Sidecar MOSN 已经多次与大家见面交流了，以往的议题重点在东西流量的服务发现与路由，那么蚂蚁集团在南北流量上的思考是怎样的？本次分享，将从蚂蚁集团 API 网关发展历程来看，Mesh 化的网关架构是怎样的，解决了什么问题，双十一的实践表现，以及我们对未来的思考。&lt;/p&gt;
&lt;h3 id=&#34;酷家乐的-istio-与-knative-踩坑实录&#34;&gt;酷家乐的 Istio 与 Knative 踩坑实录&lt;/h3&gt;
&lt;p&gt;主讲人: 付铖&lt;/p&gt;
&lt;p&gt;酷家乐在部分业务模块，自2018年使用了 Istio 进行服务治理，自2019年使用了 Knative 作为 FaaS 基础设施，在实践过程中解决了大量问题，也积累了不少第一手经验。本次分享，将重点讨论服务网格的性能损耗，存量业务迁移难题，函数计算的冷启动时间问题以及解决方案等。&lt;/p&gt;
&lt;h3 id=&#34;云原生开放智能网络代理-mosn-金融级云原生架构助推器-蚂蚁集团&#34;&gt;云原生开放智能网络代理 MOSN 金融级云原生架构助推器-蚂蚁集团&lt;/h3&gt;
&lt;p&gt;主讲人：肖涵（涵畅）&lt;/p&gt;
&lt;h3 id=&#34;圆桌环节service-mesh-落地的务实与创新&#34;&gt;圆桌环节：Service Mesh 落地的务实与创新&lt;/h3&gt;
&lt;p&gt;主讲人: 鲁直 、涵畅 、张超盟 、付铖 、王国云&lt;/p&gt;
&lt;h3 id=&#34;蚂蚁集团-service-mesh-技术风险思考和实践&#34;&gt;蚂蚁集团 Service Mesh 技术风险思考和实践&lt;/h3&gt;
&lt;p&gt;主讲人: 嘉祁&lt;/p&gt;
&lt;p&gt;Servish Mesh 是微服务架构与云原生碰撞出的火花，对于传统的中间件体系与运维支撑能力是极大的挑战。本次分享的主题主要关注于在蚂蚁集团内部如何应对这些挑战，并建设相应的技术风险能力来保障其稳定。&lt;/p&gt;
&lt;h3 id=&#34;网易严选的-service-mesh-实践&#34;&gt;网易严选的 Service Mesh 实践&lt;/h3&gt;
&lt;p&gt;主讲人: 王国云&lt;/p&gt;
&lt;p&gt;网易严选在2016年选择了 Service Mesh 作为未来微服务改造的基础架构，并在过去几年支持了业务的持续快速增长。本次分享主要介绍 Service Mesh 在严选的落地和演进情况，讨论 Service Mesh 在混合云架构下落地遇到的挑战和我们的解决方案，同时也希望和大家交流一下在架构方面的一些思考。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #8 北京站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-08/</link>
      <pubDate>Sun, 24 Nov 2019 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-08/</guid>
      <description>&lt;p&gt;本期为 Service Mesh Meetup#8 特别场，联合 CNCF、阿里巴巴及蚂蚁集团共同举办。&lt;/p&gt;
&lt;p&gt;不是任何一朵云都撑得住双 11。&lt;/p&gt;
&lt;p&gt;成交 2684 亿，阿里巴巴核心系统 100% 上云。&lt;/p&gt;
&lt;p&gt;蚂蚁集团的核心交易链路大规模上线 Service Mesh。&lt;/p&gt;
&lt;p&gt;这次，让双 11 狂欢继续，让云原生经得起双 11 大考，也让云原生走到开发者身边。&lt;/p&gt;
&lt;p&gt;你将收获 3 大经验加持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双 11 洗礼下的阿里巴巴 K8s 超大规模实践经验&lt;/li&gt;
&lt;li&gt;蚂蚁集团首次 Service Mesh 大规模落地经验&lt;/li&gt;
&lt;li&gt;阿里巴巴超大规模神龙裸金属 K8s 集群运维实践经验&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h3&gt;
&lt;h4 id=&#34;释放云原生价值双-11-洗礼下的阿里巴巴-k8s-超大规模实践&#34;&gt;释放云原生价值，双 11 洗礼下的阿里巴巴 K8s 超大规模实践&lt;/h4&gt;
&lt;p&gt;主讲人：曾凡松（逐灵） 、汪萌海（木苏）&lt;/p&gt;
&lt;p&gt;2019 双 11 点燃了全球人民的购物热情，而阿里经济体核心系统全面上云则刷爆了国内的技术圈子，引起了众多热爱云计算、云原生技术专家的热议。阿里巴巴是首个在超大规模体量公司内大规模使用 K8s 的公司，借此机会将为大家带来阿里巴巴在生产场景中大规模应用 K8s 的实践经验，包括在大规模应用管理上的经验教训；当前如何通过云原生方式高效管理应用；以及对未来应用管理发展趋势的基本看法。&lt;/p&gt;
&lt;h4 id=&#34;蚂蚁集团双-11-service-mesh-超大规模落地实践&#34;&gt;蚂蚁集团双 11 Service Mesh 超大规模落地实践&lt;/h4&gt;
&lt;p&gt;主讲人: 黄挺（鲁直） 、雷志远（碧远）&lt;/p&gt;
&lt;p&gt;Service Mesh 在过去几年中取得了巨大的关注，但是业界大规模的落地却比较少，目前蚂蚁集团已经在双十一的核心交易链路中大规模上线 Service Mesh，在本次分享中，我们将详细分享我们如何做大规模的落地，在大规模落地 Service Mesh 的时候遇到了什么样的问题，对应的解法又是什么，分享我们在大规模落地 Service Mesh 之后取得的收益，希望能够给有志于尝试 Service Mesh 的公司带来更多的参考。&lt;/p&gt;
&lt;h4 id=&#34;阿里巴巴超大规模神龙裸金属-k8s-集群运维实践&#34;&gt;阿里巴巴超大规模神龙裸金属 K8s 集群运维实践&lt;/h4&gt;
&lt;p&gt;主讲人: 周涛 (广侯）&lt;/p&gt;
&lt;p&gt;2019 年是云原生大规模落地的元年，阿里巴巴集团底层基础设施全部搬迁到公有云上，并基于阿里云最新一代的神龙裸金属服务器共同形成了云原生的最佳组合。本次分享将介绍大规模的神龙裸金属云原生集群如何管理和运维的实践。&lt;/p&gt;
&lt;h4 id=&#34;深入kubernetes的无人区--蚂蚁集团双十一的调度系统&#34;&gt;深入Kubernetes的“无人区” — 蚂蚁集团双十一的调度系统&lt;/h4&gt;
&lt;p&gt;主讲人: 曹寅&lt;/p&gt;
&lt;p&gt;蚂蚁集团今年已全面落地 Kubernetes, 支撑双 11 大促。这次分享主要介绍我们在落地过程中面对的各项新技术挑战，及应对这些问题形成的最佳实践，话题包含了规模化 Kubernetes 实践、计算型业务的统一调度与资源混部、蚂蚁双大促分时调度以及 Service Mesh 落地等。&lt;/p&gt;
&lt;h4 id=&#34;服务网格在路口的产品思考与实践&#34;&gt;服务网格在“路口”的产品思考与实践&lt;/h4&gt;
&lt;p&gt;主讲人: 宋顺（齐天）&lt;/p&gt;
&lt;p&gt;这次分享主要介绍在云原生概念如火如荼而金融行业还处在数字化转型初期的当下，蚂蚁集团服务网格从技术到产品化过程中的思考与实践。内容包括：规模化场景下如何平滑过渡、如何兼顾性能与稳定性、如何支持多语言多协议、无侵入、异构服务统一治理等方面的思考和实践。&lt;/p&gt;
&lt;h4 id=&#34;阿里集团核心应用落地-service-mesh-的挑战与机遇&#34;&gt;阿里集团核心应用落地 Service Mesh 的挑战与机遇&lt;/h4&gt;
&lt;p&gt;主讲人: 李云（至简）&lt;/p&gt;
&lt;p&gt;将分享阿里巴巴集团在核心应用落地 Service Mesh 时如何做到“在飞行的飞机上换引擎”，以及在落地的过程中面临的挑战。那些挑战虽然在现阶段的落地过程中并没有全面解决，但给后面的发展和技术突破重点指引了方向。 此外，Service Mesh 作为云原生技术的关键内容，还将分享在这个技术趋势下的发展思考，与大家交流什么是“三位一体”，以及未来 Service Mesh 应当“长成什么模样”。&lt;/p&gt;
&lt;h4 id=&#34;蚂蚁集团云原生-paas-实践之路&#34;&gt;蚂蚁集团云原生 PaaS 实践之路&lt;/h4&gt;
&lt;p&gt;主讲人: 王成昌（晙曦）&lt;/p&gt;
&lt;p&gt;已实现异地多活单元化架构的蚂蚁集团、网商银行基础设施正全面拥抱云原生。本次分享将首次披露蚂蚁集团 PaaS 产品层的建设思路：SOFAStack-CAFE - 承担着海量应用管理、变更保障、容灾多活的应用 PaaS，如何结合实际金融级技术风险保障诉求，基于 Kubernetes 构建云原生运维体系。内容将包括多集群联邦、核心运维能力下沉、发布变更体系、运行时安全、应用交付模式、SOFAMesh 运维体系支撑等方面的实践探索。&lt;/p&gt;
&lt;h4 id=&#34;函数计算在双十一小程序场景的应用&#34;&gt;函数计算在双十一小程序场景的应用&lt;/h4&gt;
&lt;p&gt;主讲人: 吴天龙 （木吴）&lt;/p&gt;
&lt;p&gt;小程序是轻量级的快速迭代的移动应用，对小程序开发者的开发效率有很高的要求。使用函数计算，开发者无需关心后端服务的搭建运维，只需要编写函数就能够提供稳定可靠并且弹性伸缩的服务。双 11 中很多推广活动都是以小程序的方式提供给用户的，在活动时间会有集中的访问，这对后端服务的稳定和弹性是很大的考验。使用函数计算提供的预留实例，可提前为活动高峰预留一部分资源，结合极速的弹性伸缩，轻松应对活动高峰。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #7 成都站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-07/</link>
      <pubDate>Sat, 26 Oct 2019 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-07/</guid>
      <description>&lt;p&gt;本期 Meetup 邀请社区大咖，从服务网格下微服务架构设计、在 5G 时代的应用、如何使用开源的 Traefik 构建云原生边缘路由及蚂蚁集团的服务网格代理演进角度给大家带来精彩分享。&lt;/p&gt;
&lt;h3 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h3&gt;
&lt;h4 id=&#34;服务网格技术在5g网络管理平台中的落地实践&#34;&gt;服务网格技术在5G网络管理平台中的落地实践&lt;/h4&gt;
&lt;p&gt;赵化冰（中兴通讯网管软件资深专家）&lt;/p&gt;
&lt;p&gt;在通信网络向5G演进的过程中，电信行业借鉴了IT行业的微服务架构和云原生相关技术对5G网络功能进行重构，以提供敏捷、灵活、易于扩展的业务能力。 本演讲主题将介绍在5G网络管理平台的微服务架构中落地微服务网格的产品实践，包括多网络平面支持、API网关和网格Ingress的定位、Consul Registry的性能增强等等。&lt;/p&gt;
&lt;h4 id=&#34;蚂蚁集团网络代理的演进之路&#34;&gt;蚂蚁集团网络代理的演进之路&lt;/h4&gt;
&lt;p&gt;肖涵（蚂蚁集团高级技术专家）&lt;/p&gt;
&lt;p&gt;从网络硬件设备到自研平台，从传统服务治理到 Service Mesh，本次分享将介绍蚂蚁集团网络代理在接入层以及 Service Mesh 化道路上是如何一步步支撑秒级百万支付，千万红包请求的。&lt;/p&gt;
&lt;h4 id=&#34;进击的traefik云原生边缘路由探秘&#34;&gt;进击的Traefik——云原生边缘路由探秘&lt;/h4&gt;
&lt;p&gt;杨川胡（ 知群后台负责人）&lt;/p&gt;
&lt;p&gt;Traefik 是一个云原生的边缘路由器，开源的反向代理和负载均衡器，寄予厚望的 2.0 版本历时一年的开发终于发布了，此处大版本的更新新增了许多新的特性，特别是大家期望的对 TCP 的支持，在当前 topic 中我们将来探索 Traefik 2.0 有哪些值得我们关注的新特性。&lt;/p&gt;
&lt;h4 id=&#34;service-mesh下微服务的架构设计&#34;&gt;Service Mesh下微服务的架构设计&lt;/h4&gt;
&lt;p&gt;杨彪（美团高级技术专家）&lt;/p&gt;
&lt;p&gt;当下Service Mesh技术可以说是炙手可热，它通过容器编排、持续交付DevOps、以及微服务等理论和方法来构建和运行云原生应用。然而Service Mesh毕竟发展才短短的2年，对于我们刚刚熟悉和稳定的微服务架构又将带来哪些挑战，业务系统架构是否有必要升级到Service Mesh，我们的微服务架构设计将发生什么改变，这些问题我将在本次大会交流讨论，敬请期待。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #6 广州站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-06/</link>
      <pubDate>Sun, 11 Aug 2019 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-06/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;h4 id=&#34;虎牙直播在微服务改造方面的实践&#34;&gt;虎牙直播在微服务改造方面的实践&lt;/h4&gt;
&lt;p&gt;张波 虎牙基础保障部中间件团队负责人&lt;/p&gt;
&lt;p&gt;本次主要分享虎牙注册中心、名字服务、DNS 的改造实践，以及如何通过 Nacos 实现与 istio 打通实现，使微服务平滑过渡到 service mesh。&lt;/p&gt;
&lt;h4 id=&#34;service-mesh-在蚂蚁集团的生产级安全实践&#34;&gt;Service Mesh 在蚂蚁集团的生产级安全实践&lt;/h4&gt;
&lt;p&gt;彭泽文 蚂蚁集团高级开发工程师&lt;/p&gt;
&lt;p&gt;介绍通过 Envoy SDS（Secret Discovery Service）实现 Sidecar 证书管理的落地方案；分享如何为可信身份服务构建敏感信息数据下发通道，以及 Service Mesh Sidecar 的 TLS 生产级落地实践。&lt;/p&gt;
&lt;h4 id=&#34;基于-kubernetes-的微服务实践&#34;&gt;基于 Kubernetes 的微服务实践&lt;/h4&gt;
&lt;p&gt;涂小刚 慧择网运维经理&lt;/p&gt;
&lt;p&gt;介绍如何跟据现有业务环境情况制定容器化整体解决方案，导入业务进入 K8S 平台，容器和原有业务环境互通。制订接入规范、配置中心对接 K8S 服务、网络互通方案、DNS 互通方案、jenkins-pipeline 流水线构建方案、日志采集方案、监控方案等。&lt;/p&gt;
&lt;h4 id=&#34;service-mesh-发展趋势续棋到中盘路往何方&#34;&gt;Service Mesh 发展趋势（续）：棋到中盘路往何方&lt;/h4&gt;
&lt;p&gt;敖小剑 蚂蚁集团高级技术专家&lt;/p&gt;
&lt;p&gt;继续探讨 Service Mesh 发展趋势：深度分析 Istio 的重大革新 Mixer v2，Envoy 支持 Web Assembly 的意义所在，以及在 Mixer v2 出来之前的权宜之计; 深入介绍 Google Traffic Director 对虚拟机模式的创新支持方式，以及最近围绕 SMI 发生的故事。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #5 广州站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-05/</link>
      <pubDate>Sun, 06 Jan 2019 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-05/</guid>
      <description>&lt;h3 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h3&gt;
&lt;h4 id=&#34;唯品会-service-mesh-的实践分享&#34;&gt;唯品会 Service Mesh 的实践分享&lt;/h4&gt;
&lt;p&gt;郑德惠 唯品会Java资深开发工程师，内部Service Mesh框架负责人，唯品会开源项目vjtools重要开发者，10年电信与互联网后台开发经验。&lt;/p&gt;
&lt;h4 id=&#34;sofamosn-持续演进路径及实践案例&#34;&gt;SOFAMosn 持续演进路径及实践案例&lt;/h4&gt;
&lt;p&gt;陈逸凡 花名无钩，蚂蚁集团资深开发工程师。专注于网络接入层，高性能服务器研发，SOFAMosn团队核心成员&lt;/p&gt;
&lt;h4 id=&#34;在网格的边缘试探企业-istio-试水指南&#34;&gt;在网格的边缘试探——企业 Istio 试水指南&lt;/h4&gt;
&lt;p&gt;崔秀龙 HPE 软件分析师，Kubernetes 权威指南作者之一，Kubernetes、Istio 项目成员&lt;/p&gt;
&lt;h4 id=&#34;roundtable回顾2018service-mesh-蓄势待发&#34;&gt;Roundtable：回顾2018，Service Mesh 蓄势待发&lt;/h4&gt;
&lt;p&gt;主持人：宋净超，ServiceMesher 社区联合创始人&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #4 上海站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-04/</link>
      <pubDate>Sun, 25 Nov 2018 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-04/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;h4 id=&#34;observability-and-istio-telemetry&#34;&gt;Observability and Istio telemetry&lt;/h4&gt;
&lt;p&gt;吴晟 Apache SkyWalking创始人、Apache Sharding-Sphere原型作者、比特大陆资深技术专家、CNCF OpenTracing标准化委员会成员&lt;/p&gt;
&lt;h4 id=&#34;蚂蚁集团-service-mesh-渐进式迁移方案&#34;&gt;蚂蚁集团 Service Mesh 渐进式迁移方案&lt;/h4&gt;
&lt;p&gt;敖小剑 蚂蚁集团高级技术专家，十六年软件开发经验，微服务专家，Service Mesh布道师，Servicemesher社区联合创始人&lt;/p&gt;
&lt;p&gt;张瑜标 阿里巴巴技术专家、前京东Hadoop负责人、Hadoop代码贡献者、现负责UC 基于Kubernetes自研的PaaS平台整体的稳定性&lt;/p&gt;
&lt;h4 id=&#34;探讨和实践基于isito的微服务治理事件监控&#34;&gt;探讨和实践基于Isito的微服务治理事件监控&lt;/h4&gt;
&lt;p&gt;徐运元 谐云科技云平台架构师，致力于容器 PaaS 平台、企业级容器云平台的方案设计和技术落地&lt;/p&gt;
&lt;h4 id=&#34;envoycontour与kubernetes实践&#34;&gt;Envoy、Contour与Kubernetes实践&lt;/h4&gt;
&lt;p&gt;冯玮 七牛容器云平台产品架构师，曾在百度和华为从事公有云领域高性能分布式计算和存储平台的架构设计和产品研发&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #3 深圳站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-03/</link>
      <pubDate>Sat, 25 Aug 2018 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-03/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;张超盟（华为）——Kubernetes容器应用基于Istio的灰度发布实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Topic摘要：随着1.0版本在上月底的发布，标志着Istio作为最火热的ServcieMesh框架已经逐渐成熟。本次议题中将以典型的灰度发布为例，分享华为云容器服务在Istio的实践，以及Istio和Kubernetes的完美结合释放云原生应用的核心优势，加速企业微服务技术转型。&lt;/p&gt;
&lt;p&gt;讲师简介：华为云微服务平台架构师，现负责华为云容器服务Istio产品化工作。参与华为PaaS平台产品设计研发，在Kubernetes容器服务、微服务架构、云服务目录、大数据、APM、DevOpS工具等多个领域有深入研究与实践。曾供职于趋势科技。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;朱经惠 （联邦车网）——Istio控制平面组件原理解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Topic摘要：网上有很多关于Istio的介绍，但主要的关注是数据平面。所以这次独辟蹊径，给大家解密Istio里强大的控制平面：管理生命周期的Pilot-Agent，配置中心Pilot-Discovery， 生成遥测报告的Mixer以及安全证书管理的Istio_Ca。通过本次分享您将了解其工作原理和现存的问题。&lt;/p&gt;
&lt;p&gt;讲师简介：朱经惠，ETC车宝平台工程师。喜欢开源，个人开源项目《Jaeger PHP Client》；喜欢研究源码，对NSQ，Jaeger，Istio（控制平面）等go语言开源项目进行过研究。除了代码还喜欢爬山和第二天睡醒后全身酸疼的感觉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;邵俊雄（蚂蚁集团）——SOFAMesh 的通用协议扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Topic摘要：介绍蚂蚁集团在SOFAMesh上开发对SOFA RPC与HSF这两个RPC框架的支持过程中总结出来的一个通用协议扩展方案。&lt;/p&gt;
&lt;p&gt;讲师介绍：蚂蚁集团中间件团队高级技术专家，目前主要负责 SOFAMesh 的开发工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;杨文（JEX）——Kubernetes、Service Mesh、CI/CD 实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Topic摘要：本次主题我将跟大家分享我们在提升研发团队工程效率上的一些思考和实践，包括如何构建自动化 CI/CD 平台，如何提升持续交付能力，以及我们在这一系列演化过程中所踩过一些坑。&lt;/p&gt;
&lt;p&gt;讲师介绍：JEX 技术VP，前小恩爱技术总监，开源爱好者，TiDB、logkit 等多个开源项目的 Contributor，Go 夜读发起人。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #2 北京站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-02/</link>
      <pubDate>Sun, 29 Jul 2018 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-02/</guid>
      <description>&lt;h2 id=&#34;讲师与演讲话题&#34;&gt;讲师与演讲话题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;张亮（京东金融数据研发负责人）：Service Mesh的延伸 —— 论道Database Mesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：张亮，京东金融数据研发负责人。热爱开源，目前主导两个开源项目Elastic-Job和Sharding-Sphere(Sharding-JDBC)。擅长以java为主分布式架构以及以Kubernetes和Mesos为主的云平台方向，推崇优雅代码，对如何写出具有展现力的代码有较多研究。2018年初加入京东金融，现担任数据研发负责人。目前主要精力投入在将Sharding-Sphere打造为业界一流的金融级数据解决方案之上。&lt;/p&gt;
&lt;p&gt;随着Service Mesh概念的推广与普及，云原生、低接入成本以及分布式组件下移等理念，已逐渐被认可。在Service Mesh依旧处于高速迭代的发展期的同时，以它的理念为参考，其他的Mesh思想也在崭露萌芽。 Database Mesh即是Service Mesh的其中一种延伸，虽然理念与Service Mesh相近，但数据库与无状态的服务却有着巨大的差别。Database Mesh与分布式数据库（如NoSQL和NewSQL）的功能范畴并非重叠而是互补，它更加关注数据库之上的中间啮合层。本次将与您一起交流Database Mesh的一些思考，以及探讨如何与现有产品相结合，实现更加强大与优雅的云原生数据库解决方案。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;吴晟（Apache SkyWalking创始人）：Observability on Service Mesh —— Apache SkyWalking 6.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：Apache SkyWalking 创始人，PPMC和Committer，比特大陆资深技术专家，&lt;a href=&#34;http://tetrate.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetrate.io&lt;/a&gt; Founding Engineer，专注APM和自动化运维相关领域。Microsoft MVP。CNCF OpenTracing标准化委员会成员。Sharding-Sphere PMC 成员。&lt;/p&gt;
&lt;p&gt;APM在传统意义上，都是通过语言探针，对应用性能进行整体分析。但随着Cloud Native, K8s容器化之后，以Istio为代表的Service Mesh的出现，为可观测性和APM提供了一种新的选择。SkyWalking作为传统上提供多语言自动探针的Apache开源项目，在service mesh的大背景下，也开始从新的角度提供可观测性支持。&lt;/p&gt;
&lt;p&gt;SkyWalking和Tetrate Inc. Istio核心团队合作，从Mixer接口提取遥感数据，提供SkyWalking语言探针一样的功能，展现service mesh风格探针的强大力量。之后，也会和更多的mesh实现进行合作，深入在此领域的运用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;朵晓东（蚂蚁集团，高级技术专家）：蚂蚁集团开源的Service Mesh数据平面SOFA MOSN深层揭秘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：蚂蚁集团高级技术专家，专注云计算技术及产品。Apache Kylin创始团队核心成员；蚂蚁金融云PaaS创始团队核心成员，Antstack网络产品负责人；SOFAMesh创始团队核心成员。&lt;/p&gt;
&lt;p&gt;Service Mesh技术体系在蚂蚁落地过程中，我们意识到Mesh结合云原生在多语言，流量调度等各方面的优势，同时面对蚂蚁内部语言体系与运维构架深度融合，7层流量调度规则方式复杂多样，金融级安全要求等诸多特征带来的问题和挑战，最终选择结合蚂蚁自身情况自研Golang版本数据平面MOSN，同时拥抱开源社区，支持作为Envoy替代方案与Istio集成工作。本次session将从功能、构架、跨语言、安全、性能、开源等多方面分享Service Mesh在蚂蚁落地过程中在数据平面的思考和阶段成果。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;丁振凯（新浪微博，微博搜索架构师）：微博Service Mesh实践 - WeiboMesh&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人简介：微博搜索架构师，主要负责搜索泛前端架构工作。主导搜索结果和热搜榜峰值应对及稳定性解决方案，以及微服务化方案落地。在Web系统架构方面拥有比较丰富的实践和积累。喜欢思考，深究技术本质。去年十一鹿晗关晓彤事件中一不小心成为网红工程师，并成功登上自家热搜榜。&lt;/p&gt;
&lt;p&gt;WeiboMesh源自于微博内部对异构体系服务化的强烈需求以及对历史沉淀的取舍权衡，它没有把历史作为包袱，而是巧妙的结合自身实际情况完成了对Service Mesh规范的实现。目前WeiboMesh在公司内部已经大规模落地，并且已经开源，WeiboMesh是非常接地气的Service Mesh实现。本次分享主要介绍微博在跨语言服务化面临的问题及WeiboMesh方案介绍，并结合业务实例分析WeiboMesh的独到之处。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service Mesh Meetup #1 杭州站</title>
      <link>https://jimmysong.io/docs/event/service-mesh-meetup-01/</link>
      <pubDate>Sat, 30 Jun 2018 13:00:00 +0800</pubDate>
      <guid>https://jimmysong.io/docs/event/service-mesh-meetup-01/</guid>
      <description>&lt;h2 id=&#34;讲师分享&#34;&gt;讲师分享&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV19h411p7jn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区 meetup 第七期深圳站开场致辞 - 宋净超&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1WQ4y1z7zQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 IAST 构建高效的 DevSecOps 流程 - 董志勇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1hf4y1E7KJ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生场景下的开发和调试-汪晟杰，黄金浩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1LL411476c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 在腾讯游戏云原生平台应用 - 田甜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1TQ4y1C7xx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 KubeVela 构建混合云应用管理平台 - 邓洪超&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
