<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ebpf | 云原生资料库</title>
    <link>https://lib.jimmysong.io/tag/ebpf/</link>
      <atom:link href="https://lib.jimmysong.io/tag/ebpf/index.xml" rel="self" type="application/rss+xml" />
    <description>ebpf</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 05 Jul 2022 17:00:00 +0800</lastBuildDate>
    <image>
      <url>https://lib.jimmysong.io/media/sharing.png</url>
      <title>ebpf</title>
      <link>https://lib.jimmysong.io/tag/ebpf/</link>
    </image>
    
    <item>
      <title>第一章：eBPF 简介</title>
      <link>https://lib.jimmysong.io/what-is-ebpf/introduction/</link>
      <pubDate>Wed, 01 Jun 2022 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/what-is-ebpf/introduction/</guid>
      <description>&lt;p&gt;在过去的几年里，eBPF 已经从相对默默无闻变成了现代基础设施建设中最热门的技术领域之一。就我个人而言，自从看到 Thomas Graf 在 DockerCon 17 的&lt;a href=&#34;https://www.youtube.com/watch?v=ilKlmTDdFgk&amp;amp;ab_channel=Docker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;黑带会议&lt;/a&gt;（Black Blet）&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 上谈到 eBPF 时，我就对它的可能性感到兴奋。在云原生计算基金会（CNCF），我在技术监督委员会（TOC）的同事把 eBPF 作为我们预测 2021 年将会起飞的重点技术之一来关注。超过 2500 人报名参加了当年的 eBPF 峰会线上会议，世界上最先进的几家软件工程公司共同创建了 &lt;a href=&#34;https://ebpf.io/foundation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 基金会&lt;/a&gt;。显然，人们对这项技术有很大的兴趣。&lt;/p&gt;
&lt;p&gt;在这个简短的报告中，我希望能给你一些启示，为什么人们对 eBPF 如此兴奋，以及它在现代计算环境中提供的工具能力。你会了解到 eBPF 是什么以及为什么它如此强大。还有一些代码实例，以使这种感觉更加具象化（但如果你愿意，你可以跳过这些）。&lt;/p&gt;
&lt;p&gt;你将了解到在建立支持 eBPF 的工具时涉及的内容，以及为什么 eBPF 在如此短的时间内变得如普遍。&lt;/p&gt;
&lt;p&gt;在这份简短的报告中，难免无法了解所有的细节，但如果你想更深入地了解，我将给你一些参考信息。&lt;/p&gt;
&lt;h2 id=&#34;扩展的伯克利数据包过滤器&#34;&gt;扩展的伯克利数据包过滤器&lt;/h2&gt;
&lt;p&gt;让我们把缩写说出来：eBPF 代表&lt;strong&gt;扩展的伯克利数据包过滤器（Extended Berkeley Packet Filter）&lt;/strong&gt;。从这个名字中，你可以看到它的根源在于过滤网络数据包，而且最初的 &lt;a href=&#34;https://www.tcpdump.org/papers/bpf-usenix93.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;论文&lt;/a&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 是在伯克利实验室（Lawrence Berkeley National Laboratory）写的。但是（在我看来）这个名字对于传达 eBPF 的真正力量并没有很大的帮助，因为&amp;quot;扩展&amp;quot; 版本可以实现比数据包过滤多得多的功能。最近，eBPF 被用作一个独立的名称，它所包含的内容比它的缩写更多。&lt;/p&gt;
&lt;p&gt;那么，如果它不仅仅是包过滤，什么是 eBPF？eBPF 是一个框架，允许用户在操作系统的内核内加载和运行自定义程序。这意味着它可以扩展甚至修改内核的行为。&lt;/p&gt;
&lt;p&gt;当 eBPF 程序被加载到内核中时，有一个验证器确保它是安全运行的，如果无法确认，则拒绝它。一旦加载，eBPF 程序需要被附加到一个事件上，这样，每当事件发生时，程序就会被触发。&lt;/p&gt;
&lt;p&gt;eBPF 最初是为 Linux 开发的，这也是我在本报告中重点讨论的操作系统；但值得注意的是，截至本文写作时，微软正在 &lt;a href=&#34;https://oreil.ly/J0N1H&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为 Windows 开发 eBPF 的实现&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在，广泛使用的 Linux 内核都支持 &amp;ldquo;扩展&amp;rdquo; 部分，eBPF 和 BPF 这两个术语现在基本上可以互换使用。&lt;/p&gt;
&lt;h2 id=&#34;基于-ebpf-的工具&#34;&gt;基于 eBPF 的工具&lt;/h2&gt;
&lt;p&gt;正如你在本报告中所看到的，动态改变内核行为的能力非常有用。传统上，如果我们想观察应用程序的行为，我们在应用程序中添加代码，以产生日志和追踪。eBPF 允许我们收集关于应用程序行为的定制信息，通过在内核中观察它，而不必修改应用程序。我们可以在这种可观测性的基础上创建 eBPF 安全工具，从内核中检测甚至防止恶意活动。我们可以用 eBPF 创建强大的、高性能的网络功能，在内核内处理网络数据包，避免昂贵的用户空间转换。&lt;/p&gt;
&lt;p&gt;从内核的角度来观测应用程序的概念并不新颖——这建立在较早的 Linux 功能之上，比如 perf &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，它也从内核内部收集行为和性能信息，而不需要修改被测量的应用程序。但是这些工具定义了可以收集的数据种类以及数据的格式。有了 eBPF，我们就有了更大的灵活性，因为我们可以编写完全自定义的程序，允许我们出于不同的目的建立广泛的工具。&lt;/p&gt;
&lt;p&gt;eBPF 编程的能力异常强大，但也很复杂。对于我们大多数人来说，eBPF 的效用不是来自于自己写的程序，而是来自于使用别人创造的工具。有越来越多的项目和供应商在 eBPF 平台上创建了新一代的工具，包括可观测性、安全性、网络等。&lt;/p&gt;
&lt;p&gt;我将在本报告后面讨论这些更高级别的工具，但是，如果你对 Linux 命令行很熟悉，迫不及待地想看到 eBPF 的运行，推荐你从 BCC 项目开始。BCC 包含丰富的追踪工具集合；即使只是瞥一眼列表也可以领略到 eBPF 广泛的应用，包括文件操作、内存使用、CPU 统计，甚至观察在系统任意位置输入的 bash 命令。&lt;/p&gt;
&lt;p&gt;在下一章，我们将介绍改变内核行为的作用，为什么使用 eBPF 比直接编写内核代码更容易操作。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Thomas Graf，《Cilium——使用 BPF 和 XDP 的网络和应用安全》（DockerCon 2017 年 4 月 17-20 日）&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Steven McCanne 和 Van Jacobson，《BSD 数据包过滤器：用户级数据包捕获的新架构》（工作文件，劳伦斯伯克利国家实验室，伯克利，1992 年 12 月 19 日）。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;perf 是一个 Linux 子系统，用于收集性能数据。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>第二章：修改内核很困难</title>
      <link>https://lib.jimmysong.io/what-is-ebpf/changing-the-kernel-is-hard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lib.jimmysong.io/what-is-ebpf/changing-the-kernel-is-hard/</guid>
      <description>&lt;p&gt;由于 eBPF 允许在 Linux 内核中运行自定义代码，在解释 eBPF 之前我需要确保你对内核的作用有所了解。然后我们将讨论为什么在修改内核行为这件事情上，eBPF 改变了游戏规则。&lt;/p&gt;
&lt;h2 id=&#34;linux-内核&#34;&gt;Linux 内核&lt;/h2&gt;
&lt;p&gt;Linux 内核是应用程序和它们所运行的硬件之间的软件层。应用程序运行在被称为&lt;strong&gt;用户空间&lt;/strong&gt;的非特权层，它不能直接访问硬件。相反，应用程序使用系统调用（syscall）接口发出请求，要求内核代表它行事。这种硬件访问可能涉及到文件的读写，发送或接收网络流量，或者只是访问内存。内核还负责协调并发进程，使许多应用程序可以同时运行。&lt;/p&gt;
&lt;p&gt;应用程序开发者通常不直接使用系统调用接口，因为编程语言给了我们更高级别的抽象和&lt;strong&gt;标准库&lt;/strong&gt;，开发者更容易掌握这些接口。因此，很多人都不知道在程序运行时内核做了什么。如果你想了解内核调用频率，你可以使用 strace 工具来显示程序所做的所有系统调用。这里有一个例子，用 cat 从文件中读取 hello 这个词并将其写到屏幕上涉及到 100 多个系统调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;liz@liz-ebpf-demo-1:~$ strace -c cat liz.txt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;% &lt;span class=&#34;nb&#34;&gt;time&lt;/span&gt;     seconds  usecs/call     calls    errors syscall
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;------ ----------- ----------- --------- --------- -------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         5	  &lt;span class=&#34;nb&#34;&gt;read&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  write
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        21	  close
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        20	  fstat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        23	  mmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         4	  mprotect
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         2	  munmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         3	  brk
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         4	  pread64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; access
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  execve
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         2	&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; arch_prctl
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;         1	  fadvise64
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.00    0.000000	&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;        19	  openat
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;------ ----------- ----------- --------- --------- -------------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;100.00    0.000000              &lt;span class=&#34;m&#34;&gt;107&lt;/span&gt;     &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; total
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于应用程序在很大程度上依赖于内核，这意味着如果我们能够观测到应用程序与内核的交互，我们就可以了解到很多关于它的行为方式。例如，如果你能够截获打开文件的系统调用，你就可以准确地看到任何应用程序访问了哪些文件。但是，怎么才能做到这种拦截呢？让我们考虑一下，如果我们想修改内核，添加新的代码，在系统调用时创建某种输出，会涉及到什么问题。&lt;/p&gt;
&lt;h2 id=&#34;向内核添加新功能&#34;&gt;向内核添加新功能&lt;/h2&gt;
&lt;p&gt;Linux 内核很复杂，在写这篇文章的时候有大约 3000 万行代码 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。对任何代码库进行修改都需要对现有的代码有一定的熟悉，所以除非你已经是一个内核开发者，否则这很可能是一个挑战。&lt;/p&gt;
&lt;p&gt;但你将面临的挑战并不是纯粹的技术问题。Linux 是一个通用的操作系统，在不同的环境和情况下使用。这意味着，如果你想对内核进行修改，这并不是简单地写出能用的代码。它必须被社区（更确切地说，是被 Linux 的创造者和主要开发者 Linus Torvalds）接受，你的改变将是为了大家的更大利益。而这并不是必然的——提交的内核补丁只有三分之一被接受 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;假如，你已经想出了一个好方法来拦截打开文件的系统调用。经过几个月的讨论和一些艰苦的开发工作，让我们想象一下，这个变化被接受到内核中。很好！但是，要到什么时候它才会出现在每个人的机器上呢？&lt;/p&gt;
&lt;p&gt;每隔两三个月就会有一个新的 Linux 内核版本，但是即使一个变化已经进入了其中一个版本，它仍然需要一段时间才能在大多数人的生产环境中使用。这是因为我们大多数人并不直接使用 Linux 内核——我们使用像 Debian、Red Hat、Alpine、Ubuntu 等 Linux 发行版，它们将 Linux 内核的一个版本与其他各种组件打包在一起。你可能会发现，你最喜欢的发行版使用的是几年前的内核版本。&lt;/p&gt;
&lt;p&gt;例如，很多企业用户都采用红帽 ® Enterprise Linux®（RHEL）。在撰写本文时，目前的版本是 RHEL8.5，发行日期为 2021 年 11 月。这使用的是基于 4.18 版本的内核。这个内核是在 2018 年 8 月发布的。&lt;/p&gt;
&lt;p&gt;如 &lt;a href=&#34;#figure-f-2-1&#34;&gt;图 2-1&lt;/a&gt; 中的漫画所示，将新功能从想法阶段转化为生产环境中的 Linux 内核，需要数年时间 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-2-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-2-1.jpg&#34; alt=&#34;图 2-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2-1. 向内核添加功能（Isovalent 公司的 Vadim Shchekoldin 绘制的漫画）
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;h2 id=&#34;内核模块&#34;&gt;内核模块&lt;/h2&gt;
&lt;p&gt;如果你不想等上好几年才把你的改动写进内核，还有一个选择。Linux 内核可以接受内核模块（module），这些模块可以根据需要加载和卸载。如果你想改变或扩展内核行为，编写一个模块是理所当然的。在我们打开文件的系统调用的例子中，你可以写一个内核模块来实现。&lt;/p&gt;
&lt;p&gt;这里最大的挑战是，这仍然是全面的内核编程。用户在使用内核模块时历来非常谨慎，原因很简单：如果内核代码崩溃了，就会导致机器和上面运行的所有东西瘫痪。用户如何确保内核模块可以安全运行呢？&lt;/p&gt;
&lt;p&gt;“安全运行”并不仅仅意味着不崩溃——用户想知道内核模块从安全角度来看是否安全。是否包括攻击者可以利用的漏洞？我们是否相信模块的作者不会在其中加入恶意代码？因为内核是特权代码，它可以访问机器上的一切，包括所有的数据，所以内核中的恶意代码将是一个令人担忧的严重问题。这也适用于内核模块。&lt;/p&gt;
&lt;p&gt;考虑到内核的安全性，这就是为什么 Linux 发行商需要这么长时间来发布新版本的一个重要原因。如果其他人已经在各种情况下运行了数月或数年的内核版本，那些漏洞可能已经被修复。发行版的维护者可以有一些信心，他们提供给用户 / 客户的内核是经过加固的，也就是说，可以安全运行。&lt;/p&gt;
&lt;p&gt;eBPF 提供了一个非常不同的安全方法：&lt;strong&gt;eBPF 验证器（verifier）&lt;/strong&gt;，它确保一个 eBPF 程序只有在安全运行的情况下才被加载。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-验证和安全&#34;&gt;eBPF 验证和安全&lt;/h2&gt;
&lt;p&gt;由于 eBPF 允许我们在内核中运行任意代码，需要有一种机制来确保它的安全运行，不会使用户的机器崩溃，也不会损害他们的数据。这个机制就是 eBPF 验证器。&lt;/p&gt;
&lt;p&gt;验证器对 eBPF 程序进行分析，以确保无论输入什么，它都会在一定数量的指令内安全地终止。例如，如果一个程序解除对一个指针的定义，验证器要求该程序首先检查指针，以确保它不是空的（null）。解除对指针的引用意味着 &amp;ldquo;查找这个地址的值&amp;rdquo;，而空值或零值不是一个有效的查找地址。如果你在一个应用程序中解引用一个空指针，该应用程序就会崩溃；而在内核中解引用一个空指针则会使整个机器崩溃，所以避免这种情况至关重要。&lt;/p&gt;
&lt;p&gt;验证也确保了 eBPF 程序只能访问其应该访问的内存。例如，有一个 eBPF 程序在网络堆栈中触发，并通过内核的 &lt;strong&gt;套接字缓冲区（socket buffer）&lt;/strong&gt;，其中包括正在传输的数据。有一些特殊的辅助函数，如 &lt;code&gt;bpf_skb_load_bytes()&lt;/code&gt;，这个 eBPF 程序可以调用，从套接字缓冲区读取字节数据。另一个由系统调用触发的 eBPF 程序，没有可用的套接字缓冲区，将不允许使用这个辅助函数。验证器还确保程序只读取套接字缓冲区内的数据字节——它不允许访问任意的内存。这里的目的是确保 eBPF 程序是安全的。&lt;/p&gt;
&lt;p&gt;当然，仍然有可能编写一个恶意的 eBPF 程序。如果你可以出于合法的原因观测数据，你也可以出于非法的原因观测它。要注意只从可验证的来源加载可信的 eBPF 程序，并且只将管理 eBPF 工具的权限授予你信任的拥有 root 权限的人。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-程序的动态加载&#34;&gt;eBPF 程序的动态加载&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以动态地加载到内核中和从内核中删除。不管是什么原因导致该事件的发生，一旦它们被附加到一个事件上就会被该事件所触发。例如，如果你将一个程序附加到打开文件的系统调用，那么只要任何进程试图打开一个文件，它就会被触发。当程序被加载时，该进程是否已经在运行，这并不重要。&lt;/p&gt;
&lt;p&gt;这也是使用 eBPF 的可观测性或安全工具的巨大优势之一——即刻获得了对机器上发生的一切事件的可视性。&lt;/p&gt;
&lt;p&gt;此外，如 &lt;a href=&#34;#figure-f-2-2&#34;&gt;图 2-2&lt;/a&gt; 所示，人们可以通过 eBPF 非常快速地创建新的内核功能，而不要求其他 Linux 用户都接受同样的变更。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-2-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-2-2.jpg&#34; alt=&#34;图 2-2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2-2. 用 eBPF 添加内核功能（漫画：Vadim Shchekoldin Isovalent）
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;现在你已经看到了 eBPF 是如何允许对内核进行动态的、自定义的修改的，让我们来看看如果你想写一个 eBPF 程序会涉及哪些内容。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Linux 5.12 有大约 2880 万行代码，Phoronix（2021 年 3 月）。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Yujuan Jiang 等人，《我的补丁能用了吗？要多久？》（论文，2013 年）。根据这篇研究论文，33% 的补丁将在 3 - 6 个月后被接受。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;值得庆幸的是，现有功能的安全补丁会更快地被提供。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>第三章：eBPF 程序</title>
      <link>https://lib.jimmysong.io/what-is-ebpf/ebpf-programs/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/what-is-ebpf/ebpf-programs/</guid>
      <description>&lt;p&gt;在这一章中，让我们来谈谈编写 eBPF 代码。我们需要考虑在内核中运行的 eBPF 程序本身，以及与之交互的用户空间代码。&lt;/p&gt;
&lt;h2 id=&#34;内核和用户空间代码&#34;&gt;内核和用户空间代码&lt;/h2&gt;
&lt;p&gt;首先，你可以用什么编程语言来编写 eBPF 程序？&lt;/p&gt;
&lt;p&gt;内核接受字节码形式的 eBPF 程序 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。人工编写这种字节码是可能的，就像用汇编语言写应用程序代码一样——但对人类来说，使用一种可以被编译（即自动翻译）为字节码的高级语言通常更实用。&lt;/p&gt;
&lt;p&gt;由于一些原因，eBPF 程序不能用任意的高级语言编写。首先，语言编译器需要支持发出内核所期望的 eBPF 字节码格式。其次，许多编译语言都有运行时特性——例如 Go 的内存管理和垃圾回收，使它们不适合。在撰写本文时，编写 eBPF 程序的唯一选择是 C（用 clang/llvm 编译）和最新的 Rust。迄今为止，绝大多数的 eBPF 代码都是用 C 语言发布的，考虑到它是 Linux 内核的语言，这是有道理的。&lt;/p&gt;
&lt;p&gt;至少，用户空间的程序需要加载到内核中，并将其附加到正确的事件中。有一些实用程序，如 bpftool，可以帮助我们解决这个问题，但这些都是低级别的工具，假定你有丰富的 eBPF 知识，它们是为 eBPF 专家设计的，而不是普通用户。在大多数基于 eBPF 的工具中，有一个用户空间的应用程序，负责将 eBPF 程序加载到内核中，传入任何配置参数，并以用户友好的方式显示 eBPF 程序收集的信息。&lt;/p&gt;
&lt;p&gt;至少在理论上，eBPF 工具的用户空间部分可以用任何语言编写，但在实践中，有一些库只支持相当少的语言。其中包括 C、Go、Rust 和 Python。这种语言的选择更加复杂，因为并不是所有的语言都有支持 libbpf 的库，libbpf 已经成为使 eBPF 程序在不同版本的内核中可移植的流行选择。(我们将在 &lt;a href=&#34;../ebpf-complexity&#34;&gt;第四章&lt;/a&gt; 中讨论 libbpf）。&lt;/p&gt;
&lt;h2 id=&#34;附属于事件的自定义程序&#34;&gt;附属于事件的自定义程序&lt;/h2&gt;
&lt;p&gt;eBPF 程序本身通常是用 C 或 Rust 编写的，并编入一个对象文件 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。这是一个标准的 ELF（可执行和可链接格式，Executable and Linkable Format）文件，可以用像 &lt;strong&gt;readelf&lt;/strong&gt; 这样的工具来检查，它包含程序字节码和任何映射的定义（我们很快就会讨论）。如 &lt;a href=&#34;#figure-f-3-1&#34;&gt;图 3-1&lt;/a&gt; 所示，如果在前一章中提到的验证器允许的话，用户空间程序会读取这个文件并将其加载到内核中。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-3-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-3-1.jpg&#34; alt=&#34;图 3-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3-1. 用户空间应用程序使用 bpf() 系统调用从 ELF 文件中加载 eBPF 程序到内核中
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;eBPF 程序加载到内核中时必须被附加到事件上。每当事件发生，相关的 eBPF 程序就会运行。有一个非常广泛的事件，你可以将程序附加到其中；我不会涵盖所有的事件，但以下是一些更常用的选项。&lt;/p&gt;
&lt;h3 id=&#34;从函数中进入或退出&#34;&gt;从函数中进入或退出&lt;/h3&gt;
&lt;p&gt;你可以附加一个 eBPF 程序，在内核函数进入或退出时被触发。当前的许多 eBPF 例子都使用了 &lt;code&gt;kprobes&lt;/code&gt;（附加到一个内核函数入口点）和 &lt;code&gt;kretprobes&lt;/code&gt;（函数退出）的机制。在最新的内核版本中，有一个更有效的替代方法，叫做 &lt;code&gt;fentry/fexit&lt;/code&gt; &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;请注意，你不能保证在一个内核版本中定义的所有函数一定会在未来的版本中可用，除非它们是稳定 API 的一部分，如 syscall 接口。&lt;/p&gt;
&lt;p&gt;你也可以用 &lt;code&gt;uprobes&lt;/code&gt; 和 &lt;code&gt;uretprobes&lt;/code&gt; 将 eBPF 程序附加到用户空间函数上。&lt;/p&gt;
&lt;h3 id=&#34;tracepoints&#34;&gt;Tracepoints&lt;/h3&gt;
&lt;p&gt;你也可以将 eBPF 程序附加到内核内定义的 &lt;code&gt;tracepoints&lt;/code&gt; &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。通过在 &lt;code&gt;/sys/kernel/debug/tracing/events&lt;/code&gt; 下查找机器上的事件。&lt;/p&gt;
&lt;h3 id=&#34;perf-事件&#34;&gt;Perf 事件&lt;/h3&gt;
&lt;p&gt;Perf &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 是一个收集性能数据的子系统。你可以将 eBPF 程序挂到所有收集 perf 数据的地方，这可以通过在你的机器上运行 perf list 来确定。&lt;/p&gt;
&lt;h3 id=&#34;linux-安全模块接口&#34;&gt;Linux 安全模块接口&lt;/h3&gt;
&lt;p&gt;LSM 接口在内核允许某些操作之前检查安全策略。你可能见过 AppArmor 或 SELinux，利用了这个接口。通过 eBPF，你可以将自定义程序附加到相同的检查点上，从而实现灵活、动态的安全策略和一些运行时安全工具的新方法。&lt;/p&gt;
&lt;h3 id=&#34;网络接口express-data-path&#34;&gt;网络接口——eXpress Data Path&lt;/h3&gt;
&lt;p&gt;eXpress Data Path（XDP）允许将 eBPF 程序附加到网络接口上，这样一来，每当收到一个数据包就会触发 eBPF 程序。它可以检查甚至修改数据包，程序的退出代码可以告诉内核如何处理该数据包：传递、放弃或重定向。这可以构成一些非常有效的网络功能 &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; 的基础。&lt;/p&gt;
&lt;h3 id=&#34;套接字和其他网络钩子&#34;&gt;套接字和其他网络钩子&lt;/h3&gt;
&lt;p&gt;当应用程序在网络套接字上打开或执行其他操作时，以及当消息被发送或接收时，你可以附加运行 eBPF 程序。在内核的网络堆栈中也有称为 &lt;strong&gt;流量控制（traffic control）&lt;/strong&gt; 或 &lt;strong&gt;tc&lt;/strong&gt; 的 钩子，eBPF 程序可以在初始数据包处理后运行。&lt;/p&gt;
&lt;p&gt;一些功能可以单独用 eBPF 程序实现，但在许多情况下，我们希望 eBPF 代码能从用户空间的应用程序接收信息，或将数据传递给用户空间的应用程序。允许数据在 eBPF 程序和用户空间之间，或在不同的 eBPF 程序之间传递的机制被称为 &lt;strong&gt;map&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-map&#34;&gt;eBPF Map&lt;/h2&gt;
&lt;p&gt;map 的开发是 eBPF 缩略语中的 &lt;strong&gt;e&lt;/strong&gt; 代表 &lt;strong&gt;extended&lt;/strong&gt; 重要区别之一。&lt;/p&gt;
&lt;p&gt;map 是与 eBPF 程序一起定义的数据结构体。有各种不同类型的 map，但它们本质上都是键值存储。eBPF 程序可以读取和写入 map，用户空间代码也可以。map 的常见用途包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eBPF 程序写入关于事件的指标和其他数据，供用户空间代码以后检索。&lt;/li&gt;
&lt;li&gt;用户空间代码编写配置信息，供 eBPF 程序读取并作出相应的行为。&lt;/li&gt;
&lt;li&gt;eBPF 程序将数据写入 map，供另一个 eBPF 程序以后检索，允许跨多个内核事件的信息协调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果内核和用户空间的代码都要访问同一个映射，它们需要对存储在该映射中的数据结构体有一个共同的理解。这可以通过在用户空间和内核代码中加入定义这些数据结构体的头文件来实现，但是如果这些代码不是用相同的语言编写的，作者将需要仔细创建逐个字节兼容的结构体定义。&lt;/p&gt;
&lt;p&gt;我们已经讨论了 eBPF 工具的主要组成部分：在内核中运行的 eBPF 程序，加载和与这些程序交互的用户空间代码，以及允许程序共享数据的 map。为了更具体化，让我们看一个例子。&lt;/p&gt;
&lt;h2 id=&#34;opensnoop-示例&#34;&gt;Opensnoop 示例&lt;/h2&gt;
&lt;p&gt;在 eBPF 程序的例子中，我选择了 &lt;code&gt;opesnnoop&lt;/code&gt;，一个可以显示任何进程所打开的文件的工具。这个工具的原始版本是 Brendan Gregg 最初在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/opensnoop.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BCC 项目&lt;/a&gt;中编写的许多 BPF 工具之一，你可以在 GitHub 上找到。它后来被重写为 &lt;code&gt;libbpf&lt;/code&gt;（你将在下一章见到它），在这个例子中，我使用 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录下的较新版本。&lt;/p&gt;
&lt;p&gt;当你运行 &lt;code&gt;opensnoop&lt;/code&gt; 时，你将看到的输出在很大程度上取决于当时在虚拟机上发生了什么，但它应该看起来像这样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PID    COMM	FD	ERR	PATH
93965  cat	3	0	/etc/ld.so.cache
93965  cat	3	0	/lib/x86_64-linux-gnu/libc.so.6
93965  cat	3	0	/usr/lib/locale/locale-archive
93965  cat	3	0	/usr/share/locale/locale.alias
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一行输出表示一个进程打开（或试图打开）一个文件。这些列显示了进程的 ID，运行的命令，文件描述符，错误代码的指示，以及被打开的文件的路径。&lt;/p&gt;
&lt;p&gt;Opensnoop 的工作方式是将 eBPF 程序附加到 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;openat()&lt;/code&gt; 系统调用上，所有应用程序都必须通过这些调用来要求内核打开文件。让我们深入了解一下这是如何实现的。为了简洁起见，我们将不看每一行代码，但我希望这足以让你了解它是如何工作的（如果你对这么深的内容不感兴趣的话，请跳到下一章！）。&lt;/p&gt;
&lt;h3 id=&#34;opensnoop-ebpf-代码&#34;&gt;Opensnoop eBPF 代码&lt;/h3&gt;
&lt;p&gt;eBPF 代码是用 C 语言编写的，在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/libbpf-tools/opensnoop.bpf.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;opensnoop.bpf.c&lt;/code&gt;&lt;/a&gt; 文件中。在这个文件的开头，你可以看到两个 eBPF map 的定义 —— &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;events&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_entries&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10240&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;__type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;__type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_MAP_TYPE_PERF_EVENT_ARRAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;__uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;events&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;.maps&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 ELF 对象文件被创建时，它包含了每个 map 和每个要加载到内核的程序的部分，&lt;code&gt;SEC()&lt;/code&gt; 宏定义了这些部分。&lt;/p&gt;
&lt;p&gt;当我们研究这个程序的时候，你会看到，在系统调用被处理的时候，&lt;code&gt;start&lt;/code&gt; map 被用来临时存储系统调用的参数 —— 包括被打开的文件的名称。&lt;code&gt;events&lt;/code&gt; map &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; 用于将事件信息从内核中的 eBPF 代码传递给用户空间的可执行程序。如 &lt;a href=&#34;#figure-f-3-2&#34;&gt;图 3-2&lt;/a&gt; 所示。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-3-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-3-2.jpg&#34; alt=&#34;图 3-2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3-2. 调用 open() 触发 eBPF 程序，将数据存储在 opensnoop 的 eBPF map 中
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 文件的后面，你会发现两个极其相似的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tracepoint/syscalls/sys_enter_open&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracepoint__syscalls__sys_enter_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;trace_event_raw_sys_enter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SEC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tracepoint/syscalls/sys_enter_openat&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tracepoint__syscalls__sys_enter_openat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;trace_event_raw_sys_enter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有两个不同的系统调用用于打开文件 &lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;：&lt;code&gt;openat()&lt;/code&gt; 和
&lt;code&gt;open()&lt;/code&gt;。它们是相同的，除了 &lt;code&gt;openat()&lt;/code&gt; 有一个额外的参数是目录文件描述符，而且要打开的文件的路径名是相对于该目录而言的。同样，除了处理参数上的差异，opensnoop 中的两个函数也是相同的。&lt;/p&gt;
&lt;p&gt;正如你所看到的，它们都需要一个参数，即一个指向名为 &lt;code&gt;trace_event_raw_sys_enter&lt;/code&gt; 结构体的指针。你可以在你运行的特定内核生成的 &lt;code&gt;vmlinux&lt;/code&gt; 头文件中找到这个结构体的定义。编写 eBPF 程序之道包括找出每个程序接收的结构体作为其上下文，以及如何访问其中的信息。&lt;/p&gt;
&lt;p&gt;这两个函数使用一个 BPF 辅助函数来检索调用这个 syscall 的进程 ID：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;u64&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpf_get_current_pid_tgid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码得到了文件名和传递给系统调用的标志，并把它们放在一个叫做 &lt;code&gt;args&lt;/code&gt; 的结构体中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个结构体被写入 &lt;code&gt;start&lt;/code&gt; map 中，使用当前程序 ID 作为键。&lt;/p&gt;
&lt;p&gt;这就是 eBPF 程序在进入 syscall 时所做的一切。但在 &lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 中定义了另一对 eBPF 程序，当系统调用退出时被触发。&lt;/p&gt;
&lt;p&gt;这个程序和它的双胞胎 &lt;code&gt;openat()&lt;/code&gt; 在函数 &lt;code&gt;trace_exit()&lt;/code&gt; 中共享代码。你有没有注意到，所有被 eBPF 程序调用的函数的前缀都是 &lt;code&gt;static __always_inline&lt;/code&gt;？这迫使编译器将这些函数的指令放在内联中，因为在旧的内核中，BPF 程序不允许跳转到一个单独的函数。新的内核和 LLVM 版本可以支持非内联的函数调用，但这是一种安全的方式，可以确保 BPF 验证器满意（现在还有一个 BPF 尾部调用的概念，即执行从一个 BPF 程序跳转到另一个程序。你可以在 &lt;a href=&#34;https://docs.cilium.io/en/v1.10/bpf/#bpf-to-bpf-calls&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 文档&lt;/a&gt;中阅读更多关于 BPF 函数调用和尾部调用的内容）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;trace_exit()&lt;/code&gt; 函数创建一个空的事件结构体：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该结构体将用即将结束的 &lt;code&gt;open/openat&lt;/code&gt; 系统调用的信息填充，并通过 &lt;code&gt;events&lt;/code&gt; map 发送到用户空间。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;start&lt;/code&gt; 哈希 map 中应该有一个与当前进程 ID 相对应的条目：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里有先前在调用 &lt;code&gt;sys_enter_open(at)&lt;/code&gt; 时写入的关于文件名和标志的信息。标志字段是一个直接存储在结构体中的整数，所以直接从结构体中读取它是可以的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相反，文件名被写入用户空间内存的一些字节中，验证者需要确定这个 eBPF 程序从内存的那个位置读取这个字节数是安全的。这是用另一个辅助函数 &lt;code&gt;bpf_probe_read_user_str()&lt;/code&gt; 完成的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;bpf_probe_read_user_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当前的命令名称（即进行 &lt;code&gt;open(at)&lt;/code&gt; 系统调用的可执行文件的名称）也被复制到事件结构体中，使用另一个 BPF 辅助函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;bpf_get_current_comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;comm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;事件结构体被写入 &lt;code&gt;events&lt;/code&gt; perf buffer map 中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;bpf_perf_event_output&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BPF_F_CURRENT_CPU&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户空间的代码从这个 map 中读取事件信息。在我们讨论这个问题之前，让我们简单看看 Makefile。&lt;/p&gt;
&lt;h3 id=&#34;libbpf-tools-makefile&#34;&gt;libbpf-tools Makefile&lt;/h3&gt;
&lt;p&gt;当你构建 eBPF 代码时，你得到一个包含 eBPF 程序和 map 的二进制定义的对象文件。你还需要一个额外的用户空间可执行文件，它将把这些程序和 map 加载到内核中，作为用户 &lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt; 的接口。我们看看如何构建 &lt;code&gt;opensnoop&lt;/code&gt; 的 Makefile，看看它是如何创建 eBPF 对象文件和可执行文件的。&lt;/p&gt;
&lt;p&gt;Makefile 由一组规则组成，这些规则的语法可能有点不透明，所以如果你不熟悉 Makefile，也不特别关心这些细节，请随意跳过这一节。&lt;/p&gt;
&lt;p&gt;我们正在看的 opensnoop 的例子是一大批示例工具的其中之一，它们都是用 Makefile 构建的，你可以在 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录中找到。在这个文件中，并不是所有的东西都特别有意义，但有几个规则我想强调一下。第一条规则是使用 &lt;code&gt;bpf.c&lt;/code&gt; 文件并使用 clang 编译器来创建一个 BPF 目标对象文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.bpf.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %.&lt;span class=&#34;n&#34;&gt;bpf&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;wildcard&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;AR&lt;/span&gt;.. 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;BPF&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CLANG&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bpf&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;D__TARGET_ARCH_&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              -&lt;span class=&#34;nv&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;ARCH&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;INCLUDES&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;filter&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@ &amp;amp;&amp;amp; \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LLVM_STRIP&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此，&lt;code&gt;opensnoop.bpf.c&lt;/code&gt; 被编译成 &lt;code&gt;\$(OUTPUT)/open snoop.bpf.o&lt;/code&gt;。这个对象文件包含将被加载到内核的 eBPF 程序和 map。&lt;/p&gt;
&lt;p&gt;另一条规则使用 &lt;code&gt;bpftool gen skeleton&lt;/code&gt;，从该 &lt;code&gt;bpf.o&lt;/code&gt; 对象文件中包含的 map 和程序定义中创建一个骨架头文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.skel.h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.&lt;span class=&#34;n&#34;&gt;bpf&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;GEN&lt;/span&gt;-&lt;span class=&#34;nv&#34;&gt;SKEL&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;BPFTOOL&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;gen&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;skeleton&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&amp;lt;&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;opensnoop.c&lt;/code&gt; 用户空间代码包括这个 &lt;code&gt;opensnoop.skel.h&lt;/code&gt; 头文件，以获得它与内核中的 eBPF 程序共享的 map 的定义。这使得用户空间和内核代码能够了解存储在这些 map 中的数据结构体的布局。&lt;/p&gt;
&lt;p&gt;下面的规则将用户空间的代码 &lt;code&gt;opensnoop.c&lt;/code&gt; 的编译成为 &lt;code&gt;$(OUTPUT)/opensnoop.o&lt;/code&gt; 的二进制对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(OUTPUT)/%.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;wildcard&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;INCLUDES&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;-c&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;filter&lt;/span&gt; %.&lt;span class=&#34;nv&#34;&gt;c&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;-o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$@&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，有一条规则是使用 &lt;code&gt;cc&lt;/code&gt; 将用户空间的应用对象（在我们的例子中是 &lt;code&gt;opensnoop.o&lt;/code&gt;）链接成一组可执行文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;$(APPS)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; %: &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUTPUT&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;/%.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LIBBPF_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;COMMON_OBJ&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;OUT&lt;/span&gt;... 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;msg&lt;/span&gt;,&lt;span class=&#34;nv&#34;&gt;BINARY&lt;/span&gt;,&lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;Q&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CC&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;^ &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LDFLAGS&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;lelf&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;lz&lt;/span&gt; -&lt;span class=&#34;nv&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$&lt;/span&gt;@
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在你已经看到 eBPF 和用户空间程序分别是如何生成的，让我们看看用户空间的代码。&lt;/p&gt;
&lt;h3 id=&#34;opensnoop-用户空间代码&#34;&gt;Opensnoop 用户空间代码&lt;/h3&gt;
&lt;p&gt;如前所述，与 eBPF 代码交互的用户空间代码几乎可以用任何编程语言编写。我们在本节讨论的例子是用 C 语言写的，但如果你有兴趣，你可以把它与用 Python 写的原始 BCC 版本相比较，你可以在 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/master/tools/opensnoop.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bcc/tools&lt;/a&gt; 中找到。&lt;/p&gt;
&lt;p&gt;用户空间的代码在 &lt;code&gt;opensnoop.c&lt;/code&gt; 文件中。文件的前半部分有 &lt;code&gt;#include&lt;/code&gt; 指令（其中之一是自动生成的 &lt;code&gt;opensnoop.skel.h&lt;/code&gt; 文件），各种定义，以及处理不同命令行选项的代码，我们在此不再赘述。我们还将略过 &lt;code&gt;print_event()&lt;/code&gt; 等函数，该函数将一个事件的信息显示到屏幕上。从 eBPF 的角度来看，所有有趣的代码都在 &lt;code&gt;main()&lt;/code&gt; 函数中。&lt;/p&gt;
&lt;p&gt;你会看到像 &lt;code&gt;opensnoop_bpf__open()&lt;/code&gt;、&lt;code&gt;opensnoop_bpf__load()&lt;/code&gt; 和 &lt;code&gt;opensnoop_bpf__attach()&lt;/code&gt; 这样的函数。这些都是在由 &lt;code&gt;bpftool gen skeleton&lt;/code&gt; &lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;  自动生成的代码中定义的。这个自动生成的代码处理所有在 eBPF 对象文件中定义的单个 eBPF 程序、map 和附着点。&lt;/p&gt;
&lt;p&gt;opensnoop 启动和运行后，它的工作就是监听 &lt;code&gt;events&lt;/code&gt; 的 perf
buffer，并将每个事件中包含的信息写到屏幕上。首先，它打开与 perf buffer 相关的文件描述符，并将 &lt;code&gt;handle_event()&lt;/code&gt; 设置为新事件到来时要调用的函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;perf_buffer__new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bpf_map__fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;PERF_BUFFER_PAGES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle_event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handle_lost_events&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后它对缓冲区事件进行轮询，直到达到一个时间限制，或者用户中断程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exiting&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;perf_buffer__poll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PERF_POLL_TIMEOUT_MS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;传递给 &lt;code&gt;handle_event()&lt;/code&gt; 的数据参数指向 eBPF 程序为该事件写进 map 的事件结构体。&lt;/p&gt;
&lt;p&gt;用户空间的代码可以检索这些信息，将其格式化并写出来给用户看。&lt;/p&gt;
&lt;p&gt;正如你所看到的，opensnoop 注册了 eBPF 程序，每当有应用程序进行 &lt;code&gt;open()&lt;/code&gt; 或 &lt;code&gt;openat()&lt;/code&gt; 系统调用时都会被调用。这些运行在内核中的 eBPF 程序收集有关该系统调用的上下文信息 —— 可执行文件名和进程 ID—— 以及被打开的文件的信息。这些信息被写进一个 map，用户空间可以从中读取并显示给用户。&lt;/p&gt;
&lt;p&gt;你会在 &lt;code&gt;libbpf-tools&lt;/code&gt; 目录中找到几十个这样的 eBPF 工具的例子，每个例子通常都是一个系统调用，或者是一系列相关的系统调用，如 &lt;code&gt;open()&lt;/code&gt; 和 &lt;code&gt;openat()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;系统调用是一个稳定的内核接口，它提供了一个非常强大的方式来观察（虚拟）机器上正在发生的事情。但是，不要以为 eBPF 编程只能用于拦截系统调用。还有很多其他的固定接口，包括 LSM 和网络堆栈中的各种点，eBPF 可以连接到这些接口。如果你愿意承担内核版本变更的风险，eBPF 程序可以附加的范围是绝对宽广的。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;见 &lt;a href=&#34;https://oreil.ly/4MMPL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BPF 指令集文档&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;也可以跳过对象文件，使用 bpf() 系统调用直接将字节码加载到内核。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;&lt;code&gt;entry/fexit&lt;/code&gt; 在 Alexei Starovoitov 的文章中描述：《引入 BPF Trampoline》（LWN.net，2019 年 11 月 14 日）。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Oracle Linux 博客，《Taming Tracepoints in the Linux Kernel》，作者 Matt Keenan，2020 年 3 月 9 日发布。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Brendan Gregg 的网站是一个关于 &lt;a href=&#34;https://www.brendangregg.com/perf.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf events&lt;/a&gt;的良好信息来源。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;如果你有兴趣看到这方面的具体例子，你可以看一下我在 2021 年 eBPF 峰会上的&lt;a href=&#34;https://www.youtube.com/watch?v=L3_AOFSNKK8&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;，我在几分钟内实现了一个非常基本的负载均衡器，以此来说明我们如何使用 eBPF 来改变内核处理网络数据包的方式。&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;在写这篇文章的时候，这段代码使用的是事件映射的 perf 缓冲器。如果你今天为最近的内核编写这段代码，你会从一个 &lt;a href=&#34;https://nakryiko.com/posts/bpf-ringbuf/#bpf-ringbuf-vs-bpf-perfbuf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ring buffer&lt;/a&gt; 中获得更好的性能，这是一个更新的替代方案。&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;在一些内核中，你还会发现 &lt;code&gt;openat2()&lt;/code&gt;，但这个版本的 opensnoop 没有处理这个问题，至少在写作本文时是这样的。&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;你可以使用一个通用的工具，如 bpftool，它可以读取 BPF 对象文件并对其进行操作，但这需要用户知道关于加载什么以及将程序附加到什么事件的细节。对于大多数应用来说，编写一个特定的工具来为最终用户简化这一点是有意义的。&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;
&lt;p&gt;见 Andrii Nakryiko 描述 BPF 骨架代码生成的&lt;a href=&#34;https://lwn.net/Articles/806328/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>第四章：eBPF 的复杂性</title>
      <link>https://lib.jimmysong.io/what-is-ebpf/ebpf-complexity/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/what-is-ebpf/ebpf-complexity/</guid>
      <description>&lt;p&gt;现在你已经看到了 eBPF 编程的例子，了解到它是如何工作的。虽然基础示例使得 eBPF 看起来相对简单，但也有一些复杂的地方使得 eBPF 编程充满挑战。&lt;/p&gt;
&lt;p&gt;长期以来，有个问题使得编写和发布 eBPF 程序相对困难，那就是内核兼容性。&lt;/p&gt;
&lt;h2 id=&#34;跨内核的可移植性&#34;&gt;跨内核的可移植性&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以访问内核数据结构，而这些结构可能在不同的内核版本中发生变化。这些结构本身被定义在头文件中，构成了 Linux 源代码的一部分。在过去编译 eBPF 程序时，必须基于你想运行这些程序的内核兼容的头文件集。&lt;/p&gt;
&lt;h3 id=&#34;bcc-对可移植性的处理方法&#34;&gt;BCC 对可移植性的处理方法&lt;/h3&gt;
&lt;p&gt;为了解决跨内核的可移植性问题，BCC &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;（BPF 编译器集合，BPF Compiler Collection）项目采取了在运行时编译 eBPF 代码的方法，在目标机器上就地进行。这意味着编译工具链需要安装到每个你想让代码运行 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 的目标机器上，而且你必须在工具启动之前等待编译完成，而且文件系统上必须有内核头文件（实际上并不总是这样）。这就引出了 BPF CO-RE。&lt;/p&gt;
&lt;h3 id=&#34;co-re&#34;&gt;CO-RE&lt;/h3&gt;
&lt;p&gt;CO-RE（Compile Once, Run Everyone，编译一次，到处运行）方法由以下元素组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BTF (BPF Type Format)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一种用于表达数据结构和函数签名布局的格式。现代 Linux 内核支持 BTF，因此你可以从运行中的系统中生成一个名为 &lt;code&gt;vmlinux.h&lt;/code&gt; 的头文件，其中包含一个 BPF 程序可能需要的关于内核的所有数据结构信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libbpf，BPF 库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;libbpf 一方面提供了加载 eBPF 程序和映射到内核的功能，另一方面也在可移植性方面也起着重要的作用：它依靠 BTF 信息来调整 eBPF 代码，以弥补其编译时的数据结构与目标机器上的数据结构之间的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译器支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;clang 编译器得到了增强，因此当它编译 eBPF 程序时，它包括所谓的 BTF 重定位（relocation），这使得 libbpf 在加载 BPF 程序和映射到内核时知道要调整什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可选的 BPF 骨架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;bpftool gen skeleton&lt;/code&gt; 可以从编译的 BPF 对象文件中自动生成一个骨架，其中包含用户空间代码可以方便调用的函数，以管理 BPF 程序的生命周期 —— 将它们加载到内核，附加到事件等等。这些函数是更高层次的抽象，对开发者来说比直接使用 libbpf 更方便。&lt;/p&gt;
&lt;p&gt;关于 CO-RE 的更详细的解释，请阅读 Andrii Nakryiko 的出色 &lt;a href=&#34;https://nakryiko.com/posts/bpf-portability-and-co-re/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;描述&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;自 5.4 版本 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; 以来，&lt;code&gt;vmlinux&lt;/code&gt; 文件形式的 BTF 信息已经包含在 Linux 内核中，但 libbpf 可以利用的原始 BTF 数据也可以为旧内核生成。在 &lt;a href=&#34;https://github.com/aquasecurity/btfhub&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BTF Hub&lt;/a&gt; 上有关于如何生成 BTF 文件的信息，以及用于各种 Linux 发行版的文件档案。&lt;/p&gt;
&lt;p&gt;BPF CO-RE 方法使得 eBPF 程序更易于在任意 Linux 发行版上运行 —— 或者至少在新 Linux 发行版上支持任意 eBPF 能力。但这并不能使 eBPF 更优雅：它本质上仍然是内核编程。&lt;/p&gt;
&lt;h2 id=&#34;linux-内核知识&#34;&gt;Linux 内核知识&lt;/h2&gt;
&lt;p&gt;很快就会发现，为了编写更高级的工具，你需要一些关于 Linux 内核的领域知识。你需要了解你可以访问的数据结构，取决于你的 eBPF 代码被调用的环境。不是所有应用程序的开发者都有解析网络数据包、访问套接字缓冲区或处理系统调用参数的经验。&lt;/p&gt;
&lt;p&gt;内核将如何对你 eBPF 代码的行为做出反应？正如你在 &lt;a href=&#34;../changing-the-kernel-is-hard&#34;&gt;第二章&lt;/a&gt; 中了解到的，内核由数百万行代码组成。它的文档可能是稀少的，所以你可能会发现自己不得不阅读内核的源代码来弄清楚某些东西是如何工作的。&lt;/p&gt;
&lt;p&gt;你还需要弄清楚你的 eBPF 代码应该附加到哪些事件。由于可以将 &lt;code&gt;kprobe&lt;/code&gt; 附加到整个内核的任何函数入口点，这可能不是一个简单的决定。在某些情况下，这可能很明确 —— 例如，如果你想访问一个传入的网络数据包，那么适当的网络接口上的 XDP 钩子是一个明显的选择。如果你想提供对特定内核事件的可观测性，在内核代码中找到合适的点可能并不难。&lt;/p&gt;
&lt;p&gt;但在其他情况下，选择可能不那么明显。例如，简单地使用 &lt;code&gt;kprobes&lt;/code&gt; 来钩住构成内核系统调用接口的函数的工具，可能会被名为 &lt;code&gt;time-of-check&lt;/code&gt; 到 &lt;code&gt;time-of-use&lt;/code&gt;（TOCTTOU）的安全漏洞所影响。攻击者有一个小的机会窗口，他们可以在 eBPF 代码读取参数后，但在参数被复制到内核内存之前，改变系统调用的参数。在 DEF CON 29 &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; 上，Rex Guo 和 Junyuan Zeng 做了一个关于这个问题的 &lt;a href=&#34;https://www.youtube.com/watch?v=yaAdM8pWKG8&amp;amp;ab_channel=DEFCONConference&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;出色演讲&lt;/a&gt;。一些被最广泛使用的 eBPF 工具是以相当天真的方式编写的，极易受到这种攻击。这不是一个简单的漏洞，而且有办法减轻这些攻击，但如果你正在保护高度敏感的数据，对抗复杂的、有动机的对手，请深入了解你使用的工具是否可能受到影响。&lt;/p&gt;
&lt;p&gt;你已经看到了 BPF CO-RE 是如何使 eBPF 程序在不同的内核版本上工作的，但它只考虑到了数据结构布局的变化，而没有考虑到内核行为的更大变化。例如，如果你想把一个 eBPF 程序附加到内核中的一个特定的函数或 tracepoint 上，你可能需要一个 B 计划，如果该函数或 tracepoint 在不同的内核版本中不存在，该怎么做。&lt;/p&gt;
&lt;h2 id=&#34;编排多个-ebpf-程序&#34;&gt;编排多个 eBPF 程序&lt;/h2&gt;
&lt;p&gt;当前有很多基于 eBPF 的工具提供了一套可观测能力，通过将 eBPF 程序与一组内核事件挂钩来实现。其中大部分是由 Brendan Gregg 和其他人在 BCC 和 &lt;code&gt;bpftrace&lt;/code&gt; 工具中所做的工作而开创的。很多工具（通常是商业的）可能会提供更漂亮的图形和用户界面，但他们还是在这些 eBPF 程序的基础上实现的。&lt;/p&gt;
&lt;p&gt;当你想写代码来编排不同类型的事件之间的交互时，事情就变得相当复杂了。举个例子，Cilium 通过内核的网络堆栈 &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 在不同的点上观察到网络数据包，基于来自 Kubernetes CNI（容器网络接口）关于 Kubernetes pod 的信息，对流量进行操作。构建这个系统需要 Cilium 开发人员深入了解内核如何处理网络流量，以及用户空间的 &lt;strong&gt;pod&lt;/strong&gt; 和 &lt;strong&gt;容器&lt;/strong&gt; 概念如何映射到内核概念，如 cgroups 和命 namespace。在实践中，一些 Cilium 的维护者也是内核的开发者，他们致力于增强 eBPF 和网络支持；因此，他们拥有这些知识。&lt;/p&gt;
&lt;p&gt;底线是，尽管 eBPF 提供了一个极其有效和强大的平台来连接到内核，但对于没有大量内核经验的普通开发者来说，这并不容易。如果你对 eBPF 编程感兴趣，我非常鼓励你把它作为练习来学习；在这个领域积累经验可能是非常有价值的，因为它在未来几年内一定会成为受欢迎的专业技能。但实际上，大多数组织不太可能在内部建立许多定制的 eBPF 工具，而是利用专业 eBPF 社区的项目和产品。&lt;/p&gt;
&lt;p&gt;让我们继续思考为什么这些基于 eBPF 的项目和产品在云原生环境中如此强大。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;你可以在 &lt;a href=&#34;https://github.com/iovisor/bcc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub 页面&lt;/a&gt; 上找到 BCC。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;一些项目采取了将 eBPF 源和所需工具链打包成一个容器镜像的方法。这避免了安装工具链的复杂性和任何随之而来的依赖管理，但这仍意味着编译步骤在目标机器上运行。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;更多信息见 Andrii Nakryiko 的 IO Visor &lt;a href=&#34;https://lists.iovisor.org/g/iovisor-dev/message/1966&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;帖子&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Rex Guo and Junyuan Zeng, &amp;ldquo;Phantom Attack: 逃离系统调用监控，&amp;quot;（DEF CON，2021 年 8 月 5-8 日）。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.cilium.io/en/stable/concepts/ebpf/intro/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 文档&lt;/a&gt;描述了 eBPF 程序如何附加到不同的网络能力钩子，组合起来以实现复杂的网络能力。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>第五章：云原生环境中的 eBPF</title>
      <link>https://lib.jimmysong.io/what-is-ebpf/ebpf-in-cloud-native-environments/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/what-is-ebpf/ebpf-in-cloud-native-environments/</guid>
      <description>&lt;p&gt;近年来，云原生应用已呈指数级增长。在本章中，我将讨论为什么 eBPF 如此适合于云原生环境。为了更具象化，我将提到 Kubernetes，但同样适用于任何容器平台。&lt;/p&gt;
&lt;h2 id=&#34;每台主机一个内核&#34;&gt;每台主机一个内核&lt;/h2&gt;
&lt;p&gt;要理解为什么 eBPF 在云原生世界中如此强大，你需要搞清楚一个概念：每台机器（或虚拟机）只有一个内核，所有运行在该机器上的容器都共享同一个内核 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 如 &lt;a href=&#34;#figure-f-5-1&#34;&gt;图 5-1&lt;/a&gt; 所示，内核了解主机上运行的所有应用代码。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-5-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-5-1.jpg&#34; alt=&#34;图 5-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5-1. 同一主机上的所有容器共享一个内核
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;通过对内核的检测，就像我们在使用 eBPF 时做的那样，我们可以同时检测在该机器上运行的所有应用程序代码。当我们将 eBPF 程序加载到内核并将其附加到事件上时，它就会被触发，而不考虑哪个进程与该事件有关。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-与-sidecar-模式的比较&#34;&gt;eBPF 与 sidecar 模式的比较&lt;/h2&gt;
&lt;p&gt;在 eBPF 之前，Kubernetes 的可观测性和安全工具大多都采用了 sidecar 模式。这种模式允许你在与应用程序相同的 pod 中，单独部署一个工具容器。这种模式的发明是一个进步，因为这意味着不再需要直接在应用程序中编写工具代码。仅仅通过部署 sidecar，工具就获得了同一 pod 中的其他容器的可视性。注入 sidecar 的过程通常是自动化的，所以这提供了一种机制，以确保你的所有应用程序都被仪器化。&lt;/p&gt;
&lt;p&gt;每个 sidecar 容器都会消耗资源，而这要乘以注入了 sidecar 的 pod 的数量。这可能是非常重要的 —— 例如，如果每个 sidecar 需要它自己的路由信息副本，或策略规则，这就是浪费（关于这一点，Thomas Graf 写了一篇 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于服务网格 sidecar 与 eBPF 的比较&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;Sidecar 的另一个问题是，你不能保证机器上的每一个应用程序都被正确检测。设想下有一个攻击者设法破坏了你的一台主机，并启动了一个单独的 pod 来运行，比如，加密货币挖矿程序。他们不可能对你有礼貌，用你的 sidecar 可观测或安全工具来检测他们的挖矿 pod。你需要一个单独的系统来了解这种活动。&lt;/p&gt;
&lt;p&gt;但同样的加密货币矿工与运行在该主机上的合法 pod 共享内核。如果你使用基于 eBPF 的工具，如 &lt;a href=&#34;#figure-f-5-2&#34;&gt;图 5-2&lt;/a&gt; 所示，矿工会自动受到它的影响。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-5-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-5-2.jpg&#34; alt=&#34;图 5-2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5-2. 旁观者只能观测到他们自己 pod 的活动，但 eBPF 程序可以观测到所有活动
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;h2 id=&#34;ebpf-和进程隔离&#34;&gt;eBPF 和进程隔离&lt;/h2&gt;
&lt;p&gt;我主张将功能整合到一个单一的、基于 eBPF 的代理中，而不是每个 pod 的 sidecar 中。如果该代理可以访问机器上运行的所有 pod，这不是一种安全风险吗？我们不是失去了应用程序之间的隔离，而这种隔离可以防止它们相互干扰吗？&lt;/p&gt;
&lt;p&gt;作为一个容器安全领域的过来人，我可以体会到你对此的担忧，但重要的是要挖掘底层机制，以真正理解为什么它不是一开始可能出现的缺陷。&lt;/p&gt;
&lt;p&gt;请注意，这些 pod 共享同一个内核，而内核原生不能感知 pod 或容器。相反，内核对进程进行操作，并使用 cgroup 和 namespace 来隔离进程。这些结构由内核监管，以隔离用户空间中的进程，防止它们互相干扰。只要数据在内核中处理（例如，从磁盘中读取或发送到网络中），你就依赖于内核的正确行为。只有内核代码控制文件权限。没有其他层面的东西可以阻止内核忽略文件权限的东西，内核可以从任何文件中读取数据 —— 只是内核本身不会这样做。&lt;/p&gt;
&lt;p&gt;存在于 Linux 系统中的安全控制措施假定内核本身是可以信任的。它们的存在是为了防止在用户空间运行的代码产生不良行为。&lt;/p&gt;
&lt;p&gt;我们在 &lt;a href=&#34;../changing-the-kernel-is-hard&#34;&gt;第二章&lt;/a&gt; 中看到，eBPF 检查器确保 eBPF 程序只能访问它有权限的内存。检查器检查程序时不可能超出其职权范围，包括确保内存为当前进程所拥有或为当前网络包的一部分。这意味着 eBPF 代码比它周围的内核代码受到更严格的控制，内核代码不需要通过任何类型的检查器。&lt;/p&gt;
&lt;p&gt;如果攻击者逃脱了容器化的应用程序而到了节点上，而且还能够提升权限，那么该攻击者就可以危害到同一节点上的其他应用程序。由于这些逃逸是未知的，作为一个容器安全专家，我不建议在没有额外安全工具的情况下，在共享机器上与不受信任的应用程序或用户一起运行敏感的应用程序。对于高度敏感的数据，你甚至可能不希望在虚拟机中与不受信任的用户在同一裸机上运行。但是，如果你准备在同一台虚拟机上并行运行应用程序（这在许多不是特别敏感的应用程序中是完全合理的），那么 eBPF 就不会在共享内核已经存在的风险之上增加额外的风险。&lt;/p&gt;
&lt;p&gt;当然，恶意的 eBPF 程序可能造成各种破坏，当然也很容易写出劣迹的 eBPF 代码 —— 例如，复制每个网络数据包并将其发送给窃听者。默认情况下，非 root 用户没有加载 eBPF 程序 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; 的权限，只有当你真正信任他们时，你才应该授予用户或软件系统这种权限，就像 root 权限一样。因此，必须小心你所运行的代码的出处（有一个倡议正在进行中，以支持 eBPF 程序的签名检查来帮助解决这个问题）。你也可以使用 eBPF 程序来监视其他的 eBPF 程序！现在你已经对为什么 eBPF 是云原生工具的强大基础有了一个概念，下一章给你举一些来自云原生生态系统中的 eBPF 工具的具体例子。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;这基本正确，除非你使用的是虚拟化技术，像 KataContainer、Firecracker 或 unikernels 这样的方法，每个 &amp;ldquo;容器&amp;rdquo; 在自己的虚拟机中运行。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Linux &lt;code&gt;CAP_BPF&lt;/code&gt; 授予加载 BPF 程序的权限。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>第六章：eBPF 工具</title>
      <link>https://lib.jimmysong.io/what-is-ebpf/ebpf-tools/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/what-is-ebpf/ebpf-tools/</guid>
      <description>&lt;p&gt;现在你已经了解了什么是 eBPF 以及它是如何工作的，我们再探索一些可能会在生产部署中使用的基于 eBPF 技术的工具。我们将举一些基于 eBPF 的开源项目的例子，这些项目提供了三方面的能力：网络、可观测性和安全。&lt;/p&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;p&gt;eBPF 程序可以连接到网络接口和内核的网络堆栈的各个点。在每个点上，eBPF 程序可以丢弃数据包，将其发送到不同的目的地，甚至修改其内容。这就实现了一些非常强大的功能。让我们来看看通常用 eBPF 实现的几个网络功能。&lt;/p&gt;
&lt;h3 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;Facebook 正在大规模的使用 eBPF 的网络功能，因此你不必对 eBPF 用于网络的可扩展性有任何怀疑。他们是 BPF 的早期采用者，并在 2018 年推出了 &lt;a href=&#34;https://engineering.fb.com/2018/05/22/open-source/open-sourcing-katran-a-scalable-network-load-balancer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katran&lt;/a&gt;，一个开源的四层负载均衡器。&lt;/p&gt;
&lt;p&gt;另一个高度扩展的负载均衡器的例子是来自 Cloudflare 的 &lt;a href=&#34;https://blog.cloudflare.com/unimog-cloudflares-edge-load-balancer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unimog&lt;/a&gt; 边缘负载均衡器。通过在内核中运行，eBPF 程序可以操作网络数据包，并将其转发到适当的目的地，而不需要数据包通过网络堆栈和用户空间。&lt;/p&gt;
&lt;p&gt;Cilium 项目作为一个 eBPF Kubernetes 网络插件更为人所知（我一会儿会讨论），但作为独立的负载均衡器，它也被用于大型电信公司和企业内部部署。同样，因为它能够在早期阶段处理数据包，而不需要进入到用户空间，它具有很高的性能。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-网络&#34;&gt;Kubernetes 网络&lt;/h3&gt;
&lt;p&gt;CNCF 项目 Cilium 最初基于 eBPF 的 CNI 实现。它最初是由一群从事 eBPF 工作的内核维护者发起的，他们认识到 eBPF 在云原生网络中的应用潜力。它现在被用作谷歌 Kubernetes 引擎、亚马逊 EKS Anywhere 和阿里云的默认数据平面。&lt;/p&gt;
&lt;p&gt;在云原生环境下，pod 在不断的启停，每个 pod 都会被分配一个 IP 地址。在启用 eBPF 网络之前，当 pod 启停的时候，每个节点都必须为它们更新 iptables 规则，以便在 pod 之间进行路由；而当这些 iptable 规则规模变大后，将十分不便于管理。如 &lt;a href=&#34;#figure-f-6-1&#34;&gt;图 6-1&lt;/a&gt; 所示，Cilium 极大地简化了路由，仅需在 eBPF 中创建的一个简单的查找表，就可以获得 &lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观的性能改进&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另一个在传统的 iptables 版本之外还增加了 eBPF 实现的 Kubernetes CNI 是 &lt;a href=&#34;https://github.com/projectcalico/calico&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Calico&lt;/a&gt;。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-6-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-1.jpg&#34; alt=&#34;图 6-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6-1. 用 eBPF 绕过主机网络堆栈
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;h3 id=&#34;服务网格&#34;&gt;服务网格&lt;/h3&gt;
&lt;p&gt;eBPF 作为服务网格数据平面的基础也是非常有意义的。许多服务网格在七层，即应用层运行，并使用代理组件（如 Envoy）来辅助应用程序。在 Kubernetes 中，这些代理通常以 sidecar 模式部署，每个 pod 中有一个代理容器，这样代理就可以访问 pod 的网络命名空间。正如你在 &lt;a href=&#34;../ebpf-in-cloud-native-environments&#34;&gt;第五章&lt;/a&gt; 中看到的，eBPF 有一个比 sidecar 模型更有效的方法。由于内核可以访问主机中所有 pod 的命名空间，我们可以使用 eBPF 连接 pod 中的应用和主机上的代理，如 &lt;a href=&#34;#figure-f-6-2&#34;&gt;图 6-2&lt;/a&gt; 所示。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-6-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-2.jpg&#34; alt=&#34;图 6-2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6-2. eBPF 实现了服务网格的高效无 sidecar 模型，每个节点一个代理，而不是每个应用 pod 一个代理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;我还有一篇关于使用 eBPF 实现更高效的服务网格数据平面的文章，Solo.io 上也有发布过类似文章。在写这篇文章的时候，Cilium 服务网格已进入测试阶段，并显示出比传统的 sidecar 代理方法具有更大的 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能提升&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;可观测性&#34;&gt;可观测性&lt;/h2&gt;
&lt;p&gt;正如你在本报告前面所看到的，eBPF 程序可以获得对机器上发生的一切的可观测性。通过收集事件数据并将其传递给用户空间，eBPF 实现了一系列强大的可观测性工具，可以向你展示你的应用程序是如何执行和表现的，而不需要对这些应用程序做任何改变。&lt;/p&gt;
&lt;p&gt;在本报告的前面，你已经看到了 BCC 项目，几年来，Brendan Gregg 在 Netflix 做了开创性的工作，展示了这些 eBPF 工具如何被用来 &lt;a href=&#34;https://www.brendangregg.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;观测我们感兴趣的几乎任何指标&lt;/a&gt;，而且是大规模和高性能的。&lt;/p&gt;
&lt;p&gt;Kinvolk 的 &lt;a href=&#34;https://github.com/kinvolk/inspektor-gadget&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inspektor Gadget&lt;/a&gt; 将其中一些起源于 BCC 的工具带入了 Kubernetes 的世界，这样你就可以在命令行上轻松观测特定的工作负载。&lt;/p&gt;
&lt;p&gt;新一代的项目和工具正在这项工作的基础上，提供基于 GUI 的观测能力。CNCF 项目 &lt;a href=&#34;https://px.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pixie&lt;/a&gt; 可以让你运行预先写好的或自定义的脚本，通过一个强大的、视觉上吸引人的用户界面查看指标和日志。因为它是基于 eBPF 的，这意味着你可以自动检测所有应用程序，获得性能数据，而无需进行任何代码修改或配置。&lt;a href=&#34;#figure-f-6-3&#34;&gt;图 6-3&lt;/a&gt; 显示的只是 Pixie 中众多可视化的一个例子。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-6-3&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-3.jpg&#34; alt=&#34;图 6-3&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6-3. 一个小型 Kubernetes 集群上运行的所有东西的 Pixie 火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;另一个名为 &lt;a href=&#34;https://github.com/parca-dev/parca&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Parca&lt;/a&gt; 的可观测性项目专注于连续剖析，使用 eBPF 对 CPU 使用率等指标进行有效采样，可以用来检测性能瓶颈。&lt;/p&gt;
&lt;p&gt;Cilium 的 &lt;a href=&#34;https://github.com/cilium/hubble&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hubble&lt;/a&gt; 组件是一个具有命令行界面和用户界面的可观测性工具（如 &lt;a href=&#34;#figure-f-6-4&#34;&gt;图 6-4&lt;/a&gt; 所示），它专注于 Kubernetes 集群中的网络流。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-6-4&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-4.jpg&#34; alt=&#34;图 6-4&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6-4. Cilium 的 Hubble 用户界面显示了 Kubernetes 集群中的网络流量
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;在云原生环境中，IP 地址不断被动态重新分配，基于 IP 地址的传统网络观测工具的作用非常有限。作为一个 CNI，Cilium 可以访问工作负载身份信息，这意味着 Hubble 可以显示由 Kubernetes pod、服务和命名空间标识的服务映射和流量数据。这对于诊断网络问题十分有用。&lt;/p&gt;
&lt;p&gt;能够观测到活动，这是安全工具的基础，这些工具将正在发生的事情与策略或规则相比较，以了解该活动是预期的还是可疑的。让我们来看看一些使用 eBPF 来提供云原生安全能力的工具。&lt;/p&gt;
&lt;h2 id=&#34;安全&#34;&gt;安全&lt;/h2&gt;
&lt;p&gt;有一些强大的云原生工具，通过使用 eBPF 检测甚至防止恶意活动来增强安全性。我将其分为两类：一类是确保网络活动的安全，另一类是确保应用程序在运行时的预期行为。&lt;/p&gt;
&lt;h3 id=&#34;网络安全&#34;&gt;网络安全&lt;/h3&gt;
&lt;p&gt;由于 eBPF 可以检查和操纵网络数据包，它在网络安全方面有许多用途。基本原理是，如果一个网络数据包被认为是恶意的或有问题的，因为它不符合一些安全验证标准，就可以被简单地丢弃。eBPF 可以很高效的来验证这一点，因为它可以钩住内核中网络堆栈的相关部分，甚至在网卡上 &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。这意味着策略外的或恶意的数据包可以在产生网络堆栈处理和传递到用户空间的处理成本之前被丢弃。&lt;/p&gt;
&lt;p&gt;这里有一个 eBPF 早期在生产中大规模使用的一个例子 —— &lt;a href=&#34;https://blog.cloudflare.com/how-to-drop-10-million-packets/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloudflare&lt;/a&gt; 的 DDoS（分布式拒绝服务）保护。DDoS 攻击者用许多网络信息淹没目标机，希望目标机忙于处理这些信息，导致无法提供有效工作。Cloudflare 的工程师使用 eBPF 程序，在数据包到达后立即对其进行检查，并迅速确定一个数据包是否是这种攻击的一部分，如果是，则将其丢弃。数据包不必通过内核的网络堆栈，因此需要的处理资源要少得多，而且目标可以应对更大规模的恶意流量。&lt;/p&gt;
&lt;p&gt;eBPF 程序也被用于动态缓解”死亡数据包“的内核漏洞 &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。攻击者以这样的方式制作一个网络工作数据包——利用了内核中的一个错误，使其无法正确处理该数据包。与其等待内核补丁的推出，不如通过加载一个 eBPF 程序来缓解攻击，该程序可以寻找这些特别制作的数据包并将其丢弃。这一点的真正好处是，eBPF 程序可以动态加载，而不必改变机器上的任何东西。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中，&lt;a href=&#34;https://networkpolicy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络策略&lt;/a&gt; 是一等资源，但它是由网络插件来执行的。一些 CNI，包括 Cilium 和 Calico，为更强大的规则提供了扩展的网络策略功能，例如允许或禁止流量到一个由完全限定域名而不是仅仅由 IP 地址指定的目的地。在 &lt;a href=&#34;https://app.networkpolicy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;app.networkpolicy.io&lt;/a&gt; 有一个探索网络策略及其效果的好工具，如 &lt;a href=&#34;#figure-f-6-5&#34;&gt;图 6-5&lt;/a&gt; 所示。&lt;/p&gt;
















&lt;figure  id=&#34;figure-f-6-5&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-5.jpg&#34; alt=&#34;图 6-5&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6-5. 网络策略编辑器显示了一个策略效果的可视化表示
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;标准的 Kubernetes 网络策略规则适用于进出应用 pod 的流量，但由于 eBPF 对所有网络流量都有可视性，它也可用于主机防火墙功能，限制进出主机（虚拟机）的流量 &lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;eBPF 也可以被用来提供透明的加密，无论是通过 WireGuard 还是 IPsec &lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。在这里，&lt;strong&gt;透明&lt;/strong&gt; 意味着应用程序不需要任何修改 —— 事实上，应用程序可以完全不知道其网络流量是被加密的。&lt;/p&gt;
&lt;h3 id=&#34;运行时安全&#34;&gt;运行时安全&lt;/h3&gt;
&lt;p&gt;eBPF 也被用来构建工具，检测恶意程序，防止恶意行为。这些恶意程序包括访问未经许可的文件，运行可执行程序，或试图获得额外的权限。&lt;/p&gt;
&lt;p&gt;事实上，你很可能已经以 seccomp 的形式使用了基于 BPF 的安全策略，这是一个 Linux 功能，限制应用程序可以调用的系统调用集。&lt;/p&gt;
&lt;p&gt;CNCF 项目 &lt;a href=&#34;https://falco.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Falco&lt;/a&gt; 扩展了这种限制应用程序可以进行系统调用的想法。Falco 的规则定义是用 YAML 创建的，这比 seccomp 配置文件更容易阅读和理解。默认的 Falco 驱动是一个内核模块，但也有一个 eBPF 探针驱动，它与”原始系统调用“事件相联系。它不会阻止这些系统调用的完成，但它可以生成日志或其他通知，提醒操作人员注意潜在的恶意程序。&lt;/p&gt;
&lt;p&gt;正如我们在 &lt;a href=&#34;../ebpf-programs&#34;&gt;第三章&lt;/a&gt; 中看到的，eBPF 程序可以附加到 LSM 接口上，以防止恶意行为或修复已知的漏洞。例如，Denis Efremov 写了一个 &lt;a href=&#34;https://github.com/evdenis/lsm_bpf_check_argc0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF 程序&lt;/a&gt; 来防止 &lt;code&gt;exec()&lt;/code&gt; 系统调用在没有传递任何参数的情况下运行，以修复 PwnKit &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; 的高危漏洞。eBPF 也可用于缓解投机执行的”Spectre“攻击 &lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/aquasecurity/tracee&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tracee&lt;/a&gt; 是另一个使用 eBPF 的运行时安全开源项目。除了基于系统调用的检查之外，它还使用 LSM 接口。这有助于避免受到 &lt;a href=&#34;https://lwn.net/Articles/245630/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOCTTOU 竞争&lt;/a&gt; 条件的影响，因为只检查系统调用时可能会出现这种情况。Tracee 支持用 Open Policy Agent 的 Rego 语言定义的规则，也允许用 Go 定义的插件规则。&lt;/p&gt;
&lt;p&gt;Cilium 的 &lt;a href=&#34;https://github.com/cilium/tetragon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tetragon&lt;/a&gt; 组件提供了另一种强大的方法，使用 eBPF 来监控 &lt;strong&gt;容器安全可观测性的四个黄金信号&lt;/strong&gt;：进程执行、网络套接字、文件访问和七层网络身份。这使操作人员能够准确地看到所有恶意或可疑事件，直击特定 pod 中的可执行文件名称和用户身份。例如，如果你受到加密货币挖矿的攻击，你可以看到到底是什么可执行程序打开了与矿池的网络连接，什么时候，从哪个 pod。这些取证是非常有价值的，可以了解漏洞是如何发生的，并使其容易建立安全策略，以防止类似的攻击再次发生。&lt;/p&gt;
&lt;p&gt;如果你想更深入地了解 eBPF 的安全可观测性这一主题，请查看 Natália Ivánkó 和 Jed Salazar 的报告 &lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;。请关注云原生 eBPF 领域，因为不久之后我们就会看到利用 BPF LSM 和其他 eBPF 定制的工具来提供安全执行和可以观测能力。&lt;/p&gt;
&lt;p&gt;我们在网络、可观测性和安全方面对几个云原生工具进行了考察。与前几代相比，eBPF 的使用为它们两个关键优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从内核中的有利位置来看，eBPF 程序对所有进程都有可视性。&lt;/li&gt;
&lt;li&gt;通过避免内核和用户空间执行之间的转换，eBPF 程序为收集事件数据或处理网络数据包提供了一种极其有效的方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这并不意味着我们应该使用 eBPF 来处理所有的事情！在 eBPF 中编写特定业务的应用程序是没有意义的，就像我们不可能将应用程序写成内核模块一样。但是也有一些例外情况，比如对于高频交易这样对性能有极高的情况下。正如我们在本章中所看到的那样，eBPF 主要是用于为其他应用程序提供工具。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;有些网卡或驱动支持 XDP 或 eXpress Data Path 钩子，允许 eBPF 程序完全从内核中卸载出来。&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Daniel Borkmann 在他的&lt;a href=&#34;https://www.youtube.com/watch?v=Qhm1Zn_BNi4&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;中讨论了这个问题，《BPF 更适合作为数据平面》（eBPF 峰会（线上），2020 年）。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;见 Cilium 的主机防火墙&lt;a href=&#34;https://docs.cilium.io/en/stable/gettingstarted/host-firewall/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Tailscale 有这两种加密协议的&lt;a href=&#34;https://tailscale.com/kb/1173/ipsec-vs-wireguard/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;比较&lt;/a&gt;。&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;见 Bharat Jogi 的&lt;a href=&#34;https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;博客&lt;/a&gt;，《PwnKit: 本地权限升级漏洞》（Qualys，2022 年 1 月 25 日）。&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;见 Daniel Borkmann 的&lt;a href=&#34;https://www.youtube.com/watch?v=6N30Yp5f9c4&amp;amp;ab_channel=eBPF%26CiliumCommunity&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;演讲&lt;/a&gt;，《BPF 和 Spectre：缓解瞬时执行攻击问题》（eBPF 峰会（线上），2021 年 8 月 18-19 日）。&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;Natália Ivánkó 和 Jed Salazar，《&lt;a href=&#34;https://learning.oreilly.com/library/view/security-observability-with/9781492096719/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Security Observability with eBPF&lt;/a&gt;》（O’Reilly，2022）。&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>第七章：结论</title>
      <link>https://lib.jimmysong.io/what-is-ebpf/conclusion/</link>
      <pubDate>Thu, 02 Jun 2022 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/what-is-ebpf/conclusion/</guid>
      <description>&lt;p&gt;我希望这个简短的报告能让你了解 eBPF 和它的强大之处。我真正希望的是，你已经准备好尝试一些基于 eBPF 的工具！如果你想在技术方面深入研究，可以从 &lt;a href=&#34;https://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf.io&lt;/a&gt; 开始，在那里你会找到更多关于技术和 ebPF 基金会的信息。对于编码实例，可以在 GitHub 上的 &lt;a href=&#34;https://github.com/lizrice/ebpf-beginners&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf-beginners&lt;/a&gt; 仓库里找到。&lt;/p&gt;
&lt;p&gt;为了了解其他人是如何利用 eBPF 工具的，请参加 &lt;a href=&#34;https://twitter.com/ebpfsummit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF Summit&lt;/a&gt; 和 &lt;a href=&#34;https://events.linuxfoundation.org/cloud-native-ebpf-day-europe/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native eBPF Day&lt;/a&gt; 等活动，在这些活动中，用户分享他们的成功和学习经验。还有一个活跃的 Slack 频道 &lt;a href=&#34;https://cilium.herokuapp.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ebpf.io/slack&lt;/a&gt;。我希望能在那里见到你！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 eBPF 准确定位服务网格的关键性能问题</title>
      <link>https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</link>
      <pubDate>Tue, 05 Jul 2022 17:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</guid>
      <description>&lt;h2 id=&#34;background&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;Apache SkyWalking 观察部署在服务网格中的服务的度量、日志、追踪和事件。在进行故障排除时，SkyWalking 错误分析是一个宝贵的工具，可以帮助确定错误发生的位置。然而，确定性能问题更加困难：利用预先存在的观察数据往往不可能找到性能问题的根本原因。为此，动态调试和故障排除在进行服务性能剖析时就必不可少。在这篇文章中，我们将讨论如何使用 eBPF 技术来改进 SkyWalking 中的剖析功能，并用于分析服务网格中的性能影响。&lt;/p&gt;
&lt;h2 id=&#34;trace-profiling-in-skywalking&#34;&gt;SkyWalking 中的追踪剖析&lt;/h2&gt;
&lt;p&gt;自 SkyWalking 7.0.0 以来，Trace Profiling 通过定期对线程堆栈进行采样，让开发者知道运行哪行代码花费更多时间，从而帮助开发者发现性能问题。然而，Trace Profiling 不适合以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程模型&lt;/strong&gt;：Trace Profiling 对于剖析在单线程中执行的代码最有用。它对严重依赖异步执行模式的中间件不太有用。例如，Go 中的 Goroutines 或 Kotlin Coroutines。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语言&lt;/strong&gt;：目前，Trace Profiling 只支持 Java 和 Python，因为在 Go 和 Node.js 等一些语言的运行时中不容易获得线程栈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent 绑定&lt;/strong&gt;：Trace Profiling 需要安装 Agent，根据语言的不同，这可能很麻烦（例如，PHP 必须依赖其 C 内核；Rust 和 C/C++ 需要的仪器需要手动安装）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联性&lt;/strong&gt;：由于追踪剖析只与单个请求相关，所以当无法确认哪个请求产生问题时则变得难已处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期短的服务&lt;/strong&gt;：由于（至少）两个原因，Trace Profiling 不支持短声明周期的服务：
&lt;ul&gt;
&lt;li&gt;在启动阶段，很难区分系统性能和类代码操作。&lt;/li&gt;
&lt;li&gt;Trace Profiling 与一个端点相连，以识别性能影响，但没有端点来匹配这些短生命周期的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，有一些技术比 Trace Profiling 更实用。&lt;/p&gt;
&lt;h2 id=&#34;introduce-ebpf&#34;&gt;eBPF 简介&lt;/h2&gt;
&lt;p&gt;我们发现，eBPF —— 一种可以在操作系统内核中运行沙盒程序的技术，从而安全有效地扩展内核的功能，而不需要修改内核或加载内核模块，可以帮助我们填补 Trace Profiling 留下的空白。eBPF 技术正在流行，因为它打破了传统上的用户和内核空间之间的障碍。现在我们可以将程序作为字节码注入到内核中运行，而不需要定制和重新编译内核。可观测可以很好地利用这一点。&lt;/p&gt;
&lt;p&gt;在下图中，我们可以看到，当系统执行 &lt;code&gt;execve&lt;/code&gt; 系统调用时，eBPF 程序被触发，通过使用函数调用获得当前进程的运行时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-程序调用流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF 程序调用流程图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_501ba58999de3fea0b73da4d1a5134c6.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 程序调用流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 eBPF 技术，可以将 SkyWalking 的剖析能力范围扩大到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局性能剖析&lt;/strong&gt;：在 eBPF 之前，数据收集被限制在代理可以观察的范围内。由于 eBPF 程序在内核中运行，它们可以观察到所有的线程。当你不确定某个性能问题是否是由一个特定的请求引起的，这一点特别有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据内容&lt;/strong&gt;：eBPF 可以转储用户和内核空间的线程栈，所以如果性能问题发生在内核空间就更容易被发现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理绑定&lt;/strong&gt;：所有现代 Linux 内核都支持 eBPF，所以不需要安装任何东西。这意味着它是一个免编排与代理的模型。这减少了由内置软件引起的摩擦，这些软件可能没有安装正确的代理，如服务网格中的 Envoy。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采样类型&lt;/strong&gt;：与追踪剖析不同，eBPF 是事件驱动的，因此，不受间隔轮询的限制。例如，eBPF 可以触发事件，并根据传输大小的阈值收集更多的数据。这可以让系统在极端负载下分流和优先收集数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ebpf-limitations&#34;&gt;eBPF 的局限性&lt;/h3&gt;
&lt;p&gt;虽然 eBPF 为发掘性能瓶颈提供了显著的优势，但没有任何技术是完美的。eBPF 有一些限制，如下所述（幸运的是，由于 SkyWalking 不依赖 eBPF，其影响是有限的）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux 版本要求&lt;/strong&gt;：eBPF 程序需要的 Linux 内核版本要 4.4 以上，更新的内核版本可以提供更多的数据收集。BCC 记录了 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/13b5563c11f7722a61a17c6ca0a1a387d2fa7788/docs/kernel-versions.md#main-features&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同 Linux 内核版本所支持的功能&lt;/a&gt;，不同版本之间的差异在于 eBPF 收集的数据集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要特权权限&lt;/strong&gt;：所有打算将 eBPF 程序加载到 Linux 内核的进程必须在特权模式下运行。因此，代码中的错误或其他问题可能对安全有很大的影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对动态语言的支持较弱&lt;/strong&gt;：eBPF 对基于 JIT 的动态语言，如 Java，支持较弱。这也取决于你想收集什么数据。对于 Profiling，eBPF 不支持解析程序的字符表（symbol），这就是为什么大多数基于 eBPF 的剖析技术只支持静态语言如 C、C++、Go 和 Rust。然而，字符表映射有时可以通过语言所提供的工具来解决。例如，在 Java 中，可以使用 &lt;a href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent#architecture&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf-map-agent&lt;/a&gt; 来生成字符表映射。然而，动态语言不支持附加（&lt;code&gt;uprobe&lt;/code&gt;）功能，而这种功能可以让我们通过符号追踪执行事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;introducing-skywalking-rover&#34;&gt;SkyWalking Rover 简介&lt;/h3&gt;
&lt;p&gt;SkyWalking Rover 是 SkyWalking 生态系统中引入的 eBPF 剖析功能。下图显示了 SkyWalking Rover 的整体架构。SkyWalking Rover 目前支持 Kubernetes 环境，必须部署在 Kubernetes 集群内。与 SkyWalking 后端服务器建立连接后，它将当前机器上的进程信息保存到 SkyWalking。当用户通过用户界面创建 eBPF 剖析任务时，SkyWalking Rover 会接收任务并在相关的基于 C、C++、Golang 和 Rust 语言的程序中执行。&lt;/p&gt;
&lt;p&gt;除了需要具有 eBPF 功能的内核外，部署 SkyWalking Rover 没有其他先决条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-skywalking-rover-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SkyWalking Rover 架构图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_77630572196fa0d44044c36d67f6e3d2.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp&#34;
               width=&#34;760&#34;
               height=&#34;259&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SkyWalking Rover 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;cpu-profiling-with-rover&#34;&gt;使用 Rover 进行 CPU 剖析&lt;/h3&gt;
&lt;p&gt;CPU 剖析是显示服务性能的最直观方式。受 &lt;a href=&#34;https://www.brendangregg.com/offcpuanalysis.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brendan Gregg 的博客文章&lt;/a&gt; 的启发，我们将 CPU 剖析分为两种类型，并在 Rover 中加以实施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 剖析&lt;/strong&gt;：线程在 CPU 上的运行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;off-CPU 剖析&lt;/strong&gt;：线程在 I/O、锁、定时器、分页 / 交换等方面被阻塞时的等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;profiling-envoy-with-ebpf&#34;&gt;用 eBPF 对 Envoy 进行剖析&lt;/h2&gt;
&lt;p&gt;Envoy 是一个流行的代理，在 Istio 服务网格中被用作为数据平面。在 Kubernetes 集群中，Istio 将 Envoy 作为 sidecar 注入到每个服务的 pod 中，在那里透明地拦截和处理传入和传出的流量。作为数据平面，Envoy 的任何性能问题都会影响到网格中的所有服务流量。在这种情况下，使用 eBPF 剖析来分析生产中由服务网格引起的问题是比较有力的。&lt;/p&gt;
&lt;h3 id=&#34;demo-environment&#34;&gt;演示环境&lt;/h3&gt;
&lt;p&gt;如果你想看到详细过程，我们已经建立了一个演示环境，在那里我们部署了一个 Nginx 服务进行压力测试。流量被 Envoy 拦截并转发到 Nginx。安装整个环境的命令可以在 &lt;a href=&#34;https://github.com/mrproliu/skywalking-rover-profiling-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上获取。&lt;/p&gt;
&lt;h2 id=&#34;on-cpu-profiling&#34;&gt;CPU 剖析&lt;/h2&gt;
&lt;p&gt;当服务的 CPU 使用率很高时，CPU 剖析适用于分析线程堆栈。如果堆栈被转储的次数较多，意味着线程堆栈占据了更多的 CPU 资源。&lt;/p&gt;
&lt;p&gt;在使用演示配置文件安装 Istio 时，我们发现有两个地方的性能可以优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Zipkin 追踪&lt;/strong&gt;：不同的 Zipkin 采样百分比对 QPS 有直接影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问日志格式&lt;/strong&gt;：减少 Envoy 访问日志的字段可以提高 QPS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zipkin-追踪&#34;&gt;Zipkin 追踪&lt;/h3&gt;
&lt;h3 id=&#34;zipkin-100-采样&#34;&gt;Zipkin 100% 采样&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，Envoy 使用 100% 采样作为默认的追踪策略。这对性能有什么影响？&lt;/p&gt;
&lt;p&gt;如下图所示，使用 CPU 剖析，我们发现它大约需要 &lt;strong&gt;16%&lt;/strong&gt; 的 CPU 开销。在固定消耗 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 的情况下，其 QPS 可以达到 &lt;strong&gt;5.7K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-zipkin-100-采样-cpu-剖析的火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Zipkin 100% 采样 CPU 剖析的火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_b68a53a9b8fc1f02dbfc560074a62481.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Zipkin 100% 采样 CPU 剖析的火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;禁用-zipkin-追踪&#34;&gt;禁用 Zipkin 追踪&lt;/h3&gt;
&lt;p&gt;此时，我们发现，如果没有必要，可以降低 Zipkin 采样比例，甚至可以禁用追踪。根据 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#Tracing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;，我们可以在安装 Istio 时使用以下命令禁用追踪。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.enableTracing=false&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.defaultConfig.tracing.sampling=0.0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用追踪后，我们再次进行 CPU 剖析。根据下图，我们发现 Zipkin 已经从火焰图中消失了。在与前面的例子相同的 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 消耗下，QPS 达到 &lt;strong&gt;9K&lt;/strong&gt;，几乎增加了 &lt;strong&gt;60%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用-zipkin-追踪的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用 Zipkin 追踪的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_4120d0c8954a6454493ed53dde25e284.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp&#34;
               width=&#34;760&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用 Zipkin 追踪的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;tracing-with-throughput&#34;&gt;追踪吞吐量&lt;/h3&gt;
&lt;p&gt;在 CPU 使用率相同的情况下，我们发现，当追踪功能被禁用时，Envoy 的性能会大大提升。当然，这需要我们在 Zipkin 收集的样本数量和 Envoy 的预期性能（QPS）之间做出权衡。&lt;/p&gt;
&lt;p&gt;下表说明了在相同的 CPU 使用率下，不同的 Zipkin 采样比例对 QPS 的影响。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Zipkin 采样比例&lt;/th&gt;
&lt;th&gt;QPS&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100% &lt;strong&gt;（默认）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5.7K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 16%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1%&lt;/td&gt;
&lt;td&gt;8.1K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;禁用&lt;/td&gt;
&lt;td&gt;9.2K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;access-log-format&#34;&gt;访问日志格式&lt;/h2&gt;
&lt;h3 id=&#34;default-log-format&#34;&gt;默认访问日志格式&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，默认的访问日志格式包含大量的数据。下面的火焰图显示了在解析数据时涉及的各种功能，如请求头、响应头和流媒体主体。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-默认访问日志格式的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;默认访问日志格式的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_ca470e83e66ecbe17169087ebaace536.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      默认访问日志格式的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;simplifying-access-log-format&#34;&gt;简化访问日志格式&lt;/h3&gt;
&lt;p&gt;通常情况下，我们不需要访问日志中的所有信息，所以我们通常可以简化它来获得我们需要的信息。下面的命令简化了访问日志的格式，只显示基本信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set meshConfig.accessLogFormat&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;[% START_TIME%] \&amp;#34;% REQ (:METHOD)% % REQ (X-ENVOY-ORIGINAL-PATH?:PATH)% % PROTOCOL%\&amp;#34;% RESPONSE_CODE%\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;简化访问日志格式后，我们发现 QPS 从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。当再次执行 CPU 剖析时，日志格式化的 CPU 使用率从 &lt;strong&gt;2.4%&lt;/strong&gt; 下降到 &lt;strong&gt;0.7%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简化日志格式帮助我们提高了性能。&lt;/p&gt;
&lt;h2 id=&#34;off-cpu-剖析&#34;&gt;Off-CPU 剖析&lt;/h2&gt;
&lt;p&gt;Off-CPU 剖析适用于由非高 CPU 使用率引起的性能问题。例如，当一个服务中有太多的线程时，使用 off-CPU 剖析可以揭示出哪些线程花费了更多的时间进行上下文切换。&lt;/p&gt;
&lt;p&gt;我们提供两个维度的数据汇总。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;切换次数&lt;/strong&gt;：一个线程切换上下文的次数。当线程返回到 CPU 时，它完成了一次上下文切换。开关次数较多的线程栈会花费更多时间进行上下文切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切换持续时间&lt;/strong&gt;：一个线程切换上下文所需的时间。切换持续时间较长的线程栈在 off-CPU 花费的时间较多。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;write-access-log&#34;&gt;写入访问日志&lt;/h3&gt;
&lt;h4 id=&#34;enable-write&#34;&gt;启用写入&lt;/h4&gt;
&lt;p&gt;使用与之前 CPU 测试相同的环境和设置，我们进行了 off-CPU 剖析。如下图所示，我们发现访问日志的写入占总上下文切换的 &lt;strong&gt;28%&lt;/strong&gt; 左右。下图中的 &lt;code&gt;__write&lt;/code&gt; 也表明这是 Linux 内核中的方法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-启用写入的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;启用写入的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_fea2e2c0d03b286f15392cc50602ab21.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      启用写入的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;禁用写入&#34;&gt;禁用写入&lt;/h4&gt;
&lt;p&gt;SkyWalking 实现了 Envoy 的访问日志服务（ALS）功能，允许我们使用 gRPC 协议将访问日志发送到 SkyWalking 可观察性分析平台（OAP）。即使禁用访问日志，我们仍然可以使用 ALS 来捕获 / 汇总日志。我们使用以下命令禁用了对访问日志的写入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo --set meshConfig.accessLogFile&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用访问日志功能后，我们进行了 off-CPU 剖析。如下图所示，文件写入条目已经消失了。Envoy 的吞吐量也从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用访问日志功能后的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用访问日志功能后的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_64a520f1998a1b10dd8b102cdaefebbb.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用访问日志功能后的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我们研究了 Apache SkyWalking 的 Trace Profiling 可以给我们带来的启示，以及使用 eBPF 剖析可以实现的更多功能。所有这些功能都在 &lt;a href=&#34;https://github.com/apache/skywalking-rover&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-rover&lt;/a&gt; 中实现。除了 CPU 和 off-CPU 剖析之外，你还会发现以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连续剖析&lt;/strong&gt;，帮助你自动剖析，无需人工干预。例如，当 Rover 检测到 CPU 超过一个可配置的阈值时，它会自动执行 CPU 剖析任务。&lt;/li&gt;
&lt;li&gt;更多的剖析类型，以丰富使用场景，如网络和内存剖析。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>告别 Sidecar——使用 eBPF 解锁内核级服务网格</title>
      <link>https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/</link>
      <pubDate>Thu, 09 Dec 2021 21:03:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/</guid>
      <description>&lt;h2 id=&#34;编者的话&#34;&gt;编者的话&lt;/h2&gt;
&lt;p&gt;本文作者是 Isovalent 联合创始人&amp;amp;CTO，原文标题 &lt;a href=&#34;https://isovalent.com/blog/post/2021-12-08-ebpf-servicemesh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How eBPF will solve Service Mesh - Goodbye Sidecars&lt;/a&gt;，作者回顾了 Linux 内核的连接性，实现服务网格的几种模式，以及如何使用 eBPF 实现无 Sidecar 的服务网格。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;随着分布式应用的引入，额外的可视性、连接性和安全性要求也浮出水面。应用程序组件通过不受信任的网络跨越云和集群边界进行通信，负载均衡、弹性变得至关重要，安全必须发展到发送者和接收者都可以验证彼此的身份的模式。在分布式应用的早期，这些要求是通过直接将所需的逻辑嵌入到应用中来解决的。服务网格将这些功能从应用程序中提取出来，作为基础设施的一部分提供给所有应用程序使用，因此不再需要修改每个应用程序。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务网格示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务网格示意图&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_2f4c949f5635907beff63e8337d6f76c.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_17137669c2ea72adc4c86b6f1c92847f.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyna8jsj32e20sojtx_hu6485f23e60e2e8e9568294bae27898e8_102977_2f4c949f5635907beff63e8337d6f76c.webp&#34;
               width=&#34;760&#34;
               height=&#34;253&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务网格示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;纵观今天服务网格的功能设置，可以总结为以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;弹性连接&lt;/strong&gt;：服务与服务之间的通信必须能够跨越边界，如云、集群和场所。通信必须是有弹性的和容错的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L7 流量管理&lt;/strong&gt;：负载均衡、速率限制和弹性必须是 L7 感知的（HTTP、REST、gRPC、WebSocket 等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于身份的安全&lt;/strong&gt;：依靠网络标识符来实现安全已经不够了，发送和接收服务都必须能够根据身份而不是网络标识符来验证对方。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可观测性和跟踪&lt;/strong&gt;：追踪和指标形式的可观测性对于理解、监控和排除应用程序的稳定性、性能和可用性至关重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明&lt;/strong&gt;：该功能必须以透明的方式提供给应用程序，即不需要改变应用程序代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在早期，服务网格的功能通常是以库的形式实现的，要求网格中的每个应用程序都要链接到以应用程序的语言框架编写的库。类似的事情也发生在互联网的早期：曾几何时，应用程序还需要运行自己的 TCP/IP 协议栈！正如我们将在这篇文章中讨论的那样，服务网格正在发展成为一种内核责任，就像网络堆栈一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于库的服务网格模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于库的服务网格模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_dc28956fcdaa8533c1e80646c297a1af.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_95551f04e0dbe65f3378e151db58034e.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyowb55j31pi0k076p_hu50a747d0fe993bbedeb4bea6655ecd4b_95490_dc28956fcdaa8533c1e80646c297a1af.webp&#34;
               width=&#34;760&#34;
               height=&#34;247&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于库的服务网格模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天，服务网格通常使用一种叫做 sidecar 模型的架构来实现。这种架构将实现上述功能的代码封装到第四层代理中，服务间的流量被重定向到这个所谓的 sidecar 代理。它之所以被称为“挎斗”，是因为每个应用程序都有一个代理，就像挎斗附着在摩托车上一样。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-sidecar-的服务网格模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 Sidecar 的服务网格模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_0d600138e96a481444eae67391d42740.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_a407f59981107c732d11d0d70af1a165.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyqsefhj31pe0moq5h_hu4fd9e548e6d25e6c485bbd6b10898244_100939_0d600138e96a481444eae67391d42740.webp&#34;
               width=&#34;760&#34;
               height=&#34;281&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 Sidecar 的服务网格模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种架构的优点是，服务不再需要自己实现服务网格的功能。如果许多服务是用不同的语言编写部署的，或者如果你正在运行不可变的第三方应用程序，这就很有好处。&lt;/p&gt;
&lt;p&gt;这种模式的缺点是有大量的代理，许多额外的网络连接，以及复杂的重定向逻辑，将网络流量输入代理。除此之外，在什么类型的网络流量可以被重定向到第四层代理上也有限制。代理（Proxy）在其能支持的网络协议方面是有限的。&lt;/p&gt;
&lt;h2 id=&#34;连接性转移到内核中的历史&#34;&gt;连接性转移到内核中的历史&lt;/h2&gt;
&lt;p&gt;几十年来，在应用程序之间提供安全可靠的连接一直是操作系统的责任。有些人可能还记得早期 Unix 和 Linux 时代的 &lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_Wrappers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCP 包装器&lt;/a&gt;和 tcpd。tcpd 允许用户在不修改应用程序的情况下透明地添加日志、访问控制、主机名验证和欺骗保护。它使用了 libwrap，而且，在一个有趣的平行于服务网格的故事中，这个库也是以前应用程序提供这些功能的链接对象。tcpd 所带来的是能够在不修改现有应用程序的情况下将这些功能透明地添加到现有应用程序中。最终，所有这些功能都进入了 Linux 本身，并以一种更有效、更强大的方式提供给所有应用程序。今天，这已经发展到了我们所知道的 iptables。&lt;/p&gt;
&lt;p&gt;然而，iptables 显然不适合解决现代应用的连接性、安全性和可观测性要求，因为它只在网络层面上操作，对应用协议层缺乏任何了解。自然，阻力最小的路径是回到库模型，然后是 sidecar 模型。现在，我们正处于这样一个阶段：为了最佳的透明度、效率和安全性，在操作系统中原生地支持这种模式是有意义的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务网格的进化&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;服务网格的进化&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_9bd5af9f2b4e222bd3c4020df3f9c9da.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_8944ed8b5c9c12d06d4e019d777f3674.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8ybphhj31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_9bd5af9f2b4e222bd3c4020df3f9c9da.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务网格的进化
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 tcpd 时代，曾经的连接记录现在是追踪。IP 层面的访问控制已经演变成应用协议层面的授权，例如使用 JWT。主机名验证已被更强大的认证所取代，如 mTLS。网络负载均衡已经扩展到 L7 流量管理。HTTP 重试是新的 TCP 重传。过去用黑洞路由解决的问题今天被称为断路。这些都不是根本性的新问题，但所需的环境和控制已经发生了变化。&lt;/p&gt;
&lt;h2 id=&#34;扩展内核命名空间概念&#34;&gt;扩展内核命名空间概念&lt;/h2&gt;
&lt;p&gt;Linux 内核已经有一个概念，可以共享共同的功能，并使其对系统上运行的许多应用程序可用。这个概念被称为命名空间（Namespace），它构成了我们今天所知的容器技术的基础。命名空间（内核的那种，不是 Kubernetes 的命名空间）存在于各种抽象中，包括文件系统、用户管理、挂载设备、进程、网络等。这就是允许单个容器呈现不同的文件系统视图、不同的用户集，以及允许多个容器绑定到单个主机上的同一网络端口。在 cgroups 的帮助下，这个概念得到了扩展，可以对 CPU、内存和网络等资源进行管理和优先排序。从云原生应用开发者的角度来看，cgroups 和资源被紧密地整合到我们所知的 &amp;ldquo;容器&amp;rdquo; 概念中。&lt;/p&gt;
&lt;p&gt;符合逻辑的是，如果我们认为服务网格是操作系统的责任，那么它必须符合并整合命名空间和 cgroup 的概念。这看起来会是这样的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-service-mesh-namespace&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Service Mesh Namespace&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_16f30dbdeb4ebf1dd12714c687c97308.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_ca4f06178231f71ce281e8690fd8ece5.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wypvr2zj31p20q0q75_hu0135ea1d7ebbf6b8a4e6efa3962cc545_164573_16f30dbdeb4ebf1dd12714c687c97308.webp&#34;
               width=&#34;760&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Mesh Namespace
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;不出所料，这看起来非常自然，而且可能是大多数用户从简单的角度所期望的。应用程序保持不变，它们继续使用套接字进行通信，就像以前那样。理想的服务网格是作为 Linux 的一部分透明地提供的。它就在那里，就像今天的 TCP 一样。&lt;/p&gt;
&lt;h3 id=&#34;注入-sidecar-的成本&#34;&gt;注入 Sidecar 的成本&lt;/h3&gt;
&lt;p&gt;如果我们仔细研究一下 sidecar 模型，我们会发现它实际上是在试图模仿这种模型。应用程序继续使用套接字，一切都被塞进 Linux 内核的网络命名空间。然而，这比它看起来要复杂得多，需要许多额外的步骤来透明地注入 sidecar 代理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-注入-sidecar-的成本&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;注入 Sidecar 的成本&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_73d4c803cb891797200a45777fbad536.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_230fa8022744b20b7f78ac0299625e07.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8nu479j31h30u041s_hu6485f23e60e2e8e9568294bae27898e8_129365_73d4c803cb891797200a45777fbad536.webp&#34;
               width=&#34;760&#34;
               height=&#34;429&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      注入 Sidecar 的成本
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种额外的复杂性在延迟和额外资源消耗方面付出了巨大的代价。早期的基准测试表明，这对延迟的影响高达 3-4 倍，而且所有代理都需要大量的额外内存。在这篇文章的后面，我们将研究这两点，因为我们将其与基于 eBPF 的模型进行比较。&lt;/p&gt;
&lt;h2 id=&#34;用-ebpf-解锁内核服务网格&#34;&gt;用 eBPF 解锁内核服务网格&lt;/h2&gt;
&lt;p&gt;为什么我们以前没有在内核中创建一个服务网格？有些人半开玩笑地说，kube-proxy 是最初的服务网格（见&lt;a href=&#34;https://www.youtube.com/watch?v=lUF88T16YqY&amp;amp;ab_channel=CloudNativeRejekts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;我们已经构建了相当多的服务网格 - Tim Hockin, Google&lt;/a&gt;）。这句话是有一定道理的。Kube-proxy 是一个很好的例子，说明了 Linux 内核在依靠传统的基于网络的 iptables 功能实现服务网格时，可以达到多么接近。然而，这还不够，L7 上下文是缺失的。Kube-proxy 完全在网络数据包层面运作。现代应用需要 L7 流量管理、跟踪、认证和额外的可靠性保证。Kube-proxy 不能在网络层面上提供这些。&lt;/p&gt;
&lt;p&gt;eBPF 改变了这个模式。它允许动态地扩展 Linux 内核的功能。我们一直在使用 eBPF 为 Cilium 建立一个高效的网络、安全和可观测性数据通路，并将其直接嵌入到 Linux 内核。应用这个相同的概念，我们也可以在内核层面上解决服务网格的要求。事实上，Cilium 已经实现了各种所需的概念，如基于身份的安全、L3-L7 可观测性和授权、加密和负载均衡。缺少的部分现在正在向 Cilium 涌来。在本博客的末尾，你会发现如何加入由 Cilium 社区推动的 Cilium 服务网格测试项目的细节。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-服务网格架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF 服务网格架构&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_ec64207fe64f13ddab54f26766098829.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_0b120b1c08842e3408423ebcee010fc8.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyrufdyj31w90u0q6o_hu445db7688add13f894a9eb7f25ded5d7_145770_ec64207fe64f13ddab54f26766098829.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 服务网格架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有人可能想知道为什么 Linux 内核社区不直接解决这些需求&lt;/strong&gt;。eBPF 有一个巨大的优势，eBPF 代码可以在运行时插入到现有的 Linux 内核中，类似于 Linux 内核模块，但与内核模块不同，它可以以安全和可移植的方式进行。这使得 eBPF 的实现能够随着服务网格社区的发展而继续发展。&lt;strong&gt;新的内核版本需要几年时间才能进入用户手中&lt;/strong&gt;。eBPF 是一项关键技术，它使 Linux 内核能够跟上快速发展的云原生技术栈。&lt;/p&gt;
&lt;h2 id=&#34;无-sidecar-的基于-ebpf-的-l7-追踪和度量&#34;&gt;无 Sidecar 的基于 eBPF 的 L7 追踪和度量&lt;/h2&gt;
&lt;p&gt;让我们看看 L7 追踪和指标可观测性，作为一个具体的例子，说明基于 eBPF 的服务网格对保持低延迟和提高观察性有巨大的影响。应用程序团队依靠应用程序的可视性和监控作为基本要求这些，这包括请求跟踪、HTTP 响应率和服务延迟信息等能力。然而，这种可观测性应该没有明显的成本（延迟、复杂性、资源…）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的可视性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的可视性&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_3c5ffec4c37ab13904b7ad3f8850c40b.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_9df96ff7ec97749415a91faf059c43e6.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wysxpr4j31ne0iugq1_hufd2b0ecfb4e71144719ce40203bf6eba_169325_3c5ffec4c37ab13904b7ad3f8850c40b.webp&#34;
               width=&#34;760&#34;
               height=&#34;241&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的可视性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在下面的基准测试中，我们可以看到早期的测量结果，即通过 eBPF 或 sidecar 方法实现 HTTP 可视性对延迟的影响。该设置是在两个不同节点上运行的两个 pod 之间通过固定数量的连接每秒稳定运行 10K 个 HTTP 请求，并测量请求的平均延时。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的延迟基准测试-vs-基于-sidecar-的-l7-可视性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_7cf7567252f38f870003e2bdc6cfef48.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_9a381eb32592d94bdcc1720e2bf4a21c.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyt6izdj31ns0rawfw_hu7a5bfe8bc9fa18fe7dc7457a21c91d33_61285_7cf7567252f38f870003e2bdc6cfef48.webp&#34;
               width=&#34;760&#34;
               height=&#34;347&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的延迟基准测试 vs 基于 Sidecar 的 L7 可视性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们故意不提这些测量中使用的具体代理，因为它并不重要。对于我们测试过的所有代理，结果几乎都是一样的。要明确的是，这不是关于 Envoy、Linkerd、Nginx 或其他代理是否更快。所提到的代理有差异，但与首先注入代理的成本相比，它们是微不足道的。&lt;strong&gt;几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这些早期的测量结果表明，基于 eBPF 的内核方法是非常有前途的，可以实现完全透明的服务网格的愿望，而且没有明显的开销。&lt;/p&gt;
&lt;h2 id=&#34;使用-ebpf-加速的-per-node-代理&#34;&gt;使用 eBPF 加速的 per-node 代理&lt;/h2&gt;
&lt;p&gt;越来越多的用例可以用这种仅有 eBPF 的方法来覆盖，从而完全取消 L4 代理。有些用例，仍然需要代理。例如，当连接需要拼接时，当 TLS 终止被执行时，或对于某些形式的 HTTP 授权。&lt;/p&gt;
&lt;p&gt;我们的 eBPF 服务网格工作将继续关注那些从性能角度可以获得最大收益的领域。如果你必须执行 TLS 终止，你可能不介意在流量流入集群时用代理终止一次连接。然而，你会更关心在每个连接的路径中注入两个代理的影响，以提取 HTTP 指标和跟踪数据。&lt;/p&gt;
&lt;p&gt;当一个用例不能用纯 eBPF 的方法来实现时，网格可以回退到每个节点的代理模型，直接将代理与内核的套接字层结合起来。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-per-node-proxy&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF per-node Proxy&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_cae09a072642115218e86546c57c2871.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_bd76ad40fcfd5a162be8d7e6e709f964.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyvrfmfj31vq0u0q87_hu7eadff7af9f47974f13c9174791de55f_203134_cae09a072642115218e86546c57c2871.webp&#34;
               width=&#34;760&#34;
               height=&#34;337&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF per-node Proxy
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;eBPF 不依赖网络级的重定向，而是直接在套接字级别注入代理，保持路径短。在 Cilium 的案例中，正在使用 Envoy 代理，尽管从架构的角度来看，任何代理都可以被整合到这个模型。从概念上讲，这允许将 Linux 内核网络命名空间的概念直接扩展到 Envoy 监听器配置的概念，并将 Envoy 变成一个多用户代理。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-与-per-node-代理&#34;&gt;Sidecar 与 per-Node 代理&lt;/h2&gt;
&lt;p&gt;即使需要代理，代理的成本也会根据部署的架构而有所不同。让我们来看看每个节点的代理模式与 sidecar 模式的比较。&lt;/p&gt;
&lt;h3 id=&#34;每个连接的代理&#34;&gt;每个连接的代理&lt;/h3&gt;
&lt;p&gt;所需的网络连接数将因是否有代理而不同。最简单的情况是无 sidecar 模式，这意味着网络连接的数量没有变化。一个单一的连接将为请求提供服务，eBPF 将提供服务网格功能，如跟踪或现有连接上的负载均衡。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-ebpf-的模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 eBPF 的模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_b1bb728478bd4a1d987e48d14e04251b.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_a955581f54b7ac14d5395e3d87b55296.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyy16o4j32960kcwg9_hua57ac0fec04afe9a17972f7f65b18710_75274_b1bb728478bd4a1d987e48d14e04251b.webp&#34;
               width=&#34;760&#34;
               height=&#34;191&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 eBPF 的模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;用 sidecar 模型提供同样的功能需要在连接中注入两次代理，这导致需要维护三个连接。这导致了开销的增加和所有额外的套接字缓冲区所需内存的倍增，表现为更高的服务间延迟。这就是我们之前在无 sidecar L7 可视性部分看到的 sidecar 开销。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-基于-sidecar-代理的模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;基于 Sidecar 代理的模型&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_47704abc0bc4ccd15f3e324e29995d3e.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_186ea6bca077e39bf5fb3791fc9b7d14.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz3o1f6j32860lego3_hu773322c04982bb804c1017287914b0af_101275_47704abc0bc4ccd15f3e324e29995d3e.webp&#34;
               width=&#34;760&#34;
               height=&#34;203&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      基于 Sidecar 代理的模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;切换到 per-node 的代理模式使我们能够摆脱其中一个代理，因为我们不再依赖在每个工作负载中运行一个 sidecar。比起不需要额外的连接，这还是不够理想，但比起总是需要两个额外的连接要好。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-per-node-代理模式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Per-node 代理模式&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7bde5738f26376430d21264bb186b5f0.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7ce78a2664dc15bb076096454262f429.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wyx2lulj32980o4dhz_hu15d35ae3518e01d6235ec2f122222c42_89210_7bde5738f26376430d21264bb186b5f0.webp&#34;
               width=&#34;760&#34;
               height=&#34;225&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Per-node 代理模式
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;所需的代理总数&#34;&gt;所需的代理总数&lt;/h3&gt;
&lt;p&gt;在每个工作负载中运行一个 sidecar 会导致大量的代理。即使每个单独的代理实例在其内存占用方面是相当优化的，但实例的数量之多将导致总的影响很大。此外，每个代理维护的数据结构，如路由和端点表，随着集群的增长而增长，所以集群越大，每个代理的内存消耗就越高。今天，一些服务网格试图通过将部分路由表推送给单个代理来解决这个问题，限制它们可以路由到哪里。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-代理数量&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;代理数量&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_e5e6f2c7d1de4f5108e2f0c65c63633b.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_2648ed10ae21eaef48205e7b5665caec.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7y8synvej31z40oiq6n_hu6485f23e60e2e8e9568294bae27898e8_147190_e5e6f2c7d1de4f5108e2f0c65c63633b.webp&#34;
               width=&#34;760&#34;
               height=&#34;262&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      代理数量
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;让我们假设在一个 500 个节点的集群中，每一个节点有 30 个 pod，一个基于 sidecar 的架构将需要运行 15K 个代理。在每个代理消耗 70MB 内存的情况下（假设已经经过极致优化过的路由表），这仍然导致集群中所有 sidecar 消耗 1.5TB 的内存。在 per-node 模型中，假设每个代理的内存足迹相同，500 个代理将消耗不超过 34GB 的内存。&lt;/p&gt;
&lt;h3 id=&#34;多租户&#34;&gt;多租户&lt;/h3&gt;
&lt;p&gt;当我们从 sidecar 模型转向 per-node 模型时，代理将为多个应用程序提供连接。代理必须具有多租户感知。这与我们从使用单个虚拟机转向使用容器时发生的过渡完全相同。由于我们不再使用在每个虚拟机中运行的完全独立的操作系统副本，而开始与多个应用程序共享操作系统，Linux 必须具有多租户感知。这就是命名空间和 cgroup 存在的原因。如果没有它们，一个容器可能会消耗一个系统的所有资源，容器可能会以不受控制的方式访问对方的文件系统。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-namespace&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Envoy Namespace&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_4c59051f9b916a64e84a2f5ffc02b30e.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_ea1a9152506ca77c4c47844ffafb9563.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7z3klyfhj31hx0u0djs_hu343c7ddad575180196b4717ceccff05e_154426_4c59051f9b916a64e84a2f5ffc02b30e.webp&#34;
               width=&#34;760&#34;
               height=&#34;423&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Envoy Namespace
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果这在服务网格级别的网络资源上表现得完全一样，那不是很好吗？Envoy 已经有了命名空间的初步概念，它们被称为监听器。监听器可以携带单独的配置并独立运行。这将开启全新的可能性：突然间，我们可以很容易地控制资源消耗，建立公平的排队规则，并将可用的资源平等地分配给所有的应用程序，或者按照指定的规则分配。这可以而且应该与我们今天在 Kubernetes 中定义应用程序的 CPU 和内存约束的方式完全一样。如果你想了解这个话题，我曾在 EnvoyCon 上讲过这个问题（&lt;a href=&#34;https://www.youtube.com/watch?v=08opgZkdYIw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy Namespace - 以更小的代价运维基于 Envoy 的服务网格，Thomas Graf，EnvoyCon 2019&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&#34;想参与其中吗--加入-cilium-服务网格测试版&#34;&gt;想参与其中吗？- 加入 Cilium 服务网格测试版&lt;/h2&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-测试版&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;测试版&#34; srcset=&#34;
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_e129888b36894c5dfc6f5bdbaa5f88c3.webp 400w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_5fa12c343403dc5a4a5172ebff80348b.webp 760w,
               /blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/ebpf-solve-service-mesh-sidecar/008i3skNly1gx7wz1obexj327t0u0dkm_huba226543b9600e73651fc49ff93da841_178422_e129888b36894c5dfc6f5bdbaa5f88c3.webp&#34;
               width=&#34;760&#34;
               height=&#34;286&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      测试版
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;伴随着即将发布的 Cilium 1.11 版本，Cilium 社区正在举办一个新的 Cilium Service Mesh 测试计划。它的特点是一个新的构建，将使以下功能可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L7 流量管理和负载均衡（HTTP，gRPC，…）&lt;/li&gt;
&lt;li&gt;跨集群、云和集群的拓扑感知路由&lt;/li&gt;
&lt;li&gt;TLS 终止&lt;/li&gt;
&lt;li&gt;通过 Envoy 配置的金丝雀发布、重试、速率限制、断路等&lt;/li&gt;
&lt;li&gt;用 OpenTelemetry 和 Jaeger 集成进行追踪&lt;/li&gt;
&lt;li&gt;内置 Kubernetes Ingress 支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述所有功能都可以在 &lt;a href=&#34;https://github.com/cilium/cilium&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github.com/cilium/cilium&lt;/a&gt; 功能分支中找到。测试计划允许 Cilium 维护者直接与用户接触，了解他们的需求。要注册，你可以直接填写 &lt;a href=&#34;https://forms.gle/j9fwhAC6HnHRJQKeA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个表格&lt;/a&gt;，或者你可以在 Cilium 社区的&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公告&lt;/a&gt;中阅读更多关于该计划的信息。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;eBPF 是提供本地和高效的服务网格实现的答案。它将把我们从 sidecar 模型中解放出来，并允许将现有的代理技术整合到现有的内核命名概念中，使它们成为我们每天都在使用的容器抽象的一部分。除此之外，eBPF 将能够卸载越来越多的目前由代理执行的功能，以进一步减少开销和复杂性。通过整合几乎任何现有的代理，该架构也允许与大多数现有的服务网格控制平面（Istio、SMI、Linkerd…）整合。这可以将 eBPF 的好处提供给广大的终端用户，同时将数据通路的效率和开销的讨论与控制平面方面相分离。&lt;/p&gt;
&lt;p&gt;如果你有兴趣探索这个话题，我们很想听到你的意见。请随时通过 &lt;a href=&#34;https://twitter.com/tgraf__&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt; 或 &lt;a href=&#34;http://ebpf.io/slack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF &amp;amp; Cilium Slack 联系我们&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;进一步阅读&#34;&gt;进一步阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://lib.jimmysong.io/blog/how-ebpf-streamlines-the-service-mesh/&#34;&gt;eBPF 如何简化服务网格&lt;/a&gt;，Liz Rice，The New Stack&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/blog/2021/12/01/cilium-service-mesh-beta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium 服务网格测试计划&lt;/a&gt;，Cilium 社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.io/learn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;了解更多关于 Cilium 的信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>eBPF 如何简化服务网格</title>
      <link>https://lib.jimmysong.io/blog/how-ebpf-streamlines-the-service-mesh/</link>
      <pubDate>Wed, 27 Oct 2021 13:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/how-ebpf-streamlines-the-service-mesh/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天有几个服务网格的产品和项目，承诺简化应用微服务之间的连接，同时提供额外的功能，如安全连接、可观测性和流量管理。但正如我们在过去几年中反复看到的那样，对服务网格的兴奋已经被对&lt;a href=&#34;https://nowei.github.io/projects/svc_mesh_measurement_final_report.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;额外的&lt;/a&gt;&lt;a href=&#34;https://engineering.hellofresh.com/everything-we-learned-running-istio-in-production-part-2-ff4c26844bfb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;复杂性&lt;/a&gt;和&lt;a href=&#34;https://pklinker.medium.com/performance-impacts-of-an-istio-service-mesh-63957a0000b&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;开销的&lt;/a&gt;实际&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;担忧所抑制&lt;/a&gt;。让我们来探讨一下 &lt;a href=&#34;https://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是如何让我们精简&lt;a href=&#34;https://thenewstack.io/category/service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格&lt;/a&gt;，使服务网格的数据平面更有效率，更容易部署。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-问题&#34;&gt;Sidecar 问题&lt;/h2&gt;
&lt;p&gt;今天的 Kubernetes 服务网格解决方案要求你在每一个应用 pod 上添加一个代理 sidecar 容器，如 &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;/a&gt; 或 &lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd-proxy&lt;/a&gt;。这是正确的：即使在一个非常小的环境中，比如说有 20 个服务，每个服务运行五个 pod，分布在三个节点上，你也有 100 个代理容器。无论代理的实现多么小和有效，这种纯粹的重复都会耗费资源。&lt;/p&gt;
&lt;p&gt;每个代理使用的内存与它需要能够通信的服务数量有关。Pranay Singhal 写了他配置 Istio 的&lt;a href=&#34;https://medium.com/geekculture/watch-out-for-this-istio-proxy-sidecar-memory-pitfall-8dbd99ea7e9d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;经验&lt;/a&gt;，将每个代理的消耗从 1GB 左右减少到更合理的 60-70MB。但是，即使在我们的小环境中，在三个节点上有 100 个代理，这种优化配置仍然需要每个节点 2GB 左右。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-来自-redhatcomarchitectwhy-when-service-mesh每个微服务都有自己的代理-sidecar&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;来自 &amp;lt;a href=&amp;#34;https://redhat.com/architect/why-when-service-mesh&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;redhat.com/architect/why-when-service-mesh&amp;lt;/a&amp;gt;——每个微服务都有自己的代理 sidecar&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_e82772dc16b0798bb43fb88f2ac134cc.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_fb23a1ea63de7ecc49e5bdb7fd35317a.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp69o74jj31w50u0jy8_hu75cdf8ad6ac0b3f98f9051bf67fd2e5c_260906_e82772dc16b0798bb43fb88f2ac134cc.webp&#34;
               width=&#34;760&#34;
               height=&#34;334&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      来自 &amp;lt;a href=&amp;#34;https://redhat.com/architect/why-when-service-mesh&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;redhat.com/architect/why-when-service-mesh&amp;lt;/a&amp;gt;——每个微服务都有自己的代理 sidecar
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为什么我们需要所有这些 sidecar？这种模式允许代理容器与 pod 中的应用容器共享一个网络命名空间。网络命名空间是 Linux 内核的结构，它允许容器和 pod 拥有自己独立的网络堆栈，将容器化的应用程序相互隔离。这使得应用之间互不相干，这就是为什么你可以让尽可能多的 pod 在 80 端口上运行一个 web 应用 —— 网络命名空间意味着它们各自拥有自己的 80 端口。代理必须共享相同的网络命名空间，这样它就可以拦截和处理进出应用容器的流量。&lt;/p&gt;
&lt;h2 id=&#34;引入-ebpf&#34;&gt;引入 eBPF&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://ebpf.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eBPF&lt;/a&gt; 是一种内核技术，允许自定义程序在内核中运行。这些程序在响应事件时运行，有成千上万个可能的事件，eBPF 程序可以被附加到这些事件上。这些事件包括轨迹点、进入或退出任何功能（在内核或用户空间）或对服务网格来说很重要的 —— 抵达的网络数据包。&lt;/p&gt;
&lt;p&gt;重要的是，&lt;strong&gt;每个节点只有一个内核&lt;/strong&gt;；在一个节点上运行的所有容器（也就是所有的 pod）共享同一个内核。如果你在内核中添加一个 eBPF 程序到一个事件中，它将被触发，无论哪个进程引起该事件，无论它是在应用容器中运行还是直接运行在主机上。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-每台主机一个内核&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;每台主机一个内核&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_847d0bf365ee18cfcdd849278134a758.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_db8f980112e5dfb449eac44c9bb97115.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6c8mn9j31ea0u0n0t_huccdd52df4dca33c37eced58c2e8ea8ae_143240_847d0bf365ee18cfcdd849278134a758.webp&#34;
               width=&#34;760&#34;
               height=&#34;453&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      每台主机一个内核
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这就是为什么 eBPF 对于 Kubernetes 中的任何一种 instrumentation 来说都是如此令人兴奋的技术 —— 你只需要在每个节点上添加一次 instrumentation，所有的应用程序 pod 都会被覆盖。无论你是在寻求可观测性、安全性还是网络，由 eBPF 驱动的解决方案都可以在不需要 sidecar 的情况下对应用进行检测。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 &lt;a href=&#34;http://cilium.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cilium&lt;/a&gt; 项目（最近 &lt;a href=&#34;https://www.cncf.io/blog/2021/10/13/cilium-joins-cncf-as-an-incubating-project/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;以孵化级别加入云计算基金会&lt;/a&gt;）将这种“无 sidecar&amp;quot; 模式带到了服务网格的世界。除了传统的 sidecar 模型，Cilium 还支持每个节点使用一个 Envoy 代理实例运行服务网格的数据平面。使用我们前面的例子，这就把代理实例的数量从 100 个减少到只有 3 个。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-用无-sidecar-代理模式减少代理实例&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;用无 sidecar 代理模式减少代理实例&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_b7de8ef9d83f49c194072ed86daeb771.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_df1496e3029f185d02ebf3eb8de2416b.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp67ocjkj31xt0u0jvp_hu3d32db78b48b2e257874198dc348cb5b_165479_b7de8ef9d83f49c194072ed86daeb771.webp&#34;
               width=&#34;760&#34;
               height=&#34;327&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      用无 sidecar 代理模式减少代理实例
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;减少-yaml&#34;&gt;减少 YAML&lt;/h2&gt;
&lt;p&gt;在 sidecar 模型中，指定每个应用 pod 的 YAML 需要被修改以添加 sidecar 容器。这通常是自动化的 —— 例如，使用一个 mutating webhook，在每个应用 pod 部署的时候注入 sidecar。&lt;/p&gt;
&lt;p&gt;以 Istio 为例，这需要&lt;a href=&#34;https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#controlling-the-injection-policy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标记&lt;/a&gt; Kubernetes 命名空间和 / 或 pod，以定义是否应该注入 sidecar—— 当然也需要为集群启用 mutating webhook。&lt;/p&gt;
&lt;p&gt;但如果出了问题怎么办？如果命名空间或 pod 的标签不正确，那么 sidecar 将不会被注入，pod 将不会被连接到服务网格。更糟糕的是，如果攻击者破坏了集群，并能够运行一个恶意的工作负载 —— 例如，一个加密货币矿工，他们将不太可能标记它，以便它加入服务网格。它不会通过服务网格提供的流量观察能力而被发现。&lt;/p&gt;
&lt;p&gt;相比之下，在支持 eBPF 的无 sidecar 代理模型中，pod 不需要任何额外的 YAML 就可以被检测。相反，一个 CRD 被用来在集群范围内配置服务网格。即使是已经存在的 pod 也可以成为服务网格的一部分，而不需要重新启动。&lt;/p&gt;
&lt;p&gt;如果攻击者试图通过直接在主机上运行工作负载来绕过 Kubernetes 编排，eBPF 程序可以检测并控制这一活动，因为这一切都可以从内核看到。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-支持的网络效率&#34;&gt;eBPF 支持的网络效率&lt;/h2&gt;
&lt;p&gt;支持 eBPF 的网络允许数据包走捷径，绕过内核的部分网络堆栈，这可以使 Kubernetes 网络的&lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能得到显著改善&lt;/a&gt;。让我们看看这在服务网格数据平面中是如何应用的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-在-ebpf-加速无-sidecar-的服务网格模型中网络数据包通过的路径要短得多&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多&#34; srcset=&#34;
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_7a9a484930ac06c27ab63979ee78513d.webp 400w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_f6be66e36d0a6d7b08ee504b51dfc6b7.webp 760w,
               /blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/how-ebpf-streamlines-the-service-mesh/008i3skNly1gvtp6ao3lqj31q90u0gqw_hu2dc6a1f8e53eb927656788db4b31bc51_202323_7a9a484930ac06c27ab63979ee78513d.webp&#34;
               width=&#34;760&#34;
               height=&#34;366&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      在 eBPF 加速、无 sidecar 的服务网格模型中，网络数据包通过的路径要短得多
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在服务网格的情况下，代理在传统网络中作为 sidecar 运行，数据包到达应用程序的路径相当曲折：入站数据包必须穿越主机 TCP/IP 栈，通过虚拟以太网连接到达 pod 的网络命名空间。从那里，数据包必须穿过 pod 的网络堆栈到达代理，代理将数据包通过回环接口转发到应用程序。考虑到流量必须在连接的两端流经代理，与非服务网格流量相比，这将导致延迟的&lt;a href=&#34;https://linkerd.io/2021/05/27/linkerd-vs-istio-benchmarks/#latency-at-20-rps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;显著增加&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;基于 eBPF 的 Kubernetes CNI 实现，如 Cilium，可以使用 eBPF 程序，明智地钩住内核中的特定点，沿着更直接的路线重定向数据包。这是可能的，因为 Cilium 知道所有的 Kubernetes 端点和服务的身份。当数据包到达主机时，Cilium 可以将其直接分配到它所要去的代理或 Pod 端点。&lt;/p&gt;
&lt;h2 id=&#34;网络中的加密&#34;&gt;网络中的加密&lt;/h2&gt;
&lt;p&gt;如果一个网络解决方案能够意识到 Kubernetes 服务，并在这些服务的端点之间提供网络连接，那么它能够提供服务网格数据平面的能力就不足为奇。但这些能力可以超越基本的连接。一个例子是透明加密。&lt;/p&gt;
&lt;p&gt;通常使用服务网格来确保所有的应用流量都是经过认证和加密的。这是通过双向 TLS（mTLS）实现的；服务网格代理组件作为网络连接的端点，并与其远程对等物协商一个安全的 TLS 连接。这种连接对代理之间的通信进行加密，而不需要对应用程序做任何改变。&lt;/p&gt;
&lt;p&gt;但在应用层管理的 TLS 并不是实现组件间认证和加密流量的唯一方法。另一个选择是在网络层加密流量，使用 &lt;a href=&#34;https://cilium.io/blog/2021/05/11/cni-benchmark#the-cost-of-encryption---wireguard-vs-ipsec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPSec 或 WireGuard&lt;/a&gt;。因为它在网络层操作，这种加密不仅对应用程序完全透明，而且对代理也是透明的 —— 它可以在有或没有服务网格时启用。如果你使用服务网格的唯一原因是提供加密，你可能想考虑网络级加密。它不仅更简单，而且还可以用来验证和加密节点上的任何流量 —— 它不只限于那些启用了 sidecar 的工作负载。&lt;/p&gt;
&lt;h2 id=&#34;ebpf-是服务网格的数据平面&#34;&gt;eBPF 是服务网格的数据平面&lt;/h2&gt;
&lt;p&gt;现在，eBPF 在 Linux 生产发行版使用的内核版本中得到广泛支持，企业可以利用它来获得更有效的网络解决方案，并作为服务网格的更有效的数据平面。&lt;/p&gt;
&lt;p&gt;去年，我代表 &lt;a href=&#34;https://cncf.io/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF&lt;/a&gt; 的技术监督委员会，对服务网格领域的整合和清晰化做了一些 &lt;a href=&#34;https://youtu.be/bESogtuHwX0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;预测&lt;/a&gt;。在同一主题演讲中，我谈到 eBPF 有可能成为更多项目和更广泛部署能力的基础。这两个想法现在正结合在一起，因为 eBPF 似乎是服务网格数据平面的自然路径。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
