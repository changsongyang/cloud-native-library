<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>可观测性 | 云原生资料库</title>
    <link>https://lib.jimmysong.io/tag/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
      <atom:link href="https://lib.jimmysong.io/tag/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <description>可观测性</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 05 Jul 2022 17:00:00 +0800</lastBuildDate>
    <image>
      <url>https://lib.jimmysong.io/media/sharing.png</url>
      <title>可观测性</title>
      <link>https://lib.jimmysong.io/tag/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
    </image>
    
    <item>
      <title>使用 eBPF 准确定位服务网格的关键性能问题</title>
      <link>https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</link>
      <pubDate>Tue, 05 Jul 2022 17:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</guid>
      <description>&lt;h2 id=&#34;background&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;Apache SkyWalking 观察部署在服务网格中的服务的度量、日志、跟踪和事件。在进行故障排除时，SkyWalking 错误分析是一个宝贵的工具，可以帮助确定错误发生的位置。然而，确定性能问题更加困难：利用预先存在的观察数据往往不可能找到性能问题的根本原因。为此，动态调试和故障排除在进行服务性能剖析时就比不可少。在这篇文章中，我们将讨论如何使用 eBPF 技术来改进 SkyWalking 中的剖析功能，并分析其对服务网格性能的影响。&lt;/p&gt;
&lt;h2 id=&#34;trace-profiling-in-skywalking&#34;&gt;SkyWalking 中的跟踪剖析&lt;/h2&gt;
&lt;p&gt;自 SkyWalking 7.0.0 以来，Trace Profiling 通过定期对线程堆栈进行采样，让开发者知道运行哪行代码花费更多时间，从而帮助开发者发现性能问题。然而，Trace Profiling 不适合以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程模型&lt;/strong&gt;：Trace Profiling 对于剖析在单线程中执行的代码最有用。它对严重依赖异步执行模式的中间件不太有用。例如，Go 中的 Goroutines 或 Kotlin Coroutines。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语言&lt;/strong&gt;：目前，Trace Profiling 只支持 Java 和 Python，因为在 Go 和 Node.js 等一些语言的运行时中不容易获得线程栈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent 绑定&lt;/strong&gt;：Trace Profiling 需要安装 Agent，根据语言的不同，这可能很麻烦（例如，PHP 必须依赖其 C 内核；Rust 和 C/C++ 需要的仪器需要手动安装）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;追踪关联性&lt;/strong&gt;：由于追踪剖析只与单个请求相关，所以很难确定哪个请求导致了问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期短的服务&lt;/strong&gt;：由于（至少）两个原因，Trace Profiling 不支持短声明周期的服务：
&lt;ul&gt;
&lt;li&gt;在启动阶段，很难区分系统性能和类代码操作。&lt;/li&gt;
&lt;li&gt;Trace Profiling 与一个端点相连，以识别性能影响，但没有端点来匹配这些短生命周期的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，有一些技术比 Trace Profiling 更实用。&lt;/p&gt;
&lt;h2 id=&#34;introduce-ebpf&#34;&gt;eBPF 简介&lt;/h2&gt;
&lt;p&gt;我们发现，eBPF —— 一种可以在操作系统内核中运行沙盒程序的技术，从而安全有效地扩展内核的功能，而不需要修改内核或加载内核模块，可以帮助我们填补 Trace Profiling 留下的空白。eBPF 技术正在流行，因为它打破了传统上的用户和内核空间之间的障碍。现在我们可以将程序作为字节码注入到内核中运行，而不需要定制和重新编译内核。可观测可以很好地利用这一点。&lt;/p&gt;
&lt;p&gt;在下图中，我们可以看到，当系统执行 &lt;code&gt;execve&lt;/code&gt; 系统调用时，eBPF 程序被触发，通过使用函数调用获得当前进程的运行时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-程序调用流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片&#34; srcset=&#34;
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp 400w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_501ba58999de3fea0b73da4d1a5134c6.webp 760w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 程序调用流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 eBPF 技术，可以将 Skywalking 的剖析能力范围扩大到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局性能剖析&lt;/strong&gt;：在 eBPF 之前，数据收集被限制在代理可以观察的范围内。由于 eBPF 程序在内核中运行，它们可以观察到所有的线程。当你不确定某个性能问题是否是由一个特定的请求引起的，这一点特别有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据内容&lt;/strong&gt;：eBPF 可以转储用户和内核空间的线程栈，所以如果性能问题发生在内核空间就更容易被发现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理绑定&lt;/strong&gt;：所有现代 Linux 内核都支持 eBPF，所以不需要安装任何东西。这意味着它是一个免编排与代理的模型。这减少了由内置软件引起的摩擦，这些软件可能没有安装正确的代理，如服务网格中的 Envoy。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采样类型&lt;/strong&gt;：与追踪剖析不同，eBPF 是事件驱动的，因此，不受间隔轮询的限制。例如，eBPF 可以触发事件，并根据传输大小的阈值收集更多的数据。这可以让系统在极端负载下分流和优先收集数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ebpf-limitations&#34;&gt;eBPF 的局限性&lt;/h3&gt;
&lt;p&gt;虽然 eBPF 为发掘性能瓶颈提供了显著的优势，但没有任何技术是完美的。eBPF 有一些限制，如下所述（幸运的是，由于 SkyWalking 不需要 eBPF，其影响是有限的）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux 版本要求&lt;/strong&gt;：eBPF 程序需要的 Linux 内核版本要 4.4 以上，更新的内核版本可以提供更多的数据收集。BCC 记录了 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/13b5563c11f7722a61a17c6ca0a1a387d2fa7788/docs/kernel-versions.md#main-features&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同 Linux 内核版本所支持的功能&lt;/a&gt;，不同版本之间的差异在于 eBPF 收集的数据集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要特权权限&lt;/strong&gt;：所有打算将 eBPF 程序加载到 Linux 内核的进程必须在特权模式下运行。因此，代码中的错误或其他问题可能对安全有很大的影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对动态语言的支持较弱&lt;/strong&gt;：eBPF 对基于 JIT 的动态语言，如 Java，支持较弱。这也取决于你想收集什么数据。对于 Profiling，eBPF 不支持解析程序的字符表（symbol），这就是为什么大多数基于 eBPF 的剖析技术只支持静态语言如 C、C++、Go 和 Rust。然而，字符表映射有时可以通过语言所提供的工具来解决。例如，在 Java 中，可以使用 &lt;a href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent#architecture&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf-map-agent&lt;/a&gt; 来生成字符表映射。然而，动态语言不支持附加（&lt;code&gt;uprobe&lt;/code&gt;）功能，而这种功能可以让我们通过符号追踪执行事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;introducing-skywalking-rover&#34;&gt;SkyWalking Rover 简介&lt;/h3&gt;
&lt;p&gt;SkyWalking Rover 是 SkyWalking 生态系统中引入的 eBPF 剖析功能。下图显示了 SkyWalking Rover 的整体架构。SkyWalking Rover 目前支持 Kubernetes 环境，必须部署在 Kubernetes 集群内。与 SkyWalking 后端服务器建立连接后，它将当前机器上的进程信息保存到 SkyWalking。当用户通过用户界面创建 eBPF 剖析任务时，SkyWalking Rover 会接收任务并在相关的基于 C、C++、Golang 和 Rust 语言的程序中执行。&lt;/p&gt;
&lt;p&gt;除了需要具有 eBPF 功能的内核外，部署 SkyWalking Rover 没有其他先决条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-skywalking-rover-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片&#34; srcset=&#34;
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp 400w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_77630572196fa0d44044c36d67f6e3d2.webp 760w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp&#34;
               width=&#34;760&#34;
               height=&#34;259&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SkyWalking Rover 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;cpu-profiling-with-rover&#34;&gt;使用 Rover 进行 CPU 剖析&lt;/h3&gt;
&lt;p&gt;CPU 剖析是显示服务性能的最直观方式。受 &lt;a href=&#34;https://www.brendangregg.com/offcpuanalysis.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brendan Gregg 的博客文章&lt;/a&gt; 的启发，我们将 CPU 剖析分为两种类型，并在 Rover 中加以实施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 剖析&lt;/strong&gt;：线程在 CPU 上的运行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;off-CPU 剖析&lt;/strong&gt;：线程在 I/O、锁、定时器、分页 / 交换等方面被阻塞时的等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;profiling-envoy-with-ebpf&#34;&gt;用 eBPF 对 Envoy 进行剖析&lt;/h2&gt;
&lt;p&gt;Envoy 是一个流行的代理，在 Istio 服务网格中被用作为数据平面。在 Kubernetes 集群中，Istio 将 Envoy 作为 sidecar 注入到每个服务的 pod 中，在那里透明地拦截和处理传入和传出的流量。作为数据平面，Envoy 的任何性能问题都会影响到网格中的所有服务流量。在这种情况下，使用 eBPF 剖析来分析生产中由服务网格引起的问题是比较有力的。&lt;/p&gt;
&lt;h3 id=&#34;demo-environment&#34;&gt;演示环境&lt;/h3&gt;
&lt;p&gt;如果你想看到详细过程，我们已经建立了一个演示环境，在那里我们部署了一个 Nginx 服务进行压力测试。流量被 Envoy 拦截并转发到 Nginx。安装整个环境的命令可以在 &lt;a href=&#34;https://github.com/mrproliu/skywalking-rover-profiling-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上获取。&lt;/p&gt;
&lt;h2 id=&#34;on-cpu-profiling&#34;&gt;CPU 剖析&lt;/h2&gt;
&lt;p&gt;当服务的 CPU 使用率很高时，CPU 剖析适用于分析线程堆栈。如果堆栈被转储的次数较多，意味着线程堆栈占据了更多的 CPU 资源。&lt;/p&gt;
&lt;p&gt;在使用演示配置文件安装 Istio 时，我们发现有两个地方的性能可以优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Zipkin 追踪&lt;/strong&gt;：不同的 Zipkin 采样百分比对 QPS 有直接影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问日志格式&lt;/strong&gt;：减少 Envoy 访问日志的字段可以提高 QPS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zipkin-追踪&#34;&gt;Zipkin 追踪&lt;/h3&gt;
&lt;h3 id=&#34;zipkin-100-采样&#34;&gt;Zipkin 100% 采样&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，Envoy 使用 100% 采样作为默认的追踪策略。这对性能有什么影响？&lt;/p&gt;
&lt;p&gt;如下图所示，使用 CPU 剖析，我们发现它大约需要 &lt;strong&gt;16%&lt;/strong&gt; 的 CPU 开销。在固定消耗 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 的情况下，其 QPS 可以达到 &lt;strong&gt;5.7K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-zipkin-100-采样-cpu-剖析的火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片&#34; srcset=&#34;
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp 400w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_b68a53a9b8fc1f02dbfc560074a62481.webp 760w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Zipkin 100% 采样 CPU 剖析的火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;禁用-zipkin-追踪&#34;&gt;禁用 Zipkin 追踪&lt;/h3&gt;
&lt;p&gt;此时，我们发现，如果没有必要，可以降低 Zipkin 采样比例，甚至可以禁用追踪。根据 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#Tracing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;，我们可以在安装 Istio 时使用以下命令禁用追踪。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.enableTracing=false&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.defaultConfig.tracing.sampling=0.0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用追踪后，我们再次进行 CPU 剖析。根据下图，我们发现 Zipkin 已经从火焰图中消失了。在与前面的例子相同的 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 消耗下，QPS 达到 &lt;strong&gt;9K&lt;/strong&gt;，几乎增加了 &lt;strong&gt;60%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用-zipkin-追踪的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片&#34; srcset=&#34;
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp 400w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_4120d0c8954a6454493ed53dde25e284.webp 760w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp&#34;
               width=&#34;760&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用 Zipkin 追踪的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;tracing-with-throughput&#34;&gt;追踪吞吐量&lt;/h3&gt;
&lt;p&gt;在 CPU 使用率相同的情况下，我们发现，当追踪功能被禁用时，Envoy 的性能会大大提升。当然，这需要我们在 Zipkin 收集的样本数量和 Envoy 的预期性能（QPS）之间做出权衡。&lt;/p&gt;
&lt;p&gt;下表说明了在相同的 CPU 使用率下，不同的 Zipkin 采样比例对 QPS 的影响。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Zipkin 采样比例&lt;/th&gt;
&lt;th&gt;QPS&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100% &lt;strong&gt;（默认）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5.7K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 16%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1%&lt;/td&gt;
&lt;td&gt;8.1K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;禁用&lt;/td&gt;
&lt;td&gt;9.2K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;access-log-format&#34;&gt;访问日志格式&lt;/h2&gt;
&lt;h3 id=&#34;default-log-format&#34;&gt;默认访问日志格式&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，默认的访问日志格式包含大量的数据。下面的火焰图显示了在解析数据时涉及的各种功能，如请求头、响应头和流媒体主体。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-默认访问日志格式的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片&#34; srcset=&#34;
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp 400w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_ca470e83e66ecbe17169087ebaace536.webp 760w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      默认访问日志格式的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;simplifying-access-log-format&#34;&gt;简化访问日志格式&lt;/h3&gt;
&lt;p&gt;通常情况下，我们不需要访问日志中的所有信息，所以我们通常可以简化它来获得我们需要的信息。下面的命令简化了访问日志的格式，只显示基本信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set meshConfig.accessLogFormat&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;[% START_TIME%] \&amp;#34;% REQ (:METHOD)% % REQ (X-ENVOY-ORIGINAL-PATH?:PATH)% % PROTOCOL%\&amp;#34;% RESPONSE_CODE%\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;简化访问日志格式后，我们发现 QPS 从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。当再次执行 CPU 剖析时，日志格式化的 CPU 使用率从 &lt;strong&gt;2.4%&lt;/strong&gt; 下降到 &lt;strong&gt;0.7%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简化日志格式帮助我们提高了性能。&lt;/p&gt;
&lt;h2 id=&#34;off-cpu-剖析&#34;&gt;Off-CPU 剖析&lt;/h2&gt;
&lt;p&gt;Off-CPU 剖析适用于由非高 CPU 使用率引起的性能问题。例如，当一个服务中有太多的线程时，使用 off-CPU 剖析可以揭示出哪些线程花费了更多的时间进行上下文切换。&lt;/p&gt;
&lt;p&gt;我们提供两个维度的数据汇总。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;切换次数&lt;/strong&gt;：一个线程切换上下文的次数。当线程返回到 CPU 时，它完成了一次上下文切换。开关次数较多的线程栈会花费更多时间进行上下文切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切换持续时间&lt;/strong&gt;：一个线程切换上下文所需的时间。切换持续时间较长的线程栈在 off-CPU 花费的时间较多。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;write-access-log&#34;&gt;写入访问日志&lt;/h3&gt;
&lt;h4 id=&#34;enable-write&#34;&gt;启用写入&lt;/h4&gt;
&lt;p&gt;使用与之前 CPU 测试相同的环境和设置，我们进行了 off-CPU 剖析。如下图所示，我们发现访问日志的写入占总上下文切换的 &lt;strong&gt;28%&lt;/strong&gt; 左右。下图中的 &lt;code&gt;__write&lt;/code&gt; 也表明这是 Linux 内核中的方法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-启用写入的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片&#34; srcset=&#34;
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp 400w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_fea2e2c0d03b286f15392cc50602ab21.webp 760w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      启用写入的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;禁用写入&#34;&gt;禁用写入&lt;/h4&gt;
&lt;p&gt;SkyWalking 实现了 Envoy 的访问日志服务（ALS）功能，允许我们使用 gRPC 协议将访问日志发送到 SkyWalking 可观察性分析平台（OAP）。即使禁用访问日志，我们仍然可以使用 ALS 来捕获 / 汇总日志。我们使用以下命令禁用了对访问日志的写入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo --set meshConfig.accessLogFile&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用访问日志功能后，我们进行了 off-CPU 剖析。如下图所示，文件写入条目已经消失了。Envoy 的吞吐量也从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用访问日志功能后的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图片&#34; srcset=&#34;
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp 400w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_64a520f1998a1b10dd8b102cdaefebbb.webp 760w,
               /translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用访问日志功能后的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我们研究了 Apache SkyWalking 的 Trace Profiling 可以给我们带来的启示，以及使用 eBPF 剖析可以实现的更多功能。所有这些功能都在 &lt;a href=&#34;https://github.com/apache/skywalking-rover&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-rover&lt;/a&gt; 中实现。除了 CPU 和 off-CPU 剖析之外，你还会发现以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连续剖析&lt;/strong&gt;，帮助你自动剖析，无需人工干预。例如，当 Rover 检测到 CPU 超过一个可配置的阈值时，它会自动执行 CPU 剖析任务。&lt;/li&gt;
&lt;li&gt;更多的剖析类型，以丰富使用场景，如网络和内存剖析。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一键开启 Kubernetes 可观测性——如何自动生成和存储 OpenTelemetry 追踪</title>
      <link>https://lib.jimmysong.io/translation/generate-and-store-opentelemetry-traces-automatically/</link>
      <pubDate>Mon, 30 May 2022 11:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/translation/generate-and-store-opentelemetry-traces-automatically/</guid>
      <description>&lt;p&gt;OpenTelemetry 追踪包含了理解分布式系统和排除故障的信息宝库 —— 但你的服务必须首先被指标化，以发射 OpenTelemetry 追踪来实现这一价值。然后，这些追踪信息需要被发送到一个可观察的后端，使你能够获得关于这些数据的任意问题的答案。可观测性是一个分析问题。&lt;/p&gt;
&lt;p&gt;本周早些时候，我们部分解决了这个问题，宣布&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Promscale 中普遍提供 OpenTelemetry 追踪支持&lt;/a&gt;，将由 SQL 驱动的可观测性带给所有开发者。随着对分析语言 ——SQL 的全面支持，我们解决了分析的问题。但我们仍然需要解决第一部分的问题：测量。&lt;/p&gt;
&lt;p&gt;为了让你的服务发出追踪数据，你必须手动添加 OpenTelemetry 测量工具到代码中。而且你必须针对所有服务和你使用的所有框架来做，否则你将无法看到每个请求的执行情况。你还需要部署 OpenTelemetry 收集器来接收所有新的追踪，处理它们，批处理它们，并最终将它们发送到你的可观测性后端。这需要花费大量的时间和精力。&lt;/p&gt;
&lt;p&gt;如果你不需要做所有这些手工工作，并且可以在几分钟内而不是几小时甚至几天内启动和运行呢？如果你还能建立一个完整的可观测性技术栈并自动连接所有的组件呢？如果我告诉你，你可以用一个命令完成所有这些工作呢？&lt;/p&gt;
&lt;p&gt;我不是疯子。我只是一个 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tobs&lt;/a&gt; 用户😎。&lt;/p&gt;
&lt;p&gt;Tobs 是 Kubernetes 的可观测性技术栈，是一个可以用来&lt;a href=&#34;https://www.timescale.com/blog/introducing-tobs-deploy-a-full-observability-suite-for-kubernetes-in-two-minutes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在几分钟内在 Kubernetes 集群中部署一个完整的可观测性技术栈&lt;/a&gt;的工具。该栈包括 OpenTelemetry Operator、OpenTelemetry Collector、Promscale 和 Grafana。它还部署了其他几个工具，如 Prometheus，以收集 Kubernetes 集群的指标，并将其发送到 Promscale。&lt;a href=&#34;https://github.com/timescale/tobs/releases/tag/0.10.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在我们的最新版本中&lt;/a&gt;，tobs 包括支持通过 OpenTelemetry Operator 用 OpenTelemetry 追踪自动检测你的 Python、Java 和 Node.js 服务。&lt;/p&gt;
&lt;p&gt;是的，你没看错：自动！你不需要改变服务中的任何一行代码，就可以让它们被检测出来。锦上添花的是什么？你可以通过执行 helm 命令来部署一切。&lt;/p&gt;
&lt;p&gt;有了 tobs，你可以安装你的可观测性技术栈，只需几步就能搞定你的 OpenTelemetry 指标化的第一层。告别繁琐的配置工作，因为你的框架会自己检测。&lt;/p&gt;
&lt;p&gt;如果你想了解如何做到这一点，请继续阅读本博文。首先，我们将解释一切是如何运作的，剖析 OpenTelemetry Operator 在内部的真正作用。接下来，我们将通过一个例子演示如何将其直接付诸实践。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将通过 tobs 在我们的 Kubernetes 集群中安装一个完整的可观测性技术栈。&lt;/li&gt;
&lt;li&gt;我们将部署一个云原生 Python 应用程序。&lt;/li&gt;
&lt;li&gt;我们将检查我们的应用程序是如何被 OpenTelemetry 追踪器自动检测到的，这要归功于 tobs 和 OpenTelemetry Operator 所做的魔术🪄。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;opentelemetry-operator&#34;&gt;OpenTelemetry Operator&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; 是一个开源的框架，可以捕获、转换和路由所有类型的信号（追踪、日志和指标）。在大多数情况下，你会使用 &lt;a href=&#34;https://open-telemetry.github.io/opentelemetry-js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry SDK&lt;/a&gt; 来在你的应用程序代码中生成这些信号。但是，在某些情况下，OpenTelemetry 可以自动检测你的代码 —— 也就是说，当你的应用框架被支持，并且你使用的语言是 OpenTelemetry 可以注入代码的。在这种情况下，你的系统将开始产生遥测，而不需要手动工作。&lt;/p&gt;
&lt;p&gt;要了解 OpenTelemetry 是如何做到这一点的，我们首先需要熟悉 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Operator&lt;/a&gt;。OpenTelemetry Operator 是一个实现 &lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Operator 模式&lt;/a&gt;的应用程序，与 Kubernetes 集群中的两个 CustomResourceDefinitions（CRD）互动。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图示说明-opentelemetry-opertator-如何与-kubernetes互动&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图示说明 OpenTelemetry Operator 如何与 Kubernetes 互动&#34; srcset=&#34;
               /translation/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_89510390ea80e6b60d8a5067819ad3e1.webp 400w,
               /translation/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_67c2a525aead983718379ac249f37412.webp 760w,
               /translation/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_89510390ea80e6b60d8a5067819ad3e1.webp&#34;
               width=&#34;760&#34;
               height=&#34;481&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图示说明 OpenTelemetry Opertator 如何与 Kubernetes互动
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 CustomResourceDefinitions（CRD&lt;/a&gt;）实例的变化，Operator 为我们管理以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建和删除 OpenTelemetry Collector 实例&lt;/li&gt;
&lt;li&gt;将 OpenTelemetry 自动测量所需的库和二进制文件直接注入到你的 pod 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们更详细地解读这两项任务。&lt;/p&gt;
&lt;h2 id=&#34;管理-opentelemetry-collector&#34;&gt;管理 OpenTelemetry Collector&lt;/h2&gt;
&lt;p&gt;OpenTelemetry Operator 的首要任务是部署 &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Collector&lt;/a&gt; 实例。这些实例将被用来把信号从源头（你的工作负载和 Kubernetes 本身）路由到它们的目标（支持 OpenTelemetry 协议的存储系统或集群外的另一个采集器）。&lt;/p&gt;
&lt;p&gt;采集器可以以三种不同的方式部署：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为 Kubernetes Deployment：这是默认选项，它允许采集器根据需要在节点之间移动，支持向上和向下扩展。&lt;/li&gt;
&lt;li&gt;作为 Kubernetes Daemonset：这个选项将在每个节点上部署一个采集器，当你想确保你的信号在没有任何网络开销的情况下被处理时，它可能很有用。&lt;/li&gt;
&lt;li&gt;作为一个 Sidecar：被注入到任何新的注释的 pod 中（使用 &lt;code&gt;sidecar.opentelemetry.io/inject: true&lt;/code&gt;）。当采集器需要一个 pod 的特定配置时，这可能是很好的（例如，也许它需要一些专门的转换）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你愿意，你可以混合和匹配这些收集器模式。例如，你可以设置一个 sidecar，为部署中的 pod 做一些转换，然后将它们发送到一个全局收集器，与你的其他工作负载共享。&lt;/p&gt;
&lt;p&gt;定义这些收集器实例的配置在收集器 CRD（&lt;code&gt;opentelemetrycollectors.opentelemetry.io&lt;/code&gt;）中进行建模。允许多个实例来实现更复杂的模式。部署类型是通过 &lt;code&gt;mode&lt;/code&gt; 设置来选择的，伴随着一个原始的配置字符串，它被逐字传递给控制器，并作为配置加载。下面是使用 Deployment 模式创建 Operator 的 CRD 的例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opentelemetry.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;OpenTelemetryCollector&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tobs-tobs-opentelemetry&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    receivers:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      jaeger:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        protocols:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          grpc:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          thrift_http:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      otlp:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        protocols:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          grpc:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          http:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    exporters:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      logging:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      otlp:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        endpoint: &amp;#34;tobs-promscale-connector.default.svc:9202&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        compression: none
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        tls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          insecure: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prometheusremotewrite:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        endpoint: &amp;#34;tobs-promscale-connector.default.svc:9201/write&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        tls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          insecure: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    processors:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      batch:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    service:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      pipelines:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        traces:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          receivers: [jaeger, otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          exporters: [logging, otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          processors: [batch]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        metrics:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          receivers: [otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          processors: [batch]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          exporters: [prometheusremotewrite]    &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如我们在后面的例子中看到的，当你使用 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tobs&lt;/a&gt; 时，你不需要担心所有这些配置细节。tobs 的好处之一是它会为你安装一个采集器，它将直接把数据发送到本地的 Promscale 实例。&lt;/p&gt;
&lt;h2 id=&#34;在-kubernetes-中添加-opentelemetry-自动监测系统&#34;&gt;在 Kubernetes 中添加 OpenTelemetry 自动监测系统&lt;/h2&gt;
&lt;p&gt;Operator 的第二个关注点是将 OpenTelemetry 自动测量所需的库和二进制文件注入到 pod 中。要做到这一点，这些 pod 需要容纳 Java、Python 或 Node.js 应用程序（OpenTelemetry 将来会支持更多语言）。&lt;/p&gt;
&lt;p&gt;用于部署这些 pod 的 Kubernetes 清单文件必须包括一个注释，以指示 OpenTelemetry Operator 对其进行检测。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instrumentation.opentelemetry.io/inject-&amp;lt;language&amp;gt;: &amp;#34;true&amp;#34;   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;language&lt;/code&gt; 可以是 &lt;code&gt;python&lt;/code&gt;、&lt;code&gt;java&lt;/code&gt; 或 &lt;code&gt;nodejs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当注解的 pod 启动时，会创建一个 &lt;code&gt;init&lt;/code&gt; 容器，注入所需的代码并改变 pod 运行代码的方式，使用正确的 OpenTelemetry 自动探测方法。实际上，这意味着在使用 Kubernetes 时，不需要修改任何代码就可以获得自动监测的好处。该配置还定义了 OpenTelemetry Collector 端点，这些追踪将被发送到该端点，传播的信息类型，以及我们用来采样追踪的方法（如果有的话）(关于 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator/blob/main/docs/api.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CRD 的全部细节，请看文档&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;为 Python、Java 和 Node.js 应用程序提供自动测量的自定义资源的例子是这样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opentelemetry.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Instrumentation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tobs-auto-instrumentation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exporter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http://tobs-opentelemetry-collector.default.svc:4318 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;propagators&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;tracecontext&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;baggage&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;b3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sampler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.25&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;parentbased_traceidratio&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再一次，如果你使用 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tobs&lt;/a&gt;，你将不需要自己创建这些自定义资源。Tobs 将确保集群被自动配置成对任何有注释的 pod 进行检测，而不需要你做任何操作。你所需要做的就是在你想收集追踪的 pod 中添加以下注释之一。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instrumentation.opentelemetry.io/inject-java: &amp;#34;true&amp;#34;
instrumentation.opentelemetry.io/inject-nodejs: &amp;#34;true&amp;#34;
instrumentation.opentelemetry.io/inject-python:&amp;#34;true&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们通过一个例子看看这在实践中是如何运作的。&lt;/p&gt;
&lt;h2 id=&#34;使用-opentelemetry-operator-和-tobs&#34;&gt;使用 OpenTelemetry Operator 和 Tobs&lt;/h2&gt;
&lt;p&gt;在本节中，我们将使用我们的&lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务演示应用程序&lt;/a&gt;，它由一个过度工程化的密码生成器应用程序组成。&lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 repo 中&lt;/a&gt;，你可以找到一个已测量的版本和一个未测量的版本，这就是我们在这个例子中要使用的版本。&lt;/p&gt;
&lt;p&gt;要运行这个，你首先需要一个 Kubernetes 集群，安装了 cert-manager，配置了通过 &lt;code&gt;kubectl&lt;/code&gt;（至少需要 1.21.0 版本）的访问，并安装了 &lt;a href=&#34;https://helm.sh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm&lt;/a&gt;。为了部署和运行所有不同的组件，你将需要在你的 Kubernetes 集群中提供大约 4 核 CPU 和 8GB 的内存。&lt;/p&gt;
&lt;p&gt;如果你的集群中没有 cert-manager，你将需要使用这个命令来安装它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;准备好后，让我们使用 Timescale Helm Chart 来安装 tobs。在命令提示符下运行以下命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add timescale https://charts.timescale.com/ --force-update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install --wait --timeout 10m tobs timescale/tobs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Tobs 需要几分钟的时间来安装，但最终，你会看到类似这样的输出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#helm install --wait tobs timescale/tobs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME: tobs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LAST DEPLOYED: Thu May &lt;span class=&#34;m&#34;&gt;19&lt;/span&gt; 11:22:19 &lt;span class=&#34;m&#34;&gt;2022&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAMESPACE: default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;STATUS: deployed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;REVISION: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NOTES:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;###############################################################################&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;👋🏽 Welcome to tobs, The Observability Stack &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Kubernetes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;✨ Auto-configured and deployed:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🔥 Kube-Prometheus
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🐯 TimescaleDB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🤝 Promscale
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🧐 PromLens
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;📈 Grafana
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🚀 OpenTelemetry
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🎯 Jaeger
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;###################################&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;👉 故障排除提示：如果你得到这个错误信息 &lt;code&gt;INSTALLATION FAILED: rate:Wait(n=1) would exceed context deadline&lt;/code&gt;，这很可能表明你的集群中没有足够的可用资源。&lt;/p&gt;
&lt;p&gt;一旦 tobs 的安装完成，检查你的 Kubernetes 集群，确认所有的组件都已正确部署。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get podes --all-namespaces &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;tobs-&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;👉故障排除提示：如果某些 pod 处于待定或错误状态，你可以使用 &lt;code&gt;kubectl describe pod &amp;lt;pod-name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;kubectl logs &amp;lt;pod-name&amp;gt;&lt;/code&gt; 来了解可能存在的问题。&lt;/p&gt;
&lt;p&gt;现在，我们可以从 &lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Demo GitHub repo&lt;/a&gt; 中导入未测量的 Kubernetes 微服务。&lt;/p&gt;
&lt;p&gt;如果你回顾一下 &lt;code&gt;uninstrumented&lt;/code&gt; 文件夹中的代码，你会发现它没有提到 OpenTelemetry。例如，看一下 &lt;code&gt;load&lt;/code&gt; 微服务的 Python 文件（这个服务通过发出密码请求来驱动其他服务的流量）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过将这些微服务导入安装了 tobs 的集群中，它们将自动获得 OpenTelemetry 追踪的测量工具。&lt;/p&gt;
&lt;p&gt;要调出演示应用程序，请运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -k &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://github.com/timescale/opentelemetry-demo/yaml/app&amp;#39;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当这个过程结束，应用程序被部署时，它将已经被 OpenTelemetry 追踪器所记录。追踪现在正在生成并自动发送到 Promscale。&lt;/p&gt;
&lt;p&gt;这种魔法是如何发生的？&lt;/p&gt;
&lt;p&gt;这里有一个总结性的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 pod 都被注解为 &lt;code&gt;instrumentation.opentelemetry.io/inject-python: &amp;quot;true&amp;quot;&lt;/code&gt;，所以当它们启动时，会被 OpenTelemetry Operator 注意到。&lt;/li&gt;
&lt;li&gt;接下来，使用一个突变的 webhook 添加一个 init 容器，注入 Python 库和启用测量工具所需的代码。&lt;/li&gt;
&lt;li&gt;然后，追踪数据被发送到 Instrumentation CRD 中注明的 OpenTelemetry Collector。&lt;/li&gt;
&lt;li&gt;OpenTelemetry Collector 将数据发送到 Promscale（和 TimescaleDB），从那里可以直接用 SQL 查询或用 Grafana 等工具进行可视化访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们看看我们直接从 Grafana（tobs 也自动安装在我们的集群中）自动生成的追踪。&lt;/p&gt;
&lt;p&gt;要获得 Grafana 实例的管理用户的密码，请运行以下命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get secret tobs-grafana -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.data.admin-password}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; base64 -d 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl port-forward svc/tobs-grafana 3000:80
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，导航到 http://localhost:3000/d/vBhEewLnk，使用你刚刚找回的密码，以管理员用户身份登录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Promscale 应用性能监控（APM）仪表盘&lt;/a&gt;将显示出来，向你展示关于演示应用的洞察力。Tobs 直接导入这套开箱即用、可用于生产的仪表盘，我们在 Grafana 中使用 SQL 查询对追踪数据进行构建，在这种情况下，它是由演示微服务自动生成的。下图显示了其中一个仪表盘 ——“服务详情”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-用演示应用程序的追踪数据填充的服务细节仪表盘httpsdocstimescalecompromscalelatestvisualize-dataapm-experience&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;用演示应用程序的追踪数据填充的&amp;lt;a href=&amp;#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;服务细节仪表盘&amp;lt;/a&amp;gt;&#34; srcset=&#34;
               /translation/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_e987cee28e5586d3309d943b90593978.webp 400w,
               /translation/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_38fa9f225f71344d9cc7cadc07a0349a.webp 760w,
               /translation/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_e987cee28e5586d3309d943b90593978.webp&#34;
               width=&#34;760&#34;
               height=&#34;390&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      用演示应用程序的追踪数据填充的&lt;a href=&#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务细节仪表盘&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于这些预建仪表盘的更多信息，请&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看这篇博文&lt;/a&gt;（导航到 “集成到 Grafana 的现代 APM 体验” 一节）。&lt;/p&gt;
&lt;p&gt;我们已经得到了所有这些信息，而在任何 Python 服务中都没有测量工具代码。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 追踪从未像现在这样方便。&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如果你的微服务是用 OpenTelemetry Operator 目前支持的语言之一编写的&lt;/a&gt;，你可以立即开始收集和存储追踪数据，只需要很少的手动工作。你只需采取以下两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/timescale/tobs/blob/master/chart/README.md#install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Helm 在你的 Kubernetes 集群中安装 tobs&lt;/a&gt;(请注意，你必须使用 Helm 来安装 tobs，才能使这个最新版本发挥作用，而不是使用 CLI)。&lt;/li&gt;
&lt;li&gt;在部署之前，给你想收集追踪数据的微服务 pods 添加&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator#opentelemetry-auto-instrumentation-injection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;注解&lt;/a&gt;（例如 &lt;code&gt;instrumentation.opentelemetry.io/inject-python: &amp;quot;true&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你的微服务将自动被 OpenTelemetry 追踪器检测，你的追踪器将自动存储在 Promscale 中，Promscale 是建立在 PostgreSQL 和 TimescaleDB 上的统一的指标和追踪器的可观测性后端。&lt;/p&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Promscale 预先建立的 APM 仪表盘&lt;/a&gt;，你将立即了解到你的系统性能如何，并且你将能够&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 SQL 查询你的追踪&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>混沌工程和视觉隐喻的可观测性</title>
      <link>https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/</link>
      <pubDate>Tue, 24 May 2022 10:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/</guid>
      <description>&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于现代软件系统来说，可观测性不是关于数学方程。它是关于人类如何与复杂的系统互动并试图理解它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混沌工程利用了可观测性，因为它可以检测到系统稳定状态的偏差。混沌工程借助可观测性可以发现和克服系统的弱点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可观测性依赖于系统所发出的信号，这些信号提供了关于系统行为的原始数据。然而，可观测性不仅受限于这些信号的质量，还受限于这些信号的可视化和解释的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑到混沌工程、可观测性和可视化涉及到人类自我的解释，仪表盘的设计者可能会对这些解释产生偏差，这是一个事实。在这个意义上，视觉隐喻并不能保证我们以正确的方式解释这些数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于视觉隐喻的仪表盘可以提供比经典的可视化更有用的数据。然而，这两种策略都很容易产生偏差；例如，在一项研究中，大多数参与者都注意到，由于显示了糟糕的柱状图和线状图，没有在图中显示出重要的分界点，因此整体结果是有偏差的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自从 Netflix、Slack 和 Linkedin 等领先的技术公司采用混沌工程来抵御生产中的意外中断后，这门学科在近来已经成为主流。在这条道路上，可观测性发挥了关键作用，为工程师们带来了数据和监控的力量，他们现在有了了解自己系统的策略，确定当某些东西发生故障时它们将如何表现，并增加复原力和可靠性。&lt;/p&gt;
&lt;p&gt;混沌工程和可观测性是两个密切相关的学科。根据 Russ Miles 的说法，&amp;quot;可观测性原则将系统变成了可检查和可调试的案发现场，而混沌工程鼓励并利用可观测性，因为它试图帮助预先发现并克服系统的弱点 &amp;quot;。混沌工程鼓励并要求可观测性，因为要自信地执行混沌实验，可观测性必须检测系统何时正常，以及在执行方法实验时如何偏离该稳定状态。见图 1 中的说明。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-混沌工程和可观测性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1. 混沌工程和可观测性&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_5d7fb018e0e824d2448996f75ff4f637.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_b2bb9661845b41200cb05c69a2d66c51.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_5d7fb018e0e824d2448996f75ff4f637.webp&#34;
               width=&#34;760&#34;
               height=&#34;399&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1. 混沌工程和可观测性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;学术界和科技界都做出了巨大的努力，为实践混沌工程和可观测性提供了工具。然而，指标的可视化和视觉策略的适当选择仍然是有限的。本文引入了一个新的角色：视觉隐喻。具体来说，它提供了混沌工程和可观测性的概念基础，介绍了市场上可用的可视化技术的现状，并展示了树状图、仪表图、地理图和城市隐喻是如何丰富观察混沌的视觉策略的。&lt;/p&gt;
&lt;h2 id=&#34;混沌工程和可观测性的基础&#34;&gt;混沌工程和可观测性的基础&lt;/h2&gt;
&lt;p&gt;关于混沌工程：混沌、弹性和可靠性是关键的概念，而关于可观测性，当人类想要观察他们的系统时，监控、度量和仪表盘是至关重要的。因此，在深入研究混沌工程和可观测性之间的关系之前，明确这些定义很重要。&lt;/p&gt;
&lt;p&gt;混沌工程根据混沌原理定义为一门在系统上进行实验的学科，以建立对系统在生产中承受动荡条件能力的信心。为了具体解决大规模分布式系统的不确定性，混沌工程提供了一种基于实验的方法，包括四个步骤：第一个步骤包括定义稳定状态，这是系统的一个可测量的输出，表示正常行为。第二步是与假设相关的，它提出了一个改变稳态的后果的句子。有了这个假设，就该引入现实世界的事件，如服务器崩溃或硬盘故障，以证实或反驳这个假设。最后，目标是建立控制组和实验组之间稳定状态的差异分析。&lt;/p&gt;
&lt;p&gt;可观测性是指能够完全理解一个系统。在控制理论中，它被定义为衡量一个系统的内部状态可以从其外部输出的知识中推断出来的程度。特别是在软件工程中，可观测性可以被描述为提出适当的问题、提供正确的答案以及用收集到的数据建立知识的艺术。&lt;/p&gt;
&lt;p&gt;监控与可观测性是不同的，理解两者的区别很重要。监控是关于收集、处理、汇总和显示系统的实时定量数据；而可观测性是关于处理和分析这些数据，让团队主动理解和调试系统的行为。对于现代软件系统来说，可观测性不是关于数学公式。它是关于人们如何与复杂的系统互动并试图理解它们。&lt;/p&gt;
&lt;p&gt;在这个意义上，监控涉及到通过数字读取系统发出的信号，这些数字被命名为度量。指标是一个单一的数字，可以选择附加标签进行分组和搜索，比如查询次数和类型、错误次数和类型、处理时间或服务器寿命。这些数值在仪表盘中被可视化，仪表盘是提供服务核心指标的摘要视图的应用程序。&lt;/p&gt;
&lt;p&gt;传统的仪表盘是建立在折线图、饼图或柱状图上的。考虑到可观测性取决于系统发出的信号以及这些信号被可视化和解释的质量，提供最好的工具和设计是很重要的。如果颜色、图例和比例使用不当，一些可视化可能会对操作者造成限制和困惑。下一节提供了监控和可观测性的技术状况，并更详细地描述了其中的一些限制。&lt;/p&gt;
&lt;h2 id=&#34;监控和可观测性&#34;&gt;监控和可观测性&lt;/h2&gt;
&lt;p&gt;监控和可观测性已经成为工程团队和一般现代数字企业最基本的能力之一，他们希望在他们的解决方案中提供卓越。由于监控和观察系统有很多原因，谷歌记录了四个黄金信号或指标，它们定义了系统健康的含义，是可观测性和监控平台现状的基础。这四个指标描述如下。&lt;/p&gt;
&lt;p&gt;延迟（Latency）是指一个服务为一个请求提供服务所需的时间。它包括由于与数据库或其他关键后端失去连接而触发的 HTTP 500 错误，这些错误可能不会很快得到服务。延迟是一个基本指标，因为慢的错误甚至比快的错误更糟糕。&lt;/p&gt;
&lt;p&gt;流量（Traffic）是衡量对系统的需求有多大。它决定了系统在某一特定时间内从用户或通过服务运行的事务中承受多大的压力。以网络服务为例，这种测量通常是每秒的 HTTP 请求。通过监控应用程序或服务中的真实用户互动和流量，工程团队可以看到系统如何支持需求的变化，以及他们应该如何扩展资源以满足需求。&lt;/p&gt;
&lt;p&gt;错误（Error）与请求失败的比率有关，无论是显性的还是隐性的。根据系统和发生故障的组件，监控错误情况可能会有很大的不同。这就是为什么工程团队需要监控整个系统的错误发生率，但也需要监控单个服务层面的错误发生率的原因。同样重要的是，要优先考虑哪些错误是关键的，哪些错误是不太危险的。&lt;/p&gt;
&lt;p&gt;最后，饱和度（Saturation）是系统对资源利用的信号，如内存、I/O 或 CPU。考虑到许多系统在达到 100% 的利用率之前就会出现性能下降的情况，拥有一个饱和度目标是非常重要的。它允许我们回答这样的问题：服务还有多少容量？什么水平的饱和度能保证客户的服务性能和可用性？&lt;/p&gt;
&lt;h2 id=&#34;用于监控的传统可视化方法&#34;&gt;用于监控的传统可视化方法&lt;/h2&gt;
&lt;p&gt;现在，上一节所述的四个黄金信号是用传统方法监控的，如折线图、柱状图或饼状图。&lt;/p&gt;
&lt;p&gt;如图 2 所示，折线图是将系统的四个黄金信号的行为在时间上可视化的最常用策略。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-虚构项目中的折线图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2. 虚构项目中的折线图&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_a7071667ac1f1e2b91f04ef67672971c.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_0c8c4496e612c4a2c59bdf77da85218f.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_a7071667ac1f1e2b91f04ef67672971c.webp&#34;
               width=&#34;760&#34;
               height=&#34;362&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2. 虚构项目中的折线图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;线形图在颜色、图例、轴和系列的标题方面提出了不同的挑战，因为变量会聚、交叉，而且通常会纠缠在一起。如果仪表盘的创建者没有使用适当的视觉资产，这种类型的图形可能会变成最令人困惑的图表之一。&lt;/p&gt;
&lt;p&gt;另一个常见的图表是柱状图，它是用高度或长度与所代表的数值成正比的矩形条来表示分类数据。如图 3 所示，一些云供应商用它们来表示日志的分类数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3-一个虚构的项目中的柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3. 一个虚构的项目中的柱状图&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_f171ab2438faaf52e91c84f8323a02f9.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_5bb59c44a456b6ffb7869609155d97d6.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_f171ab2438faaf52e91c84f8323a02f9.webp&#34;
               width=&#34;760&#34;
               height=&#34;315&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3. 一个虚构的项目中的柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，尽管较少使用，饼图是表示和比较数据分布中的比例的一种简单方法。当一个比例占主导地位——一半或四分之三时，它们是最有效的。超过几种颜色的楔形图会在楔形图之间产生同一性，使其难以比较数值。&lt;/p&gt;
&lt;p&gt;考虑到这些局限性，下一节将介绍一种不同的方式来可视化这四个黄金指标。由于本文是关于混沌工程的，这种技术是在报告事件的情况下进行分析的。&lt;/p&gt;
&lt;h2 id=&#34;视觉隐喻作为视觉化混沌的一种建议&#34;&gt;视觉隐喻作为视觉化混沌的一种建议&lt;/h2&gt;
&lt;p&gt;为了克服前面提到的局限性，本文提出了一种新的策略，将生产中的混乱现象可视化。这个建议是基于其他科学领域的一个概念：视觉隐喻。视觉隐喻是一种策略，将一个应用领域的概念和对象映射到一个相似性和类比的系统中。计算机隐喻是交互式视觉对象和模型对象之间同化的基本思想。它的作用是促进对对象的语义的更好理解。一个熟悉的例子可以是在跑车的图片前使用一只豹子，暗示该产品具有速度、力量和耐力等可比性。&lt;/p&gt;
&lt;p&gt;一些例子包括：地图、城市和几何场景，如图 3 所示。该图显示了城市隐喻，这是一种用于可视化程序代码属性的流行方法。许多项目都采用了这种隐喻来可视化软件库的属性，比如说。现有的研究已经被用来用包来映射街区，用建筑来映射类。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4-一个虚构项目中的城市隐喻来自这里httpswwwresearchgatenetpublication224503826_visual_exploration_of_large-scale_evolving_software&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4. 一个虚构项目中的城市隐喻，来自&amp;lt;a href=&amp;#34;https://www.researchgate.net/publication/224503826_Visual_Exploration_of_Large-Scale_Evolving_Software&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;这里&amp;lt;/a&amp;gt;&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_639d60ca309b4fa0a9f1d6248f19003d.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_aa172a266c11157371240586a8a2dc60.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_639d60ca309b4fa0a9f1d6248f19003d.webp&#34;
               width=&#34;500&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4. 一个虚构项目中的城市隐喻，来自&lt;a href=&#34;https://www.researchgate.net/publication/224503826_Visual_Exploration_of_Large-Scale_Evolving_Software&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种情况下，这个隐喻把类表示为建筑物，把包表示为建筑物所处的邻域。建筑物的每个边缘都被用来映射类的属性。&lt;/p&gt;
&lt;h2 id=&#34;提出一个将事件可视化的实验&#34;&gt;提出一个将事件可视化的实验&lt;/h2&gt;
&lt;p&gt;为了确定参与运营活动的工程团队的看法，我们对他们中的 28 人进行了关于传统仪表盘和视觉隐喻的调查。具体来说，他们被问及使用经典仪表盘和视觉隐喻对四个黄金指标（错误、延迟、流量和饱和度）进行可视化的事件。&lt;/p&gt;
&lt;p&gt;这项研究由关于一个事件的具体问题组成，其中提供了两种可视化：一种是传统的图表，另一种是视觉隐喻。对于每一种情况，都分析了每种可视化的价值。在接下来的段落中，将介绍每个问题和分析。&lt;/p&gt;
&lt;p&gt;关于人口统计学，共有 28 名参与者，其背景分布在后端、前端和全栈工程师、软件架构师、数据工程师和网站可靠性工程师。如图 5 所示，参与人数最多的是后端开发工程师。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-人口统计学数据&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5. 人口统计学数据&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_6fc1f3923bd515b4cb18185818326384.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_ca77edf6b3ca05bf5b1d10acd1c83280.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_6fc1f3923bd515b4cb18185818326384.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5. 人口统计学数据
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一个问题是关于 饱和信号。基本上，使用了两个仪表盘——一个折线图和一个城市隐喻来询问五个微服务的状态：&lt;code&gt;ms_authentication&lt;/code&gt;、&lt;code&gt;ms_patients&lt;/code&gt;、&lt;code&gt;ms_payments&lt;/code&gt;、&lt;code&gt;ms_medications&lt;/code&gt; 和 &lt;code&gt;ms_appointments&lt;/code&gt;。这些微服务是一个虚构的医疗系统的一部分。&lt;/p&gt;
&lt;p&gt;具体来说，问题是：使用传统的仪表板（见图 6）和视觉隐喻（见图 7），哪个微服务受到影响？正确答案是 &lt;code&gt;ms_authentication&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6-传统的折线图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6. 传统的折线图&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1ee9e729212ec6cb4d9f654db74dd193.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_13da0e1ea8b702da78230414f4c32386.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1ee9e729212ec6cb4d9f654db74dd193.webp&#34;
               width=&#34;760&#34;
               height=&#34;470&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6. 传统的折线图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-可视化的城市比喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 7. 可视化的城市比喻&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_849a632ac66913cbb50b1d54977118c9.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_f5caa61c40cac053a9e8748f658fc86b.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_849a632ac66913cbb50b1d54977118c9.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7. 可视化的城市比喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如图 8 所示，当他们使用视觉隐喻时，一些参与者的答案改变了，选择了正确的答案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-8-使用传统图表与视觉隐喻的参与者的回答&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 8. 使用传统图表与视觉隐喻的参与者的回答&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_ca0ae0f9fd58663980ac08bb34025b9a.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_179f3b49e5d007a9cd7dd4c0e446ddbe.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_ca0ae0f9fd58663980ac08bb34025b9a.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8. 使用传统图表与视觉隐喻的参与者的回答
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所有参与者都认为，受 CPU 高利用率影响的微服务是认证。在这种情况下，视觉隐喻比传统的图表更有用，因为图表线很混乱，而且颜色、形状和大小都不好，改变了参与者的看法。&lt;/p&gt;
&lt;p&gt;关于错误信号，我们用经典的柱状图和树状图来要求参与者计算每个微服务的平均错误，如图 9 所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-9-用于可视化误差的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 9. 用于可视化误差的传统柱状图&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_971d7e48c9f2a61b10d467821226c341.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_b77ff086fff6e5f915ee9a79adec1483.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_971d7e48c9f2a61b10d467821226c341.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 9. 用于可视化误差的传统柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-10-用于可视化错误的可视化树状图隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 10. 用于可视化错误的可视化树状图隐喻&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_ddc62a921dc2aff3227ae56fdc16329d.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_fb541186e99cf3cc9b08ae4cfe7f652b.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_ddc62a921dc2aff3227ae56fdc16329d.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 10. 用于可视化错误的可视化树状图隐喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;正确的答案是 &lt;code&gt;ms_appointments&lt;/code&gt;，虽然有些参与者没有选择它，但当他们使用视觉隐喻时，许多人改变了他们的答案。图 11 说明了这一点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-11-参与者使用传统图表与视觉隐喻来可视化错误的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 11. 参与者使用传统图表与视觉隐喻来可视化错误的答案&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1872b7f97e3073fc67fc96da84d3ebef.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_9eeb70bde9ec5d18ae643d93f31f345f.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1872b7f97e3073fc67fc96da84d3ebef.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 11. 参与者使用传统图表与视觉隐喻来可视化错误的答案
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于流量信号，我们用一个经典的柱状图和一个地理中心的隐喻来询问参与者哪个第三方服务的流量更大。在这种情况下，原有的微服务和新的四个第三方服务：&lt;code&gt;srv_ldap&lt;/code&gt;、&lt;code&gt;srv_goverment&lt;/code&gt;、&lt;code&gt;srv_assurance&lt;/code&gt; 和 &lt;code&gt;srv_authentication&lt;/code&gt; 之间的互动被分析了。图 12 用柱状图显示了这种整合，图 13 用地理中心的隐喻显示了相同的流量值。在这个比喻中，圆圈代表服务和微服务，线条连接它们之间的关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-12-用于可视化微服务和第三方服务之间流量的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 12. 用于可视化微服务和第三方服务之间流量的传统柱状图&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_6dd60bbb299279159e708431f5278dc5.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_5e76b95d1820fd6044312887fa31e2e6.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_6dd60bbb299279159e708431f5278dc5.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 12. 用于可视化微服务和第三方服务之间流量的传统柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-13-用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 13. 用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_dd7b9d20afbc634fbd73d38f1b50ac84.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_fc95584fa2e09b78c209d0382eebdaa5.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_dd7b9d20afbc634fbd73d38f1b50ac84.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 13. 用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;尽管有线条和大小来代表微服务和第三方服务之间的连接和流量负载，但这个比喻对参与者来说是混乱的。圆圈的大小可能与 &lt;code&gt;srv_ldap&lt;/code&gt; 的最小百分比有关，而 &lt;code&gt;srv_ldap&lt;/code&gt; 是正确的答案，它在饼中由绿色部分表示（见图 14）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-14-参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 14. 参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案。&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_775bfa66179990f0526e69b01cceb5a9.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_5f79a6e8736454681951a1a343353fde.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_775bfa66179990f0526e69b01cceb5a9.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 14. 参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们用柱状图的视觉化和仪表的比喻来分析&lt;strong&gt;延迟信号&lt;/strong&gt;。图 15 和图 16 分别说明了这两种可视化方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-15-用于可视化延迟信号的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 15. 用于可视化延迟信号的传统柱状图。&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_a7a2aa61d99536a844016d68f20d893e.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_4e9ed215760e368102e54b9329ea069e.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_a7a2aa61d99536a844016d68f20d893e.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 15. 用于可视化延迟信号的传统柱状图。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-16-用于可视化微服务的延迟的可视化仪表隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 16. 用于可视化微服务的延迟的可视化仪表隐喻。&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_2ca0bbcf6f7b32d0e1594dd7c8ba72ac.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_b5edc29fe68b56aa6464afa5dbba7c14.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_2ca0bbcf6f7b32d0e1594dd7c8ba72ac.webp&#34;
               width=&#34;500&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 16. 用于可视化微服务的延迟的可视化仪表隐喻。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于这种情况，这个隐喻肯定没有为参与者提供价值，因为正确的答案是 &lt;code&gt;ms_patients&lt;/code&gt;，这在图 17 中有说明。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-17-参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 17. 参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案。&#34; srcset=&#34;
               /translation/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_e9e4644b5b090d4ff1d18293e733753e.webp 400w,
               /translation/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_b34fee8578d57da90b06724ec34cabfd.webp 760w,
               /translation/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/translation/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_e9e4644b5b090d4ff1d18293e733753e.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 17. 参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;引入视觉隐喻的结论&#34;&gt;引入视觉隐喻的结论&lt;/h2&gt;
&lt;p&gt;混沌的可视化，特别是生产事故的可视化，给专注于可观测性的工业和学术界带来了一些挑战。正如我们在这篇文章中所展示的，由于混沌工程、可观测性和可视化涉及到人与机器的互动，解释中的偏差是一个持续的风险。通过一项研究，28 位工程师回答了与经典仪表盘和视觉隐喻有关的 12 个问题，可以得出结论，可观测性不仅受到这些信号的数量和质量的限制，而且受到这些信号的可视化和解释方式的限制。结论是，视觉隐喻可能比传统的仪表盘表现得更好，然而，由于两者都涉及到人，所以都不能保证操作人员以正确的方式解释事故中的数据。&lt;/p&gt;
&lt;h2 id=&#34;有兴趣了解更多关于混沌工程中的可观测性吗&#34;&gt;有兴趣了解更多关于混沌工程中的可观测性吗？&lt;/h2&gt;
&lt;p&gt;我想推荐这三本书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我的第一个推荐是 Russ Miles 的《&lt;a href=&#34;https://www.humio.com/chaos-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程可观测性&lt;/a&gt;》一书。在这本书中，作者演示了如何将你的混沌实验带入系统可观测性的世界。混沌可观测性能够使整个系统的混沌实验实时地浮现、调试和可视化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个很好的参考是 Charity Majors、Liz Fong-Jones 和 George
Miranda 的《&lt;a href=&#34;https://learning.oreilly.com/library/view/observability-engineering/9781492076438/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观测性工程&lt;/a&gt;》一书，他们在一家名为 Honeycomb 的公司工作，正是专门从事可观测性的工作。我喜欢这本书，因为在书中，可观测性被当作一个工程领域。如你所知，可观测性对于工程、管理和改进复杂的关键业务系统至关重要，所以它应该被视为一门学科，甚至是一个组织内部的角色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，我想提到一本专注于 &lt;a href=&#34;https://www.manning.com/books/chaos-engineering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程&lt;/a&gt; 的参考书。我说的是 Mikolaj
Pawlikowski 的一本实用书，由曼宁公司出版。该书记录了模拟现实生活中的失败的实验室和实际实验。作者通过学习像混沌工程师那样思考，最大限度地发挥了混沌工程的优势，提供了涵盖整个软件领域的例子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
