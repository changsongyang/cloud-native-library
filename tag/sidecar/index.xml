<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sidecar | 云原生资料库</title>
    <link>https://lib.jimmysong.io/tag/sidecar/</link>
      <atom:link href="https://lib.jimmysong.io/tag/sidecar/index.xml" rel="self" type="application/rss+xml" />
    <description>Sidecar</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Wed, 02 Aug 2023 11:00:00 +0800</lastBuildDate>
    <image>
      <url>https://lib.jimmysong.io/media/sharing.png</url>
      <title>Sidecar</title>
      <link>https://lib.jimmysong.io/tag/sidecar/</link>
    </image>
    
    <item>
      <title>Kubernetes 将推出新 sidecar container 特性</title>
      <link>https://lib.jimmysong.io/blog/understanding-kubernetes-new-sidecar-container-feature/</link>
      <pubDate>Wed, 02 Aug 2023 11:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/understanding-kubernetes-new-sidecar-container-feature/</guid>
      <description>&lt;p&gt;上周，Kubernetes 项目&lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/116429&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;合并&lt;/a&gt;了一个新的 alpha 特性，使用户能够在规范中定义“sidecar containers”。这个新功能旨在帮助定义多容器 pod 中辅助容器的行为，这些容器可能有助于配置、网络、日志和度量收集等方面。&lt;/p&gt;
&lt;h2 id=&#34;什么是-sidecar-container&#34;&gt;什么是 sidecar container？&lt;/h2&gt;
&lt;p&gt;理论上，Kubernetes 期望您在每个 pod 中运行一个容器。实际上，&lt;a href=&#34;https://www.mirantis.com/blog/kubernetes-pod-vs-container-multi-container-pods-and-container-communication/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;许多用例需要多容器 pod&lt;/a&gt;——例如，当您使用某些服务网格时，几乎所有的 pod 中都可能有 sidecar。&lt;/p&gt;
&lt;p&gt;有时，辅助容器仅用于初始化：例如为主容器配置和管理 secret。Kubernetes 已经为用户提供了定义 initContainer 的方式一段时间了。这个新功能最终为 initContainer 提供了更精细的粒度，以反映 sidecar 的特定要求，简化常见用法模式并为未来开辟了一些有趣的设计空间。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-container-特性如何工作&#34;&gt;sidecar container 特性如何工作？&lt;/h2&gt;
&lt;p&gt;在这个新的功能门控中，sidecar containers 被定义为&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 pod 中比其他容器更早地启动，因为它们可能需要先初始化。这对于像服务网格这样的事情很重要，其中您希望 sidecar 准备好为主容器进程建立网络连接，以及在日志记录方面，您希望收集器 sidecar 能够抓取主容器的启动日志。&lt;/li&gt;
&lt;li&gt;在 pod 的整个生命周期内保持运行，因为它们可能需要长期运行。例如，在网络和指标/日志记录的情况下，您需要 sidecar 运行的时间与主进程一样长。&lt;/li&gt;
&lt;li&gt;永远不会阻止 pod 被终止，因为它们仅支持 pod 的核心功能——如果没有新功能，运行的 sidecar 容器可以阻止作业完成，即使 pod 的核心任务已完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在较丑的一面上，在这个 alpha 实现中，您可以通过在您的 &lt;code&gt;initContainer&lt;/code&gt; 规范中添加值为 &lt;code&gt;Always&lt;/code&gt; 的 &lt;code&gt;restartPolicy&lt;/code&gt; 字段来定义 sidecar container。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initContainers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;init-myservice&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox:1.28&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;init-mydb&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox:1.28&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-proxy&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio/proxyv2:1.16.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;proxy&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;sidecar&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;restartPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Always&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myapp-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox:1.28&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上面的规范中，&lt;strong&gt;init-myservice&lt;/strong&gt; 和 &lt;strong&gt;init-mydb&lt;/strong&gt; 是标准 initContainers，而设置为 &lt;code&gt;Always&lt;/code&gt; 的 &lt;code&gt;restartPolicy&lt;/code&gt; 字段使 &lt;strong&gt;istio-proxy&lt;/strong&gt; 成为 sidecar container。&lt;/p&gt;
&lt;p&gt;这个新特性的 Kubernetes Enhancement Proposal (KEP) 承认了这种表面上的不优雅，指出 initContainer“不适合作为 sidecar containers，因为它们通常做的不仅是初始化”，并建议“基础设施容器”是一个更好的名称，未来可能会采用。KEP 解释了选择的结构背后的思考方式：&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;将 sidecar containers 定义在其他 init 容器之间是很重要的，以便能够表达容器的初始化顺序。&lt;/p&gt;
&lt;p&gt;一位高级贡献者在 Hacker News 上补充了一些细节，指出：&lt;/p&gt;
&lt;p&gt;分离属性的挑战在于它与我们可能添加到 pod 周围的有关排序和生命周期的新功能不兼容。如果我们使用一个简单的布尔值，最终我们将不得不让它与其他字段交互，并处理“sidecar”的含义和更灵活性之间的冲突行为。[&amp;hellip;]我们为 init containers 可以失败 pod、并且可以并行化、以及常规容器具有唯一的 restartPolicies 留出了空间。这两个都将允许更多的工作流/作业引擎控制，以分解单体容器并获得更好的隔离。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&#34;https://news.ycombinator.com/item?id=36666359&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;另一个评论&lt;/a&gt;中，他们补充说，团队想要&amp;hellip;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;留下更复杂的 init containers 和 sidecars 的排序（常规容器没有 restart 顺序）。例如，您可能需要一个服务网格来需要一个 vault secret——这两个可能都是 sidecars，并且如果两者都关闭，您可能需要确保 vault sidecar 首先启动。最终，我们可能希望在启动顺序中添加并行性，而单独的字段将阻止简单的排序现在起作用。&lt;/p&gt;
&lt;p&gt;KEP 提供了有关引发该功能的问题案例以及一些组织正在运行 Kubernetes 分叉以实现类似功能的有趣更广泛的背景的详细见解。&lt;/p&gt;
&lt;p&gt;如果您迫不及待地想在新的测试集群上尝试这个新功能，您需要为 kubelet、kube-apiserver、kube-controller-manager 和 kube-scheduler 启用 SidecarContainers feature gate。KEP 提供了有关默认策略和实现的有用细节，您可以期待在 8 月份发布 Kubernetes 1.28 时看到更多关于此功能的讨论。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Istio 服务网格 ambient 模式安全详解</title>
      <link>https://lib.jimmysong.io/blog/ambient-security/</link>
      <pubDate>Thu, 08 Sep 2022 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/ambient-security/</guid>
      <description>&lt;p&gt;我们最近发布了 Istio Ambient Mesh（译者注：笔者更倾向于将其称为 Ambient Mode，即外围模式，但译文中仍然保留了 Ambient Mesh 的叫法），它是 Istio 的无 sidecar 数据平面。如&lt;a href=&#34;https://lib.jimmysong.io/blog/introducing-ambient-mesh/&#34;&gt;公告博客中所述&lt;/a&gt;，我们使用 Ambient Mesh 解决的首要问题是简化操作、更广泛的应用程序兼容性、降低基础设施成本和提高性能。在设计 ambient 数据平面时，我们希望在不牺牲安全性或功能的情况下仔细平衡运维、成本和性能方面的问题。随着 ambient 组件在应用程序 pod 之外运行，安全边界发生了变化 —— 我们相信会变得更好。在这篇博客中，我们将详细介绍这些安全性变化以及它们与 sidecar 部署模式在安全性方面的对比。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ambient-mesh-的分层示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Ambient Mesh 的分层示意图&#34;
           src=&#34;https://lib.jimmysong.io/blog/ambient-security/amibent-mesh-layer.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Ambient Mesh 的分层示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;回顾一下，Istio Ambient Mesh 引入了一个分层网格数据平面，它具有负责传输安全和路由的安全覆盖层，可以选择为需要它们的命名空间添加 L7 功能。要了解更多信息，请参阅&lt;a href=&#34;https://istio.io/latest/blog/2022/introducing-ambient-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;公告博客&lt;/a&gt;和&lt;a href=&#34;https://istio.io/latest/blog/2022/get-started-ambient&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;入门博客&lt;/a&gt;。安全覆盖层包括一个节点共享组件 ztunnel，它负责 L4 遥测和部署为 DaemonSet 的 mTLS。网格的 L7 层由 Waypoint 代理提供，完整的 L7 Envoy 代理按身份/工作负载类型部署。这种设计的一些基本原则包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序与数据平面分离&lt;/li&gt;
&lt;li&gt;安全覆盖层的组件类似于 CNI&lt;/li&gt;
&lt;li&gt;操作简单更利于安全&lt;/li&gt;
&lt;li&gt;避免多租户 L7 代理&lt;/li&gt;
&lt;li&gt;Sidecar 仍然是首选的部署模式之一&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用程序和数据平面分离&#34;&gt;应用程序和数据平面分离&lt;/h2&gt;
&lt;p&gt;尽管 Ambient Mesh 的主要目标是简化服务网格的操作，但它也确实有助于提高安全性。复杂性会滋生漏洞，企业应用程序（及其传递依赖项、库和框架）极其复杂且容易出现漏洞。从处理复杂的业务逻辑到利用 OSS 库或有缺陷的内部共享库，攻击者（来自内部或外部）的主要目标是用户的应用程序代码。如果应用程序遭到破坏，凭据、机密和密钥就会暴露给攻击者，包括那些安装或存储在内存中的数据。在查看 sidecar 模型时，sidecar 接管应用程序中的身份/密钥材料。在 Istio ambient 模式下，数据平面组件不会与应用程序运行在同一个 pod 中，因此，应用程序的中的秘密不会泄露给数据平面。&lt;/p&gt;
&lt;p&gt;作为漏洞的潜在目标，Envoy Proxy 怎么样？Envoy 是一个经过严格审查的极其坚固的基础设施，并&lt;a href=&#34;https://www.infoq.com/news/2018/12/envoycon-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在关键环境中大规模运行&lt;/a&gt;（例如，&lt;a href=&#34;https://cloud.google.com/load-balancing/docs/https&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用于生产以支持 Google 的网络&lt;/a&gt;）。然而，由于 Envoy 是软件，它不能免受漏洞的影响。当漏洞出现时，Envoy 有一个强大的 CVE 流程来识别快速修复它们，并在它们产生广泛影响之前将补丁推送给客户。&lt;/p&gt;
&lt;p&gt;回到前面“复杂性滋生漏洞”的评论，Envoy Proxy 最复杂的部分在于其 L7 处理，事实上，历史上 Envoy 的大多数漏洞都在其 L7 处理堆栈中。但是，如果你只将 Istio 用于 mTLS 会怎样？当你不使用该功能时，为什么要冒险部署一个更容易发生 CVE 的成熟 L7 代理？分离 L4 和 L7 网格功能在这里很有用。在 Sidecar 部署中，你采用所有代理，即使你只使用一小部分功能，在 ambient 模式下，我们可以通过提供安全覆盖并仅根据需要在 L7 中分层来限制暴露。此外，L7 组件完全独立于应用程序运行，不会暴露供攻击面。&lt;/p&gt;
&lt;h2 id=&#34;将-l4-下推到-cni&#34;&gt;将 L4 下推到 CNI&lt;/h2&gt;
&lt;p&gt;Ambient 数据平面的 L4 组件作为 DaemonSet 运行，或者说每个节点一个。这意味着它是在特定节点上运行的所有 Pod 的共享基础架构。这个组件特别敏感，应该与节点上的任何其他共享组件（例如任何 CNI 代理、kube-proxy、kubelet 甚至 Linux 内核）处于同一级别。来自工作负载的流量被重定向到 ztunnel，ztunnel 然后识别工作负载并选择正确的证书来代表 mTLS 连接中的工作负载。&lt;/p&gt;
&lt;p&gt;ztunnel 为每个 pod 使用一个独特的凭证，只有当 pod 在当前节点上运行时才会被发出。这确保了被破坏的 ztunnel 的爆炸半径——只有调度到当前节点上的 pod 的凭证可以被盗。这是一个类似于其他实现良好的共享节点基础设施的属性，包括其他安全 CNI 实现。ztunnel 不使用集群范围或每个节点的凭证，如果被盗，可能会立即危及集群中的所有应用流量，除非这些应用也实施复杂的二级授权机制。&lt;/p&gt;
&lt;p&gt;如果我们将其与 sidecar 模式进行比较，我们会注意到 ztunnel 是共享的，它的暴露可能导致节点上运行的应用程序的身份泄露。但是，该组件中出现 CVE 的可能性低于 Istio sidecar，因为攻击面大大减少（仅 L4 处理）；ztunnel 不做任何 L7 处理。此外，sidecar 中的 CVE（具有更大的 L7 攻击面）并没有真正包含在受到损害的特定工作负载中。Sidecar 中的所有严重的 CVE 都可能在网格中的任何工作负载复现。&lt;/p&gt;
&lt;h2 id=&#34;操作简单更利于安全&#34;&gt;操作简单更利于安全&lt;/h2&gt;
&lt;p&gt;归根结底，Istio 是一个关键的基础设施，必须进行维护。Istio 代表应用程序实施零信任网络安全的一些原则受到信任，按计划或按需求推出补丁是最重要的。平台团队通常有可预测的补丁或维护周期，这与应用程序的周期完全不同。当需要新的能力和功能时，应用程序可能会被更新，通常是项目的一部分。这种对应用程序变化、升级、框架和库补丁的方法，是非常不可预测的，会耗费大量时间，不适合安全实践。因此，保持这些安全功能是平台的一部分，与应用程序分开，有利于保持更好的安全态势。&lt;/p&gt;
&lt;p&gt;正如我们在公告博客中指出的，由于 sidecar 的侵入性，操作 sidecar 可能会更加复杂（注入 sidecar/改变部署描述，重启应用程序，容器之间的竞争条件等）。对带有 sidecar 的工作负载的升级需要更多的计划和滚动重启，可能需要协调，以避免应用程序崩溃。有了 Ambient Mesh，对 ztunnel 的升级可以与任何正常的节点补丁或升级同时进行，而 waypoint 代理是网络的一部分，可以根据需要对应用程序进行完全透明的升级。&lt;/p&gt;
&lt;h2 id=&#34;避免多租户-l7-代理&#34;&gt;避免多租户 L7 代理&lt;/h2&gt;
&lt;p&gt;支持 L7 协议（例如 HTTP 1/2/3、gRPC、解析标头、实现重试、在数据平面中使用 Wasm 或 Lua 进行自定义）比支持 L4 复杂得多。实现这些行为的代码要多得多（包括 Lua 和 Wasm 等用户自定义代码），这种复杂性可能会导致潜在的漏洞。正因为如此，CVE 在这些 L7 功能领域中出现的几率更高。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-每个命名空间身份都有自己的l7代理没有多租户代理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;每个命名空间/身份都有自己的L7代理；没有多租户代理&#34;
           src=&#34;https://lib.jimmysong.io/blog/ambient-security/l7-function.svg&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      每个命名空间/身份都有自己的L7代理；没有多租户代理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在 ambient mesh 中，我们不在多个身份之间共享代理中的 L7 处理。每个身份（Kubernetes 中的服务账户）都有自己专门的 L7 代理（waypoint 代理），这与我们使用的 sidecar 模型非常相似。试图将多个身份、复杂的不同的策略和定制放在一起，会给共享资源增加很多变数，最好的情况是导致资源的不公平分配，最坏的情况是导致代理被完全破坏。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-模式仍然是首先的部署模式之一&#34;&gt;Sidecar 模式仍然是首先的部署模式之一&lt;/h2&gt;
&lt;p&gt;我们理解，有些人对 sidecar 模型及其已知的安全边界感到满意，并希望留在该模型上。Sidecar 仍然是网格的一等公民，平台所有者可以选择继续使用它们。如果平台所有者想同时支持 sidecar 和 ambient 也是可以。具有 ambient 数据平面的工作负载可以与部署了 sidecar 的工作负载进行本地通信。随着人们更好地了解 ambient mesh 的安全态势，我们相信，ambient 将成为 Istio 服务网格的首选模式，而 sidecar 则用于特定的优化。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
