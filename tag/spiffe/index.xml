<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SPIFFE | 云原生资料库</title>
    <link>https://lib.jimmysong.io/tag/spiffe/</link>
      <atom:link href="https://lib.jimmysong.io/tag/spiffe/index.xml" rel="self" type="application/rss+xml" />
    <description>SPIFFE</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Mon, 23 Oct 2023 00:00:00 +0800</lastBuildDate>
    <image>
      <url>https://lib.jimmysong.io/media/sharing.png</url>
      <title>SPIFFE</title>
      <link>https://lib.jimmysong.io/tag/spiffe/</link>
    </image>
    
    <item>
      <title>SPIFFE 基本概念</title>
      <link>https://lib.jimmysong.io/spiffe-and-spire/concept/spiffe/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe-and-spire/concept/spiffe/</guid>
      <description>&lt;p&gt;SPIFFE，即普适安全生产身份框架（Secure Production Identity Framework for Everyone），是一套开源标准，用于在动态和异构环境中安全地进行身份识别。采用 SPIFFE 的系统无论在哪里运行，都可以轻松可靠地相互认证。&lt;/p&gt;
&lt;p&gt;SPIFFE 开源规范的核心是——通过简单 API 定义了一个短期的加密身份文件 SVID。然后，工作负载进行认证时可以使用该身份文件，例如建立 TLS 连接或签署和验证 JWT 令牌等。&lt;/p&gt;
&lt;p&gt;SPIFFE 已经在云原生应用中得到了大量的应用，尤其是在 Istio 和 Envoy 中。下面将向你介绍 SPIFFE 的一些基本概念。&lt;/p&gt;
&lt;h2 id=&#34;工作负载&#34;&gt;工作负载&lt;/h2&gt;
&lt;p&gt;工作负载是一个单一的软件实体，通过特定配置部署，用于单一目的；它可能包括多个运行中的软件实例，所有这些实例执行相同的任务。术语“工作负载”可能涵盖软件系统的各种不同定义，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行 Python Web 应用程序的 Web 服务器，部署在一组虚拟机上，前面有一个负载均衡器。&lt;/li&gt;
&lt;li&gt;一个 MySQL 数据库的实例。&lt;/li&gt;
&lt;li&gt;处理队列中条目的工作程序。&lt;/li&gt;
&lt;li&gt;一组独立部署的系统共同工作，例如使用数据库服务的 Web 应用程序。Web 应用程序和数据库也可以分别被视为工作负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 SPIFFE 来说，工作负载往往比物理或虚拟节点更精细 - 通常精细到节点上的单个进程。对于在容器编排器中托管的工作负载而言，这对于多个工作负载可以共存（但在彼此之间隔离）于单个节点的情况非常重要。&lt;/p&gt;
&lt;p&gt;对于 SPIFFE 来说，工作负载也可能跨越多个节点 - 例如，一个可以在多台机器上同时运行的弹性缩放的 Web 服务器。&lt;/p&gt;
&lt;p&gt;尽管在不同的上下文中，将何为工作负载的粒度会有所不同，但对于 SPIFFE 的目的而言，&lt;em&gt;假定&lt;/em&gt;工作负载与其他工作负载隔离得足够好，以至于恶意的工作负载在发放证书后无法窃取另一个工作负载的凭据。此隔离的稳固性以及其实现机制超出了 SPIFFE 的范围。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-id&#34;&gt;SPIFFE ID&lt;/h2&gt;
&lt;p&gt;SPIFFE ID 是一个字符串，唯一且具体地标识一个工作负载。SPIFFE ID 也可以分配给工作负载运行在的中间系统（如一组虚拟机）。例如，&lt;strong&gt;spiffe://acme.com/billing/payments&lt;/strong&gt; 是一个有效的 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;SPIFFE ID 是一个&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;统一资源标识符 (URI)&lt;/a&gt;，其格式如下：&lt;strong&gt;spiffe://信任域/工作负载标识符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;工作负载标识符&lt;/em&gt;唯一地标识&lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-domain&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任域&lt;/a&gt;中的特定工作负载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 规范&lt;/a&gt;详细描述了 SPIFFE ID 的格式和用途。&lt;/p&gt;
&lt;h2 id=&#34;信任域&#34;&gt;信任域&lt;/h2&gt;
&lt;p&gt;信任域对应于系统的信任根。信任域可以代表运行其独立 SPIFFE 基础设施的个人、组织、环境或部门。在相同信任域中标识的所有工作负载都会收到可以与信任域的根密钥进行验证的身份文件。&lt;/p&gt;
&lt;p&gt;通常建议将位于不同物理位置（例如不同数据中心或云区域）或应用不同安全实践的环境（例如与生产环境相比的暂存或实验环境）的工作负载保持在不同的信任域中。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-可验证身份文件svid&#34;&gt;SPIFFE 可验证身份文件（SVID）&lt;/h2&gt;
&lt;p&gt;SVID 是工作负载用于向资源或调用方证明其身份的文档。如果由 SPIFFE ID 信任域内的权威签名，SVID 被认为是有效的。&lt;/p&gt;
&lt;p&gt;一个 SVID 包含一个单一的 SPIFFE ID，代表了呈现它的服务的身份。它将 SPIFFE ID 编码在一个密码学可验证的文档中，支持两种当前支持的格式之一：X.509 证书或 JWT 令牌。&lt;/p&gt;
&lt;p&gt;由于令牌容易受到&lt;em&gt;重放攻击&lt;/em&gt;，在传输中获取了令牌后，攻击者可以使用它来冒充一个工作负载，因此建议尽可能使用 X.509-SVIDs。但是，在某些情况下，JWT 令牌格式可能是唯一的选择，例如当你的架构在两个工作负载之间有一个 L7 代理或负载均衡器时。&lt;/p&gt;
&lt;p&gt;有关 SVID 的详细信息，请参阅&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/main/standards/X509-SVID.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SVID 规范&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-工作负载-api&#34;&gt;SPIFFE 工作负载 API&lt;/h2&gt;
&lt;p&gt;工作负载 API 提供以下功能：&lt;/p&gt;
&lt;p&gt;对于 X.509 格式的身份文件（X.509-SVID）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其身份，以 SPIFFE ID 形式描述。&lt;/li&gt;
&lt;li&gt;与该 ID 相关的私钥，可用于代表工作负载对数据进行签名。还创建了相应的短暂的 X.509 证书，即 X509-SVID。这可用于建立 TLS 连接或以其他方式对其他工作负载进行身份验证。&lt;/li&gt;
&lt;li&gt;一组证书 - 称为&lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-bundle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任捆绑包&lt;/a&gt; - 可用于验证另一个工作负载呈现的 X.509-SVID。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 JWT 格式的身份文件（JWT-SVID）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其身份，以 SPIFFE ID 形式描述。&lt;/li&gt;
&lt;li&gt;JWT 令牌&lt;/li&gt;
&lt;li&gt;一组证书 - 称为&lt;a href=&#34;https://spiffe.io/docs/latest/spiffe-about/spiffe-concepts/#trust-bundle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任捆绑包&lt;/a&gt; - 可用于验证其他工作负载的身份。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与&lt;a href=&#34;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amazon EC2 实例元数据 API&lt;/a&gt;和&lt;a href=&#34;https://cloud.google.com/compute/docs/storing-retrieving-metadata&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google GCE 实例元数据 API&lt;/a&gt;类似，工作负载 API 不要求调用工作负载具有自己的身份知识，或在调用 API 时拥有任何身份验证令牌。这意味着你的应用程序无需将任何身份验证密钥与工作负载一起部署。&lt;/p&gt;
&lt;p&gt;然而，与这些其他 API 不同，工作负载 API 是平台无关的，并且可以在进程级别以及内核级别识别运行的服务 - 这使其适用于与容器调度器（如 Kubernetes）一起使用。&lt;/p&gt;
&lt;p&gt;为了最小化由于密钥泄露或被破坏而造成的风险，所有私钥（及相应的证书）都是短暂的，会经常自动轮换。在相应的密钥到期之前，工作负载可以从工作负载 API 请求新的密钥和信任捆绑包。&lt;/p&gt;
&lt;h2 id=&#34;信任捆绑包&#34;&gt;信任捆绑包&lt;/h2&gt;
&lt;p&gt;在使用 X.509-SVID 时，信任捆绑包用于由目标工作负载验证源工作负载的身份。信任捆绑包是一个包含一个或多个证书颁发机构（CA）根证书的集合，工作负载应将其视为可信任的。信任捆绑包包含了验证 X.509 和 JWT SVID 的公钥材料。&lt;/p&gt;
&lt;p&gt;用于验证 X.509 SVID 的公钥材料是一组证书。用于验证 JWT 的公钥材料是一个原始的公钥。信任捆绑包的内容经常会发生变化。在调用工作负载 API 时，工作负载会检索信任捆绑包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPIFFE ID 和 SVID</title>
      <link>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-id/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-id/</guid>
      <description>&lt;p&gt;SPIFFE 标准提供了一个规范，用于在异构环境和组织边界中引导和颁发服务的身份。它包括各种规范，每个规定了 SPIFFE 功能的特定子集的操作。&lt;/p&gt;
&lt;p&gt;特别是本文档作为 SPIFFE 标准的核心规范。虽然在 SPIFFE 范围内还有其他规范，但符合本文档就足以实现 SPIFFE 合规性，并获得 SPIFFE 标准本身的互操作性好处。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;本文档提出了正式的 SPIFFE 规范。它定义了 SPIFFE 标准的两个最基本组件：SPIFFE 身份和 SPIFFE 可验证身份文档。&lt;/p&gt;
&lt;p&gt;第 2 节概述了 SPIFFE 身份（SPIFFE ID）及其命名空间。SPIFFE ID 被定义为符合&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;标准的 URI，包括“信任域名”和相关路径。信任域名作为 URI 的授权组件，用于识别发放给定身份的系统。以下示例演示了如何构造 SPIFFE ID：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://trust-domain-name/path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有效的 SPIFFE ID 必须将方案设置为&lt;code&gt;spiffe&lt;/code&gt;，包含非零的信任域名，并且不能包含查询或片段组件。换句话说，SPIFFE ID 由&lt;code&gt;spiffe&lt;/code&gt;方案和一个特定站点的&lt;code&gt;hier-part&lt;/code&gt;（其中包括授权组件和可选路径）完全定义。&lt;/p&gt;
&lt;h3 id=&#34;信任域&#34;&gt;信任域&lt;/h3&gt;
&lt;p&gt;信任域对应于系统的信任根。信任域可以代表独立运行其自己的 SPIFFE 基础设施的个人、组织、环境或部门。&lt;/p&gt;
&lt;p&gt;信任域名称通常是自我注册的，与公共 DNS 不同，没有委托权机构来断言并注册基本域名到实际的法律实体，或者断言该法律实体对任何特定信任域名拥有公正和正当的权利。&lt;/p&gt;
&lt;p&gt;信任域名被定义为 URI 的授权组件，并应用以下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分不得为空。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;userinfo&lt;/code&gt;和&lt;code&gt;port&lt;/code&gt;部分必须为空。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分必须小写。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分只能包含字母、数字、点、破折号和下划线（[a-z0-9.-_]）。&lt;/li&gt;
&lt;li&gt;授权组件的&lt;code&gt;host&lt;/code&gt;部分不能包含百分比编码的字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，此定义不排除用点分四段表示法表示的 IPv4 地址，但排除了 IPv6 地址。DNS 名称是有效信任域名的严格子集。实现在处理信任域名时，无论它们是有效的 IP 地址还是有效的 DNS 名称，都不得以不同方式处理它们。&lt;/p&gt;
&lt;h4 id=&#34;信任域名称冲突&#34;&gt;信任域名称冲突&lt;/h4&gt;
&lt;p&gt;信任域操作员可以自由选择任何他们认为合适的信任域名称：没有中央权威机构来监管或注册信任域名称。因此，不能保证全局唯一性，也没有技术手段阻止不同的信任域使用相同的信任域名称。&lt;/p&gt;
&lt;p&gt;为防止意外碰撞（两个信任域选择相同的名称），建议操作员选择高度可能全球唯一的信任域名称。即使信任域名称不是 DNS 名称，但如果可用，使用注册的域名作为信任域名的后缀将降低意外碰撞的可能性；例如，如果信任域操作员拥有域名&lt;code&gt;example.com&lt;/code&gt;，那么使用类似&lt;code&gt;trust_domain_name.example.com&lt;/code&gt;的信任域名可能不会产生冲突。当信任域名在没有操作员输入的情况下自动生成时，强烈建议随机生成一个唯一的名称（例如 UUID）。&lt;/p&gt;
&lt;p&gt;发生冲突时，这些信任域将继续独立运行，但将无法联合（相互连接）。因为每个信任域使用独特的信任根，由一个信任域发放的身份声明将在另一个信任域中验证失败。&lt;/p&gt;
&lt;h3 id=&#34;路径&#34;&gt;路径&lt;/h3&gt;
&lt;p&gt;SPIFFE ID 的路径组件允许唯一标识给定的工作负载。路径的含义是开放式的，由管理员负责定义。&lt;/p&gt;
&lt;p&gt;有效的 SPIFFE ID 路径组件必须遵循以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径组件不能包含百分比编码的字符。&lt;/li&gt;
&lt;li&gt;路径组件不能包含空段或相对路径修饰符（即&lt;code&gt;.&lt;/code&gt;、&lt;code&gt;..&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;路径组件不能以斜杠结尾。&lt;/li&gt;
&lt;li&gt;单个路径段只能包含字母、数字、点、破折号和下划线（[a-zA-Z0-9.-_]）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;路径可以是分层的，类似于文件系统路径。路径的具体含义保留给实施者，不属于 SVID 规范的范围之内。以下是一些示例和约定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接标识服务&lt;/p&gt;
&lt;p&gt;通常，直接标识服务是有价值的。例如，管理员可能会决定在特定一组节点上运行的任何进程都应该能够以特定的身份呈现自己。例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://staging.example.com/payments/mysql&lt;/code&gt;
或
&lt;code&gt;spiffe://staging.example.com/payments/web-fe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述两个 SPIFFE ID 指代了两个不同的组件 - mysql 数据库服务和一个运行在暂存环境中的支付服务的 web 前端。环境“staging”的含义和“payments”作为高级服务集合的含义由实施者定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识服务所有者&lt;/p&gt;
&lt;p&gt;通常，更高级别的编排器和平台可能已经内置了它们自己的身份概念（如 Kubernetes 服务账户或 AWS/GCP 服务账户），直接将 SPIFFE 身份映射到这些身份是很有帮助的。例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://k8s-west.example.com/ns/staging/sa/default&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，example.com 的管理员正在运行一个名为 k8s-west.example.com 的 Kubernetes 集群，该集群有一个“staging”命名空间，在其中有一个名为“default”的服务账户（sa）。这些都是由 SPIFFE 管理员定义的约定，而不是本规范所保证的断言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不透明的 SPIFFE 身份&lt;/p&gt;
&lt;p&gt;上述示例是说明性的，在最一般的情况下，SPIFFE 路径可能是不透明的，不包含任何可见的分层信息。例如，地理位置、逻辑系统分区和/或服务名称等元数据可以由注册身份及其属性的次级系统提供。可以查询以检索与 SPIFFE 标识符相关联的任何元数据。例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spiffe://example.com/9eebccd2-12bf-40a6-b262-65fe0487d453&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最大-spiffe-id-长度&#34;&gt;最大 SPIFFE ID 长度&lt;/h3&gt;
&lt;p&gt;如&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;定义的 URI 没有最大长度。出于互操作性考虑，SPIFFE 实现必须支持最长为 2048 字节的 SPIFFE URI，并且不应生成长度大于 2048 字节的 URI。&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;仅允许 ASCII 字符，因此 SPIFFE ID 的推荐最大长度为 2048 字节。&lt;/p&gt;
&lt;p&gt;所有 URI 组件都会影响 URI 的长度，包括“spiffe”方案、“：//”分隔符、信任域名和路径组件。非 ASCII 字符在将其编码为 ASCII 字符后会影响 URI 的长度。请注意，&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;为 URI 的“host”组件定义了最大长度为 255 个字符；因此，信任域名的最大长度为 255 字节。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-id-解析&#34;&gt;SPIFFE ID 解析&lt;/h3&gt;
&lt;p&gt;SPIFFE ID 遵循由&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt;定义的 URI 规范。SPIFFE ID 的方案和信任域名对大小写不敏感，而路径对大小写敏感。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-可验证身份文档&#34;&gt;SPIFFE 可验证身份文档&lt;/h2&gt;
&lt;p&gt;SPIFFE 可验证身份文档（SVID）是工作负载将其身份通信给资源或调用者的机制。如果 SVID 已由 SPIFFE ID 所在信任域内的授权方签名，则认为 SVID 是有效的。&lt;/p&gt;
&lt;h3 id=&#34;svid-信任&#34;&gt;SVID 信任&lt;/h3&gt;
&lt;p&gt;SPIFFE 信任根植于给定 ID 的信任域。每个信任域必须存在一个签名授权机构，该授权机构必须携带自己的 SVID。签名授权机构的 SPIFFE ID 应该驻留在其具有权威性的信任域中，并且不应具有路径组件。授权机构的 SVID 然后形成了给定信任域的信任基础。&lt;/p&gt;
&lt;p&gt;如果需要，可以通过使用外部信任域授权机构的私钥对授权机构的 SVID 进行签名来实现信任链。如果不需要链接信任，那么授权机构的 SVID 将进行自签名。&lt;/p&gt;
&lt;h3 id=&#34;svid-组件&#34;&gt;SVID 组件&lt;/h3&gt;
&lt;p&gt;SVID 是一个相当简单的构造，包括三个基本组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 SPIFFE ID&lt;/li&gt;
&lt;li&gt;一个有效的签名&lt;/li&gt;
&lt;li&gt;一个可选的公钥&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SPIFFE ID 和公钥（如果存在）必须包含在签名的有效载荷的一部分中。如果包含了公钥，则相应的私钥将由发放 SVID 的实体保留，并用于证明对 SVID 本身的所有权。&lt;/p&gt;
&lt;p&gt;个别的 SVID 规范可能要求或以其他方式允许在 SVID 中包含超出此处描述的内容。所包含信息的性质可能或可能不会严格由相关的 SPIFFE 规范定义 - 例如，JWT-SVID 规范允许用户在 SVID 本身中包含任意信息。在相关 SVID 规范未明确指定此附加信息的情况下，操作者在将此信息用作安全决策的输入时应格外小心，特别是如果要验证的 SVID 属于不同的信任域。有关更多信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;h3 id=&#34;svid-格式&#34;&gt;SVID 格式&lt;/h3&gt;
&lt;p&gt;SVID 本身不是一种文件类型。已经存在许多文件格式可以满足 SPIFFE SVID 的需求，我们不希望重新发明这些格式。相反，我们定义了一组特定于格式的规范，规范化了 SVID 信息的编码。&lt;/p&gt;
&lt;p&gt;为了使 SVID 被视为有效，它必须利用已定义相应规范的文件类型。在撰写本文时，唯一受支持的文件类型是 X.509 和 JWT。请注意，特定于格式的 SVID 规范可能会升级本文中规定的要求。&lt;/p&gt;
&lt;h2 id=&#34;安全注意事项&#34;&gt;安全注意事项&lt;/h2&gt;
&lt;p&gt;本节包含在使用 SPIFFE ID 和 SVID 时实施者和用户应考虑的安全注意事项。&lt;/p&gt;
&lt;h3 id=&#34;svid-断言&#34;&gt;SVID 断言&lt;/h3&gt;
&lt;p&gt;SVID 始终包含一组数据 - 至少是一个 SPIFFE ID。有时，此数据代表了信任域授权机构对 SVID 主体所做的断言。在从此数据中解释含义时，必须小心确保所有涉及方都充分理解所使用信息的含义和重要性。&lt;/p&gt;
&lt;p&gt;在考虑给定断言的相对安全性时，有四个主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先是时间上的准确性 - SVID 在到期之前一段时间内是有效的，SVID 中的断言在 SVID 的整个生命周期内是否为真？&lt;/li&gt;
&lt;li&gt;其次，断言的范围和影响 - 断言最初是在什么上下文下进行的，它的影响有多大？&lt;/li&gt;
&lt;li&gt;第三是解释和含义的问题 - 断言对授权机构和消费者是否具有相同的含义或解释，或者存在着不同的解释可能性？&lt;/li&gt;
&lt;li&gt;最后，断言本身的真实性在某些情况下可能会受到质疑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节探讨了这四个关注领域的所有方面，并提供了操作者可以评估任何给定 SVID 断言的相对安全性的指导方针。一般来说，操作者应该以谨慎为原则，只包含那些对所涉及的断言的安全性具有非常高度信心的断言。&lt;/p&gt;
&lt;p&gt;值得注意的是，虽然通常由 SPIFFE 规范直接形式化的断言通常不容易受到与解释和含义相关的问题的影响，但它们仍然可能容易受到与真实性相关的问题的影响。但是，由于 SPIFFE 定义的断言的范围非常有限，因此在这方面的真实性问题表明了与问题相关的信任域的安全姿态的更大问题，此时操作者应该认真考虑是否应该在第一时间与这些系统交换数据。&lt;/p&gt;
&lt;h4 id=&#34;时间上的准确性&#34;&gt;时间上的准确性&lt;/h4&gt;
&lt;p&gt;SVID 在一段有限的时间内有效，主要是为了降低密钥被泄露和相关损害的可能性。虽然通常情况下，SVID 中的断言在签发时是真实的，但并不一定意味着在使用时也是真实的。&lt;/p&gt;
&lt;p&gt;某些类型的断言比其他类型更容易受到此问题的影响。服务所有者的名称、角色或组成员资格以及访问策略都是在 SVID 签发时和验证或使用时之间更有可能发生变化的示例。相反，工作负载及其运行时的自然属性（例如 SPIFFE ID 或工作负载所在的区域）通常与工作负载的生命周期绑定，因此不太可能发生变化，这使得它们不太容易受到时间上的准确性的问题影响。&lt;/p&gt;
&lt;p&gt;在决定是否应该在 SVID 中包含某个特定的断言时，考虑到这一点是很重要的。在 SVID 中作出的断言将被认为在 SVID 的生命周期内都是有效的，并且对于具有旧断言的所有 SVID 来说，将首先过期，因此在活动系统上对此断言进行更改（或撤销）将会很费时。如果对于所考虑的断言的波动性不清楚，操作者应该以谨慎为原则，并将其排除在 SVID 之外。&lt;/p&gt;
&lt;h4 id=&#34;范围和影响&#34;&gt;范围和影响&lt;/h4&gt;
&lt;p&gt;SVID 由位于其信任域中的授权机构签名。签名授权机构有责任验证其签署的 SVID 中的所有信息，而包含在 SVID 中的所有断言实际上都是由签名授权机构所做的断言。&lt;/p&gt;
&lt;p&gt;此授权机构的影响和断言所做的范围是自然有限的。一个信任域的授权机构的权限不应该对其他信任域中的实体做出断言（即其断言的范围仅限于其控制下的实体）。同样，在消费 SVID 数据时，消费者应该将其中包含的所有断言视为受到 SVID 所在信任域的限制。&lt;/p&gt;
&lt;p&gt;例如：如果信任域 A 和 B 都使用名为“role”的属性，那么信任域 A 中具有“admin”角色的实体可以使用该角色做出自己信任域中 SVID 的断言，但信任域 B 中的实体不能使用与 A 中相同的断言对其 SVID 进行断言。&lt;/p&gt;
&lt;p&gt;在这方面，SPIFFE 设计意图是将这些信任域之间的安全隔离形式化并保证在接受 SPIFFE SVID 的所有系统中得到正确执行。&lt;/p&gt;
&lt;h4 id=&#34;解释&#34;&gt;解释&lt;/h4&gt;
&lt;p&gt;通过签名 SVID 断言，签名授权机构明确其对所签名断言的含义的解释。此解释的范围由信任域的信任基础确定。&lt;/p&gt;
&lt;p&gt;此外，消费者和其他参与者也可以对断言的含义进行自己的解释。例如，可能存在一个交叉信任域的场景，其中包含了不同信任域中的实体。这些实体可能会在实体之间以不同方式解释相同的断言。&lt;/p&gt;
&lt;p&gt;操作者和开发人员在评估任何给定 SVID 断言的相对安全性时应该非常小心，特别是如果要验证的 SVID 属于不同的信任域。尽管通常情况下这种情况不会出现问题，但它也可能会导致复杂的安全问题，甚至不可知的问题。&lt;/p&gt;
&lt;h4 id=&#34;真实性&#34;&gt;真实性&lt;/h4&gt;
&lt;p&gt;就像所有数字证书和断言一样，SVID 的真实性取决于其颁发方的安全性。签名授权机构的私钥的保护是 SVID 真实性的主要保障。如果授权机构的私钥暴露或泄漏，那么可以生成无效 SVID，并可能会导致错误的授权。&lt;/p&gt;
&lt;p&gt;授权机构的私钥的安全性是信任域操作员的责任，他们应该采取必要的措施来确保私钥的安全，包括使用强大的密码学方法（如硬件安全模块）来保护私钥。此外，应定期更换私钥以降低突破的风险。&lt;/p&gt;
&lt;p&gt;授权机构的私钥的安全性也是操作员选择是否使用外部信任域授权机构的一个重要考虑因素。如果使用外部授权机构的私钥进行签名，那么授权机构的私钥的安全性不再完全由信任域操作员控制，而是由外部授权机构的授权机构控制。这可能会引入一些风险和不确定性，特别是如果外部授权机构是第三方服务或实体。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;请注意，上述文档是一个假设的 SPIFFE（面向所有人的安全生产身份框架）标准的核心规范的示例草稿。实际的 SPIFFE 规范可能会包含更多细节和具体规定，同时也可能会参考其他相关规范。在实际使用中，请始终参考最新的 SPIFFE 规范文档以确保遵守正确的标准和规定。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于本书</title>
      <link>https://lib.jimmysong.io/spiffe/preface/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/preface/</guid>
      <description>&lt;p&gt;本书介绍了服务身份的 SPIFFE 标准，以及 SPIFFE 的参考实现 SPIRE。这些项目为现代异构基础设施提供了一个统一的身份控制平面。这两个项目都是开源的，隶属于云原生计算基金会（CNCF）。&lt;/p&gt;
&lt;p&gt;随着企业发展他们的应用架构以充分利用新的基础设施技术，他们的安全模式也必须不断发展。软件已经从一个单片机上的单个应用发展到了几十甚至几百个紧密联系的微服务，这些微服务可能分布在公共云或私人数据中心的数千个虚拟机上。在这个新的基础设施世界里，SPIFFE 和 SPIRE 帮助保障系统的安全。&lt;/p&gt;
&lt;p&gt;本书努力提炼了 SPIFFE 和 SPIRE 的最重要的专家经验，以提供对身份问题的深刻理解，并协助你解决这些问题。通过这些项目，开发和运维可以利用新的基础设施技术构建软件，同时让安全团队摆脱昂贵和耗时的人工安全流程。&lt;/p&gt;
&lt;h2 id=&#34;关于零号乌龟&#34;&gt;关于零号乌龟&lt;/h2&gt;
&lt;p&gt;访问控制、秘密管理和身份是相互依赖的。大规模地管理秘密需要有效的访问控制；实施访问控制需要身份；证明身份需要拥有一个秘密。保护一个秘密需要想出一些办法来保护另一个秘密，这就需要保护那个秘密，以此类推。&lt;/p&gt;
&lt;p&gt;这让人想起一个著名的轶事：一个女人打断了一位哲学家的讲座，告诉他世界是在乌龟的背上。当哲学家问她乌龟靠的是什么时，她说：&amp;ldquo;还是乌龟！&amp;quot;。找到底层的乌龟，即所有其他安全所依赖的坚实基础，是 SPIFFE 和 SPIRE 项目的目标。&lt;/p&gt;
&lt;p&gt;本书封面上的 &amp;ldquo;零号乌龟&amp;rdquo; 就是这只底层乌龟。零代表了数据中心和云计算的安全基础。零号是值得信赖的，愉快地支持所有其他的乌龟。&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 是帮助你为你的组织找到底层乌龟的项目。通过这本书中的工具，我们希望你也能为 &amp;ldquo;底层乌龟&amp;rdquo; 找到一个家。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPIFFE 工作负载 API</title>
      <link>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-workload-api/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-workload-api/</guid>
      <description>&lt;p&gt;对于互联网工作负载而言，可移植和互操作的网络工作负载的加密身份可能是 SPIFFE 的核心用例。为了完全满足这个需求，社区必须达成一致，采用一种标准化的方式来检索、验证和与 SPIFFE 身份进行交互。本规范概述了要支持基于 SPIFFE 的身份验证系统所需的 API 签名和客户端/服务器行为。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载 API 是一个 API，它提供了信息和服务，使工作负载或计算进程能够利用 SPIFFE 身份和基于 SPIFFE 的身份验证系统。它由 SPIFFE 工作负载端点提供，并由一些服务或“概要”组成。&lt;/p&gt;
&lt;p&gt;目前，有两个概要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X.509-SVID 概要&lt;/li&gt;
&lt;li&gt;JWT-SVID 概要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个概要是强制性的，并且 SPIFFE 实现必须支持它们。但是，运营商可以在部署中禁用特定的概要。&lt;/p&gt;
&lt;p&gt;本规范的未来版本可能会引入其他概要或使一个或多个概要成为可选项。&lt;/p&gt;
&lt;h2 id=&#34;可扩展性&#34;&gt;可扩展性&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载 API 不能超出本规范进行扩展。希望提供扩展功能的实现者可以通过引入新的 gRPC 服务来实现，这是根据 SPIFFE 工作负载端点规范中概述的可扩展性方法来实现的。&lt;/p&gt;
&lt;h2 id=&#34;服务定义&#34;&gt;服务定义&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载 API 由一份协议缓冲区（版本 3）服务定义来定义。完整的定义可以在 workloadapi.proto 中找到。&lt;/p&gt;
&lt;p&gt;概要作为单个&lt;code&gt;WorkloadAPI&lt;/code&gt;服务中的一组相关的 RPC 实现。&lt;/p&gt;
&lt;h2 id=&#34;客户端和服务器行为&#34;&gt;客户端和服务器行为&lt;/h2&gt;
&lt;h3 id=&#34;身份标识调用者&#34;&gt;身份标识调用者&lt;/h3&gt;
&lt;p&gt;SPIFFE 工作负载 API 支持任意数量的本地客户端，使其能够引导任何能够访问它的进程的身份标识。通常，希望为每个进程分配身份标识，其中某些进程被授予特定的身份标识。为了做到这一点，SPIFFE 工作负载 API 实现必须能够确定调用者的身份标识。&lt;/p&gt;
&lt;p&gt;SPIFFE 工作负载端点规范规定了不直接进行客户端身份验证的要求，而是依赖于带外真实性检查。因此，SPIFFE 工作负载端点实现有责任识别调用者。然后，SPIFFE 工作负载 API 可以利用有关调用者的信息来确定要提供的适当内容。有关详细信息，请参阅 SPIFFE 工作负载端点规范中的身份验证部分。&lt;/p&gt;
&lt;h3 id=&#34;连接生命周期&#34;&gt;连接生命周期&lt;/h3&gt;
&lt;p&gt;SPIFFE 工作负载 API 的客户端应尽可能保持打开连接的状态，等待流上接收服务器的响应消息。连接可以随时由服务器或客户端终止。在这种情况下，客户端应立即建立新连接。这有助于确保工作负载保持最新的身份相关材料。SPIFFE 工作负载 API 服务器实现者可以假设此属性，如果未能及时接收到消息，则工作负载可能过时，可能会影响其可用性。&lt;/p&gt;
&lt;h3 id=&#34;流式响应&#34;&gt;流式响应&lt;/h3&gt;
&lt;p&gt;SPIFFE 工作负载 API 包括使用 gRPC 服务器端流式传输的 RPC，以促进快速传播更新，例如吊销和 CA 证书引入。这使得客户端可以循环遍历服务器响应，接受发生的更新。&lt;/p&gt;
&lt;p&gt;服务器发送的每个流式响应消息都必须包含完整的信息集，而不仅仅是发生更改的信息。这避免了在客户端和服务器实现上进行状态跟踪的复杂性，包括对反熵机制的需求。&lt;/p&gt;
&lt;p&gt;服务器响应消息的确切定时是特定于实现的，并且应由更改响应的事件（例如 SVID 旋转、CRL 更新等）来决定。从客户端接收到请求消息被视为生成响应的事件。换句话说，服务器响应流的第一个响应消息（基于连接的基础上）应尽快发送，不延迟。&lt;/p&gt;
&lt;p&gt;最后，SPIFFE 工作负载 API 服务器的实现者应小心地推送更新的响应消息。一些软件可能会在接收到新信息后自动重新加载，如果所有实例同时重新加载，可能会导致一段时间的不可用。&lt;/p&gt;
&lt;h2 id=&#34;默认值和删除的信息&#34;&gt;默认值和删除的信息&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload API 响应消息是对先前发送的响应消息的完整更新。当响应消息包含设置为默认值或空值的字段时，客户端必须将这些字段的值解释为已设置为它们的默认值或空值；在接收到字段的默认值或空值之后，先前接收到的非默认值或非空值不应由客户端保留。例如，如果客户端在&lt;code&gt;federated_bundles&lt;/code&gt;字段中接收到默认值，则应舍弃先前接收到的&lt;code&gt;federated_bundles&lt;/code&gt;值。&lt;/p&gt;
&lt;p&gt;由于每个消息必须包含完整的信息集（请参阅 Stream Responses 部分），客户端应将数据的缺失解释为删除。例如，如果客户端加载了&lt;code&gt;spiffe://foo.bar&lt;/code&gt;的 bundle，并接收到不包含&lt;code&gt;spiffe://foo.bar&lt;/code&gt;的 bundle 的消息，则应卸载该 bundle。&lt;/p&gt;
&lt;h3 id=&#34;强制字段&#34;&gt;强制字段&lt;/h3&gt;
&lt;p&gt;为了执行 profile RPC，交换的消息由强制和可选字段组成。服务器在接收到具有默认值的强制字段的消息时，应使用“InvalidArgument”gRPC 状态代码进行响应（有关更多信息，请参阅 SPIFFE Workload Endpoint 规范中的错误代码部分）。当客户端接收到具有默认值的强制字段的消息时，应报告错误并丢弃该消息。&lt;/p&gt;
&lt;h3 id=&#34;联邦-bundle&#34;&gt;联邦 Bundle&lt;/h3&gt;
&lt;p&gt;在此规范中定义的各种 RPC 可以返回来自外部信任域的信任 Bundle。包含外部 Bundle 可以使工作负载在信任域之间进行通信，并且是启用联邦的主要机制。代表外部信任域的 Bundle 称为&lt;em&gt;联邦 Bundle&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;在验证客户端时，验证器会选择代表客户端所呈现的信任域的 Bundle 进行验证。同样，在验证服务器时，客户端会使用代表服务器所在的信任域的 Bundle。如果在使用的 SVID 的 SVID 中不存在匹配的 Bundle，则对等方是不受信任的。这种方法是必需的，以解决常见 X.509 库中对 SAN URI Name Constraints 的广泛支持的缺乏。&lt;/p&gt;
&lt;h2 id=&#34;x509-svid-profile&#34;&gt;X.509-SVID Profile&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload API 的 X.509-SVID 配置文件提供了一组 gRPC 方法，工作负载可以使用这些方法来检索 X.509-SVIDs 及其相关的信任捆绑包。该配置文件概述了这些方法的签名，以及相关的客户端和服务器行为。&lt;/p&gt;
&lt;h3 id=&#34;配置文件定义&#34;&gt;配置文件定义&lt;/h3&gt;
&lt;p&gt;下面定义了 X.509-SVID 配置文件中的 RPC 和相关的消息。有关完整的 Workload API 服务定义，请参见 workloadapi.proto。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SpiffeWorkloadAPI&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// X509-SVID配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取工作负载有权访问的所有SPIFFE标识的X.509-SVID，以及与之相关的信任捆绑包和CRL。随着信息的更改，后续的消息将从服务器流式传输。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchX509SVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X509SVIDRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X509SVIDResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取信任捆绑包和CRL。对于仅需要验证SVID而不获取SVID自身的客户端非常有用。随着信息的更改，后续的消息将从服务器流式传输。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchX509Bundles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X509BundlesRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X509BundlesResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 其他配置文件的RPC ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509SVIDRequest消息传递请求X.509-SVID的参数。目前没有此类参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509SVIDRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509SVIDResponse消息携带X.509-SVID和相关信息，包括用于与外部信任域联合的全局CRL集合和捆绑列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509SVIDResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。X509SVID消息列表，每个消息包括单个X.509-SVID、其私钥和信任域的捆绑。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X509SVID&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svids&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。ASN.1 DER编码的证书吊销列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;crl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。工作负载应该信任的外部信任域的CA证书捆绑，按照外部信任域的SPIFFE ID进行索引。捆绑包是ASN.1 DER编码的。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;federated_bundles&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509SVID消息携带单个SVID和所有相关信息，包括信任域的X.509捆绑包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509SVID&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。此条目中的SVID的SPIFFE ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。ASN.1 DER编码的证书链。可以包括中间证书，但必须首先是叶子证书（或SVID本身）。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x509_svid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。ASN.1 DER编码的PKCS#8私钥。必须是未加密的。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x509_svid_key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。信任域的ASN.1 DER编码的X.509捆绑包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bundle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。操作员指定的字符串，用于在返回多个SVID时为工作负载提供其使用方式的指导。例如，`internal`和`external`分别表示内部或外部使用的SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509BundlesRequest消息传递请求X.509捆绑包的参数。目前没有这样的参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509BundlesRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// X509BundlesResponse消息携带一组全局CRL和工作负载应该信任的信任域的映射的CA证书捆绑包。由SPIFFE ID的信任域键控。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;X509BundlesResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。ASN.1 DER编码的证书吊销列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;crl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必需。工作负载应该信任的信任域的CA证书捆绑包，由SPIFFE ID的信任域键控。捆绑包是ASN.1 DER编码的。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bundles&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;profile-rpcs&#34;&gt;Profile RPCs&lt;/h3&gt;
&lt;h3 id=&#34;fetchx509svid&#34;&gt;FetchX509SVID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FetchX509SVID&lt;/code&gt; RPC 流式返回 X509-SVID 和信任域以及外部信任域的 X.509 捆绑包。这些捆绑包只能用于验证 X509-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X509SVIDRequest&lt;/code&gt;请求消息当前为空，是将来扩展的占位符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X509SVIDResponse&lt;/code&gt;响应由一个必需的&lt;code&gt;svids&lt;/code&gt;字段组成，该字段必须包含一个或多个&lt;code&gt;X509SVID&lt;/code&gt;消息（每个授予客户端的标识一个）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;X509SVID&lt;/code&gt;消息中的所有字段都是必需的，除了&lt;code&gt;hint&lt;/code&gt;字段。当设置&lt;code&gt;hint&lt;/code&gt;字段时（即非空），SPIFFE Workload API 服务器必须确保其值在任何给定的&lt;code&gt;X509SVIDResponse&lt;/code&gt;消息中是唯一的。如果 SPIFFE Workload API 客户端遇到具有相同设置的&lt;code&gt;hint&lt;/code&gt;值的多个&lt;code&gt;X509SVID&lt;/code&gt;消息，则应选择列表中的第一个消息。&lt;/p&gt;
&lt;p&gt;如果客户端没有权限接收任何 X509-SVID，则服务器应以“PermissionDenied”gRPC 状态代码响应（有关更多信息，请参见 SPIFFE Workload Endpoint 规范中的“错误代码”部分）。在这种情况下，客户端可以在退避后尝试重新连接到&lt;code&gt;FetchX509SVID&lt;/code&gt; RPC 的另一个调用。&lt;/p&gt;
&lt;p&gt;如流式响应所述，每个 FetchX509SVID 流返回的 X509SVIDResponse 消息都包含客户端在那个时间点上的授权 SVID 和 bundle 的完整集合。因此，如果服务器从后续响应中删除了 SVID（或全部 SVID，即返回“PermissionDenied”gRPC 状态代码），客户端应停止使用已删除的 SVID。&lt;/p&gt;
&lt;h3 id=&#34;fetchx509bundles&#34;&gt;FetchX509Bundles&lt;/h3&gt;
&lt;p&gt;FetchX509Bundles RPC 流返回服务器所在的信任域和外部信任域的 X.509 bundles。这些 bundles 只用于验证 X509-SVID。&lt;/p&gt;
&lt;p&gt;X509BundlesRequest 请求消息目前为空，是未来扩展的占位符。&lt;/p&gt;
&lt;p&gt;X509BundlesResponse 响应消息有一个强制性的 bundles 字段，必须至少包含服务器所在信任域的信任 bundle。crl 字段是可选的。&lt;/p&gt;
&lt;p&gt;如果客户端无权接收任何 X.509 bundles，那么服务器应以“PermissionDenied”gRPC 状态代码响应（有关更多信息，请参见 SPIFFE Workload Endpoint 规范中的错误代码部分）。客户端可以在退避后尝试重新连接 FetchX509Bundles RPC。&lt;/p&gt;
&lt;p&gt;如流式响应所述，每个 X509BundleResponse 响应在那个时间点上包含客户端的授权 X.509 bundles 的完整集合。因此，如果服务器从后续响应中删除了 bundles（或全部 bundles，即返回“PermissionDenied”gRPC 状态代码），客户端应停止使用已删除的 bundles。&lt;/p&gt;
&lt;h3 id=&#34;默认身份&#34;&gt;默认身份&lt;/h3&gt;
&lt;p&gt;通常情况下，工作负载不知道它应该扮演什么身份。决定何时扮演何种身份是特定于站点的问题，因此，SPIFFE 规范不涉及如何做到这一点。&lt;/p&gt;
&lt;p&gt;为了支持最广泛的用例，X.509-SVID 配置文件支持发出多个身份，并定义了默认身份。预计了解多个身份的工作负载可以自行进行决策。不了解如何利用多个身份的工作负载可以使用默认身份。默认身份是在 X509SVIDResponse 消息中返回的&lt;code&gt;svids&lt;/code&gt;列表中的第一个。协议缓冲区确保列表的顺序得到保留。&lt;/p&gt;
&lt;p&gt;了解如何使用多个身份的工作负载可以利用可选的&lt;code&gt;hint&lt;/code&gt;字段，该字段可用于消除身份的歧义，并告知工作负载应该为何目的使用哪个身份。例如，&lt;code&gt;internal&lt;/code&gt;和&lt;code&gt;external&lt;/code&gt;分别表示用于内部或外部使用的 SVID。SPIFFE Workload API 实现不应支持超过 1024 字节长度的值。&lt;code&gt;hint&lt;/code&gt;字段的确切值是操作员的选择，除此规范外并无限制。&lt;/p&gt;
&lt;p&gt;工作负载有责任处理预期提示的缺失或意外存在（例如，失败、警告等）。&lt;/p&gt;
&lt;h2 id=&#34;jwt-svid-配置文件&#34;&gt;JWT-SVID 配置文件&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload API 的 JWT-SVID 配置文件提供了一组 gRPC 方法，可以用于工作负载获取 JWT-SVID 及其相关的信任包。该配置文件概述了这些方法的签名，以及相关的客户端和服务器行为。&lt;/p&gt;
&lt;h3 id=&#34;配置文件定义-1&#34;&gt;配置文件定义&lt;/h3&gt;
&lt;p&gt;JWT-SVID 配置文件的 RPC 和相关消息如下所定义。有关完整的 Workload API 服务定义，请参见 workloadapi.proto。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;service&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SpiffeWorkloadAPI&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// JWT-SVID配置文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;/////////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取工作负载有权访问的所有SPIFFE标识的JWT-SVID，用于请求的受众。如果请求了可选的SPIFFE ID，则仅返回该SPIFFE ID的JWT-SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchJWTSVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JWTSVIDRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JWTSVIDResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 获取以JWKS文档格式表示的JWT信任包，由信任域的SPIFFE ID作为键。随着这些信息的更改，后续的消息将从服务器流式传输。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FetchJWTBundles&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JWTBundlesRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JWTBundlesResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 根据请求的受众验证JWT-SVID。返回JWT-SVID的SPIFFE ID和JWT声明。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;rpc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ValidateJWTSVID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValidateJWTSVIDRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;returns&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ValidateJWTSVIDResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// ... 其他配置文件的RPC ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTSVIDRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。工作负载打算进行身份验证的受众。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audience&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。请求的JWT-SVID的SPIFFE ID。如果未设置，则返回工作负载有权访问的所有标识的JWT-SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTSVIDResponse消息传递JWT-SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTSVIDResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。返回的JWT-SVID列表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;repeated&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JWTSVID&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svids&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTSVID消息携带JWT-SVID令牌和相关元数据。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTSVID&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。JWT-SVID的SPIFFE ID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。使用JWS紧凑序列化的编码JWT。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 可选。操作员指定的字符串，用于在返回多个SVID时为工作负载提供如何使用此标识的指导。例如，`internal`和`external`分别表示用于内部或外部使用的SVID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hint&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTBundlesRequest消息传递请求JWT信任包的参数。目前没有请求参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTBundlesRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// JWTBundlesReponse传递JWT信任包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;JWTBundlesResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。以信任域的SPIFFE ID为键的JWK编码的JWT信任包。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bundles&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ValidateJWTSVIDRequest消息传递JWT-SVID验证的请求参数。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ValidateJWTSVIDRequest&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。验证方的受众。JWT-SVID必须包含一个包含此值的受众声明才能成功验证。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audience&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。要验证的JWT-SVID，使用JWS紧凑序列化进行编码。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;svid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ValidateJWTSVIDReponse消息传递JWT-SVID验证结果。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ValidateJWTSVIDResponse&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。验证的JWT-SVID的SPIFFE ID。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spiffe_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 必填。验证的JWT-SVID有效载荷中包含的声明。包括SPIFFE所需和非所需的声明。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;google.protobuf.Struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;claims&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;配置文件-rpc&#34;&gt;配置文件 RPC&lt;/h3&gt;
&lt;h3 id=&#34;获取-jwtsvid&#34;&gt;获取 JWTSVID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FetchJWTSVID&lt;/code&gt; RPC 允许客户端请求一个或多个特定受众的短期 JWT-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTSVIDRequest&lt;/code&gt; 请求消息包含一个必填的&lt;code&gt;audience&lt;/code&gt;字段，该字段必须包含要嵌入返回的 JWT-SVID 中的受众声明的值。&lt;code&gt;spiffe_id&lt;/code&gt;字段是可选的，用于请求特定 SPIFFE ID 的 JWT-SVID。如果未指定，服务器必须返回授权给客户端的所有身份的 JWT-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTSVIDResponse&lt;/code&gt; 响应消息由一个必填的&lt;code&gt;svids&lt;/code&gt;字段组成，该字段必须包含一个或多个&lt;code&gt;JWTSVID&lt;/code&gt;消息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTSVID&lt;/code&gt;消息中的所有字段都是必填的，除了&lt;code&gt;hint&lt;/code&gt;字段。当设置了&lt;code&gt;hint&lt;/code&gt;字段（即非空）时，SPIFFE Workload API 服务器必须确保其值在给定的&lt;code&gt;JWTSVIDResponse&lt;/code&gt;消息中的返回的 SVID 集合中是唯一的。如果 SPIFFE Workload API 客户端遇到具有相同&lt;code&gt;hint&lt;/code&gt;值设置的多个&lt;code&gt;JWTSVID&lt;/code&gt;消息，则应选择列表中的第一个消息。&lt;/p&gt;
&lt;p&gt;如果客户端没有授权任何身份，或者未经授权访问&lt;code&gt;spiffe_id&lt;/code&gt;字段请求的特定身份，则服务器应使用“PermissionDenied”gRPC 状态代码进行响应（有关更多信息，请参见 SPIFFE Workload 端点规范中的错误代码部分）。&lt;/p&gt;
&lt;h3 id=&#34;获取-jwt-bundles&#34;&gt;获取 JWT Bundles&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;FetchJWTBundles&lt;/code&gt; RPC 返回服务器所在的信任域和外部信任域的 JWT bundles。这些 bundles 必须仅用于认证 JWT-SVID。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTBundlesRequest&lt;/code&gt;请求消息目前为空，是未来扩展的占位符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JWTBundlesResponse&lt;/code&gt;响应消息由一个必填的&lt;code&gt;bundles&lt;/code&gt;字段组成，该字段必须至少包含服务器所在信任域的 JWT bundle。&lt;/p&gt;
&lt;p&gt;返回的 bundles 以&lt;a href=&#34;https://tools.ietf.org/html/rfc7517&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7517&lt;/a&gt;定义的标准 JWK Set 格式进行编码，其中包含信任域的 JWT-SVID 签名密钥。这些密钥可能仅表示 SPIFFE 信任域中的密钥子集。服务器不得在返回的 JWT bundles 中包含其他用途的密钥。&lt;/p&gt;
&lt;p&gt;如果客户端无权接收任何 JWT bundles，则服务器应使用“PermissionDenied”gRPC 状态代码进行响应（有关更多信息，请参见 SPIFFE Workload 端点规范中的错误代码部分）。客户端可以在退避后尝试重新连接到&lt;code&gt;FetchJWTBundles&lt;/code&gt; RPC 的另一个调用。&lt;/p&gt;
&lt;p&gt;如流式响应中所述，每个&lt;code&gt;JWTBundleResponse&lt;/code&gt;响应在当前时间点包含客户端的所有授权 JWT bundles 的完整集合。因此，如果服务器从后续响应中删除 bundles（或所有 bundles，即返回“PermissionDenied”gRPC 状态代码），客户端应停止使用被删除的 bundles。&lt;/p&gt;
&lt;h3 id=&#34;验证-jwtsvid&#34;&gt;验证 JWTSVID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ValidateJWTSVID&lt;/code&gt; RPC 代表客户端验证特定受众的 JWT-SVID。此外，服务器必须根据 JWT-SVID 规范中概述的规则解析和验证 JWT-SVID。JWT-SVID 负载中嵌入的声明应在&lt;code&gt;ValidateJWTSVIDResponse&lt;/code&gt;中的&lt;code&gt;claims&lt;/code&gt;字段中提供；本规范中定义的声明是必需的，但实现可能会在将它们返回给客户端之前过滤非 SPIFFE 声明。SPIFFE 声明对于互操作性是必需的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValidateJWTSVIDRequest&lt;/code&gt;和&lt;code&gt;ValidateJWTSVIDResponse&lt;/code&gt;消息中的所有字段都是必填的。&lt;/p&gt;
&lt;h3 id=&#34;jwt-svid-验证&#34;&gt;JWT-SVID 验证&lt;/h3&gt;
&lt;p&gt;如果客户端支持，Workload API 客户端应使用&lt;code&gt;ValidateJWTSVID&lt;/code&gt;方法进行 JWT 验证，允许 SPIFFE Workload API 代表其执行验证。这样做可以避免工作负载实现验证逻辑，从而减少出错的可能性。&lt;/p&gt;
&lt;p&gt;当与传统的 JWT 验证器进行交互时，可以使用&lt;code&gt;FetchJWTBundles&lt;/code&gt;方法获取 JWKS bundles，用于验证 JWT-SVID 的签名。例如，如果 SPIFFE Workload API 可用，但 JWT 验证软件不知道 Workload API（因此无法调用&lt;code&gt;ValidateJWTSVID&lt;/code&gt;），则实现可以单独检索每个 bundle 并将其提供给传统工作负载进行验证。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FetchJWTBundles&lt;/code&gt;方法返回以信任域的 SPIFFE ID 为键的 bundles。在验证 JWT-SVID 时，验证器必须使用与主题的信任域对应的 bundle。如果指定信任域的 JWT bundle 不存在，则令牌是不可信的。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-示例实现状态机&#34;&gt;附录 A. 示例实现状态机&lt;/h2&gt;
&lt;p&gt;为了提供清晰度，作者认为包括 SPIFFE Workload API 的客户端和服务器实现的示例状态图可能是有用的。应注意，有许多实现方式可以符合本规范，此特定实现仅供参考。&lt;/p&gt;
&lt;h3 id=&#34;服务器状态机&#34;&gt;服务器状态机&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务器状态机&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/workload_api_server_diagram.png&#34; alt=&#34;服务器状态机&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务器状态机
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SPIFFE Workload 端点侦听器正在启动。&lt;/li&gt;
&lt;li&gt;使用 SPIFFE Workload API 处理程序启动 gRPC 服务器，现在可以接受连接。&lt;/li&gt;
&lt;li&gt;正在验证传入的 FetchX509SVIDRequest。这包括检查强制性的安全头，并确保调用方可用身份。&lt;/li&gt;
&lt;li&gt;Workload API 正在向客户端发送 FetchX509SVIDResponse。&lt;/li&gt;
&lt;li&gt;Workload API 处于等待状态。从等待状态过渡需要中断或取消。中断等待状态的典型原因是响应中的信息已更新（例如，SVID 已旋转或 CRL 已更改）。&lt;/li&gt;
&lt;li&gt;对待处理的响应执行验证。确保客户端仍有权使用身份，并且请求尚未取消。&lt;/li&gt;
&lt;li&gt;服务器正在关闭流，为客户端提供正确的错误代码以表示遇到的条件。&lt;/li&gt;
&lt;li&gt;服务器遇到致命错误，必须停止。这可能发生在无法创建侦听器或 gRPC 服务器遇到致命错误的情况下。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;客户端状态机&#34;&gt;客户端状态机&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-客户端状态机&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/workload_api_client_diagram.png&#34; alt=&#34;客户端状态机&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      客户端状态机
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Workload API 客户端正在拨号 SPIFFE Workload 端点。&lt;/li&gt;
&lt;li&gt;客户端正在调用 FetchX509SVID RPC 调用，向服务器发送请求。&lt;/li&gt;
&lt;li&gt;客户端正在阻塞等待从服务器接收 X509SVIDResponse 消息。&lt;/li&gt;
&lt;li&gt;客户端正在使用从服务器响应中接收的 SVIDs、CRLs 和 bundles 更新其配置。此时，它可以将接收到的信息与当前配置进行比较，确定是否需要重新加载。&lt;/li&gt;
&lt;li&gt;客户端遇到致命错误，必须退出。&lt;/li&gt;
&lt;li&gt;客户端正在执行指数回退。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SPIRE 基本概念</title>
      <link>https://lib.jimmysong.io/spiffe-and-spire/concept/spire/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe-and-spire/concept/spire/</guid>
      <description>&lt;p&gt;SPIRE 是 &lt;a href=&#34;../spiffe&#34;&gt;SPIFFE API&lt;/a&gt; 的一个生产就绪的实现，它执行节点和工作负载认证，以便根据一组预先定义的条件，安全地向工作负载发出 SVID，并验证其他工作负载的 SVID。&lt;/p&gt;
&lt;h2 id=&#34;spire-架构和组件&#34;&gt;SPIRE 架构和组件&lt;/h2&gt;
&lt;p&gt;SPIRE 部署由一个 SPIRE 服务器和一个或多个 SPIRE 代理组成。服务器充当通过代理向一组工作负载发放身份的签名机构。它还维护一个工作负载身份的注册表，以及为签发这些身份而必须验证的条件。代理在本地向工作负载公开 SPIFFE 工作负载 API，必须安装在工作负载运行的每个节点上。&lt;/p&gt;
















&lt;figure  id=&#34;figure-spire-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/spire-arch.svg&#34; alt=&#34;SPIRE 架构图&#34; loading=&#34;lazy&#34; data-zoomable width=&#34;30%&#34; /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SPIRE 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;h2 id=&#34;服务器&#34;&gt;服务器&lt;/h2&gt;
&lt;p&gt;SPIRE 服务器负责管理和发布其配置的 SPIFFE 信任域中的所有身份。它存储注册条目（指定决定特定 SPIFFE ID 应被签发的条件的选择器）和签名密钥，使用节点证明来自动验证代理的身份，并在被验证的代理请求时为工作负载创建 SVID。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-spire-服务器&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/spire-server.svg&#34; alt=&#34;SPIRE 服务器&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SPIRE 服务器
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;服务器的行为是通过一系列的插件决定的。SPIRE 包含几个插件，你可以建立额外的插件来扩展 SPIRE 以满足特定的使用情况。插件的类型包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点证明器插件&lt;/strong&gt;：与代理节点证明器一起，验证代理运行的节点的身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点解析器插件&lt;/strong&gt;：它通过验证关于节点的额外属性来扩展服务器可以用来识别节点的选择器集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据存储插件&lt;/strong&gt;：服务器用它来存储、查询和更新各种信息，如注册条目、哪些节点已认证、这些节点的选择器是什么。有一个内置的数据存储插件，可以使用 MySQL、SQLite3 或 PostgresSQL 数据库来存储必要的数据。默认情况下，使用 SQLite 3。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥管理器插件&lt;/strong&gt;：控制服务器如何存储用于签署 X.509-SVID 和 JWT-SVID 的私钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上游权威机构插件&lt;/strong&gt;：默认情况下，SPIRE 服务器充当其自身的证书授权机构。但是，你可以使用上游权威机构插件来使用来自不同 PKI 系统的不同 CA。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以通过配置插件和其他各种配置变量来定制服务器的行为。详见 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器配置参考&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;
&lt;p&gt;SPIRE 代理在已识别的工作负载所运行的每个节点上运行。该代理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从服务器上请求 SVID，并将其缓存起来，直到工作负载请求其 SVID 为止。&lt;/li&gt;
&lt;li&gt;向节点上的工作负载公开 SPIFFE 工作负载 API，并证明调用它的工作负载的身份&lt;/li&gt;
&lt;li&gt;为已识别的工作负载提供其 SVID&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-spire-代理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/spire-agent.svg&#34; alt=&#34;SPIRE 代理&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SPIRE 代理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;该代理的主要组成部分包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点证明器插件&lt;/strong&gt;：与服务器节点证明器一起，验证代理运行的节点的身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作负载证明器插件&lt;/strong&gt;：通过从节点操作系统中查询有关工作负载进程的信息，并将其与你在使用选择器注册工作负载属性时提供给服务器的信息进行比较，来验证节点上工作负载进程的身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;密钥管理器插件&lt;/strong&gt;：代理用来生成和使用颁发给工作负载的 X.509-SVID 的私钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以通过配置插件和其他配置变量来定制代理的行为。详见《&lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_agent/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理配置参考》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;自定义服务器和代理插件&#34;&gt;自定义服务器和代理插件&lt;/h2&gt;
&lt;p&gt;你可以为特定的平台和架构创建自定义的服务器和代理插件，而 SPIRE 并不包括这些插件。例如，你可以为一个架构创建服务器和代理节点验证器，而不是在节点验证下总结的那些。或者你可以创建一个自定义密钥管理器插件，以 SPIRE 目前不支持的方式处理私钥。因为 SPIRE 在运行时加载自定义插件，你不需要重新编译 SPIRE 来启用它们。&lt;/p&gt;
&lt;h2 id=&#34;工作负载注册&#34;&gt;工作负载注册&lt;/h2&gt;
&lt;p&gt;为了让 SPIRE 识别工作负载，你必须通过注册条目向 SPIRE 服务器注册工作负载。工作负载注册告诉 SPIRE 如何识别工作负载以及为其提供哪个 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;注册条目将身份（以 SPIFFE ID 的形式）映射到一组称为选择器的属性，工作负载必须拥有这些属性才能获得特定身份。在工作负载证明期间，代理使用这些选择器值来验证工作负载的身份。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/registering/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 文档&lt;/a&gt;中详细介绍了工作负载注册。&lt;/p&gt;
&lt;h2 id=&#34;证明&#34;&gt;证明&lt;/h2&gt;
&lt;p&gt;SPIRE 上下文中的证明（attestation）是断言工作负载的身份。SPIRE 通过从受信任的第三方收集工作负载进程本身和运行 SPIRE 代理的节点的属性并将它们与工作负载注册时定义的一组选择器进行比较来实现这一点。&lt;/p&gt;
&lt;p&gt;用于执行证明的可信第三方 SPIRE 查询是特定于平台的。&lt;/p&gt;
&lt;p&gt;SPIRE 分两个阶段执行证明：首先是节点证明（其中验证工作负载正在运行的节点的身份），然后是工作负载证明（其中验证节点上的工作负载）。&lt;/p&gt;
&lt;p&gt;SPIRE 有一个灵活的架构，允许它根据工作负载运行的环境，使用许多不同的受信第三方进行节点和工作负载验证。你通过代理和服务器配置文件中的条目告诉 SPIRE 使用哪些受信任的第三方，并通过你在注册工作负载时指定的选择器值告诉 SPIRE 使用哪些类型的信息进行验证。&lt;/p&gt;
&lt;h3 id=&#34;节点证明&#34;&gt;节点证明&lt;/h3&gt;
&lt;p&gt;SPIRE 要求每个代理在首次连接到服务器时进行身份验证和自我验证；这个过程称为节点证明（Node Attestation）。在节点证明期间，代理和服务器一起验证运行代理的节点的身份。他们通过称为节点证明器的插件来做到这一点。所有节点证明器都向节点及其环境询问只有该节点拥有的信息片段，以证明该节点的身份。&lt;/p&gt;
&lt;p&gt;节点证明的成功后，代理收到唯一的 SPIFFE ID。然后，代理的 SPIFFE ID 充当其负责的工作负载的“父级”。&lt;/p&gt;
&lt;p&gt;节点身份证明的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过云平台交付给节点的身份证明文件（例如 AWS Instance 身份证明文件）&lt;/li&gt;
&lt;li&gt;验证存储在连接到节点的硬件安全模块或可信平台模块上的私钥&lt;/li&gt;
&lt;li&gt;安装代理时通过加入令牌提供的手动验证&lt;/li&gt;
&lt;li&gt;多节点软件系统安装在节点上时提供的标识凭据（例如 Kubernetes 服务账户令牌）&lt;/li&gt;
&lt;li&gt;其他机器身份证明（例如部署的服务器证书）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点证明器向服务器返回一组（可选）节点选择器，用于标识特定机器（例如 Amazon 实例 ID）。由于在定义工作负载的身份时，单个机器的特定身份通常没有用处，因此 SPIRE 会查询&lt;a href=&#34;https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-resolution&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;节点解析器&lt;/a&gt;（如果有）以查看可以验证被证明节点的哪些附加属性（例如，如果节点是 AWS 安全组的成员）。来自证明器和解析者的选择器集成为与代理节点的 SPIFFE ID 关联的选择器集。&lt;/p&gt;
&lt;div class=&#34;alert-note-title&#34;&gt;
    &lt;p&gt;注意&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
    节点证明不需要节点选择器，除非你&lt;a href=&#34;https://spiffe.io/docs/latest/spire/using/registering/#mapping-workloads-to-multiple-nodes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将工作负载映射到多个节点&lt;/a&gt;。
&lt;/div&gt;

&lt;p&gt;下图说明了节点证明中的步骤。在此图中，底层平台是 AWS：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-spire-节点证明步骤&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/spire-node-attestor.svg&#34; alt=&#34;SPIRE 节点证明步骤&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SPIRE 节点证明步骤
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;步骤总结节点证明&#34;&gt;步骤总结：节点证明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;代理 AWS 节点证明器插件向 AWS 查询节点身份证明，并将该信息提供给代理。&lt;/li&gt;
&lt;li&gt;代理将此身份证明传递给服务器。服务器将此数据传递给其 AWS 节点证明器。&lt;/li&gt;
&lt;li&gt;服务器 AWS 节点证明器独立验证身份证明，或者通过调用 AWS API，使用它在步骤 2 中获得的信息。节点证明器还为代理创建一个 SPIFFE ID，并将其传递回服务器进程，以及它发现的任何节点选择器。&lt;/li&gt;
&lt;li&gt;服务器发回代理节点的 SVID。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;节点证明器&#34;&gt;节点证明器&lt;/h4&gt;
&lt;p&gt;代理和服务器通过它们各自的节点证明器询问底层平台。SPIRE 支持节点证明器在各种环境中证明节点身份，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS 上的 EC2 实例（使用 EC2 实例身份文档）&lt;/li&gt;
&lt;li&gt;Microsoft Azure 上的 VM（使用 Azure 托管服务标识）&lt;/li&gt;
&lt;li&gt;Google Cloud Platform 上的 Google Compute Engine 实例（使用 GCE 实例身份令牌）&lt;/li&gt;
&lt;li&gt;作为 Kubernetes 集群成员的节点（使用 Kubernetes 服务账户令牌）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于没有平台可以直接识别节点的情况，SPIRE 包括用于证明的节点证明器：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用服务器生成的加入令牌&lt;/strong&gt;—— 加入令牌（join token）是 SPIRE 服务器和代理之间的预共享密钥。服务器可以在安装后生成加入令牌，该令牌可用于在代理启动时对其进行验证。为帮助防止滥用，加入令牌在使用后立即过期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用现有的 X.509 证书&lt;/strong&gt;—— 有关配置节点证明器的信息，请参阅 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_server/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 服务器配置参考&lt;/a&gt;和 &lt;a href=&#34;https://spiffe.io/docs/latest/deploying/spire_agent/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 代理配置参考&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;节点解析&#34;&gt;节点解析&lt;/h4&gt;
&lt;p&gt;一旦验证了单个节点的身份，“节点解析器”插件就会扩展一组选择器，这些选择器可用于通过验证节点的其他属性来识别节点（例如，如果节点是特定 AWS 安全组的成员） ，或具有与之关联的特定标签）。只有服务器参与节点解析。SPIRE 在证明之后直接运行一次节点解析器。&lt;/p&gt;
&lt;h4 id=&#34;节点解析器&#34;&gt;节点解析器&lt;/h4&gt;
&lt;p&gt;服务器支持以下平台的节点解析器插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;亚马逊网络服务（AWS）&lt;/li&gt;
&lt;li&gt;微软 Azure&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工作负载证明&#34;&gt;工作负载证明&lt;/h3&gt;
&lt;p&gt;工作负载证明提出了一个问题：“这是谁的进程？”代理通过询问本地可用的权限（例如节点的操作系统内核，或在同一节点上运行的本地 kubelet）来回答这个问题，以确定调用工作负载 API 的进程的属性。&lt;/p&gt;
&lt;p&gt;然后，当你使用选择器注册工作负载的属性时，将这些属性与提供给服务器的信息进行比较。&lt;/p&gt;
&lt;p&gt;这些类型的信息可能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;底层操作系统如何调度进程。在基于 Unix 的系统上，这可能是用户 ID (uid)、组 ID (gid)、文件系统路径等。）&lt;/li&gt;
&lt;li&gt;进程是如何由 Kubernetes 等编排系统调度的。在这种情况下，工作负载可能由运行它的 Kubernetes 服务账户或命名空间来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然代理和服务器都在节点证明中发挥作用，但只有代理参与工作负载证明。&lt;/p&gt;
&lt;p&gt;下图说明了工作负载证明的步骤：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-工作负载证明&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/workload-attestation.svg&#34; alt=&#34;工作负载证明&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      工作负载证明
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;步骤摘要工作负载证明&#34;&gt;步骤摘要：工作负载证明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;工作负载调用工作负载 API 以请求 SVID。在 Unix 系统上，这被暴露为 Unix 域套接字。&lt;/li&gt;
&lt;li&gt;代理询问节点的内核以识别调用者的进程 ID。然后，它调用任何已配置的工作负载证明器插件，为它们提供工作负载的进程 ID。&lt;/li&gt;
&lt;li&gt;工作负载证明者使用进程 ID 来发现有关工作负载的其他信息，并根据需要查询相邻平台特定的组件，例如 Kubernetes kubelet。通常，这些组件也与代理驻留在同一节点上。&lt;/li&gt;
&lt;li&gt;证明者将发现的信息以选择器的形式返回给代理。&lt;/li&gt;
&lt;li&gt;代理通过将发现的选择器与注册条目进行比较来确定工作负载的身份，并将正确的缓存 SVID 返回给工作负载。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;工作负载证明者&#34;&gt;工作负载证明者&lt;/h4&gt;
&lt;p&gt;SPIRE 包括适用于 Unix、Kubernetes 和 Docker 的工作负载证明器插件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPIFFE 的历史和动机</title>
      <link>https://lib.jimmysong.io/spiffe/history-and-motivation-for-spiffe/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/history-and-motivation-for-spiffe/</guid>
      <description>&lt;p&gt;本章介绍了 SPIFFE 的动机和它是如何诞生的。&lt;/p&gt;
&lt;h2 id=&#34;压倒性的动机和需要&#34;&gt;压倒性的动机和需要&lt;/h2&gt;
&lt;p&gt;我们到达今天的位置，首先要经历一些成长的痛苦。&lt;/p&gt;
&lt;p&gt;当互联网在 1981 年首次广泛使用时，它只有 213 个不同的服务器，而安全问题&lt;a href=&#34;https://tools.ietf.org/html/rfc1296&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;几乎没有被考虑到&lt;/a&gt;。随着互联计算机数量的增加，安全问题仍然是一个弱点：容易被利用的漏洞导致了大规模的攻击，如&lt;a href=&#34;https://spaf.cerias.purdue.edu/tech-reps/823.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;莫里斯蠕虫病毒&lt;/a&gt;，它在 1988 年占领了互联网上的大多数 Unix 服务器，或 &lt;a href=&#34;https://www.caida.org/publications/papers/2003/sapphire/sapphire.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Slammer 蠕虫病毒&lt;/a&gt;，它在 2003 年在数十万台 Windows 服务器上传播。&lt;/p&gt;
&lt;p&gt;随着时间的推移，过去的传统周边防御模式已经不能很好地适应不断发展的计算架构和现代技术的边界。各种解决方案和技术层出不穷，以掩盖基础网络安全概念未能跟上现代化趋势而出现的越来越大的裂缝。&lt;/p&gt;
&lt;p&gt;那么，为什么周边模式如此普遍，怎样才能解决这些缺陷？&lt;/p&gt;
&lt;p&gt;多年来，我们观察到三大的趋势，突出了传统的周边模式对网络未来的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件不再在组织控制的单个服务器上运行。自 2015 年以来，新的软件通常被构建为微服务的集合，可以单独扩展或转移到云主机供应商。如果你不能在需要安全的服务周围画出一条精确的线，就不可能在它们周围筑起一道墙。&lt;/li&gt;
&lt;li&gt;你不能相信一切，即使是公司内的软件。曾经，我们认为软件漏洞就像苍蝇，我们可以单独拍打；现在，它们似乎更像一群蜜蜂。平均而言，国家漏洞数据库每年报告超过 &lt;a href=&#34;https://nvd.nist.gov/vuln/search/statistics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;15000 个新的软件漏洞&lt;/a&gt;。如果你编写或购买了一个软件，它在某些时候可能会有一些漏洞。&lt;/li&gt;
&lt;li&gt;你也不能相信人，他们会犯错，会心烦意乱，再加上他们可以完全接触到内部服务。首先，每年有&lt;a href=&#34;https://www.comparitech.com/blog/vpn-privacy/phishing-statistics-facts/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数以万计的攻击是基于网络钓鱼&lt;/a&gt;或窃取有效的员工凭证。其次，随着云计算应用和移动工作队伍的出现，员工可以合法地从许多不同的网络访问资源。当人们为了工作而不得不不断地来回穿越这堵墙时，建造一堵墙就不再有意义了。正如你所看到的，对于当今的组织来说，周界安全不再是一个现实的解决方案。当周界安全被严格执行时，阻碍了组织使用微服务和云；当周界安全松懈时，它给了入侵者可乘之机。2004 年，Jericho 论坛认识到需要一个周界安全的继承者。十年后的 2014 年，谷歌发布了一个&lt;a href=&#34;https://research.google/pubs/pub43231/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;关于 BeyondCorp 安全架构的案例研究&lt;/a&gt;。然而，两者都没有被广泛的采用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络曾经是友好的只要我们保持自律&#34;&gt;网络曾经是友好的，只要我们保持自律&lt;/h2&gt;
&lt;p&gt;最初的互联网使用案例集中在学术界，目的是分享信息，而不是组织意外访问。当其他组织开始将联网的计算机系统用于商业敏感的场景时，他们在很大程度上依赖于物理周界和物理证明，以保证访问网络的个人得到授权。当时还不存在受信任的内部威胁的概念。随着网络从学术用途发展到商业用途，软件从单体发展到微服务，安全成为增长的障碍。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-11网络的演变从大学校园的范围到全球网络的范围&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-1.jpg&#34; alt=&#34;图 1.1：网络的演变从大学校园的范围到全球网络的范围。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.1：网络的演变从大学校园的范围到全球网络的范围。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最初，通过防火墙、网络分段、私有地址空间和 ACL 来模拟墙和警卫来保护计算机的物理访问的传统方法。这在当时是有意义的，特别是考虑到需要控制的点的数量有限。&lt;/p&gt;
&lt;p&gt;随着网络的扩散，以及用户和商业伙伴访问点的增加，通过安全地交换和管理密钥、凭证和令牌，物理身份验证（常见于墙和警卫）变得虚拟化，随着技术和需求的发展，所有这些都变得越来越有问题。&lt;/p&gt;
&lt;h2 id=&#34;采用公共云&#34;&gt;采用公共云&lt;/h2&gt;
&lt;p&gt;从传统的内部部署和数据中心运作迁移到公共云，放大了现有问题。&lt;/p&gt;
&lt;p&gt;随着人们获得了在云中创建计算资源的自由，企业内的开发团队和运维团队开始更紧密地合作，并围绕着专注于软件自动化部署和管理的 DevOps 概念形成新的团队。公共云快速发展的动态环境使团队能够更频繁地进行部署 —— 从每几个月部署一次，到每天部署多次。按需配置和部署资源的能力使人们能够高速创建专门的、有针对性的、可独立部署的服务套件，其责任范围较小，俗称为&lt;strong&gt;微服务&lt;/strong&gt;。这反过来又增加了跨部署集群识别和访问服务的需要。&lt;/p&gt;
&lt;p&gt;这种高度动态和弹性的环境打破了公认的边界安全概念，需要更好的服务水平互动，与基础网络无关。传统的边界执行使用 IP 和端口进行认证、授权和审计，在云计算范式下，这不再是干净地映射到工作负载。&lt;/p&gt;
&lt;p&gt;公共云的参与所激发的模式，如 API 网关或用于多服务工作负载的管理的负载均衡器，强调了对不依赖网络拓扑或路径的身份的需求。保护这些服务间的通信的完整性变得更加重要，特别是对于需要跨工作负载统一性的团队。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-12随着企业网络的复杂性增加加上云计算saas-和移动负载建立和维护周边安全变得越来越难&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-2.jpg&#34; alt=&#34;图 1.2：随着企业网络的复杂性增加，加上云计算、SaaS 和移动负载，建立和维护周边安全变得越来越难。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.2：随着企业网络的复杂性增加，加上云计算、SaaS 和移动负载，建立和维护周边安全变得越来越难。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;休斯顿我们有一个问题&#34;&gt;休斯顿，我们有一个问题&lt;/h2&gt;
&lt;p&gt;随着企业采用新技术，如容器、微服务、云计算和无服务器功能，有一个趋势是明确的：更多更小的软件。这既增加了攻击者可以利用的潜在漏洞的数量，也使得管理周边防御越来越不现实。&lt;/p&gt;
&lt;p&gt;这种趋势正在加快，这意味着越来越多的组件被部署在自动化基础设施上，往往牺牲了安全和保障。绕过手动流程，如防火墙规则票或安全组的变化，并非闻所未闻。在这个新的现代世界里，无论部署环境如何，面向网络的访问控制都会迅速过时，需要不断维护。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-13随着新技术创新的激增基础设施环境和相关的操作需求也越来越复杂&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-3.jpg&#34; alt=&#34;图 1.3：随着新技术创新的激增，基础设施环境和相关的操作需求也越来越复杂。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.3：随着新技术创新的激增，基础设施环境和相关的操作需求也越来越复杂。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些规则和例外情况的管理可以自动化，然而，它们需要迅速发生，这在较大的基础设施中可能是一个挑战。此外，网络拓扑结构，如网络地址转换（NAT），会使其变得困难。随着基础设施变得越来越大，越来越动态，依靠人力的系统根本无法扩展。毕竟，没有人愿意花钱请一个整天玩弄防火墙规则的团队，而他们仍然无法跟上需求的进度。&lt;/p&gt;
&lt;p&gt;依靠特定地点的细节，如服务器名称、DNS 名称、网络接口细节，在一个动态调度和弹性扩展的应用世界里有几个缺点。虽然网络结构的使用很普遍，但该模型是软件身份的一个无效的模拟。在应用层，使用传统的用户名和密码组合或其他硬编码的凭证，可以赋予一定程度的身份，但更多的是处理授权而不是认证。&lt;/p&gt;
&lt;p&gt;在软件开发生命周期的早期整合安全并引入反馈，使开发人员能够对其工作负载的识别和信息交换机制进行更多的操作控制。有了这种变化，授权政策的决定可以委托给个别服务或产品所有者，他们最适合做出与有关组件相关的决定。&lt;/p&gt;
&lt;h2 id=&#34;重新认识访问控制&#34;&gt;重新认识访问控制&lt;/h2&gt;
&lt;p&gt;在采用公有云之前，企业所经历的问题不断增加，而采用公有云后，企业又痛苦地出现了问题，这就推动了传统的周界是不够的，需要有更好的解决方案的概念。最终，去边界化意味着企业需要弄清楚如何识别他们的软件并实现服务对服务的访问控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案之一：秘密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;像密码和 API 密钥这样的共享秘密为分布式系统的访问控制提供了一个简单的选择。但这种解决方案也带来了许多问题。密码和 API 密钥很容易被泄露（试着在 GitHub 上搜索 &amp;ldquo;client_secret&amp;rdquo; 这样的短语，看看会发生什么）。在大型组织中，秘密可能很难因泄露而轮换，因为每个服务都需要以一种协调的方式意识到变化（而错过一个服务可能会导致停工）。&lt;/p&gt;
&lt;p&gt;诸如 HashiCorp Vault 这样的工具和秘密存储库已经被开发出来，以帮助缓解秘密管理和生命周期的困难。虽然也有许多其他工具试图解决这个问题，但它们往往提供了一个更加有限的解决方案，效果平平（见 &lt;a href=&#34;https://www.youtube.com/watch?v%3D15H5uCj1hlE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Secrets at Scale: Automated Bootstrapping of Secrets &amp;amp; Identity in the Cloud&lt;/a&gt;）。有了所有这些选择，我们最终还是回到了同一个问题上：工作负载应该如何获得对这个秘密库的访问？仍然需要一些 API 密钥、密码或其他秘密。&lt;/p&gt;
&lt;p&gt;所有这些解决方案最终都会出现“乌龟下面还有一只乌龟&amp;quot; 的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启用对资源的访问控制，如数据库或其他资源。&lt;/li&gt;
&lt;li&gt;服务需要一个秘密，如 API 密钥或密码。&lt;/li&gt;
&lt;li&gt;该钥匙或密码需要被保护，所以你可以保护它，比如说用加密。但是，你仍然担心密码的解密密钥。&lt;/li&gt;
&lt;li&gt;该解密密钥可以被放入秘密库，但这样你仍然需要一些凭证，如密码或 API 密钥来访问秘密库。&lt;/li&gt;
&lt;li&gt;最终，为了保护对秘密的访问会产生需要保护的一个新秘密。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了打破这个循环，我们需要找到一个底层乌龟，也就是说，一些秘密提供了对我们所需的认证和访问控制的其他秘密的访问。一种选择是在服务部署时手动提供秘密。然而，这在高度动态的生态系统中是无法扩展的。随着企业转向具有快速部署管道和自动扩展资源的云计算，随着新计算单元的创建，手动配置秘密变得不可行。而当一个秘密被破坏时，使旧的凭证失效会带来使整个系统崩溃的风险。&lt;/p&gt;
&lt;p&gt;在应用程序中嵌入一个秘密，这样它就不需要手动配置了，其安全属性甚至更差。嵌入到源代码中的秘密有一个习惯，那就是出现在公共存储库中（你试过我建议的 GitHub 搜索吗）。虽然秘密可以在构建时被嵌入到机器镜像中，但这些镜像最终还是会被意外地推送到公共镜像库中，或者作为杀毒链的第二步从内部镜像库中提取。&lt;/p&gt;
&lt;p&gt;我们希望有一种解决方案，不包括长期存在的秘密（这些秘密很容易被破坏，也很难轮换），也不需要人工向工作负载提供秘密。为了实现这一点，无论是在硬件还是在云提供商，都&lt;strong&gt;必须有一个信任的根&lt;/strong&gt;，&lt;strong&gt;在此基础上建立一个以软件（工作负载）身份为中心的自动化解决方案&lt;/strong&gt;。然后，这种身份构成了所有需要认证和授权的互动的基础。为了避免产生另一个底层乌龟，工作负载需要能够在没有秘密或其他凭证的情况下获得这一身份。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-14有了健全的身份基石就不再是一路乌龟了&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-4.jpg&#34; alt=&#34;图 1.4：有了健全的身份基石，就不再是一路乌龟了。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.4：有了健全的身份基石，就不再是一路乌龟了。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迈向未来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自 2010 年以来，业界为解决软件身份问题进行了多种努力。谷歌的低开销认证服务（LOAS），后来被命名为&lt;a href=&#34;https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用层传输安全（ALTS）&lt;/a&gt;，建立了一个新的身份格式和有线协议，用于从运行时环境接收软件身份，并将其应用于所有网络通信。它被称为&lt;strong&gt;拨号音安全（dial tone security）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在另一个例子中，Netflix 的内部开发的解决方案（代号为 &lt;a href=&#34;https://www.usenix.org/sites/default/files/conference/protected-files/enigma_haken_slides.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Metatron&lt;/a&gt;）通过利用云 API 来证明实例上运行的机器镜像，并通过 CI/CD 集成来产生机器镜像和代码身份之间的加密绑定，从而在每个实例基础上建立软件身份。这种软件身份采取 X.509 证书的形式，对服务间的通信进行相互认证，包括访问作为该解决方案一部分开发的&lt;strong&gt;秘密服务&lt;/strong&gt;，在此基础上实现秘密管理。&lt;/p&gt;
&lt;p&gt;业界的其他一些努力，包括来自 &lt;a href=&#34;https://engineering.fb.com/security/service-encryption/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Facebook 等公司的努力&lt;/a&gt;，证明了对这样一个系统的需要，并强调了实施的难度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普适安全生产身份框架（SPIFFE）的愿景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在成立通用的解决方案之前，需要建立一个框架编码原则。Kubernetes 的创始工程师 Joe Beda 在过去的工作中接触过各种技术，这些技术使工程团队的生活更加轻松，他在 2016 年开始呼吁为生产身份创建一个解决方案，作为一个专门的解决方案，旨在以一种通用的方式解决问题，可以在许多不同类型的系统中利用，而不是以艰难的方式进行 PKI 的中间解决方案。这种公司之间的大规模合作努力，为基于 PKI 的服务身份开发了一个新的标准，这就是 SPIFFE 的开始。&lt;/p&gt;
&lt;p&gt;2016 年 Beda 在 &lt;a href=&#34;https://engineering.fb.com/security/service-encryption/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GlueCon 上发表的论文&lt;/a&gt;展示了一个具有这些参数的难题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过利用基于内核的自省来获得关于调用者的信息，而无需调用者出示凭证，从而解决零号秘密的问题。&lt;/li&gt;
&lt;li&gt;使用 X.509，因为大多数软件已经兼容，而且&lt;/li&gt;
&lt;li&gt;有效地将身份的概念从网络定位器中剥离出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在引入 SPIFFE 概念之后，Netflix 服务认证方面的专家举行了一次会议，讨论原始 SPIFFE 提案的最终形态和可行性。许多成员已经实施了、继续改进并重新解决了工作负载识别问题，突出了社区合作的机会。参加会议的成员希望获得彼此之间的互操作性。这些专家意识到他们已经实施了类似的解决方案来解决同样的问题，可以建立一个共同的标准。&lt;/p&gt;
&lt;p&gt;解决工作负载身份问题的最初目标是建立一个开放的规范和相应的生产实现。该框架需要在不同的实现和现成的软件之间提供互操作性，其核心是在一个不信任的环境中建立信任的根基，驱除隐性信任。最后，摆脱以网络为中心的身份，以实现灵活性和更好的扩展特性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-15起源2016-年在-netflix-的会议上安全专家们开始勾勒出-spiffe-的蓝图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-5.jpg&#34; alt=&#34;图 1.5：起源：2016 年在 Netflix 的会议上，安全专家们开始勾勒出 SPIFFE 的蓝图。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1.5：起源：2016 年在 Netflix 的会议上，安全专家们开始勾勒出 SPIFFE 的蓝图。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPIFFE 工作负载端点</title>
      <link>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-workload-endpoint/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-workload-endpoint/</guid>
      <description>&lt;p&gt;对于网络工作负载而言，可移植且互操作的加密身份可能是 SPIFFE 的核心用例之一。为了完全满足这一要求，社区必须达成一致，以标准化检索身份和在运行时使用身份相关服务的方式。&lt;/p&gt;
&lt;p&gt;SPIFFE 工作负载终端点规范通过定义一个终端点来提供 SPIFFE 可验证身份文档（SVIDs）和相关服务。具体而言，它概述了如何定位终端点以及如何服务或使用它。这个终端点所暴露的服务集合超出了本文档的范围，但有一个例外，即 SPIFFE 工作负载 API。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点是一个 API 终端点，工作负载或正在运行的计算进程可以通过它在运行时访问与身份相关的服务（如身份签发或身份验证）。这个终端点可以暴露任意数量的与身份相关的服务，但至少，符合规范的环境中运行的工作负载可以期望 SPIFFE 工作负载 API 可用。&lt;/p&gt;
&lt;p&gt;本文档详细介绍了 SPIFFE 工作负载终端点的可访问性和范围、传输协议、身份验证过程以及可扩展性/发现机制。&lt;/p&gt;
&lt;h2 id=&#34;可访问性&#34;&gt;可访问性&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点通常用作初始身份引导的机制，包括传递和管理信任根的过程。由于在早期阶段，工作负载可能对自己的身份或应该信任的对象没有任何先验知识，因此很难确保对终端点的访问安全。因此，SPIFFE 工作负载终端点应通过本地终端点公开，并且实现者不应将同一终端点实例公开给多个主机。将终端点和相关流量限制在单个主机上可以减轻与初始身份验证和签发安全相关的引导问题。更多详细信息，请参见 传输 和 身份验证 部分。&lt;/p&gt;
&lt;h2 id=&#34;传输&#34;&gt;传输&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点必须通过 gRPC 进行提供，并且符合规范的客户端必须支持 gRPC。它可以作为 Unix 域套接字（Unix Domain Socket，UDS）或 TCP 监听套接字公开。实现者应优先选择 Unix 域套接字传输，但如果 Unix 域套接字不可行或不可能，也可以支持 TCP 传输。除非底层网络允许工作负载终端点服务器根据源 IP 地址（例如通过本地主机或链路本地网络）或其他强网络级断言（例如通过 SDN 策略）对工作负载进行强身份验证，否则不得使用 TCP 传输。&lt;/p&gt;
&lt;p&gt;为了防止 &lt;a href=&#34;https://www.owasp.org/index.php/Server_Side_Request_Forgery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务器端请求伪造&lt;/a&gt;（SSRF）攻击，每个客户端请求 SPIFFE 工作负载终端点时，都必须包含静态的 gRPC 元数据键 &lt;code&gt;workload.spiffe.io&lt;/code&gt;，其值为 &lt;code&gt;true&lt;/code&gt;（区分大小写）。未包含此元数据键/值的请求必须被 SPIFFE 工作负载终端点拒绝（有关详细信息，请参见 错误代码 部分）。这样可以防止攻击者利用 SSRF 漏洞访问 SPIFFE 工作负载终端点，除非该漏洞还使攻击者能够控制出站 gRPC 元数据。&lt;/p&gt;
&lt;h3 id=&#34;传输安全&#34;&gt;传输安全&lt;/h3&gt;
&lt;p&gt;尽管 gRPC 强烈推荐使用传输层安全（Transport Layer Security，TLS），但不得要求 SPIFFE 工作负载终端点。由于 SPIFFE 工作负载终端点通常传递和管理信任根，我们不能指望工作负载具有对活跃根的先进知识。因此，在早期阶段，工作负载可能无法验证所呈现身份的真实性，除非通过 Workload API 实现的特权位置。这是 SPIFFE 工作负载终端点实例不应公开给多个主机的另一个原因。有关更多信息，请参见 身份验证 部分。&lt;/p&gt;
&lt;h2 id=&#34;定位终端点&#34;&gt;定位终端点&lt;/h2&gt;
&lt;p&gt;客户端可以显式配置套接字位置，也可以使用名为 &lt;code&gt;SPIFFE_ENDPOINT_SOCKET&lt;/code&gt; 的众所周知的环境变量。如果没有显式配置，符合规范的客户端必须回退到环境变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SPIFFE_ENDPOINT_SOCKET&lt;/code&gt; 环境变量的值结构化为 &lt;a href=&#34;https://www.ietf.org/rfc/rfc3986.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986&lt;/a&gt; URI。方案（scheme）必须设置为 &lt;code&gt;unix&lt;/code&gt; 或 &lt;code&gt;tcp&lt;/code&gt;，分别表示终端点通过 Unix 域套接字或 TCP 监听套接字提供服务。&lt;/p&gt;
&lt;p&gt;如果方案设置为 &lt;code&gt;unix&lt;/code&gt;，则授权组件不得设置，路径组件必须设置为 SPIFFE 工作负载终端点 Unix 域套接字的绝对路径（例如 &lt;code&gt;unix:///path/to/endpoint.sock&lt;/code&gt;）。方案和路径组件是强制的，不得设置其他组件。&lt;/p&gt;
&lt;p&gt;如果方案设置为 &lt;code&gt;tcp&lt;/code&gt;，则授权的主机组件必须设置为 IP 地址，授权的端口组件必须设置为 SPIFFE 工作负载终端点 TCP 监听套接字的 TCP 端口号。方案、主机和端口组件是强制的，不得设置其他组件。例如，&lt;code&gt;tcp://127.0.0.1:8000&lt;/code&gt; 是有效的，而 &lt;code&gt;tcp://127.0.0.1:8000/foo&lt;/code&gt; 是无效的。&lt;/p&gt;
&lt;h2 id=&#34;身份验证&#34;&gt;身份验证&lt;/h2&gt;
&lt;p&gt;SPIFFE 工作负载终端点通常用作初始身份引导的机制。因此，预期工作负载没有任何可用于自身身份验证的“秘密”材料。为了适应这一非常重要的用例，SPIFFE 工作负载终端点不得要求直接对其客户端进行身份验证。&lt;/p&gt;
&lt;p&gt;实现者应该执行带外真实性检查，而不是直接的客户端身份验证。这可以包括内核检查或编排工具询问等技术。例如，可以通过检查内核套接字状态来了解调用 API 的进程是哪个。另一种方法是允许编排工具将 Unix 域套接字放入特定容器中，向 SPIFFE 工作负载终端点实现传递容器的属性/身份信息。然后可以将此信息用作身份验证机制。&lt;/p&gt;
&lt;p&gt;应注意，虽然如何实现这一点的方法是特定于实现的，但所选择的方法不得要求工作负载积极参与其中。&lt;/p&gt;
&lt;h2 id=&#34;错误代码&#34;&gt;错误代码&lt;/h2&gt;
&lt;p&gt;在与 SPIFFE Workload 端点交互时，客户端可能会遇到多种错误条件。例如，客户端请求可能省略了必需的安全头部（请参阅传输部分获取更多信息），或者 SPIFFE Workload 端点实现可能仍在初始化或无法使用。&lt;/p&gt;
&lt;p&gt;如果收到不包含必需安全头部的客户端请求，实现必须使用 gRPC 状态码 &amp;ldquo;InvalidArgument&amp;rdquo; 进行响应。如果客户端收到 &amp;ldquo;InvalidArgument&amp;rdquo; 状态码，不应重试，因为这表示客户端实现有误，不可恢复。&lt;/p&gt;
&lt;p&gt;如果 SPIFFE Workload 端点实现正在运行但不可用，例如仍在初始化或执行负载均衡，客户端将收到 gRPC 状态码 &amp;ldquo;Unavailable&amp;rdquo;。如果客户端收到这个状态码，或者无法到达 SPIFFE Workload 端点，可以使用指数退避重试。&lt;/p&gt;
&lt;p&gt;最后，如果给定调用者/客户端没有为 SPIFFE Workload 端点服务定义身份，服务应使用 gRPC 状态码 &amp;ldquo;PermissionDenied&amp;rdquo; 进行响应。如果客户端收到这个状态码，可以使用指数退避重试，因为在实现最终一致性的情况下可能会遇到此类响应。&lt;/p&gt;
&lt;p&gt;请参阅 附录 A 获取错误条件和代码的摘要。&lt;/p&gt;
&lt;h2 id=&#34;可扩展性和提供的服务&#34;&gt;可扩展性和提供的服务&lt;/h2&gt;
&lt;p&gt;SPIFFE Workload 端点可以提供多种与身份相关的服务，例如身份发放或身份验证。通过使用 gRPC/Protobuf 服务原语来公开单个服务。为了扩展 SPIFFE Workload 端点，必须引入一个新的（唯一命名的）服务。&lt;/p&gt;
&lt;p&gt;由于本规范承诺提供强大的可移植性，作者认为允许扩展现有逻辑服务与 SPIFFE 的精神相悖。如果通过向现有逻辑服务添加端点来提供附加功能，那么在从一个符合 SPIFFE 的环境移动到另一个环境时，无法保证可移植性。因此，不能直接扩展现有的 gRPC 逻辑服务，如 SPIFFE Workload API。相反，可以通过添加 SPIFFE 规范集中未描述的独立逻辑服务来增强端点。&lt;/p&gt;
&lt;p&gt;虽然所有 SPIFFE Workload 端点实现都必须公开 SPIFFE Workload API，但有时很难知道给定环境中支持哪些附加服务。因此，端点实现者应该包含对 &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/doc/server-reflection.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC Server Reflection&lt;/a&gt; 的支持。如果客户端遇到不支持 gRPC Server Reflection 的端点，应假设唯一可用的服务是 SPIFFE Workload API 中定义的那些。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-错误代码列表&#34;&gt;附录 A. 错误代码列表&lt;/h2&gt;
&lt;p&gt;本节列出了 SPIFFE Workload 端点实现可能返回的各种错误代码、返回条件以及如何处理它们。请参阅 错误代码 部分和 &lt;a href=&#34;https://godoc.org/google.golang.org/grpc/codes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC Code package 文档&lt;/a&gt; 以获取有关这些代码的更多信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;th&gt;条件&lt;/th&gt;
&lt;th&gt;客户端行为&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;InvalidArgument&lt;/td&gt;
&lt;td&gt;客户端请求中未包含 gRPC 安全头部。请参阅 传输部分 获取更多信息。&lt;/td&gt;
&lt;td&gt;报告错误，不要重试。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Unavailable&lt;/td&gt;
&lt;td&gt;SPIFFE Workload 端点实现无法处理请求。&lt;/td&gt;
&lt;td&gt;使用指数退避重试。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PermissionDenied&lt;/td&gt;
&lt;td&gt;客户端无权执行请求的操作。根据实现的情况，这可能表示工作负载在身份或信任域被配置之前就已启动。&lt;/td&gt;
&lt;td&gt;使用指数退避重试。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>收益</title>
      <link>https://lib.jimmysong.io/spiffe/benefits/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/benefits/</guid>
      <description>&lt;p&gt;本章从业务和技术的角度解释了在基础设施中部署 SPIFFE 和 SPIRE 的好处。&lt;/p&gt;
&lt;h2 id=&#34;任何人任何地方都适用&#34;&gt;任何人任何地方都适用&lt;/h2&gt;
&lt;p&gt;SPIFFE 和 SPIRE 旨在加强对软件组件的识别，以一种通用的方式，任何人在任何地方都可以在分布式系统中加以利用。现代基础设施的技术环境是错综复杂的。环境在硬件和软件投资的混合下变得越来越不一样。通过对系统定义、证明和维护软件身份标准化的方式来维护软件安全，无论系统部署在哪里，也无论谁来部署这些系统，都会带来许多好处。&lt;/p&gt;
&lt;p&gt;对于专注于提高业务便利性和回报的企业领导人来说，SPIFFE 和 SPIRE 可以大大降低管理和签发加密身份文件（如 X.509 证书）的开销，开发人员无需了解服务间通信所需的身份和认证技术，从而加速开发和部署。&lt;/p&gt;
&lt;p&gt;对于专注于提供强大、安全和可互操作产品的服务提供商和软件供应商来说，SPIFFE 和 SPIRE 解决了在将许多解决方案互连到最终产品时普遍存在的关键身份问题。例如，SPIFFE 可以作为产品的 TLS 功能和用户管理/认证功能的基础，一举两得。还有，SPIFFE 可以取代管理和发行平台访问的 API 令牌的需要，&lt;strong&gt;免费&lt;/strong&gt;带来令牌轮换，并消除存储和管理访问所述令牌的客户负担。&lt;/p&gt;
&lt;p&gt;对于希望不仅加强传输中的数据安全，而且实现监管合规并解决其信任根源问题的安全从业人员来说，SPIFFE 和 SPIRE 致力于在不信任的环境中提供相互认证，而不需要交换秘密。安全和管理边界可以很容易地划定，并且在策略允许的情况下，可以跨越这些边界进行通信。&lt;/p&gt;
&lt;p&gt;对于需要身份管理抽象的开发人员、运维和 DevOps 从业人员，以及需要与现代云原生服务和解决方案互操作的工作负载和应用程序，SPIFFE 和 SPIRE 在整个软件开发生命周期中与许多其他工具兼容，以提供可靠的产品。开发人员可以继续他们的工作，直接进入业务逻辑，而不必担心证书、私钥和 JavaScript Web Token（JWT）等烦人的问题。&lt;/p&gt;
&lt;h2 id=&#34;对于企业领导人&#34;&gt;对于企业领导人&lt;/h2&gt;
&lt;h3 id=&#34;现代的组织有现代的需求&#34;&gt;现代的组织有现代的需求&lt;/h3&gt;
&lt;p&gt;在今天的商业环境中，通过差异化的应用和服务快速提供创新的客户体验是保持竞争优势的必要条件。因此，企业见证了应用程序和服务的架构、构建和部署方式的变化。诸如云和容器等新技术帮助企业更快、更大规模地发布。服务需要高速构建并部署在大量的平台上。随着开发速度的加快，这些系统变得越来越相互依赖和相互联系，以提供一致的客户体验。&lt;/p&gt;
&lt;p&gt;组织在实现高速发展和获得市场份额或任务保证方面可能会受到抑制，主要原因是合规性、专业知识的储备以及团队 / 组织之间和现有解决方案内的互操作性挑战。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互操作性的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着系统的发展，对互操作性的需求也在无限地增长。脱节的团队建立的服务是孤立的，互不相识，尽管他们最终需要意识到彼此的存在。收购发生时，新的或从未见过的系统需要被整合到现有的系统中。商业关系的建立，需要与可能存在于堆栈深处的服务建立新的沟通渠道。所有这些挑战都围绕着“我如何以安全的方式将所有这些服务连接在一起，每个服务都有自己独特的属性和历史？”&lt;/p&gt;
&lt;p&gt;当不同的技术栈必须结合在一起进行互操作时，由于组织融合而产生的技术整合可能是一个挑战。为系统与系统之间的通信与身份和认证制定一个共同的、行业认可的标准，可以简化跨多个堆栈的完全互操作性和整合的技术问题。&lt;/p&gt;
&lt;p&gt;SPIFFE 带来了对构成软件身份的共识。通过进一步利用 SPIFFE Federation，不同组织或团队的不同系统中的组件可以建立信任，安全地进行通信，而不需要增加诸如 VPN 隧道、one-off 证书或用于这些系统之间的共享凭证等结构的开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合规性和可审计性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 实施中的可审计性保证了执行行动的身份不会因为在环境中执行相互认证而被否定。此外，SPIFFE/SPIRE 发布的身份文件使相互认证的 TLS 得到广泛使用，有效地解决了与这种性质的项目相关的最困难的挑战之一。相互认证的 TLS 的其他好处包括对服务之间传输的数据进行本地加密，不仅保护了通信的完整性，还保证了敏感或专有数据的保密性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-21-使用-spiffe-无缝地满足合规和监管目标&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f2-1.jpg&#34; alt=&#34;图 2.1: 使用 SPIFFE 无缝地满足合规和监管目标。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2.1: 使用 SPIFFE 无缝地满足合规和监管目标。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;另一个常见的合规要求是由《通用数据保护条例》（GDPR）带来的 —— 特别是要求欧盟（EU）的数据完全停留在欧盟内部，而不是在其管辖范围之外的实体中转或被处理。有了多个信任根基，全球组织可以确保欧盟实体只与其他欧盟实体沟通。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专业知识库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保开发、安全和运营团队具备正确的知识和经验，以适当地处理安全敏感系统，仍然是一项重大挑战。企业需要雇用具有基于标准的技能组合的开发人员，以减少入职时间，并在减少风险的情况下改善产品效率。&lt;/p&gt;
&lt;p&gt;解决以自动方式向每个软件实例提供加密身份的问题，并从根本上实现凭证轮换，是一项重大挑战。对于安全和运维团队来说，具有的实施此类系统所需的专业知识少之又少。在不依靠社区或行业知识的情况下维持日常运营会使问题恶化，导致中断和指责。&lt;/p&gt;
&lt;p&gt;不能合理地期望开发人员了解或获得安全的实际问题的专业知识，特别是在组织环境中适用于服务身份。此外，在开发、运维和工作负载执行方面具有深度知识的安全从业人员的储备是非常少的。利用一个开放的标准和开放的规范来解决关键的身份问题，允许没有个人经验的人通过一个得到良好支持的、不断增长的 SPIFFE/SPIRE 终端用户和从业人员社区来扩展知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节约&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用 SPIFFE/SPIRE 可以在许多方面节省成本，包括减少云 / 平台锁定，提高开发人员的效率，以及减少对专业知识的依赖，等等。&lt;/p&gt;
&lt;p&gt;通过将云提供商的身份接口抽象为一套建立在开放标准上的定义明确的通用 API，SPIFFE 大大减轻了开发和维护&lt;strong&gt;云感知&lt;/strong&gt;应用的负担。由于 SPIFFE 是平台无关的，它几乎可以在任何地方部署。当需要改变平台技术时，这种差异化可以节省时间和金钱，甚至可以加强与现有平台供应商的谈判地位。从历史上看，身份和访问管理服务是由每个组织自己的部署指挥和控制平台 —— 云服务提供商知道这一点，并利用这一制约因素作为主要的锁定机制，与他们的平台完全整合。&lt;/p&gt;
&lt;p&gt;在提高开发人员的效率方面也有很大的节省。SPIFFE/SPIRE 有两个重要方面可以节省开支：加密身份及其相关生命周期的完全自动化发布和管理，以及认证和服务间通信加密的统一性和加载性。通过消除与前者相关的手动流程，以及在后者中花费的研究和试验 / 错误时间，开发人员可以更好地专注于对他们重要的事情：业务逻辑。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;&lt;strong&gt;提高开发人员的生产力&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开发人员在获取证书和配置每个应用组件的认证 / 保密协议方面花费的平均时间（小时）。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;减少开发人员在每个应用组件上对应的证书所花费的时间。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;95%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开发人员在学习和实施特定 API 网关、秘密存储等控制方面花费的平均时间（小时）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;减少了开发人员学习和实施特定 API 网关、秘密存储等控制的时间。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;75%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;本年度开发的新应用组件的数量&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;strong&gt;预计因提高开发人员生产力而节省的时间&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;530&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;正如我们在历史上看到的那样，财富 50 强的技术组织雇用了高度熟练和专业的工程师，花了几十年时间来解决这个身份问题。将 SPIFFE/SPIRE 添加到企业的云原生解决方案目录中，可以让你在多年的超专业安全和开发人才的基础上构建，而不需要相应的成本。&lt;/p&gt;
&lt;p&gt;凭借强大的社区支持几十个到几十万个节点的部署，SPIFFE/SPIRE 在复杂、大规模环境中的运作经验可以满足组织的需求。&lt;/p&gt;
&lt;h2 id=&#34;对于服务提供商和软件供应商&#34;&gt;对于服务提供商和软件供应商&lt;/h2&gt;
&lt;p&gt;减少客户在使用产品过程中的负担，始终是所有优秀产品经理的首要目标。了解那些表面上看起来无害的功能的实际意义是很重要的。例如，如果一个数据库产品需要支持 TLS，因为这是客户的要求，很简单，在产品中添加一些配置就可以了。&lt;/p&gt;
&lt;p&gt;不幸的是，这给客户带来了一些重大的挑战。即使是看似简单的用户管理也面临类似的挑战。考虑一下这两个常见的功能在默认情况下引入的以下客户痛点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谁生成证书和密码，以及如何生成？&lt;/li&gt;
&lt;li&gt;它们如何被安全地分配给需要的应用程序？&lt;/li&gt;
&lt;li&gt;如何限制对私钥和密码的访问？&lt;/li&gt;
&lt;li&gt;这些秘密是如何存储的，才能让它们不会泄漏到备份中？&lt;/li&gt;
&lt;li&gt;当证书过期，或必须改变密码时，会发生什么？这个过程是否具有破坏性？&lt;/li&gt;
&lt;li&gt;在这些任务中，有多少是必须要有人类操作的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这些功能从客户的角度来看是可行的之前，所有这些问题都需要得到回答。通常，客户发明或安装的解决方案在操作上是很痛苦的。&lt;/p&gt;
&lt;p&gt;这些客户的负担是非常真实的。有些组织有整个团队专门负责管理这些负担。通过简单地支持 SPIFFE，上述所有的担忧都会得到缓解。该产品可以集成进现有的基础设施，并&lt;strong&gt;免费&lt;/strong&gt;增加 TLS 支持。此外，由 SPIFFE 赋予的客户（用户）身份可以直接取代管理用户凭证（如密码）的需要。&lt;/p&gt;
&lt;h3 id=&#34;平台访问管理&#34;&gt;平台访问管理&lt;/h3&gt;
&lt;p&gt;访问一个服务或平台（如 SaaS 服务）也涉及类似的挑战。归根结底，这些挑战为凭证管理所带来的固有困难，尤其是当凭证是一个共享的秘密时。&lt;/p&gt;
&lt;p&gt;考虑一下 API 令牌 —— 在 SaaS 提供商中，使用 API 令牌来验证非人类的 API 调用者是很普遍的。它们实际上是密码，而且每一个都必须由客户仔细管理。上面列出的所有挑战都适用于此。支持 SPIFFE 认证的平台大大减轻了与访问平台有关的客户负担，一次性解决了存储、发行和生命周期问题。利用 SPIFFE，问题被简化为简单地授予给定工作负载所需的权限。&lt;/p&gt;
&lt;h2 id=&#34;对于安全从业人员&#34;&gt;对于安全从业人员&lt;/h2&gt;
&lt;p&gt;技术创新不能成为安全产品的抑制因素。开发、分发和部署工具需要与安全产品和方法无缝集成，不影响软件开发的自主性或为组织带来负担。组织需要易于使用的软件产品，并为现有工具增加额外的安全性。&lt;/p&gt;
&lt;p&gt;SPIRE 不是所有安全问题的最终解决方案。它并不否定对强大的安全实践和深度防御或分层安全的需要。然而，利用 SPIFFE/SPIRE 提供跨不信任网络的信任根，使组织能够在通往&lt;a href=&#34;https://csrc.nist.gov/publications/detail/sp/800-207/final&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;零信任架构&lt;/a&gt;的道路上迈出有意义的一步，作为全面安全战略的一部分。&lt;/p&gt;
&lt;h3 id=&#34;默认安全&#34;&gt;默认安全&lt;/h3&gt;
&lt;p&gt;SPIRE 可以帮助减轻 &lt;a href=&#34;https://owasp.org/www-project-top-ten/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OWASP 的几个主要威胁&lt;/a&gt;。为了减少通过凭证泄露的可能性，SPIRE 为整个基础设施的认证提供了一个强有力的证明身份。保持证明的自动化使平台默认安全，消除了开发团队的额外配置负担。&lt;/p&gt;
&lt;p&gt;对于希望从根本上解决其产品或服务中的信任和身份问题的组织来说，SPIFFE/SPIRE 还通过实现普遍的相互 TLS 认证来解决客户的安全需求，以便在工作负载之间安全地进行通信，无论它们部署在何处。此外，与每个开源产品一样，代码库背后的社区和贡献者提供了更多双眼睛来审查合并前和合并后的代码。这个 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linus%27s_law&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;莱纳斯法则（Linus Law）&lt;/a&gt;的实施超越了&lt;strong&gt;四只眼睛&lt;/strong&gt;的原则，以确保任何潜在的错误或已知的安全问题在进入发布阶段之前被发现。&lt;/p&gt;
&lt;h3 id=&#34;策略执行&#34;&gt;策略执行&lt;/h3&gt;
&lt;p&gt;SPIRE 的 API 为安全团队提供了一种机制，以便以易于使用的方式在各平台和业务部门执行一致的认证策略。当与定义明确的策略相结合时，服务之间的互动可以保持在最低限度，确保只有授权的工作负载可以相互通信。这限制了恶意实体的潜在攻击面，并可以在策略引擎的默认拒绝规则中触发警报。&lt;/p&gt;
&lt;p&gt;SPIRE 利用一个强大的多因素证明引擎，该引擎实时运行，可以肯定地确定加密身份的发放。它还自动发放、分配和更新短期凭证，以确保组织的身份架构准确反映工作负载的运行状态。&lt;/p&gt;
&lt;h3 id=&#34;零信任&#34;&gt;零信任&lt;/h3&gt;
&lt;p&gt;在架构中采用零信任模式，可以减少漏洞发生时的爆炸半径。相互认证和信任撤销可以阻止被破坏的前端应用服务器从网络上或集群内可能存在的不相关数据库中渗出数据。虽然不可能发生在网络安全严密的组织中，但 SPIFFE/SPIRE 肯定会增加额外的防御层，以减轻错误配置的防火墙或不变的默认登录带来的漏洞和暴露点。它还将安全决策从 IP 地址和端口号（可以用不可察觉的方式进行操纵）转移到享有完整性保护的加密标识符上。&lt;/p&gt;
&lt;h3 id=&#34;记录和监控&#34;&gt;记录和监控&lt;/h3&gt;
&lt;p&gt;SPIRE 可以帮助改善基础设施的可观测性。关键的 SPIRE 事件，如身份请求和发放，是可记录的事件，有助于提供一个更完整的基础设施视图。SPIRE 还将生成各种行动的事件，包括身份注册、取消注册、验证尝试、身份发放和轮换。然后，这些事件可以被汇总并发送到组织的安全信息和事件管理（SIEM）解决方案，以便进行统一监控。&lt;/p&gt;
&lt;h2 id=&#34;对于开发运维和-devops-来说&#34;&gt;对于开发、运维和 DevOps 来说&lt;/h2&gt;
&lt;p&gt;即使你可以通过采用和支持 SPIFFE/SPIRE 而不考虑环境，量化对开发人员甚至运维生产力的改善，但最终，它通过在日常工作中重新引入焦点、流程和快乐，缓解了团队所经历的大部分劳累。&lt;/p&gt;
&lt;h3 id=&#34;聚焦&#34;&gt;聚焦&lt;/h3&gt;
&lt;p&gt;不能让安全成为技术创新的障碍。安全工具和控制需要与现代产品和方法进行无摩擦的整合，不影响开发的自主性或给运维团队带来负担。&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 提供了一个统一的服务身份控制平面，可通过一致的 API 跨平台和跨域使用，因此团队可以专注于交付应用程序和产品，而不必担心或为目的地进行特殊配置。每个开发人员都可以利用这个 API，安全、轻松地进行跨平台和跨域的认证。&lt;/p&gt;
&lt;p&gt;开发人员还可以请求并接收一个身份，然后可用于为所提供的身份建立额外的应用程序特定控制，而运维和 DevOps 团队可以以自动化的方式管理和扩展身份，同时实施和执行消耗这些身份的策略。此外，团队可以使用 OIDC 联盟将 SPIFFE 身份与各种云认证系统（如 AWS IAM）相关联，从而减少对复杂的秘密管理需求。&lt;/p&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;
&lt;p&gt;每一个曾经生成的凭证都面临着同样的问题：在某些时候，它将不得不被改变或撤销。这个过程往往是手动的和痛苦的 —— 就像部署一样，越是不经常发生就越是痛苦。对过程的不熟悉和因缺乏及时性或不方便的更新程序而引起的中断是正常的。&lt;/p&gt;
&lt;p&gt;当需要轮换时，常要求运维和开发人员进行昂贵的上下文切换。SPIFFE/SPIRE 通过将轮换作为一个关键的核心功能来解决这个问题。它是完全自动化的，并且定期发生，无需人工干预。轮换的频率由运维选择，而且涉及到权衡；然而，SPIFFE 证书每小时轮换一次的情况并不少见。这种频繁和自动化的轮换方式最大限度地减少了与证书生命周期管理有关的运维和开发人员的中断。&lt;/p&gt;
&lt;p&gt;值得注意的是，不仅仅轮换是自动化的。证书的最初发放（最常见的是 X.509 证书的形式）也是完全自动化的。这有助于简化开发人员的流程，将生成或采购凭证的任务从启动新服务的检查清单中剔除。&lt;/p&gt;
&lt;h3 id=&#34;互操作性&#34;&gt;互操作性&lt;/h3&gt;
&lt;p&gt;开发人员和集成商不再需要为组织的安全身份和认证解决方案缺乏互操作性而感到沮丧。SPIRE 提供了一个插件模型，允许开发人员和集成商扩展 SPIRE 以满足他们的需求。如果企业需要一套专有的 API 来生成 SPIRE 的密钥，或者 SPIRE 的中间签名密钥应该存在于特定的专有密钥管理服务（KMS）中，那么这种能力就特别重要。开发人员也不需要担心为即将上线的新工作负载开发定制的包装器，因为该组织正在遵守一个开放的规范。&lt;/p&gt;
&lt;p&gt;许多团队不敢改变或删除允许网络间追踪的防火墙规则，因为这可能会对关键系统的可用性产生不利影响。运维可以将身份及其相关策略的范围扩大到应用而不是全局。运维将有信息更改本地范围的身份和策略，而不必担心对下游的影响。&lt;/p&gt;
&lt;h3 id=&#34;改善日常工作&#34;&gt;改善日常工作&lt;/h3&gt;
&lt;p&gt;如果没有一个强大的软件身份系统，服务之间的访问管理通常是通过使用网络层面的控制（例如，基于 IP / 端口的策略）来完成的。不幸的是，这种方法产生了大量与管理网络访问控制列表（ACL）相关的操作。随着弹性基础设施的增减，以及网络拓扑结构的变化，这些 ACL 需要不间断的维护。它们甚至会妨碍新基础设施的启用，因为现有的系统现在需要被告知新组件的存在。&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 致力于减少这种辛劳，因为与网络上的主机和工作负载的安排相比，软件身份的概念相对稳定。此外，它们还为将授权决策委托给服务所有者本身铺平了道路，因为他们最终处于做出这种决策的最佳位置。例如，希望向新的消费者授予访问权的服务所有者，他们不需要关心网络层面的细节就可以创建访问策略 —— 他们可以简单地声明他们希望授予访问权的服务名称，然后继续。&lt;/p&gt;
&lt;p&gt;SPIFFE/SPIRE 还致力于提高可观测性、监测以及最终对服务水平目标（SLO）的遵守。通过在许多不同类型的系统中规范软件身份（不一定只是容器化或云原生），并提供身份发布和使用的审计跟踪，SPIFFE/SPIRE 可以在事件发生之前、期间和之后极大地提高态势感知。更成熟的团队甚至会发现，它可以提高预测影响服务可用性问题的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPIFFE 信任域和 Bundle</title>
      <link>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-trust-domain-and-bundle/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-trust-domain-and-bundle/</guid>
      <description>&lt;p&gt;SPIFFE 标准提供了一个规范，用于在异构环境和组织中引导和发放可互操作的服务身份。它定义了一个称为&amp;quot;信任域&amp;quot;的概念，用于划分管理和/或安全边界。信任域隔离发放机构并区分身份命名空间，但也可以松散耦合以提供联合身份。&lt;/p&gt;
&lt;p&gt;本文档描述了 SPIFFE 信任域的语义、表示方式以及它们如何耦合在一起的机制。&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;SPIFFE 信任域表示 SPIFFE ID 有资格的基础，指示任何给定 SPIFFE ID 已经发放的领域或发放机构。它们由发放机构支持，负责管理其相应信任域中的 SPIFFE 身份发放。尽管信任域的名称由一个简单的人类可读字符串组成，但还必须表达由信任域的发放机构使用的密码密钥，以使其他人能够验证其发放的身份。这些密钥被表示为&amp;quot;SPIFFE Bundle&amp;quot;，与其所代表的信任域紧密相连。&lt;/p&gt;
&lt;p&gt;本规范定义了 SPIFFE 信任域和 SPIFFE Bundle 的性质和语义。&lt;/p&gt;
&lt;h2 id=&#34;信任域&#34;&gt;信任域&lt;/h2&gt;
&lt;p&gt;SPIFFE 信任域是由一组密码密钥支持的身份命名空间。这些密钥共同为驻留在信任域中的所有身份提供了密码锚点。&lt;/p&gt;
&lt;p&gt;信任域与支持它们的密钥之间存在一对多的关系。一个信任域可以由多个密钥和密钥类型来表示。例如，前者可以在根密钥轮换期间使用，而后者在使用多个 SVID 类型时避免多协议攻击是必要的。&lt;/p&gt;
&lt;p&gt;需要注意的是，虽然可以在多个信任域之间共享密码密钥，但我们强烈建议每个授权密钥仅在一个信任域中使用。密钥的重复使用可能会降低信任域的隔离性（例如，在演练和生产之间），并引入额外的安全挑战（例如，需要为辅助发放机构实施名称约束系统）。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-spiffe-bundle&#34;&gt;SPIFFE Bundle (SPIFFE Bundle)&lt;/h2&gt;
&lt;p&gt;SPIFFE Bundle 是包含信任域的密码密钥的对象。Bundle 中的密钥被视为代表 Bundle 所代表的信任域的权威，并用于证明驻留在该信任域中的 SVIDs 的有效性。&lt;/p&gt;
&lt;p&gt;SPIFFE Bundle 设计用于在 SPIFFE 控制平面实现内部和之间使用。然而，此规范不排除直接由工作负载消费的使用。&lt;/p&gt;
&lt;p&gt;在存储或管理 SPIFFE Bundle 时，独立记录 Bundle 所代表的信任域的名称至关重要，通常通过使用&lt;code&gt;&amp;lt;trust_domain_name, bundle&amp;gt;&lt;/code&gt;元组来实现。在验证 SVID 时，验证器必须选择与 SVID 所在的信任域对应的 Bundle，因此在大多数情况下需要维护此关系。&lt;/p&gt;
&lt;p&gt;请注意，信任域 Bundle 的内容预计会随时间变化，因为它所包含的密钥进行轮换。通过发放包含新密钥的新 Bundle 并省略已撤销的密钥来添加和撤销密钥。SPIFFE 实现负责根据需要将 Bundle 内容更新分发给工作负载。确切的格式和通过哪种方法传递这些更新超出了本规范的范围。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-格式&#34;&gt;SPIFFE Bundle 格式&lt;/h2&gt;
&lt;p&gt;SPIFFE Bundle 被表示为 RFC 7517 兼容的 JWK 集合。选择 JWK 的原因有两个主要原因。首先，它提供了一种灵活的格式，用于表示各种类型的密码密钥（和 X.509 等文档），从而在定义新的 SVID 格式时提供了一定程度的未来证明。其次，它得到了广泛支持和部署，主要用于域间联合，这是 SPIFFE 项目的核心目标。&lt;/p&gt;
&lt;h3 id=&#34;jwk-集合&#34;&gt;JWK 集合&lt;/h3&gt;
&lt;p&gt;本节定义了 JWK 集合的参数。未在此处定义的参数可以根据实现者的需要包含，但是 SPIFFE 实现&lt;strong&gt;不能&lt;/strong&gt;要求它们的存在以使其正常工作。&lt;/p&gt;
&lt;h3 id=&#34;序列号&#34;&gt;序列号&lt;/h3&gt;
&lt;p&gt;参数&lt;code&gt;spiffe_sequence&lt;/code&gt;&lt;strong&gt;应该&lt;/strong&gt;被设置。该序列号可以被 SPIFFE 控制平面用于许多目的，包括传播测量和更新顺序/替代。当存在时，其值&lt;strong&gt;必须&lt;/strong&gt;为单调递增的整数，并且当 bundle 的内容被更新时必须更改。&lt;/p&gt;
&lt;p&gt;值得注意的是，尽管 JSON 整数类型是可变宽度且没有定义最大限制，但许多实现可能将其解析为固定宽度类型。为了防止溢出，应该确保生成的类型至少具有 64 位的精度。&lt;/p&gt;
&lt;h3 id=&#34;刷新提示&#34;&gt;刷新提示&lt;/h3&gt;
&lt;p&gt;参数&lt;code&gt;spiffe_refresh_hint&lt;/code&gt;&lt;strong&gt;应该&lt;/strong&gt;被设置。刷新提示指示消费者应该多久检查更新。Bundle 发布者可以将刷新提示作为其密钥轮换频率的函数进行广告。值得注意的是，刷新提示还可能影响密钥撤销的传播速度。如果设置了刷新提示，其值&lt;strong&gt;必须&lt;/strong&gt;是表示建议的消费者刷新间隔的整数，以秒为单位。正如名称所示，刷新间隔只是一个提示，根据实现的不同，消费者可以更频繁或更不频繁地检查更新。&lt;/p&gt;
&lt;h3 id=&#34;密钥&#34;&gt;密钥&lt;/h3&gt;
&lt;p&gt;参数&lt;code&gt;keys&lt;/code&gt;&lt;strong&gt;必须&lt;/strong&gt;存在。其值是一个 JWK 数组。遇到未知的密钥类型或用途的客户端&lt;strong&gt;必须&lt;/strong&gt;忽略相应的 JWK 元素。请参阅 RFC 7517 的第 5 节以了解有关&lt;code&gt;keys&lt;/code&gt;参数语义的更多信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;keys&lt;/code&gt;参数可以包含一个空数组。发布空密钥数组的信任域表示该信任域已撤销先前发布的任何密钥。工作负载还可能遇到经处理后不产生可用密钥（即没有 JWK 通过下面描述的验证）的 bundle，并且实际上为空。这可能表明信任域已迁移到客户端不理解的新密钥类型或用途。在这两种情况下，工作负载&lt;strong&gt;必须&lt;/strong&gt;将来自信任域的所有 SVID 视为无效和不可信。&lt;/p&gt;
&lt;h3 id=&#34;jwk&#34;&gt;JWK&lt;/h3&gt;
&lt;p&gt;本节定义了作为 JWK 集合一部分包含的 JWK 元素的高级要求。JWK 元素表示单个密码密钥，用于对单个类型的 SVID 进行身份验证。虽然安全使用 JWK 的确切要求因 SVID 类型而异，但在本节中我们概述了一些顶级要求。SVID 规范必须为&lt;code&gt;use&lt;/code&gt;参数（参见下面的&lt;code&gt;Public Key Use&lt;/code&gt;节）定义适当的值，并且可以根据需要对其 JWK 元素设置进一步的要求或限制。&lt;/p&gt;
&lt;p&gt;实现者&lt;strong&gt;不应&lt;/strong&gt;包含在此处或相应的 SVID 规范中未定义的参数。&lt;/p&gt;
&lt;h3 id=&#34;密钥类型&#34;&gt;密钥类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kty&lt;/code&gt; 参数必须设置，并且其行为遵循 RFC 7517 的 Section 4.1。遇到未知密钥类型的客户端必须忽略整个 JWK 元素。&lt;/p&gt;
&lt;h3 id=&#34;公钥用途&#34;&gt;公钥用途&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;use&lt;/code&gt; 参数必须设置。其值表示其具有权威性的身份文档（或 SVID）的类型。截至本文撰写时，仅支持两种 SVID 类型：&lt;code&gt;x509-svid&lt;/code&gt; 和 &lt;code&gt;jwt-svid&lt;/code&gt;。值区分大小写。有关 &lt;code&gt;use&lt;/code&gt; 值的更多信息，请参见相应的 SVID 规范。遇到缺少 &lt;code&gt;use&lt;/code&gt; 参数或未知 &lt;code&gt;use&lt;/code&gt; 值的客户端必须忽略整个 JWK 元素。&lt;/p&gt;
&lt;h2 id=&#34;安全注意事项&#34;&gt;安全注意事项&lt;/h2&gt;
&lt;p&gt;本节概述了在实施和部署 SPIFFE 控制平面时应考虑的与安全相关的注意事项。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-bundle-刷新提示&#34;&gt;SPIFFE Bundle 刷新提示&lt;/h3&gt;
&lt;p&gt;SPIFFE Bundle 包括一个可选的 &lt;code&gt;refresh_hint&lt;/code&gt; 字段，用于指示消费者应尝试刷新其 Bundle 副本的频率。这个值对密钥的轮换速度有明显的影响，但它也影响了密钥的撤销速度。应该仔细选择刷新提示值。&lt;/p&gt;
&lt;p&gt;由于此字段不是必需的，因此可能会遇到没有设置 &lt;code&gt;refresh_hint&lt;/code&gt; 的 SPIFFE Bundle。在这种情况下，客户端可以通过检查 SVID 有效期来使用合适的间隔。应该认识到，省略 &lt;code&gt;refresh_hint&lt;/code&gt; 可能会影响信任域迅速撤销已被损坏密钥的能力。客户端应该默认使用相对较低（例如五分钟）的刷新间隔，以便及时获取更新的信任 Bundle。&lt;/p&gt;
&lt;h3 id=&#34;在信任域之间重用加密密钥&#34;&gt;在信任域之间重用加密密钥&lt;/h3&gt;
&lt;p&gt;本规范不鼓励在信任域之间共享加密密钥，因为这种做法会降低信任域的隔离性并引入额外的安全挑战。当一个根密钥在多个信任域之间共享时，认证和授权实现必须仔细检查标识的信任域名组件，并且信任域名组件在授权策略中必须易于表达和习惯性地表达。&lt;/p&gt;
&lt;p&gt;假设一个天真的实现导入（即完全信任）一个特定的根密钥，并且认证系统被配置为认证链到受信任根密钥的任何 SVID 的 SPIFFE 身份。如果天真的实现未配置为仅信任特定的信任域，则任何信任域中发行的标识都可以被认证（只要 SVID 链接到受信任的根密钥）。&lt;/p&gt;
&lt;p&gt;继续上述例子，其中天真的实现导入了特定的 CA 证书，假设认证未区分信任域并且接受链到受信任根密钥的任何 SVID。然后，授权系统将只授权特定的信任域。换句话说，授权策略需要明确配置以检查 SVID 的信任域名组件。这里的安全关注点是天真的授权实现可能盲目地相信认证系统已过滤掉不受信任的信任域。&lt;/p&gt;
&lt;p&gt;总之，安全性的最佳实践是在信任域和根密钥之间维持一对一的映射，以减少细微（但灾难性的）认证和授权实现错误。重新使用跨信任域的根密钥的系统应确保（a）SVID 发行系统（例如 CA）在发行 SVID 前正确实现授权检查，并且（b）依赖方（即使用 SVID 的系统）正确实现强大的认证和授权系统，能够区分多个信任域。&lt;/p&gt;
&lt;h2 id=&#34;附录-a-spiffe-bundle-示例&#34;&gt;附录 A. SPIFFE Bundle 示例&lt;/h2&gt;
&lt;p&gt;在下面的示例中，我们为名为&lt;code&gt;example.com&lt;/code&gt;的信任域配置了初始的 SPIFFE Bundle，并演示了在根密钥轮换期间如何更新 Bundle。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;example.com&lt;/code&gt;信任域的初始 X.509 CA 证书：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Certificate #1:
     Data:
         Version: 3 (0x2)
         Serial Number:
             df:d0:ad:fd:32:9f:b8:15:76:f5:d4:b9:e3:be:b5:a7
     Signature Algorithm: sha256WithRSAEncryption
         Issuer: O = example.com
         Validity
             Not Before: Jan  1 08:00:45 2019 GMT
             Not After : Apr  1 08:00:45 2019 GMT
         Subject: O = example.com
         X509v3 extensions:
             X509v3 Key Usage: critical
                 Certificate Sign
             X509v3 Basic Constraints: critical
                 CA:TRUE
             X509v3 Subject Alternative Name:
                 URI:spiffe://example.com/
 [...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请注意以下事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证书是自签名的（颁发者和主题相同）；&lt;/li&gt;
&lt;li&gt;证书的 CA 标志设置为 true；&lt;/li&gt;
&lt;li&gt;证书是 SVID（具有 spiffe URI SAN）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;example.com&lt;/code&gt;的相应信任 Bundle：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Trust bundle #1 for example.com:
 {
         &amp;#34;spiffe_sequence&amp;#34;: 1,
         &amp;#34;spiffe_refresh_hint&amp;#34;: 2419200,
         &amp;#34;keys&amp;#34;: [
                 {
                         &amp;#34;kty&amp;#34;: &amp;#34;RSA&amp;#34;,
                         &amp;#34;use&amp;#34;: &amp;#34;x509-svid&amp;#34;,
                         &amp;#34;x5c&amp;#34;: [&amp;#34;&amp;lt;base64 DER encoding of Certificate #1&amp;gt;&amp;#34;],
                         &amp;#34;n&amp;#34;: &amp;#34;&amp;lt;base64urlUint-encoded value&amp;gt;&amp;#34;,
                         &amp;#34;e&amp;#34;: &amp;#34;AQAB&amp;#34;
                 }
         ]
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述信任 Bundle 是第 1 个版本，如&lt;code&gt;spiffe_sequence&lt;/code&gt;字段所示，并且指示客户端应该每 2419200 秒（或 28 天）轮询更新 Bundle。请注意，&lt;code&gt;x5c&lt;/code&gt;参数包含了基于 RFC7517 Section 4.7 中所指定的 base64 编码的 DER 证书。密钥特定值（例如&lt;code&gt;n&lt;/code&gt;和&lt;code&gt;e&lt;/code&gt;）的编码方法在 RFC7518 Section 6 中有描述。&lt;/p&gt;
&lt;p&gt;为了准备&lt;code&gt;example.com&lt;/code&gt;的 CA 证书的过期，生成了一个替换证书，并将其添加到信任 Bundle：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Certificate #2:
     Data:
         Version: 3 (0x2)
         Serial Number:
             a4:dc:5f:05:8a:a2:bf:88:9d:a4:fa:1e:9a:a5:db:74
     Signature Algorithm: sha256WithRSAEncryption
         Issuer: O = example.com
         Validity
             Not Before: Feb  15 08:00:45 2019 GMT
             Not After : Jul  1 08:00:45 2019 GMT
         Subject: O = example.com
         X509v3 extensions:
             X509v3 Key Usage: critical
                 Certificate Sign
             X509v3 Basic Constraints: critical
                 CA:TRUE
             X509v3 Subject Alternative Name:
                 URI:spiffe://example.com/
 [...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 2 月 15 日发布的&lt;code&gt;example.com&lt;/code&gt;的更新后的信任 Bundle：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; Trust bundle #2 for example.com:
 {
         &amp;#34;spiffe_sequence&amp;#34;: 2,
         &amp;#34;spiffe_refresh_hint&amp;#34;: 2419200,
         &amp;#34;keys&amp;#34;: [
                 {
                         &amp;#34;kty&amp;#34;: “RSA”,
                         &amp;#34;use&amp;#34;: &amp;#34;x509-svid&amp;#34;,
                         &amp;#34;x5c&amp;#34;: [&amp;#34;&amp;lt;base64 DER encoding of Certificate #1&amp;gt;&amp;#34;],
                         &amp;#34;n&amp;#34;: &amp;#34;&amp;lt;base64urlUint-encoded value&amp;gt;&amp;#34;,
                         &amp;#34;e&amp;#34;: &amp;#34;AQAB&amp;#34;
                 },
                 {
                         &amp;#34;kty&amp;#34;: “RSA”,
                         &amp;#34;use&amp;#34;: &amp;#34;x509-svid&amp;#34;,
                         &amp;#34;x5c&amp;#34;: [&amp;#34;&amp;lt;base64 DER encoding of Certificate #2&amp;gt;&amp;#34;],
                         &amp;#34;n&amp;#34;: &amp;#34;&amp;lt;base64urlUint-encoded value&amp;gt;&amp;#34;,
                         &amp;#34;e&amp;#34;: &amp;#34;AQAB&amp;#34;
                 }
         ]
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Bundle #2 中，请注意&lt;code&gt;spiffe_sequence&lt;/code&gt;参数已经增加，并添加了&lt;code&gt;example.com&lt;/code&gt;的第二个根证书。一旦发布并分发了这个新的信任 Bundle，验证器将接受由原始根证书或替换根证书签名的 SVID。通过提前发布替换证书，有效器有充分的机会刷新&lt;code&gt;example.com&lt;/code&gt;的信任 Bundle 并了解即将到期的替换证书。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>身份背后的通用概念</title>
      <link>https://lib.jimmysong.io/spiffe/general-concepts-behind-identity/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/general-concepts-behind-identity/</guid>
      <description>&lt;p&gt;本章解释了什么是身份，以及分配、管理和使用身份的基本知识。这些是你需要知道的概念，以便了解 SPIFFE 和 SPIRE 的工作方式。&lt;/p&gt;
&lt;h2 id=&#34;什么是身份&#34;&gt;什么是身份？&lt;/h2&gt;
&lt;p&gt;对于人类来说，身份是复杂的。人类是独特的个体，不能被克隆，也不能用代码取代他们的思想，而且一生中可能会有多种社会身份。软件服务也同样复杂。&lt;/p&gt;
&lt;p&gt;一个单一的程序可能会扩展到成千上万的节点，或者在构建系统推送新的更新时，一天内多次改变其代码。在这样一个快速变化的环境中，一个身份必须代表服务的特定逻辑目的（例如，客户计费数据库）和与已建立的权威或信任根（例如，&lt;code&gt;my-company.example.org&lt;/code&gt; 或生产工作负载的发行机构）的关联。&lt;/p&gt;
&lt;p&gt;一旦为一个组织中的所有服务发布了身份，它们就可以被用于&lt;strong&gt;认证&lt;/strong&gt;：证明一个服务是它所声称的那样。一旦服务经过相互认证，它们就可以使用身份进行&lt;strong&gt;授权&lt;/strong&gt;，或控制谁可以访问这些服务，以及&lt;strong&gt;保密性&lt;/strong&gt;，或保持它们相互传输的数据的秘密。虽然 SPIFFE 本身并不包括认证、授权或保密性，但它发出的身份可用于所有这些。&lt;/p&gt;
&lt;p&gt;为一个组织指定服务身份与设计该组织基础设施的任何其他部分类似：它密切依赖于该组织的需求。当一个服务扩大规模、改变代码或移动位置时，它保持相同的身份可能是合乎逻辑的。&lt;/p&gt;
&lt;h3 id=&#34;值得信赖的身份&#34;&gt;值得信赖的身份&lt;/h3&gt;
&lt;p&gt;现在我们已经定义了身份，那么我们如何表示这种身份？我们如何知道，当一个软件（或工作负载）声称自己的身份时，这个声称是值得信赖的？为了开始探索这些问题，我们必须首先讨论身份是如何建立的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人类的身份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请允许我们用大家共同的东西来解释这些概念：现实世界中的身份。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;身份证件&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果一个名字是一个人的身份，那么这个身份的证明就是一个身份文件。护照是允许一个人证明其身份的文件，所以它是一个身份文件。像不同国家的护照一样，不同类型的软件身份文件可能看起来不同，而且不总是包含相同的信息。但为了有用，它们通常至少都包含一些共同的信息，如姓名。&lt;/p&gt;
&lt;p&gt;护照和写有你名字的餐巾纸之间的区别是什么？&lt;/p&gt;
&lt;p&gt;最重要的区别是来源。对于护照，我们相信&lt;strong&gt;签发机构&lt;/strong&gt;已经核实了你的身份，而且我们有能力核实护照是由该受信任的机构签发的（验证）。对于那张餐巾纸，我们不知道它来自哪里，也没有办法验证它是否来自你说的那家餐馆。我们也无法相信餐厅在餐巾纸上写了正确的名字，或者在你传达你的名字时验证了它的准确性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;信任一个发行机构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们相信护照，因为我们隐含地相信签发护照的机构。我们信任他们签发这些身份文件的过程：他们有记录和控制，以确保他们只向正确的个人签发身份。我们信任这个过程的管理，所以我们知道该机构签发的护照是某人身份的忠实代表。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;核实身份文件&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;鉴于此，我们如何区分真护照和假护照？这就是验证的意义所在。组织需要一种方法来确定身份文件是否是由我们信任的权威机构签发的。这通常是通过难以复制但容易验证的水印来实现的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对出示身份证件的人进行认证&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;护照记录了关于身份所代表的人的几项信息。首先，它们包括一个人的照片，可以用来验证出示者是护照上的同一个人。它们还可能包括此人的其他身体特征 —— 例如，他们的身高、体重和眼睛颜色。&lt;/p&gt;
&lt;p&gt;所有这些属性都可以用来&lt;strong&gt;验证&lt;/strong&gt;出示护照的人。&lt;/p&gt;
&lt;p&gt;简而言之，护照是我们的&lt;strong&gt;身份文件&lt;/strong&gt;，我们用它来确认彼此的身份，因为我们信任&lt;strong&gt;签发机构&lt;/strong&gt;，并且有办法&lt;strong&gt;验证&lt;/strong&gt;该文件来自该机构。最后，我们可以通过交叉参考护照的内容和持有护照的人，来&lt;strong&gt;验证&lt;/strong&gt;出示护照的人。&lt;/p&gt;
&lt;h3 id=&#34;数字世界中的身份加密身份&#34;&gt;数字世界中的身份：加密身份&lt;/h3&gt;
&lt;p&gt;绕回工作负载身份，上述概念如何映射到计算机系统？计算机使用的是&lt;strong&gt;数字身份文件&lt;/strong&gt;，而不是护照。X.509 证书、签名的 JSON 网络令牌（JWT）和 Kerberos 票据，都是数字身份文件的例子。数字身份文件可以使用加密技术进行验证。然后，计算机系统可以被验证，就像一个拥有护照的人一样。&lt;/p&gt;
&lt;p&gt;做到这一点的最有用和最普遍的技术之一是&lt;strong&gt;公钥基础设施（PKI）&lt;/strong&gt;。PKI 被定义为一套创建、管理、分发、使用、存储和撤销数字证书以及管理公钥加密所需的角色、策略、硬件、软件和程序。有了 PKI，数字身份文件可以在本地进行验证，即根据一组小的、静态的根信任包进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X.509 的简要概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当&lt;a href=&#34;https://www.itu.int/en/ITU-T/about/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国际电信联盟电信标准化部门（ITU-T）&lt;/a&gt;于 1988 年首次发布 X.509 标准的 PKI 时，这在当时是非常雄心勃勃的，现在仍然被认为是如此。该标准最初设想为人类、服务器和其他设备提供证书，形成一个巨大的全球一体化安全通信系统。虽然 X.509 从未达到其最初的预期，但它是几乎所有安全通信协议的基础。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;X.509 是如何在单一机构中工作的&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bob 的计算机需要一个证书。他生成了一个随机的&lt;strong&gt;私钥&lt;/strong&gt;，还有一个&lt;strong&gt;证书签名请求&lt;/strong&gt;（CSR），其中包括他的计算机的基本信息，比如它的名字；我们称之为 &lt;code&gt;bobsbox&lt;/code&gt;。CSR 有点像护照申请。&lt;/li&gt;
&lt;li&gt;Bob 将他的 CSR 发送给一个&lt;strong&gt;证书颁发机构&lt;/strong&gt;（CA）。CA 验证 Bob 是否真的是 Bob。这种验证的具体方式可能有所不同 —— 它可能涉及一个人检查 Bob 的文件，或自动检查。&lt;/li&gt;
&lt;li&gt;然后，CA 通过对 CSR 中提出的信息进行编码来创建&lt;strong&gt;证书&lt;/strong&gt;，并添加数字签名，以断言 CA 已经验证了其中包含的信息是真实和正确的。它把证书送回给 Bob。&lt;/li&gt;
&lt;li&gt;当 Bob 想与 Alice 建立安全通信时，他的计算机可以出示他的证书，并以密码学方式证明它拥有 Bob 的私钥（而不需要实际与任何人分享该私钥的内容）。&lt;/li&gt;
&lt;li&gt;Alice 的计算机可以通过检查证书颁发机构是否签署了 Bob 的证书来检查 Bob 的证书是否真的是 Bob 的证书。她相信证书颁发机构在签署证书之前正确检查了 Bob 的身份。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-31bob-向证书颁发机构申请证书并用它来向-alice-证明他的身份&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f3-1.jpg&#34; alt=&#34;图 3.1：Bob 向证书颁发机构申请证书，并用它来向 Alice 证明他的身份。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3.1：Bob 向证书颁发机构申请证书，并用它来向 Alice 证明他的身份。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-32pki-简况&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f3-2.jpg&#34; alt=&#34;图 3.2：PKI 简况。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3.2：PKI 简况。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-33中间证书颁发机构的说明&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f3-3.jpg&#34; alt=&#34;图 3.3：中间证书颁发机构的说明。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3.3：中间证书颁发机构的说明。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;带有中间证书机构的 X.509&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在许多情况下，签署了某一特定证书的 CA &lt;strong&gt;并不&lt;/strong&gt;广为人知。相反，该 CA 有自己的密钥和证书，而该证书是由另一个 CA 签署的。通过签署该 CA 证书，上级 CA 证明了下级 CA 被授权签发数字身份。这种由高阶 CA 对低阶 CA 的授权被称为&lt;strong&gt;委托（delegation）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;委托可以重复发生，低阶 CA 进一步委托他们的权力，形成一个任意高的证书授权树。最高等级的 CA 被称为&lt;strong&gt;根 CA&lt;/strong&gt;，必须有一个知名的证书。链中的每一个其他 CA 都被称为 &lt;strong&gt;中间 CA&lt;/strong&gt;。这种方法的好处是，需要知名的密钥较少，允许列表的变化不那么频繁。&lt;/p&gt;
&lt;p&gt;这导致了 X.509 的一个关键弱点：&lt;strong&gt;任何 CA 可以签署任何证书，没有任何限制&lt;/strong&gt;。如果一个黑客决定建立自己的中间 CA，并能得到任何一个现有中间 CA 的批准，那么他就可以有效地签发他想要的任何身份。至关重要的是，每个知名的 CA 都是&lt;strong&gt;完全&lt;/strong&gt;值得信赖的，而且他们委托的每个中间 CA 也是&lt;strong&gt;完全&lt;/strong&gt;值得信赖的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证书和身份的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 PKI 中有几个额外的功能，使数字身份的管理和认证更容易和更安全。权限委托、身份撤销和有限的身份文件寿命是其中的几个例子。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;身份发放&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先，必须能够发布一个新的身份。人类的诞生，新软件服务的编写，在每一种情况下，我们都必须在以前没有身份的地方颁发一个身份。&lt;/p&gt;
&lt;p&gt;首先，一项服务需要申请一个新的身份。对于人来说，这可能是一个纸质表格。对于软件来说，它是一个 X.509 文件，称为&lt;strong&gt;证书签名请求（CSR）&lt;/strong&gt;，它是用一个相应的私钥创建的。CSR 类似于证书，但由于它没有被任何证书颁发机构签署，没有人会承认它是有效的。然后，该服务将 CSR 安全地发送给证书颁发机构。&lt;/p&gt;
&lt;p&gt;接下来，证书颁发机构根据申请证书的服务检查 CSR 的每个细节。最初，这本来是一个手工过程：人类检查文书工作，并在个人基础上作出决定。今天，检查和签署过程通常是完全自动化的。如果你使用过流行的 LetsEncrypt 证书颁发机构，那么你就会熟悉完全自动化的证书颁发机构签署过程。&lt;/p&gt;
&lt;p&gt;一旦满意，证书颁发机构将其数字签名附加到 CSR 上，将其变成一个完全成熟的证书。它把证书返回给服务。与它先前生成的私钥一起，该服务可以让他人安全地识别自己。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;证书撤销&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那么，如果一项服务被破坏了，会发生什么？如果 Bob 的笔记本电脑被黑了，或者 Bob 离开了公司，不应该再有访问权，怎么办？&lt;/p&gt;
&lt;p&gt;这种取消信任的过程被称为&lt;strong&gt;证书撤销（Certificate Revocation）&lt;/strong&gt;。证书颁发机构维护一个名为 **&amp;ldquo;证书撤销列表&amp;rdquo;（CRL）**的文件，其中包含被撤销的证书的唯一 ID，并将该文件的签名副本分发给任何要求的人。&lt;/p&gt;
&lt;p&gt;撤销是很棘手的，有几个原因。首先，CRL 必须由某个端点托管和提供，这就给确保端点的正常运行和可达带来了挑战。当该端点不可用时，PKI 是否停止工作？在实践中，大多数软件将&lt;strong&gt;无法打开&lt;/strong&gt;，在 CRL 不可用时继续信任证书，使它们实际上没有用处。&lt;/p&gt;
&lt;p&gt;第二，CRL 可能会变得庞大而不方便。被撤销的证书必须保留在 CRL 中，直到它过期为止，而证书的寿命一般都很长（在几年的时间内）。这可能导致服务、下载和处理清单本身的性能问题。&lt;/p&gt;
&lt;p&gt;已经开发了几种不同的技术，试图使证书撤销更简单、更可靠，如在线证书状态协议（OCSP）。各种各样的方法使证书撤销成为一个持续的挑战。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;证书过期&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;每个证书都有一个内置的过期日期。过期日期是 X.509 安全的一个重要部分，有几个不同的原因：管理过时，限制证书显示的身份变化的可能性，限制 CRL 的大小，以及减少秘钥被盗的可能性。&lt;/p&gt;
&lt;p&gt;证书已经存在了很长时间了。当它们刚被开发出来时，许多 CA 使用 1989 年的 MD2 散列算法，这种算法很快被发现是不安全的。如果这些证书仍然有效，攻击者可以伪造它们。&lt;/p&gt;
&lt;p&gt;有限的证书寿命的另一个重要方面是，CA 只有一次机会来验证申请者的身份，但这些信息不能保证长期保持正确。例如，域名经常改变所有权，是证书中一般包括的比较关键的信息之一。&lt;/p&gt;
&lt;p&gt;如果使用了证书撤销列表，那么每个仍然有效的证书都有可能被撤销。如果证书永远持续下去，那么证书撤销列表就会无止境地增长。为了保持证书撤销列表的小规模，证书需要过期。&lt;/p&gt;
&lt;p&gt;最后，证书的有效期越长，其证书的私钥或任何通往根的证书被盗的风险就越大。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;频繁的证书更新&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解决撤销所带来的挑战的一个折中办法是更多地依靠证书过期。如果证书的有效期很短（也许只有几个小时），那么 CA 就可以经常重新执行它最初做的所有检查。如果证书的更新足够频繁，那么 CRL 可能甚至没有必要，因为等待证书过期可能会更快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;身份寿命的权衡&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;更短的寿命&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;更长的寿命&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果文件被盗，它的有效期会缩短&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;减少了证书颁发机构的负担（人和程序）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CRL 比较短，也许没有必要&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;降低网络的负荷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一次性减少未结清的身份文件（更容易跟踪）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在一个节点因网络中断而无法更新其证书时，具有更好的弹性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;另一种加密身份：JSON 网络令牌（JWT）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;另一个公钥身份文件，JSON 网络令牌（RFC7519），也表现为一个类似 PKI 的系统。它不使用证书，而是使用 JSON 令牌，并有一个称为 JSON Web Key Set 的结构，作为 CA 绑定来验证 JSON 令牌。证书和 JWT 之间有一些重要的区别，超出了本书的范围，但就像 X.509 证书一样，JWT 的真实性可以通过 PKI 来验证。&lt;/p&gt;
&lt;h3 id=&#34;外部身份的可信度&#34;&gt;外部身份的可信度&lt;/h3&gt;
&lt;p&gt;无论你使用哪种身份，都必须由一些受信任的机构来签发。在许多情况下，并不是每个人都信任相同的当局或其颁发的过程。Alice 的纽约州驾照在纽约是有效的身份证明，但它在伦敦是无效的，因为伦敦当局不信任纽约州的政府。然而，Bob 的美国护照在伦敦是有效的，因为英国当局信任美国政府，而伦敦当局信任英国当局。&lt;/p&gt;
&lt;p&gt;在数字身份文件领域，情况是相同的。Alice 和 Bob 可能拥有由完全不相关的 CA 签署的证书，但只要他们都信任这些 CA，他们就可以相互认证。这并不意味着 Alice 必须信任 Bob，只是她可以安全地识别他。&lt;/p&gt;
&lt;h2 id=&#34;如何使用软件身份&#34;&gt;如何使用软件身份&lt;/h2&gt;
&lt;p&gt;一旦一个软件有了数字身份文件，它就可以被用于许多不同的目的。我们已经讨论了使用身份文件进行认证。它们还可以用于相互 TLS、授权、可观测性和计量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;身份文件最常见的用途是作为认证的基础。对于软件身份，存在几种不同的认证协议，使用 X.509 证书或 JWT 来证明一个服务对另一个服务的身份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保密性和完整性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保密性意味着攻击者不能看到信息的内容，而完整性意味着他们不能在传输过程中改变信息。传输层安全（TLS）是一个广泛使用的协议，用于建立安全连接，在使用 X.509 证书的不受信任的网络连接之上提供认证、保密性和消息完整性。&lt;/p&gt;
&lt;p&gt;TLS 的一个特点是，连接的&lt;strong&gt;任何一方都&lt;/strong&gt;可以使用证书进行认证。例如，当你连接到你的银行网站时，你的网络浏览器使用银行提供的 X.509 证书来验证你的银行，但你的浏览器并没有向银行提供证书。(你用用户名和密码登录，而不是用证书）。&lt;/p&gt;
&lt;p&gt;当两个软件进行通信时，连接的&lt;strong&gt;双方&lt;/strong&gt;通常都有 X.509 证书并相互认证。这被称为相互认证的 TLS。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;授权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦数字身份得到认证，它就可以被用来授权访问服务。通常情况下，每个服务都有一个允许其他服务对其提出请求的列表。授权只有在认证之后才能发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可观测性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;身份识别对于提高你的组织的基础设施内的可观测性也很有用。在大型组织中，旧的或未维护的服务以神秘的、未记录的方式进行通信是非常普遍的。每个服务的独特身份可以与可观测性工具一起解决这个问题。对于日志记录来说，如果以后出了问题，请求者的可反驳身份是很有用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在微服务架构中，一个常见的需求是对请求进行节流，以便快速的微服务不至于压倒慢的微服务。如果每个微服务都有一个独特的身份，就可以用来管理每秒的请求配额来解决这个问题，或者完全拒绝访问。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;人类和软件都有身份，而且都可以使用身份文件来证明自己的身份。对人类来说，护照是身份文件的一种典型形式。对于软件来说，最常见的数字身份文件形式是 X.509 证书。&lt;/p&gt;
&lt;p&gt;证书是由证书颁发机构颁发的。证书颁发机构需要注意正确验证他们为之创建证书的人或事，并管理证书的寿命。证书颁发后，无论谁使用它，都需要信任颁发它的证书机构。&lt;/p&gt;
&lt;p&gt;一旦有了可信的数字身份文件，它们有许多不同的用途。其中最常见的是创建一个相互认证的 TLS 连接，其中包括认证、保密性和完整性。另一个常见的用途是用于授权。有了认证、保密性、完整性和授权，服务之间的连接是安全的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPIFFE 联邦</title>
      <link>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-federation/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe-and-spire/standard/spiffe-federation/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;SPIFFE 规范定义了建立一个平台无关的工作负载身份框架所需的文档和接口，该框架能够在不需要实现身份转换或凭证交换逻辑的情况下连接不同域中的系统。它们定义了一个“&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;信任域&lt;/a&gt;”，它作为一个身份命名空间。&lt;/p&gt;
&lt;p&gt;SPIFFE 的本质是分散的。每个信任域都根据自己的授权行事，与驻留在其他信任域中的系统在管理上是隔离的。虽然信任域划定了行政和/或安全域，但核心的 SPIFFE 用例是在需要时跨越这些边界进行通信。因此，有必要定义一种机制，使实体可以被引入到外部信任域中，从而允许其验证由“其他”SPIFFE 授权机构颁发的凭证，并允许一个信任域中的工作负载安全地验证一个外部信任域中的工作负载。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#3-spiffe-bundles&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 包&lt;/a&gt;是一个包含验证特定信任域凭证所需的公钥材料的资源。本文档介绍了一种规范，用于安全地获取 SPIFFE 包，以便验证外部机构颁发的身份。其中包括有关如何提供 SPIFFE 包、如何检索 SPIFFE 包以及如何验证提供它们的端点的信息。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;SPIFFE 联邦使得在信任域之间验证身份凭证 (SVIDs) 成为可能。具体来说，它是获取验证来自不同信任域颁发的 SVIDs 所需的 SPIFFE 包的行为，并将这些包提供给执行验证的工作负载。&lt;/p&gt;
&lt;p&gt;为了验证来自一个信任域的 SVIDs，必须拥有该信任域的包。因此，实现 SPIFFE 联邦需要在信任域之间交换 SPIFFE 包。这种交换应该定期发生，以允许信任域包的内容随时间变化。&lt;/p&gt;
&lt;p&gt;为了实现这一点，SPIFFE 联邦定义了一个“包端点”，它是一个 URL，用于为特定的信任域提供 SPIFFE 包。还定义了一组“端点配置文件”，它们指定了包端点服务器和客户端之间使用的协议和身份验证语义。最后，本文档进一步指定了包端点客户端和服务器的行为，以及联邦关系的管理和生成的包数据。&lt;/p&gt;
&lt;h2 id=&#34;目标用例&#34;&gt;目标用例&lt;/h2&gt;
&lt;p&gt;最终，SPIFFE 联邦使得工作负载能够对其他信任域中的对等方进行身份验证。这个功能对于支持各种用例至关重要，但我们希望重点关注三个核心用例。&lt;/p&gt;
&lt;p&gt;SPIFFE 信任域经常用于将同一公司或组织中不同信任级别的环境进行分割。例如，可以在暂存和生产环境之间、PCI 和非 PCI 环境之间进行分割。在这些情况下，每个域中使用的 SPIFFE 部署共享一个共同的管理机构，并且很可能由相同的实现支持。这是一个重要的区别，因为它意味着不同的部署可以就某些事情达成一致（例如命名方案），并且每个部署的安全姿态可以被其他部署了解和理解。&lt;/p&gt;
&lt;p&gt;其次，SPIFFE 联邦也被用于在不同公司或组织之间的信任域之间进行联邦。这种情况与第一种情况相似，我们正在对 SPIFFE 部署进行联邦，但由于可能存在的实现和管理差异，协调通常仅限于在此处描述的 SPIFFE 联邦协议中交换的数据。&lt;/p&gt;
&lt;p&gt;最后，SPIFFE 联邦还可以为尚未部署成熟 SPIFFE 控制平面的客户端提供用例。例如，托管产品可能希望使用客户端的 SPIFFE 身份对其客户进行身份验证，而无需内部实现或部署 SPIFFE。这可以通过允许工作负载直接获取客户端的信任域绑定来实现，以便对其调用者进行身份验证，从而避免了承诺部署完整的 SPIFFE 的需求。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-端点&#34;&gt;SPIFFE Bundle 端点&lt;/h2&gt;
&lt;p&gt;SPIFFE Bundle 端点是一个资源（由 URL 表示），用于提供一个信任域的 SPIFFE Bundle 的副本。SPIFFE 控制平面可以同时暴露和使用这些端点，以便在它们之间传输 bundle，从而实现联邦。&lt;/p&gt;
&lt;p&gt;SPIFFE Bundle 端点的语义类似于 OpenID Connect 规范中定义的&lt;code&gt;jwks_uri&lt;/code&gt;机制，因为 bundle 包含了一个或多个用于在信任域内证明身份的公共加密密钥。Bundle 端点是一个 HTTPS URL，对 HTTP GET 请求做出 SPIFFE bundle 的响应。&lt;/p&gt;
&lt;h3 id=&#34;添加和删除密钥&#34;&gt;添加和删除密钥&lt;/h3&gt;
&lt;p&gt;信任域的操作者可以根据需要（例如，作为内部密钥轮换过程的一部分）引入或删除用于颁发 SVID 的密钥。在添加新密钥时，应提前发布包含密钥的更新信任捆绑包到捆绑包端点，以便外部信任域有机会检索和内部传播新捆绑包内容；建议提前时间为捆绑包的&lt;code&gt;spiffe_refresh_hint&lt;/code&gt;的 3-5 倍。至少，在使用密钥颁发 SVID 之前，新密钥必须发布到捆绑包端点。&lt;/p&gt;
&lt;p&gt;当信任域不再颁发来自这些密钥的活动有效 SVID 时，应从信任捆绑包中删除已弃用的密钥。如果在将密钥添加到捆绑包中或从捆绑包中删除密钥时不遵循这些建议，可能会导致暂时的跨域身份验证失败。&lt;/p&gt;
&lt;p&gt;更新信任捆绑包的要求不适用于仅用于内部使用的颁发 SVID 的密钥。&lt;/p&gt;
&lt;p&gt;应定期轮询捆绑包端点以获取更新，因为其内容预计会随时间&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#appendix-a-spiffe-bundle-example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;更改&lt;/a&gt; - 常见的密钥有效期通常为几周甚至几天。客户端应以与捆绑包的&lt;code&gt;spiffe_refresh_hint&lt;/code&gt;值相等的频率轮询。如果未设置，应适用合理低的默认值 - 建议为五分钟。&lt;/p&gt;
&lt;h3 id=&#34;管理获取的-bundle&#34;&gt;管理获取的 Bundle&lt;/h3&gt;
&lt;p&gt;Bundle 终端的客户端应在每次检索到 Bundle 时存储最新的 SPIFFE Bundle。当比较两个 Trust Bundle 的新鲜度或顺序时，应使用 Trust Bundle 的序列号字段。如果 Trust Bundle 省略了序列号，操作员应将最近检索到的 Bundle 视为最新的。&lt;/p&gt;
&lt;p&gt;操作员可以随时在外部信任域中本地更新 SPIFFE Bundle。在这种情况下，本地更新的 Bundle 版本将被视为最新版本，直到被后续的刷新替换。&lt;/p&gt;
&lt;p&gt;不同信任域的 Bundle 内容不得合并为单个更大的 Bundle。这样做将使一个信任域能够在验证器的眼中伪造属于另一个信任域的身份。因此，非常重要的是确保从外部信任域接收的 Bundle 保持清晰可辨，并明确反映它们所属的信任域名称。有关更多信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;h3 id=&#34;终端地址的稳定性&#34;&gt;终端地址的稳定性&lt;/h3&gt;
&lt;p&gt;一旦外部信任域开始依赖于特定的终端 URL，将所有终端的客户端迁移到替代终端 URL 是一个复杂且容易出错的过程。因此，最安全的做法是优先选择稳定的终端 URL。&lt;/p&gt;
&lt;h2 id=&#34;spiffe-bundle-终端的提供和使用&#34;&gt;SPIFFE Bundle 终端的提供和使用&lt;/h2&gt;
&lt;p&gt;本规范定义了两种基于 HTTPS 的 SPIFFE Bundle 终端服务器支持的配置文件。其中一种依赖于使用 Web PKI 对终端进行身份验证，另一种则利用 SPIFFE 身份验证。SPIFFE Bundle 终端客户端必须同时支持这两种配置文件，而 SPIFFE Bundle 终端服务器必须至少支持其中一种。&lt;/p&gt;
&lt;p&gt;支持基于 TLS 的配置文件（例如&lt;code&gt;https_web&lt;/code&gt;或&lt;code&gt;https_spiffe&lt;/code&gt;）的 Bundle 终端服务器必须遵守&lt;a href=&#34;https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mozilla 中间兼容性&lt;/a&gt;要求，除非使用配置文件另有规定。&lt;/p&gt;
&lt;h3 id=&#34;端点参数&#34;&gt;端点参数&lt;/h3&gt;
&lt;p&gt;在从 SPIFFE 捆绑端点检索捆绑之前，客户端必须配置以下三个参数：（1）SPIFFE 捆绑端点的 URL，（2）端点配置文件类型，以及（3）与捆绑端点关联的信任域名称。前两个参数指示捆绑端点的位置和如何进行身份验证。由于信任捆绑不包含信任域名称，客户端使用第三个参数将已下载的捆绑与特定的信任域名称关联起来。特定的端点配置文件（例如&lt;code&gt;https_spiffe&lt;/code&gt;，如下所述）可以定义其他强制的配置参数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bundle Endpoint URL:		&amp;#34;&amp;lt;https://example.com/production/bundle.json&amp;gt;&amp;#34;
Bundle Endpoint Profile:	&amp;#34;https_web&amp;#34;
Trust Domain:			&amp;#34;prod.example.com&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图 1：用于信任域&lt;a href=&#34;http://prod.example.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;prod.example.com&lt;/a&gt;的示例 SPIFFE 捆绑端点配置。管理员通过捆绑端点配置来检索外部信任捆绑。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;当控制平面将信任捆绑分发给工作负载时，必须通信信任域名称和信任捆绑之间的关联。有关这些参数的敏感性，请参见安全注意事项部分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/spiffe_bundle_distribution.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图 2：在检索到外部 SPIFFE 信任捆绑后，控制平面将信任域名称和相应的捆绑分发给内部工作负载。工作负载使用此配置来验证外部信任域中的身份。有关信任捆绑内容的详细信息，请参见&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 信任域和捆绑&lt;/a&gt; ，特别是&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#4-spiffe-bundle-format&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 捆绑格式&lt;/a&gt;和&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#appendix-a-spiffe-bundle-example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 捆绑示例&lt;/a&gt;部分。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本节中的要求适用于所有 SPIFFE 捆绑端点服务器和客户端。个别的 SPIFFE 捆绑端点配置文件可能会添加其他要求。&lt;/p&gt;
&lt;h3 id=&#34;端点配置文件&#34;&gt;端点配置文件&lt;/h3&gt;
&lt;p&gt;端点配置文件描述了在提供或使用捆绑端点时应使用的传输协议和身份验证方法。&lt;/p&gt;
&lt;p&gt;以下各节描述了受支持的捆绑端点配置文件。&lt;/p&gt;
&lt;h3 id=&#34;web-pkihttps_web&#34;&gt;Web PKI（&lt;code&gt;https_web&lt;/code&gt;）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https_web&lt;/code&gt;配置文件利用公信任的证书颁发机构提供了一种低摩擦的方式来配置 SPIFFE 联邦。当访问网页时，它的行为与大多数人熟悉的“https”URL 完全相同。在此配置文件中，捆绑点服务器使用由公共 CA 颁发的证书，无需额外的客户端配置；使用&lt;code&gt;https_web&lt;/code&gt;配置文件类型的端点使用通常安装在现代操作系统中的相同公共 CA 证书进行身份验证。&lt;/p&gt;
&lt;p&gt;有关使用公共证书颁发机构的更多信息，请参见安全注意事项部分。&lt;/p&gt;
&lt;h3 id=&#34;端点-url-要求&#34;&gt;端点 URL 要求&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;https_web&lt;/code&gt;的捆绑点 URL 必须将方案设置为&lt;code&gt;https&lt;/code&gt;，并且在授权组件中不能包括用户信息。此规范不限制 URL 的其他组件（由&lt;a href=&#34;https://tools.ietf.org/html/rfc3986#section-3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986 第 3 节&lt;/a&gt;定义）。&lt;/p&gt;
&lt;p&gt;例如，URL &lt;code&gt;https://host.example.com/trust_domain&lt;/code&gt; 是 &lt;code&gt;https_web&lt;/code&gt; 配置文件类型的有效 SPIFFE 捆绑点 URL。&lt;/p&gt;
&lt;h3 id=&#34;端点参数-1&#34;&gt;端点参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https_web&lt;/code&gt;配置文件在功能上不需要任何额外的参数，除了每个配置文件都需要的参数（即信任域名、配置文件类型和端点 URL）。&lt;/p&gt;
&lt;h3 id=&#34;提供-bundle-端点&#34;&gt;提供 Bundle 端点&lt;/h3&gt;
&lt;p&gt;支持&lt;code&gt;https_web&lt;/code&gt;传输类型的 SPIFFE bundle 端点服务器使用标准的 TLS 保护的 HTTP（即 HTTPS）。所使用的服务器证书应由公共证书颁发机构（根据 CA/Browser 论坛的成员名单定义）颁发，并且必须将端点的 DNS 名称或 IP 地址作为 X.509 主题备用名称（或通用名称）包含在内。&lt;/p&gt;
&lt;p&gt;作为互操作性问题，服务器不得要求对访问 bundle 端点进行客户端身份验证；这包括传输层（例如客户端证书）和 HTTP 层（例如身份验证标头）身份验证方案。&lt;/p&gt;
&lt;p&gt;在收到正确路径的 HTTP GET 请求后，bundle 端点服务器必须回复最新版本的可用 SPIFFE bundle。响应必须以 UTF-8 编码，并应在响应上设置&lt;code&gt;Content-Type&lt;/code&gt;标头为&lt;code&gt;application/json&lt;/code&gt;。此规范不限制提供 SPIFFE bundle 的路径。&lt;/p&gt;
&lt;p&gt;如果请求的 bundle 的授权机构已经更改，bundle 端点服务器可以使用 HTTP 重定向（根据&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;定义）进行响应。重定向的目标 URL 也必须是符合此配置文件中定义的有效的 bundle 端点 URL。服务器应使用临时重定向；重定向的支持是为了操作考虑（例如通过 CDN 提供 bundle），而不是作为永久迁移 bundle 端点 URL 的手段。有关详细信息，请参阅安全考虑事项。&lt;/p&gt;
&lt;h3 id=&#34;web-pkihttps_web-1&#34;&gt;Web PKI（&lt;code&gt;https_web&lt;/code&gt;）&lt;/h3&gt;
&lt;h3 id=&#34;提供-bundle-端点-1&#34;&gt;提供 Bundle 端点&lt;/h3&gt;
&lt;p&gt;支持&lt;code&gt;https_web&lt;/code&gt;传输类型的 SPIFFE bundle 端点服务器使用标准的 TLS 保护的 HTTP（即 HTTPS）。所使用的服务器证书应由公共证书颁发机构（根据 CA/Browser 论坛的成员名单定义）颁发，并且必须将端点的 DNS 名称或 IP 地址作为 X.509 主题备用名称（或通用名称）包含在内。&lt;/p&gt;
&lt;p&gt;作为互操作性问题，服务器不得要求对访问 bundle 端点进行客户端身份验证；这包括传输层（例如客户端证书）和 HTTP 层（例如身份验证标头）身份验证方案。&lt;/p&gt;
&lt;p&gt;在收到正确路径的 HTTP GET 请求后，bundle 端点服务器必须回复最新版本的可用 SPIFFE bundle。响应必须以 UTF-8 编码，并应在响应上设置&lt;code&gt;Content-Type&lt;/code&gt;标头为&lt;code&gt;application/json&lt;/code&gt;。此规范不限制提供 SPIFFE bundle 的路径。&lt;/p&gt;
&lt;p&gt;如果请求的 bundle 的授权机构已经更改，bundle 端点服务器可以使用 HTTP 重定向（根据&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;定义）进行响应。重定向的目标 URL 也必须是符合此配置文件中定义的有效的 bundle 端点 URL。服务器应使用临时重定向；重定向的支持是为了操作考虑（例如通过 CDN 提供 bundle），而不是作为永久迁移 bundle 端点 URL 的手段。有关详细信息，请参阅安全考虑事项。&lt;/p&gt;
&lt;h3 id=&#34;使用-bundle-终点&#34;&gt;使用 Bundle 终点&lt;/h3&gt;
&lt;p&gt;当与&lt;code&gt;https_web&lt;/code&gt; bundle 终点进行交互时，SPIFFE bundle 终点客户端使用标准的 TLS 保护的 HTTP（即 HTTPS）。在连接到终点时，必须根据&lt;a href=&#34;https://tools.ietf.org/html/rfc6125&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 6125&lt;/a&gt;验证服务器证书。总结该文档，服务器证书必须由本地信任的证书颁发机构签发，且必须包含与配置的终点 URL 的主机组件匹配的 X.509 主体替代名称（或公共名称）。&lt;/p&gt;
&lt;p&gt;在建立与 bundle 终点的 TLS 连接并验证呈现的服务器证书后，客户端发出终点 URL 指定的 HTTP GET 请求。响应的正文是一个 SPIFFE bundle。在检索信任 bundle 之前，客户端必须知道终点 URL 代表的信任域的名称，最好通过显式配置；有关详细信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;p&gt;如果终点服务器具有 HTTP 重定向功能（如&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;定义的），则 bundle 终点服务器可以响应 HTTP 重定向。如果 URL 满足有效 bundle 终点 URL 的所有要求，bundle 终点客户端应遵循重定向。连接到新 URL 时，必须应用与连接到原始 URL 相同的 TLS 注意事项。bundle 终点客户端应使用配置的终点 URL 进行每个 bundle 刷新，并不应永久存储位置以供将来获取。有关详细信息，请参阅安全注意事项。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-身份验证https_spiffe&#34;&gt;SPIFFE 身份验证（&lt;code&gt;https_spiffe&lt;/code&gt;）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https_spiffe&lt;/code&gt;配置文件使用由 SPIFFE 信任域（而不是由公共证书颁发机构签发的证书）颁发的 X509-SVID。该配置文件允许 bundle 终点避免使用网络定位器作为服务器标识的一种形式，并且通过标准 SPIFFE 机制支持自动根 CA 轮换和吊销。&lt;/p&gt;
&lt;p&gt;除了所有配置文件所需的终点参数之外，&lt;code&gt;https_spiffe&lt;/code&gt;配置文件还需要其他终点客户端参数，如下所述。&lt;/p&gt;
&lt;h3 id=&#34;终点-url-要求&#34;&gt;终点 URL 要求&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;https_spiffe&lt;/code&gt;的 bundle 终点 URL 的方案必须设置为&lt;code&gt;https&lt;/code&gt;，并且在授权组件中不能包含用户信息。此规范不限制 URL 的其他组件（如&lt;a href=&#34;https://tools.ietf.org/html/rfc3986#section-3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 3986 第 3 节&lt;/a&gt;定义）。&lt;/p&gt;
&lt;p&gt;例如，URL &lt;code&gt;https://host.example.com/trust_domain&lt;/code&gt; 是&lt;code&gt;https_spiffe&lt;/code&gt;配置文件类型的有效 SPIFFE bundle 终点 URL。&lt;/p&gt;
&lt;h3 id=&#34;终端参数&#34;&gt;终端参数&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;https_spiffe&lt;/code&gt;配置文件的终端终端客户端必须配置终端终端服务器的 SPIFFE ID 以及获取终端终端服务器信任域的信任终端终端的安全方法。&lt;strong&gt;自助终端终端&lt;/strong&gt;是指终端终端服务器的 SPIFFE ID 与获取的终端终端相同信任域中。配置的终端终端终端可能是自助终端终端或非自助终端终端。&lt;/p&gt;
&lt;p&gt;如果终端是自助终端终端，则客户端需要配置一个最新的终端以启动联邦关系。客户端必须支持使用&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#4-spiffe-bundle-format&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE Bundle 格式&lt;/a&gt;指定终端，并且可以支持其他格式（例如 PEM），前提是它们提供必要的根证书以验证连接。客户端依赖于此配置的终端进行第一次检索，然后存储检索到的终端以验证后续连接。有关详细信息，请参见下面的使用终端终端。&lt;/p&gt;
&lt;p&gt;如果终端不是自助终端终端，则客户端必须单独为终端服务器的信任域进行配置。可以通过以下任何方式配置终端服务器的信任域和终端终端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信任域的终端参数，该参数配置客户端使用终端配置文件根据本文档中所述的终端配置进行终端检索。请注意，客户端可以使用任何可用配置文件，并不限于&lt;code&gt;https_spiffe&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;未定义且超出本文档范围的获取或配置终端终端的过程，无论是自动还是静态。有关如何保护此方法的指导，请参见安全注意事项部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bundle Endpoint URL:		&amp;#34;&amp;lt;https://example.com/global/bundle.json&amp;gt;&amp;#34;
Bundle Endpoint Profile:	&amp;#34;https_spiffe&amp;#34;
Trust Domain:			&amp;#34;example.com&amp;#34;
Endpoint SPIFFE ID:		&amp;#34;spiffe://example.com/spiffe-bundle-server&amp;#34;
Endpoint Trust Bundle:		{example.com bundle contents omitted}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图 3：使用 SPIFFE 身份验证的&lt;code&gt;example.com&lt;/code&gt;信任域的 SPIFFE 捆绑点端点配置示例。在此示例中，捆绑点端点是自助的，并且配置包括捆绑点端点的 SPIFFE ID 和&lt;code&gt;example.com&lt;/code&gt;的信任捆绑，即此 SPIFFE ID 的信任域。此初始捆绑用于对捆绑点端点进行首次连接的身份验证并验证其 SVID。随后对该捆绑点端点的连接使用最新获取的副本进行身份验证。&lt;/em&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Bundle Endpoint URL:		&amp;#34;&amp;lt;https://example.com/production/bundle.json&amp;gt;&amp;#34;
Bundle Endpoint Profile:	&amp;#34;https_spiffe&amp;#34;
Trust Domain:			&amp;#34;prod.example.com&amp;#34;
Endpoint SPIFFE ID:		&amp;#34;spiffe://example.com/spiffe-bundle-server&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图 4：使用 SPIFFE 身份验证的&lt;code&gt;prod.example.com&lt;/code&gt;信任域的 SPIFFE 捆绑点端点配置示例。在此示例中，捆绑点端点不是自助的：&lt;code&gt;prod.example.com&lt;/code&gt;的信任捆绑可通过具有 SPIFFE ID &lt;code&gt;spiffe://example.com/spiffe-bundle-server&lt;/code&gt;的&lt;code&gt;example.com&lt;/code&gt;获取。通过上述联邦示例已经获取了用于验证&lt;a href=&#34;http://example.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example.com&lt;/a&gt;的信任捆绑。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;提供-bundle-端点-2&#34;&gt;提供 Bundle 端点&lt;/h3&gt;
&lt;p&gt;支持&lt;code&gt;https_spiffe&lt;/code&gt;传输类型的 SPIFFE Bundle 端点服务器使用标准的 TLS 保护的 HTTP（即 HTTPS）。服务器证书必须是有效的 X509-SVID。&lt;/p&gt;
&lt;p&gt;作为互操作性的关注点，服务器不得要求客户端进行身份验证以访问 Bundle 端点；包括传输层（例如客户端证书）和 HTTP 层（例如身份验证头）的身份验证方案。&lt;/p&gt;
&lt;p&gt;在收到正确路径的 HTTP GET 请求后，Bundle 端点服务器必须响应最新版本的可用 SPIFFE Bundle。操作员可以选择确切的路径值，并将其作为 Bundle 端点 URL 的一部分显示。Bundle 端点服务器必须使用 UTF-8 编码传输 Bundle，并应在响应中设置&lt;code&gt;Content-Type&lt;/code&gt;头为&lt;code&gt;application/json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果用于提供所请求 Bundle 的授权发生了变化，Bundle 端点服务器可以使用 HTTP 重定向（如&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;所定义）。重定向的目标 URL 也必须是此配置文件中定义的有效 Bundle 端点 URL，并且新目标呈现的服务器证书必须是具有与原始端点相同的 SPIFFE ID 的有效 X509-SVID。服务器应使用临时重定向；重定向的支持旨在用于运营考虑（例如通过 CDN 提供 Bundle），而不是作为永久迁移 Bundle 端点 URL 的手段。有关更多信息，请参阅安全注意事项。&lt;/p&gt;
&lt;h3 id=&#34;使用-bundle-终端点&#34;&gt;使用 Bundle 终端点&lt;/h3&gt;
&lt;p&gt;SPIFFE bundle 终端点客户端在与&lt;code&gt;https_spiffe&lt;/code&gt; bundle 终端点交互时使用标准的 TLS 保护的 HTTP（即 HTTPS）。在连接到终端点时，必须验证服务器证书是否是提供的 bundle 终端点 SPIFFE ID 的有效 X509-SVID。有关验证 X509-SVID 的信息，请参阅&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/X509-SVID.md#5-validation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE X509-SVID&lt;/a&gt;规范。&lt;/p&gt;
&lt;p&gt;自服务 bundle 终端点是指 bundle 终端点服务器的 SPIFFE ID 与正在获取的 bundle 所属的信任域位于同一信任域中。在首次连接到自服务 bundle 终端点时，客户端使用操作员提供的 SPIFFE bundle（通过 bundle 终端点参数）来验证服务器证书。随后的连接必须使用最新的可用 bundle 来验证。这样可以使外部信任域旋转密钥而不中断联邦关系。&lt;/p&gt;
&lt;p&gt;非自服务 bundle 终端点是指 bundle 终端点服务器的 SPIFFE ID 不位于正在获取的 bundle 所属的信任域中。连接到非自服务终端点时，客户端使用与终端点 SPIFFE ID 的信任域对应的最新可用 SPIFFE bundle，该 bundle 可能是直接配置的，也可能是通过另一个联邦关系获取的。&lt;/p&gt;
&lt;p&gt;在与 bundle 终端点建立 TLS 连接并验证呈现的服务器证书之后，客户端发出终端点 URL 指定的 HTTP GET 请求。响应的正文是一个 SPIFFE bundle。在检索信任 bundle 之前，客户端必须知道终端点 URL 所代表的信任域的名称，最好通过显式配置来获取；有关更多信息，请参阅安全注意事项部分。&lt;/p&gt;
&lt;p&gt;终端点可以使用 HTTP 重定向进行响应（如&lt;a href=&#34;https://tools.ietf.org/html/rfc7231#section-6.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 7231 第 6.4 节&lt;/a&gt;所定义）。如果 URL 满足有效的 bundle 终端点 URL 的所有要求，则 bundle 终端点客户端应跟随重定向。连接到新 URL 时，必须应用与连接到原始 URL 相同的 TLS 考虑。特别是，必须呈现与最初配置的相同 SPIFFE ID 的有效 X509-SVID。bundle 终端点客户端应该对每个 bundle 刷新使用配置的终端点 URL，并且不应该永久存储用于将来获取的位置。有关更多信息，请参阅安全注意事项。&lt;/p&gt;
&lt;h2 id=&#34;关系生命周期&#34;&gt;关系生命周期&lt;/h2&gt;
&lt;p&gt;本节描述了联邦“关系”的生命周期，包括建立第一个连接、进行持续维护和终止。&lt;/p&gt;
&lt;p&gt;联邦关系是单向的。换句话说，Alice 可以与 Bob 建立关系，但反过来不行。在这种情况下，Alice 能够验证由 Bob 颁发的身份，但 Bob 不知道如何验证由 Alice 颁发的身份。&lt;/p&gt;
&lt;p&gt;为了实现相互身份验证，需要形成两个关系 - 每个方向一个。&lt;/p&gt;
&lt;h3 id=&#34;建立关系&#34;&gt;建立关系&lt;/h3&gt;
&lt;p&gt;如“终端点参数”部分所述，为正确配置联邦关系，所有 bundle 终端点客户端需要至少三个信息：外部信任域名称、其 bundle 终端点 URL 和终端点配置文件。&lt;/p&gt;
&lt;p&gt;bundle 终端点 URL 提供了可以找到外部信任域的 bundle 的地址，而配置文件告知客户端在调用它时应使用哪个协议。配置文件可能需要额外的特定于配置文件的参数。有关如何连接和验证 bundle 终端点的详细信息，请参阅相关的终端点配置文件子部分。&lt;/p&gt;
&lt;p&gt;连接成功建立并接收到 bundle 副本后，将其与其所属的信任域名称一起存储。现在，可以分发 bundle 的内容（例如 CA 证书、JWT 签名密钥等），以验证源自外部信任域的 SVID。&lt;/p&gt;
&lt;p&gt;此分发的确切方式和机制是实现细节，超出了本文档的范围。有关 SPIFFE 感知工作负载如何接收 bundle 更新的更多信息，请参阅&lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Workload_API.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE 工作负载 API&lt;/a&gt;规范。&lt;/p&gt;
&lt;h3 id=&#34;维护关系&#34;&gt;维护关系&lt;/h3&gt;
&lt;p&gt;SPIFFE bundle 终端点客户端应定期轮询 bundle 终端点以获取更新。检测到更新后，存储代表终端点外部信任域的存储的 bundle 将进行更新。然后，将更新的内容分发，以便验证者可以根据需要添加新的密钥并删除撤销的密钥。再次强调，将此更新分发给验证者的确切方法超出了本文档的范围。&lt;/p&gt;
&lt;p&gt;如果轮询 bundle 终端点的尝试失败，bundle 终端点客户端应在下一个轮询间隔重试，而不是立即或强制重试，因为这可能会导致 bundle 终端点服务器过载。如添加和删除密钥部分所讨论的那样，新密钥应足够提前发布，以使错过一两次轮询不会导致跨域身份验证失败。&lt;/p&gt;
&lt;h3 id=&#34;终止关系&#34;&gt;终止关系&lt;/h3&gt;
&lt;p&gt;终止联邦关系就是删除对外信任域的本地副本，停止轮询其信任域终点，并确保验证器也删除了该外部信任域的终点，不再成功验证从该终点呈现的 SVID。&lt;/p&gt;
&lt;p&gt;如果需要重新建立关系，则需要重新开始此生命周期。&lt;/p&gt;
&lt;h3 id=&#34;生命周期图&#34;&gt;生命周期图&lt;/h3&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-生命周期图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/spiffe_federation_lifecycle.png&#34; alt=&#34;生命周期图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      生命周期图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;安全考虑&#34;&gt;安全考虑&lt;/h2&gt;
&lt;p&gt;本节包含与该规范相关的安全信息和观察结果。实施者和用户都应熟悉这些信息。&lt;/p&gt;
&lt;h3 id=&#34;终点参数的分发&#34;&gt;终点参数的分发&lt;/h3&gt;
&lt;p&gt;联邦关系的配置参数，包括信任域名称、终点 URL 和配置文件本身对于篡改是高度敏感的。联邦关系配置的被篡改可能会削弱或完全破坏 SPIFFE 实现所隐含的安全保证。&lt;/p&gt;
&lt;p&gt;以下是一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;篡改信任域名称可以使控制相应终点束端点的一方冒充任意信任域&lt;/li&gt;
&lt;li&gt;篡改终点 URL，特别是与&lt;code&gt;https_web&lt;/code&gt;配置文件结合使用时，攻击者可以发出欺诈性密钥并冒充相应信任域中的任何身份&lt;/li&gt;
&lt;li&gt;篡改终点配置文件可以改变联邦的安全保证，例如用&lt;code&gt;https_spiffe&lt;/code&gt;替换&lt;code&gt;https_web&lt;/code&gt;。如果您的威胁模型包括 Web PKI 的妥协（请另请参阅下面的网络流量拦截部分），则这可能被认为是安全姿态的重大降级。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，控制平面管理员必须谨慎地安全源这些参数并安全地输入它们。终点束配置可以使用各种方法来获取，包括但不限于电子邮件、受 HTTPS 保护的网站、公司内部 wiki 等。无论使用的是哪种特定方法来初始分发终点配置，分发方法都需要抵御在途篡改、未经授权的静止修改以及恶意冒充。例如，电子邮件通常不具备抵御篡改或冒充（即&amp;quot;伪造&amp;quot;电子邮件）的抗性。&lt;/p&gt;
&lt;h3 id=&#34;明确定义的终结点参数&#34;&gt;明确定义的终结点参数&lt;/h3&gt;
&lt;p&gt;每个 SPIFFE 联邦关系至少配置以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信任域名&lt;/li&gt;
&lt;li&gt;终结点 URL&lt;/li&gt;
&lt;li&gt;终结点配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要的是这三个参数要明确配置，不能从彼此中安全地推断出值。&lt;/p&gt;
&lt;p&gt;例如，人们可能会试图从终结点 URL 的主机部分推断出 SPIFFE 信任域名。这是危险的，因为它可能允许任何可以从特定 DNS 名称提供文件的人断言同名 SPIFFE 信任域的信任根。&lt;/p&gt;
&lt;p&gt;想象一个名为 MyPage（&lt;code&gt;mypage.example.com&lt;/code&gt;）的网络托管公司，它允许客户 Alice 在&lt;code&gt;https://mypage.example.com/alice/&amp;lt;filename&amp;gt;&lt;/code&gt;这样的 URL 上提供网络内容，并且 MyPage 还通过 SPIFFE 联邦与 SPIFFE 信任域名&lt;code&gt;mypage.example.com&lt;/code&gt;运行 API。假设 Alice 与 Bob 建立了 SPIFFE 联邦关系，Bob 也是 MyPage 的客户，Alice 选择从&lt;code&gt;https://mypage.example.com/alice/spiffe-bundle&lt;/code&gt;提供她的信任捆绑包。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5说明-alicebob-和-mypage-之间关系的图表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/spiffe_federation_mypage_example.png&#34; alt=&#34;图 5：说明 Alice、Bob 和 MyPage 之间关系的图表。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5：说明 Alice、Bob 和 MyPage 之间关系的图表。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果 Bob 的控制平面从 URL 中隐式获取信任域名，这将允许 Alice 冒充信任域&lt;code&gt;mypage.example.com&lt;/code&gt;！还值得强调的是，SPIFFE 信任域名不一定是已注册的 DNS 名称，这通常使得这种假设本来就是错误的。在这个例子中，Alice 的信任域名只是&lt;code&gt;alice&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;终结点配置文件也不能从 URL 中安全地推断出。&lt;code&gt;https_web&lt;/code&gt;和&lt;code&gt;https_spiffe&lt;/code&gt;都使用具有相同要求的普通 HTTPS URL。没有安全的方法来区分它们。尝试使用&lt;code&gt;https_web&lt;/code&gt;并回退到&lt;code&gt;https_spiffe&lt;/code&gt;，或者反过来，是不充分的，原因与上述类似：从安全的角度来看，能够在特定的 HTTPS 终结点上托管使用 Web PKI 的文件与能够使用有效的 SPIFFE SVID 托管它是不等价的。&lt;/p&gt;
&lt;h3 id=&#34;保持-信任域名-捆绑包-的绑定&#34;&gt;保持 &lt;code&gt;&amp;lt;信任域名, 捆绑包&amp;gt;&lt;/code&gt; 的绑定&lt;/h3&gt;
&lt;p&gt;在对 SVID 进行身份验证时，验证者必须仅使用与 SPIFFE ID 所属的信任域名相对应的捆绑包。如果我们简单地将所有的捆绑包汇集起来，并且只要某个捆绑包对某个捆绑包有效，就接受一个 SVID，那么信任域之间就可以轻易地冒充对方的身份。换句话说，捆绑包是针对特定信任域的。&lt;/p&gt;
&lt;p&gt;由于捆绑包在信任域和发行捆绑包的终结点之间没有自我描述的特性，且自我发布，因此在存储和传播捆绑包时，需要将 SPIFFE 联邦关系的信任域名和捆绑包终结点之间的绑定转化为信任域名和捆绑包之间的绑定。这要求不同于传统的 Web PKI，传统的 Web PKI 使用单个根证书存储来验证所有证书，而不管实际发行验证的 CA 系统是哪个。&lt;/p&gt;
&lt;h3 id=&#34;捆绑包终结点服务器的可信性&#34;&gt;捆绑包终结点服务器的可信性&lt;/h3&gt;
&lt;p&gt;捆绑包终结点服务器的可信性和完整性对于确保捆绑包所代表的信任域的安全性至关重要。这不仅包括捆绑包终结点服务器本身，还包括其运行的平台以及对其或其平台具有管理控制权的任何实体。&lt;/p&gt;
&lt;p&gt;虽然这个事实可能看起来是不言自明的，但也有一些情况可能没有那么明显。例如，在非自服务捆绑包终结点的情况下，信任域 A 为信任域 B 提供捆绑包，信任域 B 隐式地信任信任域 A 及其管理员提供正确的捆绑包内容。类似地，如果从像 AWS S3 这样的托管平台提供捆绑包，那么代表涉及捆绑包的信任域的运营者隐式地信任 AWS 提供正确的捆绑包内容。&lt;/p&gt;
&lt;p&gt;在选择将提供 SPIFFE 捆绑包的位置时，重要的是考虑涉及的各方的可信性。&lt;/p&gt;
&lt;h3 id=&#34;捆绑包终结点的真实性&#34;&gt;捆绑包终结点的真实性&lt;/h3&gt;
&lt;p&gt;确保捆绑包终结点的真实性至关重要。这一点无法过于强调。本节探讨了确保捆绑包终结点真实性的一些考虑因素。&lt;/p&gt;
&lt;h3 id=&#34;捆绑包终结点-url-重定向&#34;&gt;捆绑包终结点 URL 重定向&lt;/h3&gt;
&lt;p&gt;URL 重定向有两种变体：临时重定向和永久重定向。该规范通过 SHOULD 指示建议服务器只发送临时重定向，并且客户端应将所有重定向视为临时重定向，即使服务器将其标记为永久重定向。&lt;/p&gt;
&lt;p&gt;如果客户端遵循永久重定向，那么永久重定向代表了终结点 URL 配置参数的带内自动重写。这会导致两个相关的安全风险。&lt;/p&gt;
&lt;p&gt;首先，信任域操作员可能会试图使用永久重定向作为迁移终结点 URL 的方法。然而，没有可靠的方法来确保所有客户端都已处理了重定向，并且没有办法确保它们将永久地遵守重定向（例如，通过重启、升级、重新部署等）。如果终结点 URL 转移所有权并且客户端继续从原始终结点 URL 获取捆绑包，那么这些客户端可能会检索到由意外所有者控制的捆绑包。这在使用基于 Web PKI 的方案（如&lt;code&gt;https_web&lt;/code&gt;）时尤其令人担忧，因为新域所有者有权获得公开受信任的与其相关的证书。因此，最安全的做法是选择具有长期稳定性的捆绑包终结点 URL。如果绝对需要 URL 迁移，最好使用首次获取捆绑包终结点配置的外带方法来处理，同时提前公布长期的迁移窗口。&lt;/p&gt;
&lt;p&gt;其次，永久重定向可能被滥用为将短暂的妥协升级为更持久的妥协的机制。由于重定向是自动的，捆绑包终结点客户端操作员可能会忽略这个重定向。&lt;/p&gt;
&lt;p&gt;临时重定向通常由 Web 主机用于操作目的：例如，允许在接收方附近的节点上提供全球稳定的 URL。禁止在 SPIFFE 联邦中使用重定向将从操作员的工具包中删除一个有用的工具。但是，临时重定向确实有安全考虑因素。并非所有的 Web 主机在其安全态势方面都是等价的，这意味着如果发生重定向，操作员可能无法获得预期的安全保证。本规范中对客户端“应该”遵循重定向的建议应该被解释为推荐的默认值：在操作价值和安全价值之间的平衡。依赖 SPIFFE 联邦捆绑包终结点的操作员可能希望禁用重定向，以避免出现意外情况。&lt;/p&gt;
&lt;h3 id=&#34;网络流量拦截&#34;&gt;网络流量拦截&lt;/h3&gt;
&lt;p&gt;虽然所有 SPIFFE 捆绑包终结点配置文件都使用的协议在很大程度上不受网络流量拦截和操纵的风险影响，但重要的是要注意，这并不一定意味着用于发放协议凭证的方案也不受影响。如果 SPIFFE 作为“零信任”解决方案的一部分部署，或者如果操作者的威胁模型中包括网络妥协，则必须特别关注用于发放捆绑包终结点服务器凭证的机制。&lt;/p&gt;
&lt;p&gt;常见的服务器凭证发放方法是通过使用挑战 - 响应机制，其中凭证请求的授权是基于请求者能够回答发送到特定网络地址或 DNS 名称的挑战。ACME 协议就是一个例子，如果希望使用公共证书颁发机构，则应考虑补偿控制措施。特别需要注意的是捆绑包终结点服务器所在的二层网络的安全性。&lt;/p&gt;
&lt;p&gt;最后，应指出，ACME 和公共证书颁发机构基础设施在历史上一直是稳定和可靠的。本节所描述的关注点是几十年的问题，然而，作为一种用于缓解对网络或 DNS 中信任的方式采用 SPIFFE 的操作者可能会发现这种行为令人惊讶。&lt;/p&gt;
&lt;h3 id=&#34;终结点参数&#34;&gt;终结点参数&lt;/h3&gt;
&lt;p&gt;破坏捆绑包终结点的一种方法是篡改终结点参数，无论是在传输中还是在终结点的客户端中以休息形式。修改其他方面真实的终结点参数可能导致降级的安全态势，甚至导致客户端与完全不同的终结点进行通信。请参阅终结点参数的分发部分以获取更多信息。&lt;/p&gt;
&lt;h3 id=&#34;使用-https_spiffe-进行信任链接&#34;&gt;使用 &lt;code&gt;https_spiffe&lt;/code&gt; 进行信任链接&lt;/h3&gt;
&lt;p&gt;在使用 SPIFFE 身份验证时，可以通过验证提供的 X509-SVID 来建立信任捆绑服务器的真实性，客户端可以通过各种方式获取到该信任捆绑。例如，信任域 A 的捆绑可以由信任域 B 中的一个端点提供，而信任域 B 的捆绑可以由信任域 C 中的一个端点提供，依此类推。&lt;/p&gt;
&lt;p&gt;通过这种方式，获取的捆绑通过链式关系与提供捆绑的信任域之间建立了信任。该链式关系最终会终止于以下几种情况之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过与自服务信任域的联邦关系&lt;/li&gt;
&lt;li&gt;通过与由 Web PKI 提供的捆绑端点的联邦关系&lt;/li&gt;
&lt;li&gt;在长期静态配置的信任捆绑中&lt;/li&gt;
&lt;li&gt;在本文档范围之外的某个过程中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如在 Bundle 端点服务器的可信性一节中所描述的那样，重要的是要理解该方案的安全性取决于链中的每个信任域能够履行其安全保证。链中信任域或捆绑端点服务器的妥协将导致“下一个”信任域的妥协。具有足够强大的网络拦截能力的攻击者可能会以某种方式升级此攻击，以导致链中后续的信任域可能被妥协。因此，通常不鼓励以这种方式形成长链。如果需要，管理员应花时间分析这些链，以确保所有参与的信任域符合其所需的标准。&lt;/p&gt;
&lt;p&gt;最后，应注意到该链中的“链接”是由各个 HTTPS 请求操作（针对链中不同的捆绑端点服务器）形成的，并且这些操作可能在不同的时间发生。SPIFFE 捆绑端点客户端应记录这些 HTTPS 请求操作，并且管理员应注意保留这些日志以备将来进行法医分析（如果有必要）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SPIFFE 和 SPIRE 概念介绍</title>
      <link>https://lib.jimmysong.io/spiffe/introduction-to-spiffe-and-spire-concepts/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/introduction-to-spiffe-and-spire-concepts/</guid>
      <description>&lt;p&gt;在第三章介绍的概念基础上，本章说明了 SPIFFE 标准。解释 SPIRE 实现的组成部分以及它们是如何结合在一起的。最后，讨论威胁模型以及如果特定组件被破坏会发生什么。&lt;/p&gt;
&lt;h2 id=&#34;什么是-spiffe&#34;&gt;什么是 SPIFFE？&lt;/h2&gt;
&lt;p&gt;普适安全生产身份框架（SPIFFE）是一套软件身份的开源标准。为了以一种与组织和平台无关的方式实现可互操作的软件身份，SPIFFE 定义了必要的接口和文件，以完全自动化的方式获得和验证加密身份。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-41spiffe-组件&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-1.jpg&#34; alt=&#34;图 4.1：SPIFFE 组件。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.1：SPIFFE 组件。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SPIFFE ID，代表软件服务的名称（或身份）。&lt;/li&gt;
&lt;li&gt;SPIFFE 可验证身份文件（SVID），这是一个可加密验证的文件，用于向对等者证明服务的身份。&lt;/li&gt;
&lt;li&gt;SPIFFE Workload API，这是一个简单的节点本地 API，服务用它来获得身份，而不需要认证。&lt;/li&gt;
&lt;li&gt;SPIFFE Trust Bundle（信任包），一种代表特定 SPIFFE 发行机构使用的公钥集合的格式。&lt;/li&gt;
&lt;li&gt;SPIFFE Federation，这是一个简单的机制，通过它可以共享 SPIFFE Trust Bundle。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spiffe-不是什么&#34;&gt;SPIFFE 不是什么&lt;/h3&gt;
&lt;p&gt;SPIFFE 旨在识别服务器、服务和其他通过计算机网络通信的非人类实体。这些都有一个共同点，那就是这些身份必须是&lt;strong&gt;可以自动发出的&lt;/strong&gt;（没有人类在其中参与）。虽然有可能使用 SPIFFE 来识别人或其他野生动物物种，但该项目特意将这些用例排除在范围之外。除了机器人和机器之外，没有其他特别的考虑。&lt;/p&gt;
&lt;p&gt;SPIFFE 向服务提供身份和相关信息，同时管理该身份的生命周期，但&lt;strong&gt;它仅仅作为提供者&lt;/strong&gt;，因为它不直接利用其提供的身份。利用 SPIFFE 身份是服务的责任。在使用 SPIFFE 身份时，有多种解决方案可以实现认证层，如端到端加密通信或服务间授权和访问控制，但是，这些功能也被认为不属于 SPIFFE 项目的范围，SPIFFE 不会直接解决这些问题。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-id&#34;&gt;SPIFFE ID&lt;/h3&gt;
&lt;p&gt;SPIFFE ID 是一个字符串，作为服务的唯一名称。它被模拟成一个 URI，由几个部分组成。前缀 &lt;code&gt;spiffe://&lt;/code&gt;（作为 URI 的方案），信任域的名称（作为主机部分），以及特定工作负载的名称或身份（作为路径部分）。&lt;/p&gt;
&lt;p&gt;一个简单的 SPIFFE ID 可能只是 &lt;code&gt;spiffe://example.com/myservice&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-42一个-spiffe-id-示例以及它的组成&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-2.jpg&#34; alt=&#34;图 4.2：一个 SPIFFE ID 示例，以及它的组成。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.2：一个 SPIFFE ID 示例，以及它的组成。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SPIFFE ID 的第一个组成部分是 &lt;code&gt;spiffe:// &lt;/code&gt;URI 方案。虽然很普通，但包括它是一个重要的细节，因为它有助于将 SPIFFE ID 与 URL 或其他类型的 URL 区分开来。&lt;/p&gt;
&lt;p&gt;SPIFFE ID 的第二个组成部分是信任域名称（&lt;code&gt;example.com&lt;/code&gt;）。在某些情况下，整个组织只有一个信任域。在其他情况下，可能需要有许多信任域。信任域的语义将在本章后面介绍。&lt;/p&gt;
&lt;p&gt;最后一个组成部分是工作负载本身的名称部分，由 URI 路径表示。SPIFFE ID 的这一部分的具体格式和组成是因地制宜的。各机构可以自由选择对其最有意义的命名方案。例如，我们可以选择一个既能反映组织位置又能反映工作负载目的的命名方案，如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://example.com/bizops/hr/taxrun/withholding
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，SPIFFE ID 的主要目的是以一种灵活的方式来表示工作负载的身份，使人类和机器都能轻松使用。当试图在 SPIFFE ID 的格式中灌输太多的意义时，应该谨慎行事。例如，试图编纂后来被用作授权元数据的各个部分的属性，会导致互操作性和灵活性的挑战。相反，建议使用一个&lt;a href=&#34;https://en.wiktionary.org/wiki/lookaside&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;单独的数据库&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-信任域&#34;&gt;SPIFFE 信任域&lt;/h3&gt;
&lt;p&gt;SPIFFE 规范引入了&lt;strong&gt;信任域&lt;/strong&gt;的概念。信任域被用来管理组织内部和组织之间的管理和安全边界，每个 SPIFFE ID 都有其信任域的名称，如上所述。具体来说，信任域是 SPIFFE ID 命名空间的一部分，在这个命名空间中，一组特定的公钥被认为是权威的。&lt;/p&gt;
&lt;p&gt;由于不同的信任域有不同的签发机构，一个信任域的破坏不会危及另一个信任域。这是一个重要的属性，使互不信任的各方之间能够进行安全通信，例如，在 staging 和生产之间或一个公司和另一个公司之间。&lt;/p&gt;
&lt;p&gt;跨越多个信任域验证 SPIFFE 身份的能力被称为 SPIFFE Federation，在本章后面介绍。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-可验证身份文件svid&#34;&gt;SPIFFE 可验证身份文件（SVID）&lt;/h3&gt;
&lt;p&gt;SPIFFE 可验证身份文件（SVID）是一个可加密验证的&lt;strong&gt;身份文件&lt;/strong&gt;，用于向对等体证明一个服务的身份。SVID 包括一个单一的 SPIFFE ID，并由代表服务所在的信任域的签发机构签署。&lt;/p&gt;
&lt;p&gt;与其发明一种新的文件类型让软件支持，SPIFFE 选择利用那些已经被广泛使用并被充分理解的文件类型。在撰写本报告时，有两种身份文件被定义为 SPIFFE 规范中的 SVID 使用：X.509 和 JWT。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X509-SVID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;X509-SVID 将 SPIFFE 身份编码为&lt;a href=&#34;https://tools.ietf.org/html/rfc5280&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标准 X.509 证书&lt;/a&gt;。相应的 SPIFFE ID 被设置为主题替代名称（SAN）扩展字段中的 URI 类型。虽然 X509-SVID 上只允许设置一个 URI SAN 字段，但证书可以包含任何数量的其他类型的 SAN 字段，包括 DNS SAN。&lt;/p&gt;
&lt;p&gt;建议尽可能使用 X509-SVID，因为它们比 JWT-SVID 有更好的安全属性。具体来说，当与 TLS 结合使用时，X.509 证书不能被中间人记录和重放。&lt;/p&gt;
&lt;p&gt;利用 X509-SVID 可能有额外的要求，请参考 &lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/X509-SVID.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;X509-SVID 规范部分&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JWT-SVID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JWT-SVID 将 SPIFFE 身份编码为一个标准的 &lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT&lt;/a&gt;—— 特别是一个 &lt;a href=&#34;https://tools.ietf.org/html/rfc7515&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWS&lt;/a&gt;。JWT-SVID 被用作承载令牌，在应用层向对等者证明身份。与 X509-SVID 不同，JWT-SVID 受到一类被称为 &lt;a href=&#34;https://en.wikipedia.org/wiki/Replay_attack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;重放攻击&lt;/a&gt;的威胁，即令牌被未经授权的一方获得并重新使用。&lt;/p&gt;
&lt;p&gt;SPIFFE 规定了三种机制来缓解这种攻击媒介。首先，JWT-SVID 必须只通过安全通道传输。其次，受众声明（ &lt;code&gt;aud&lt;/code&gt; 声明）必须被设置为与令牌的目的方严格匹配的字符串。最后，所有的 JWT-SVID 必须包括一个过期时间，限制被盗令牌的有效期限。&lt;/p&gt;
&lt;p&gt;尤其需要注意的是，尽管有这些缓解措施，JWT-SVID 从根本上说仍然容易受到重放攻击，因此应该谨慎使用并小心处理。也就是说，它们是 SPIFFE 规范集的一个重要部分，因为它们允许 SPIFFE 认证在不可能建立端到端通信渠道的情况下发挥作用。&lt;/p&gt;
&lt;p&gt;利用 JWT-SVID 可能有额外的要求，请参考 &lt;a href=&#34;https://github.com/spiffe/spiffe/blob/master/standards/JWT-SVID.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT-SVID 规范部分&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-信任包&#34;&gt;SPIFFE 信任包&lt;/h3&gt;
&lt;p&gt;SPIFFE 信任包是一个包含信任域公钥的文件。每种 SVID 类型都有一个特定的方式在这个包中表示出来（例如，对于 X509-SVID，包括代表公钥的 CA 证书）。每个 SPIFFE 信任域都有一个与之相关的捆绑包，该捆绑包中的材料被用来验证声称位于该信任域中的 SVID。&lt;/p&gt;
&lt;p&gt;由于信任包不包含任何秘密（只有公钥），它可以安全地与公众分享。尽管这一事实，它确实需要安全地分发，以保护其内容不被擅自修改。换句话说，保密性是不需要的，但完整性是需要的。&lt;/p&gt;
&lt;p&gt;SPIFFE 捆绑包的格式是 JWK Set（或 JWKS 文档），与现有的认证技术如 &lt;a href=&#34;https://openid.net/connect/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenID Connect&lt;/a&gt; 兼容。JWKS 是一种灵活且被广泛采用的格式，用于表示各种类型的加密密钥和文件，在新的 SVID 格式被定义的情况下，它提供了一些未来证明。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-federation&#34;&gt;SPIFFE Federation&lt;/h3&gt;
&lt;p&gt;通常，允许在不同信任域的服务之间进行安全通信是可取的。在许多情况下，你不能把所有的服务放在一个信任域中。一个常见的例子是两个不同的组织需要相互通信。另一个例子可能是一个组织需要建立安全边界，也许是在信任度较低的云环境和高度信任的内部服务之间。&lt;/p&gt;
&lt;p&gt;为了能够实现这一点，每个服务必须拥有远程服务所来自的外部信任域的&lt;strong&gt;捆绑包（Bundle）&lt;/strong&gt;。因此，SPIFFE 信任域必须公开或以其他方式分享其捆绑包内容，使外部信任域中的服务能够验证来自本地信任域的身份。用于共享信任域的捆绑内容的机制被称为&lt;strong&gt;捆绑端点（Bundle Endpoint）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;捆绑端点是简单的 TLS 保护的 HTTP 服务。希望与外部信任域联合的运营商必须用外部信任域的名称和捆绑端点的 URL 来配置他们的 SPIFFE 实现，允许定期获取捆绑包的内容。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-43-有两个不同的信任域通过联邦连接的公司架构的说明每个-spire-服务器只能为自己的信任域签署-svid&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-3.jpg&#34; alt=&#34;图 4.3: 有两个不同的信任域通过联邦连接的公司架构的说明。每个 SPIRE 服务器只能为自己的信任域签署 SVID。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.3: 有两个不同的信任域通过联邦连接的公司架构的说明。每个 SPIRE 服务器只能为自己的信任域签署 SVID。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;spiffe-workload-api&#34;&gt;SPIFFE Workload API&lt;/h3&gt;
&lt;p&gt;SPIFFE Workload API 是一个本地的、非网络化的 API，工作负载用它来获取当前的身份文件、信任捆绑和相关信息。重要的是，这个 API 是&lt;strong&gt;未经认证的&lt;/strong&gt;，不要求工作负载拥有任何预先存在的证书。将这一功能作为本地 API 提供，允许 SPIFFE 实现者提出创造性的解决方案，在不需要直接认证的情况下识别调用者（例如，利用操作系统提供的功能）。Workload API 以 gRPC 服务器的形式公开，并使用双向流，允许根据需要将更新推入工作负载。&lt;/p&gt;
&lt;p&gt;Workload API 不要求调用的工作负载对自己的身份有任何了解，也不要求调用 API 时拥有任何凭证。这就避免了在工作负载旁边部署任何认证秘密的需要。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-44工作负载-api-提供信息和设施来利用-spiffe-的身份&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-4.jpg&#34; alt=&#34;图 4.4：工作负载 API 提供信息和设施来利用 SPIFFE 的身份。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.4：工作负载 API 提供信息和设施来利用 SPIFFE 的身份。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;SPIFFE 工作负载 API 向工作负载提供 SVID 和信任包，并在必要时对其进行轮换。&lt;/p&gt;
&lt;h2 id=&#34;什么是-spire&#34;&gt;什么是 SPIRE？&lt;/h2&gt;
&lt;p&gt;SPIFFE 运行环境（SPIRE）是 SPIFFE 规范中所有五个部分的一个生产可用的开源实现。&lt;/p&gt;
&lt;p&gt;SPIRE 项目（以及 SPIFFE）由云原生计算基金会主办，该基金会由许多领先的基础设施技术公司成立，为有利于云原生社区的开源项目提供一个中立的家园。&lt;/p&gt;
&lt;p&gt;SPIRE 有两个主要组成部分：服务器和代理。服务器负责验证代理和构建 SVID，而代理则负责为 SPIFFE Workload API 提供服务。这两个组件都是使用面向插件的架构编写的，因此它们可以很容易地被扩展，以适应大量不同的配置和平台。&lt;/p&gt;
&lt;h3 id=&#34;spire-架构&#34;&gt;SPIRE 架构&lt;/h3&gt;
&lt;p&gt;SPIRE 的架构由两个关键组件组成，即 SPIRE 服务器和 SPIRE 代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPIRE 服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 服务器管理和发布 SPIFFE 信任域中的所有身份。它使用一个数据存储来保存关于其代理和工作负载等的信息。SPIRE 服务器通过使用注册条目获知其管理的工作负载，注册条目是为节点和工作负载分配 SPIFFE ID 的灵活规则。&lt;/p&gt;
&lt;p&gt;该服务器可以通过 API 或命令行命令进行管理。需要注意的是，由于服务器掌握着 SVID 的签名密钥，它被认为是一个重要的安全组件。在决定它的位置时应特别考虑。这一点将在本书后面讨论。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;数据存储&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 服务器使用一个&lt;strong&gt;数据存储&lt;/strong&gt;来跟踪其当前的注册条目，以及它所发布的 SVID 的状态。目前，支持几种不同的 SQL 数据库。SPIRE 内置 SQLite，这是一个内存中的嵌入式数据库，用于开发和测试目的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;上游机构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一个信任域中的所有 SVID 都由 SPIRE 服务器签署。默认情况下，SPIRE 服务器会生成一个自签名证书（用自己随机生成的私钥签名的证书）来签署 SVID，除非配置了一个 &lt;strong&gt;上游证书机构（Upstream Certificate Authority）&lt;/strong&gt; 插件接口。上游证书授权的插件接口允许 SPIRE 从另一个证书授权机构获得其签名证书。&lt;/p&gt;
&lt;p&gt;在许多简单的情况下，使用自签名的证书就可以了。然而，对于较大的安装，可能需要利用预先存在的证书颁发机构和 X.509 证书的分层性质，使多个 SPIRE 服务器（和其他生成 X.509 证书的软件）一起工作。&lt;/p&gt;
&lt;p&gt;在一些组织中，上游证书颁发机构可能是一个中央证书颁发机构，你的组织在其他方面使用它。如果你有许多不同种类的证书在使用，而且你希望它们在你的基础设施中都被信任，那么这就很有用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SPIRE 代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 代理只有一个功能，尽管是一个非常重要的功能：为 Workload API 服务。在完成这一壮举的过程中，它解决了一些相关的问题，如确定工作负载的身份，调用它，并安全地将自己介绍给 SPIRE 服务器。在这种安排中，它是执行所有重任的代理。&lt;/p&gt;
&lt;p&gt;代理不需要像 SPIRE 服务器那样的主动管理。虽然它们确实需要一个配置文件，但 SPIRE 代理从 SPIRE 服务器直接接收有关本地信任域和可能调用它的工作负载的信息。在给定的信任域中定义新的工作负载时，只需在 SPIRE 服务器中定义或更新记录，有关新工作负载的信息就会自动传播给相应的代理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-45spire-代理暴露了-spiffe-workload-api并与-spire-服务器一起工作向调用代理的工作负载发布身份信息&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-5.jpg&#34; alt=&#34;图 4.5：SPIRE 代理暴露了 SPIFFE Workload API，并与 SPIRE 服务器一起工作，向调用代理的工作负载发布身份信息。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.5：SPIRE 代理暴露了 SPIFFE Workload API，并与 SPIRE 服务器一起工作，向调用代理的工作负载发布身份信息。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;插件架构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 是作为一套插件建立的，因此很容易扩展，以适应新的节点验证器、工作负载验证器和上游机构。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-46spire-支持的密钥插件接口说明服务器包括-node-attestorkeymanager-和-upstream-authority-插件而-agent-端包括-node-attestor-和-workload-attestor-插件&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-6.jpg&#34; alt=&#34;图 4.6：SPIRE 支持的密钥插件接口说明。服务器包括 Node Attestor、KeyManager 和 Upstream Authority 插件，而 Agent 端包括 Node Attestor 和 Workload Attestor 插件。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.6：SPIRE 支持的密钥插件接口说明。服务器包括 Node Attestor、KeyManager 和 Upstream Authority 插件，而 Agent 端包括 Node Attestor 和 Workload Attestor 插件。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SVID 管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 代理使用其在节点认证期间获得的身份，向 SPIRE 服务器进行认证，并获得其被授权管理的工作负载的 SVID。由于 SVID 是有时间限制的，代理还负责根据需要更新 SVID，并将这些更新传达给相关工作负载。信任捆绑也会轮换和接收捆绑包，这些更新由代理跟踪并传达给工作负载。代理维护所有这些信息的内存缓存，因此，即使 SPIRE 服务器停机，也可以提供 SVID，而且还可以确保 Workload API 响应的性能，因为当有人调用工作负载 API 时，不需要往返于服务器。&lt;/p&gt;
&lt;h3 id=&#34;证明&#34;&gt;证明&lt;/h3&gt;
&lt;p&gt;证明是一个过程，通过这个过程可以发现和断言有关工作负载及其环境的信息。换句话说，它是一个利用现有信息作为证据证明工作负载身份的过程。&lt;/p&gt;
&lt;p&gt;在 SPIRE 中，有两种类型的证明：节点和工作负载证明。节点证明主张描述节点的属性（例如，特定 AWS 自动扩展组的成员，或节点位于哪个 Azure 区域），而工作负载证明主张描述工作负载的属性（例如，它正在运行的 Kubernetes 服务账户，或磁盘上的二进制文件的路径）。这些属性在 SPIRE 中的表述被称为&lt;strong&gt;选择器（Selector）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;SPIRE 支持几十种开箱即用的选择器类型，而且这个列表还在继续增加。截至本文撰写之时，节点验证器列表包括对裸机、Kubernetes、亚马逊网络服务、谷歌云平台、Azure 等的支持。工作负载验证器包括对 Docker、Kubernetes、Unix 等的支持。&lt;/p&gt;
&lt;p&gt;此外，SPIRE 的可插拔架构允许运营商轻松扩展系统，以支持他们认为合适的其他选择器类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;节点认证发生在代理首次启动时。在节点认证中，代理与 SPIRE 服务器联系并进行交流，服务器旨在积极识别代理正在运行的节点及其所有相关选择器。为了实现这一目标，在代理和服务器中都运行了一个特定平台的插件。例如，在 AWS 的情况下，代理插件从 AWS 收集只有该特定节点可以访问的信息（由 AWS 密钥签署的文件），并将其传递给服务器。然后，服务器插件验证 AWS 的签名，并进一步调用 AWS 的 API，以断定该声明的准确性，并收集有关该节点的额外选择器。&lt;/p&gt;
&lt;p&gt;成功的节点认证会导致其向有关的代理发放身份。然后，代理使用这个身份进行所有进一步的服务器通信。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-47在-aws-中运行的节点的节点证明&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-7.jpg&#34; alt=&#34;图 4.7：在 AWS 中运行的节点的节点证明。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.7：在 AWS 中运行的节点的节点证明。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理收集节点的身份证明，调用 AWS 的 API。&lt;/li&gt;
&lt;li&gt;代理将此身份证明发送给服务器。&lt;/li&gt;
&lt;li&gt;服务器通过调用 AWS API 验证步骤 2 中获得的身份证明，然后为代理创建一个 SPIFFE ID。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;工作负载证明&#34;&gt;工作负载证明&lt;/h3&gt;
&lt;p&gt;工作负载认证是确定工作负载身份的过程，它将导致身份文件的发布和交付。在工作负载调用并建立与 SPIFFE Workload API 的连接时（在工作负载对 API 的每一次 RPC 调用中），都会进行认证，而此后的过程则由 SPIRE 代理上的一组插件驱动。&lt;/p&gt;
&lt;p&gt;当代理收到来自调用工作负载的新连接时，代理将利用操作系统功能来确定到底是哪个进程打开了新连接。所利用的操作系统功能将取决于代理运行的操作系统。在 Linux 的情况下，代理将进行系统调用，以检索进程 ID，用户标识符，以及在特定套接字上调用的远程系统的全局唯一标识符。在 BSD 和 Windows 中，要求的内核元数据将是不同的。反过来，代理将向验证器插件提供调用工作负载的 ID。从这里开始，验证器在其插件中扇出，提供关于调用者的额外进程信息，并以选择器的形式将其返回给代理。&lt;/p&gt;
&lt;p&gt;每个验证器插件负责对调用者进行内省，生成一组描述调用者的选择器。例如，一个插件可以查看内核级别的细节，并生成选择器，如进程以何种身份运行的用户和组，而另一个插件可以与 Kubernetes 通信，并生成选择器，如进程运行的命名空间和服务账户。第三个插件可以与 Docker 守护进程通信，并生成 Docker 镜像 ID、Docker 标签和容器环境变量的选择器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-48-工作负载证明&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-8.jpg&#34; alt=&#34;图 4.8: 工作负载证明。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.8: 工作负载证明。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工作负载调用 Workload API 请求 SVID。&lt;/li&gt;
&lt;li&gt;代理询问节点的内核以获得调用进程的属性。&lt;/li&gt;
&lt;li&gt;代理得到发现的选择器。&lt;/li&gt;
&lt;li&gt;代理通过比较发现的选择器和注册条目来确定工作负载的身份，并向工作负载返回正确的 SVID。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;登记条目&#34;&gt;登记条目&lt;/h3&gt;
&lt;p&gt;为了让 SPIRE 发布工作负载身份，它必须首先了解其环境中预期或允许的工作负载；哪些工作负载应该在哪里运行，它们的 SPIFFE ID 和一般组成应该是什么。SPIRE 通过&lt;strong&gt;注册条目&lt;/strong&gt;了解这些信息，注册条目是使用 SPIRE API 创建和管理的对象，包含上述信息。&lt;/p&gt;
&lt;p&gt;对于每个注册条目，有三个核心属性。第一个被称为 Parent ID—— 这实际上是告诉 SPIRE 一个特定的工作负载应该在哪里运行（以及延伸到哪些代理被授权代表它询问 SVID）。第二个是 SPIFFE ID—— 当我们看到这个工作负载时，我们应该向它发出什么 SPIFFE ID？最后，SPIRE 需要一些信息来帮助它识别工作负载，这就是证明中选择器的作用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-49注册条目的三个核心属性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-9.jpg&#34; alt=&#34;图 4.9：注册条目的三个核心属性。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.9：注册条目的三个核心属性。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;注册条目将 SPIFFE ID 与它们所代表的节点和工作负载绑定。&lt;/p&gt;
&lt;p&gt;注册条目既可以描述一组节点，也可以描述一个工作负载，后者通常使用 Parent ID 来引用前者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点条目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;描述一个节点（或一组节点）的注册条目使用由节点认证产生的选择器来分配一个 SPIFFE ID，这在以后注册工作负载时可以被引用。一个节点可以被证明有一组与多个节点条目相匹配的选择器，从而允许它加入一个以上的组。在决定一个特定的工作负载被允许运行的确切位置时，这提供了很大的灵活性。&lt;/p&gt;
&lt;p&gt;SPIRE 自带各种节点验证器可供使用，每个验证器都会生成特定平台的选择器。虽然 SPIRE 服务器支持一次加载多个节点验证器插件，但 SPIRE 代理只支持加载一个。目前可用的节点选择器包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在谷歌云平台（GCP）上。&lt;/li&gt;
&lt;li&gt;在 Kubernetes 上，该节点所处的 Kubernetes 集群的名称。&lt;/li&gt;
&lt;li&gt;在亚马逊网络服务（AWS），节点的 AWS 安全组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点条目的 Parent ID 被设置为 SPIRE 服务器的 SPIFFE ID，因为是服务器在进行验证，并断言有关节点确实符合条目定义的选择器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作负载条目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;描述工作负载的注册条目使用由工作负载证明产生的选择器，在满足一定条件的情况下为工作负载分配一个 SPIFFE ID。当 Parent ID 和选择器的条件得到满足时，工作负载可以得到一个 SPIFFE ID。&lt;/p&gt;
&lt;p&gt;工作负载条目的 Parent ID 描述了该工作负载被授权运行的地方。其值是一个节点或一组节点的 SPIFFE ID。在节点上运行的 SPIRE 代理会收到该工作负载条目的副本，包括在为该特定条目发出 SVID 之前必须证明的选择器。&lt;/p&gt;
&lt;p&gt;当工作负载调用代理时，代理进行工作负载验证，并将发现的选择器与条目中定义的选择器进行交叉对比。如果一个工作负载拥有整个定义的选择器集，那么条件就得到了满足，该工作负载就会得到一个带有定义的 SPIFFE ID 的 SVID。&lt;/p&gt;
&lt;p&gt;与节点认证不同，SPIRE 代理支持同时加载许多工作负载验证器插件。这允许在工作负载条目中混合匹配选择器。例如，工作负载条目可能要求工作负载在特定的 Kubernetes 命名空间中，在其 Docker 镜像上应用特定的标签，并具有特定的 SHA 和。&lt;/p&gt;
&lt;h2 id=&#34;spiffespire-应用的概念威胁模型&#34;&gt;SPIFFE/SPIRE 应用的概念威胁模型&lt;/h2&gt;
&lt;p&gt;SPIFFE 和 SPIRE 所面临的一系列具体威胁是情景性的。了解 SPIFFE/SPIRE 的一般威胁模式是断言你的具体需求可以得到满足的重要步骤，也是发现可能需要进一步缓解的地方。&lt;/p&gt;
&lt;p&gt;在本节中，我们将描述 SPIFFE 和 SPIRE 的安全边界，以及系统中每个组件被破坏的影响。在本书的后面，我们将介绍不同的 SPIRE 部署模式所带来的具体安全考虑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 旨在作为分布式身份和认证的基础，与&lt;a href=&#34;https://github.com/cncf/toc/blob/master/DEFINITION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生&lt;/a&gt;设计架构一致。SPIRE 支持 Linux 和 BSD 系列（包括 MacOS）。目前不支持 Windows，尽管在这个领域已经做了一些早期的原型设计。&lt;/p&gt;
&lt;p&gt;SPIRE 坚持零信任网络安全模型，其中假定网络通信是敌对的或可能完全被破坏。也就是说，还假设 SPIRE 组件运行的硬件以及其操作人员是值得信赖的。如果硬件植入或内部威胁是威胁模型的一部分，应围绕 SPIRE 服务器的物理位置和其配置参数的安全性进行仔细考虑。&lt;/p&gt;
&lt;p&gt;根据所选择的节点和工作负载证明方法，可能进一步隐含对第三方平台或软件的信任。通过多个独立的机制来证明信任，可以提供更多的信任证明。例如，利用基于 AWS 或 GCP 的节点证明，意味着计算平台被认为是值得信赖的，而利用 Kubernetes 的工作负载证明，意味着 Kubernetes 的部署被认为是值得信赖的。由于完成证明的方式多种多样，而且 SPIRE 架构是完全可插拔的，因此本评估不考虑这些流程的安全性（和相关假设）。相反，它们应逐一进行评估。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-410作为威胁模型的一部分被考虑的组件&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-10.jpg&#34; alt=&#34;图 4.10：作为威胁模型的一部分被考虑的组件。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.10：作为威胁模型的一部分被考虑的组件。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;安全边界&#34;&gt;安全边界&lt;/h3&gt;
&lt;p&gt;安全边界在形式上被理解为两个不同信任程度的区域之间的交汇线。&lt;/p&gt;
&lt;p&gt;SPIFFE/SPIRE 定义了三个主要的安全边界：一个是工作负载和代理之间，一个是代理和服务器之间，还有一个是不同信任域的服务器之间。在这个模型中，工作负载是完全不受信任的，其他信任域中的服务器也是如此，如前所述，网络通信始终是完全不受信任的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-411spiffespire-的安全边界&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f4-11.jpg&#34; alt=&#34;图 4.11：SPIFFE/SPIRE 的安全边界。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4.11：SPIFFE/SPIRE 的安全边界。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作负载 | 代理边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着人们在系统中的移动和跨越这些边界，信任程度会慢慢增加。从工作负载开始，我们跨越安全边界进入代理。通常预计（尽管不是必须的），工作负载和代理之间存在超越 SPIRE 设计的安全机制，例如利用 Linux 用户权限和 / 或容器化。&lt;/p&gt;
&lt;p&gt;代理不相信工作负载会提供任何形式的输入。代理对工作负载身份的所有断言都是通过带外检查做出的。在工作负载证明的背景下，这是一个重要的细节 —— 任何选择器的值可以被工作负载本身操纵，这本身就是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理 | 服务器边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一个边界存在于代理和服务器之间。代理比工作负载更值得信任，但比服务器更不值得信任。SPIRE 的一个明确的设计目标是，它应该能够在节点受到威胁的情况下存活。由于工作负载是完全不可信的，我们在任何给定的时间点上离节点只有一到两次攻击威胁。代理有能力代表工作负载创建和管理身份，但也有必要将任何特定代理的权力限制在它完成任务所严格需要的范围内（遵循最小特权原则）。&lt;/p&gt;
&lt;p&gt;为了减轻节点（和代理）受到威胁的影响，SPIRE 需要了解特定工作负载被授权运行的地方（以 Parent ID 的形式）。代理必须能够证明注册条目的所有权，然后才能为其获得身份。因此，被攻击的代理不能获得任意的身份 —— 它们只能获得首先应该在节点上运行的工作负载的身份。&lt;/p&gt;
&lt;p&gt;值得注意的是，在节点认证过程中，SPIRE 服务器和 SPIRE 代理之间的通信可以在不同的时间点使用 TLS 和相互 TLS，这取决于节点是否尚未被认证，或者代理是否已经拥有有效的 SVID 并可以将其用于相互 TLS，此时服务器和代理之间的所有通信是安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器 | 服务器边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后的边界存在于不同信任域的服务器之间。SPIRE 服务器只被信任为在其直接管理的信任域内构造的 SVID。当 SPIRE 服务器相互联合并交换公钥信息时，它们收到的秘钥仍然是在它们所收到的信任域范围内的。与网络 PKI 不同，SPIFFE 不会简单地把所有的公钥扔到一个大的混合包里。其结果是，如果外部信任域的破坏不会导致本地信任域的 SVID 的构造能力。&lt;/p&gt;
&lt;p&gt;应该注意的是，SPIRE 服务器没有任何多方保护。信任域中的每个 SPIRE 服务器都可以访问签名密钥，它可以用这些密钥构造 SVID。服务器之间存在的安全边界严格限于不同信任域的服务器，不适用于同一信任域内的服务器。&lt;/p&gt;
&lt;h3 id=&#34;组件被破坏后的影响&#34;&gt;组件被破坏后的影响&lt;/h3&gt;
&lt;p&gt;虽然工作负载总是被认为是被破坏的，但预计代理一般不会被破坏。如果一个代理被破坏，攻击者将能够访问相应代理被授权管理的任何身份。在工作负载和代理之间存在 1:1 关系的部署中，这一点不太值得关注。在代理管理多个工作负载的部署中，这是一个需要理解的重要问题。&lt;/p&gt;
&lt;p&gt;当代理被引用为某一身份的父代时，它们被授权管理该身份。由于这个原因，在合理的范围内，将注册条目父身份的范围尽可能地缩小是一个好主意。&lt;/p&gt;
&lt;p&gt;在服务器被破坏的情况下，可以预计，攻击者将能够在该信任域内构造任意的身份。SPIRE 服务器无疑是整个系统中最敏感的组成部分。在管理和放置这些服务器时应小心谨慎。例如，SPIRE 解决了节点破坏的问题，因为工作负载不受信任，但如果 SPIRE 服务器与不受信任的工作负载在同一主机上运行，那么服务器就不再享有曾经由代理 / 服务器安全边界提供的保护。因此，强烈建议将 SPIRE 服务器放在与它们要管理的不受信任的工作负载不同的硬件上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理的注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 通过将一个代理的权限限定在它直接被授权管理的身份上，来说明节点的破坏&amp;hellip;&amp;hellip; 但如果攻击者可以破坏多个代理，或者也许是所有的代理，情况就明显要糟糕得多。&lt;/p&gt;
&lt;p&gt;SPIRE 代理之间没有任何通信途径，大大限制了代理之间横向移动的可能性。这是一个重要的设计决定，旨在减轻可能的代理漏洞的影响。然而，应该理解的是，某些配置或部署选择可能部分或全部破坏这种缓解。例如，SPIRE 代理支持暴露一个 Prometheus 指标端点，然而，如果所有代理都暴露这个端点，并且那里存在漏洞，那么横向移动就变得轻而易举，除非有足够的网络级别控制。出于这个原因，我们强烈不建议将 SPIRE 代理暴露于传入的网络连接。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>开始前的准备</title>
      <link>https://lib.jimmysong.io/spiffe/before-you-start/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/before-you-start/</guid>
      <description>&lt;p&gt;本章旨在让你为上线 SPIFFE/SPIRE 时需要做出的许多决定做好准备。&lt;/p&gt;
&lt;h2 id=&#34;准备人力&#34;&gt;准备人力&lt;/h2&gt;
&lt;p&gt;如果你读了前面的章节，你一定很想开始使用 SPIRE，以一种可以在许多不同类型的系统和所有组织的服务中利用的方式管理身份。然而，在你开始之前，你需要考虑，部署 SPIRE 是&lt;strong&gt;一个重大的基础设施变化&lt;/strong&gt;，有可能影响到许多不同的系统。本章是关于如何开始规划 SPIRE 的部署：获得认同，以不中断的方式启用 SPIRE 支持，然后利用它来实施新的安全控制。&lt;/p&gt;
&lt;h3 id=&#34;组建团队并确定其他利益相关者&#34;&gt;组建团队并确定其他利益相关者&lt;/h3&gt;
&lt;p&gt;要部署 SPIRE，你需要确定来自安全、软件开发和 DevOps 团队的利益相关者。谁来维护 SPIRE 服务器本身？谁来部署代理？谁来编写注册条目？谁将把 SPIFFE 功能集成到应用程序中？它将如何影响现有的 CI/CD 管道？如果发生了服务中断，谁来修复它？性能要求和服务水平目标是什么？&lt;/p&gt;
&lt;p&gt;在这本书中，以及许多公开的博客文章和会议演讲中，都有一些成功部署 SPIRE 的组织的例子，既可以作为一种模式，也可以作为向同事宣传 SPIRE 的有用材料。&lt;/p&gt;
&lt;h3 id=&#34;说明你的情况并获得支持&#34;&gt;说明你的情况并获得支持&lt;/h3&gt;
&lt;p&gt;SPIRE 跨越了几个不同的传统信息技术孤岛，因此，期望看到你的 DevOps 团队、软件开发团队和安全团队之间有更多的跨组织合作。重要的是，他们要一起工作，以确保成功和无缝部署。考虑到这些团队中的每一个都有不同的需求和优先事项，需要解决这些问题以获得他们的支持。&lt;/p&gt;
&lt;p&gt;在规划 SPIRE 部署时，你需要了解哪些成果对你的企业最重要，并将这些成果作为项目的驱动力和你将提供的解决方案的价值。每个团队都需要看到 SPIRE 对自己以及对整个企业的好处。本书第 2 章 &amp;ldquo;收益&amp;rdquo; 中描述了 SPIRE 部署的许多好处，在本节中，我们将把其中一些好处提炼成令人信服的论据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对安全团队有说服力的论点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;减少安全团队的工作量是部署 SPIRE 的一个非常有说服力的案例：他们可以专注于设计正确的注册条目，以确保每个服务获得正确的身份，而不是部署临时的安全解决方案，以及手动管理数百或数千个证书。&lt;/p&gt;
&lt;p&gt;一个更长期的好处是，SPIRE 可以提高组织的整体安全态势，因为 SPIRE 没有容易被盗或误用的凭证。与盗用或歪曲凭证有关的大量攻击，以及敏感数据的暴露，都得到了缓解。有可能向外部审计师证明，正确的服务正在相互安全地进行通信，没有意外疏忽的可能。即使外部人员可以破坏一个服务，他们对其他服务发起攻击的能力也是有限的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对软件开发团队有说服力的论点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于应用程序开发团队来说，他们能够通过不等待工单或手动工作流程来提供证书而加快行动，这是最有说服力的案例。如果他们目前在代码旁边手动部署秘密，并被安全团队谈话，他们不再需要忍受这些。他们也不需要在秘密存储中管理秘密。&lt;/p&gt;
&lt;p&gt;一个次要的好处是，软件组件可能能够以它们以前无法安全进行的方式直接进行通信。如果云服务不能访问一个关键的数据库或基本的云服务，因为没有办法安全地做到这一点，那么就有可能使用 SPIFFE 身份来创建一个安全连接，为你的团队提供新的架构潜力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对 DevOps 团队有说服力的论点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署 SPIRE 的最大收益是针对 DevOps 团队。如果每个服务都有自己的安全身份，那么服务就可以部署在任何地方 —— 在任何内部数据中心、云供应商或一个云供应商中的区域。这种新的灵活性允许降低成本，提高可扩展性，并改善可靠性，因为部署决策可以独立于安全要求。&lt;/p&gt;
&lt;p&gt;对 DevOps 团队来说，另一个关键的好处是，每个服务的传入请求都被贴上 SPIFFE ID 的标签，这可以被记录、测量，并报告给监控系统。这对拥有数百或数千项服务的大型组织的性能管理是非常有帮助的。&lt;/p&gt;
&lt;h2 id=&#34;创建一个计划&#34;&gt;创建一个计划&lt;/h2&gt;
&lt;p&gt;规划 SPIRE 部署的第一个目标是确定是否每项服务都需要被 SPIFFE 感知，或者非 SPIFFE 服务的 &amp;ldquo;孤岛&amp;rdquo; 是否仍然可以满足要求。将每项服务都转移到 SPIFFE 是最直接的选择，但要一下子全部实施可能是个挑战，特别是在非常大的组织中。&lt;/p&gt;
&lt;h3 id=&#34;岛屿和桥梁的规划&#34;&gt;岛屿和桥梁的规划&lt;/h3&gt;
&lt;p&gt;有些环境很复杂，要么有多个组织，要么是传统和新开发的结合。在这种情况下，人们往往希望只让环境的一个子集启用 SPIFFE。需要考虑两种选择，这取决于系统之间的整合程度和它们之间的复杂性。让我们来看看这两种架构，我们称之为 &amp;ldquo;独立岛&amp;rdquo; 和“桥接岛”。&lt;/p&gt;
&lt;p&gt;每个岛被认为是它自己的信任域，在每个岛上有工作负载或“居民”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立岛&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-51这里有两个独立的-spiffe-部署独立岛屿&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-1.jpg&#34; alt=&#34;图 5.1：这里有两个独立的 SPIFFE 部署（独立岛屿）。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5.1：这里有两个独立的 SPIFFE 部署（独立岛屿）。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;独立岛模式允许各个信任域相互独立运行。这通常是最简单的选择，因为每个岛可以以对该岛有意义的方式运行 SPIRE。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桥接岛&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-52这里我们有两个独立的-spiffe-部署通过-federation-桥接使每个岛的服务都能信任对方从而进行通信在-spiffe-和非-spiffe-岛屿之间仍然没有通信&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-2.jpg&#34; alt=&#34;图 5.2：这里我们有两个独立的 SPIFFE 部署，通过 Federation 桥接，使每个岛的服务都能信任对方，从而进行通信。在 SPIFFE 和非 SPIFFE 岛屿之间仍然没有通信。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5.2：这里我们有两个独立的 SPIFFE 部署，通过 Federation 桥接，使每个岛的服务都能信任对方，从而进行通信。在 SPIFFE 和非 SPIFFE 岛屿之间仍然没有通信。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-53-向非-spiffe-岛添加网关是连接-spiffe-和非-spiffe-岛的一种方式&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-3.jpg&#34; alt=&#34;图 5.3: 向非 SPIFFE 岛添加网关是连接 SPIFFE 和非 SPIFFE 岛的一种方式。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5.3: 向非 SPIFFE 岛添加网关是连接 SPIFFE 和非 SPIFFE 岛的一种方式。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;桥接岛模式允许非 SPIFFE 岛上的非 SPIFFE 服务与网关对话。然后，网关将请求转发给支持 SPIFFE 的岛上的居民，我们称他们为 Zero。从 Zero 的角度来看，网关发出了请求。Zero 和他在支持 SPIFFE 的岛上的朋友可以向网关进行认证，并向非 SPIFFE 岛上的服务发送消息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-54在这个图中有一个支持-spiffe-的生态系统大陆而在这个生态系统中有一个非-spiffe-服务的口袋湖上的岛屿为了使大陆和岛屿上的服务能够相互交流需要有一个网关&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-4.jpg&#34; alt=&#34;图 5.4：在这个图中，有一个支持 SPIFFE 的生态系统（大陆），而在这个生态系统中，有一个非 SPIFFE 服务的口袋（湖上的岛屿）。为了使大陆和岛屿上的服务能够相互交流，需要有一个网关。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5.4：在这个图中，有一个支持 SPIFFE 的生态系统（大陆），而在这个生态系统中，有一个非 SPIFFE 服务的口袋（湖上的岛屿）。为了使大陆和岛屿上的服务能够相互交流，需要有一个网关。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-55桥接岛结构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-5.jpg&#34; alt=&#34;图 5.5：桥接岛结构。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5.5：桥接岛结构。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在桥接岛架构下，网关是在未启用 SPIFFE 的岛上创建的。这些非 SPIFFE 岛可能不容易采用 SPIFFE 架构，原因有很多：可能有遗留软件，不能轻易修改或更新；岛屿可能使用自己的识别生态系统，如 Kerberos 或 SPIFFE 与其他技术比较一章中描述的其他选项之一；或者系统可能在不太适合现有 SPIFFE 解决方案（如 SPIRE）模式的技术上运行工作负载。&lt;/p&gt;
&lt;p&gt;在这些情况下，使用&lt;strong&gt;网关&lt;/strong&gt;服务在 SPIFFE 世界和非 SPIFFE 岛之间架起连接的桥梁可能是有用的。当支持 SPIFFE 的工作负载想要与非 SPIFFE 岛的工作负载对话时，它与网关建立一个经过认证的连接，然后与目标工作负载建立一个连接。这个与目标工作负载的连接可能是未经认证的，或者使用该岛的非 SPIFFE 身份解决方案。同样，当非 SPIFFE 岛的工作负载想要连接到 SPIFFE 启用的工作负载时，非 SPIFFE 工作负载会连接到网关，然后创建一个 SPIFFE 认证的连接到目标 SPIFFE 启用的工作负载。&lt;/p&gt;
&lt;p&gt;在这种情况下，发生在网关和启用 SPIFFE 的工作负载之间的认证在网关处被&lt;strong&gt;终止&lt;/strong&gt;。这意味着支持 SPIFFE 的工作负载可以验证它是在与适当的网关对话，但不能验证它是在与网关另一端的正确工作负载对话。同样，目标工作负载只知道网关服务向它发送了一个请求，但却失去了原 SPIFFE 启用的工作负载的验证背景。这种模式允许这些复杂的组织开始采用 SPIFFE，而不必一下子转换。&lt;/p&gt;
&lt;p&gt;在请求和工作流通过非 SPIFFE 岛的情况下，利用 JWT-SVID 进行跨请求的传播会很有用。你可以使用 X509-SVID 来签署文件（&lt;a href=&#34;https://tools.ietf.org/id/draft-cavage-http-signatures-12.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如 HTTP 消息请求签署&lt;/a&gt;），而不是只使用服务间的相互认证的 TLS，这样整个消息的真实性就可以被另一边支持 SPIFFE 的工作负载所验证。这对已知安全属性较弱的岛屿特别有用，因为它提供了对通过中间生态系统的消息没有被操纵的信心。&lt;/p&gt;
&lt;h3 id=&#34;文档和监控工具&#34;&gt;文档和监控工具&lt;/h3&gt;
&lt;p&gt;在准备开始上线时，重要的是要对服务进行检测，使指标和流量日志以一种方式暴露出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监督上线的人知道哪些（以及有多少）服务是支持 SPIFFE 的，哪些（以及有多少）不是。&lt;/li&gt;
&lt;li&gt;客户端作者知道他们调用的哪些服务是支持 SPIFFE 的，哪些不是。&lt;/li&gt;
&lt;li&gt;服务所有者知道他们的哪些客户端以及有多少客户端在调用支持 SPIFFE 的端点，哪些在调用传统端点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要的是，要为客户端和服务器实施者创建参考文件，预测你将收到的支持请求的种类，从而为上线做准备。&lt;/p&gt;
&lt;p&gt;同样重要的是，创建工具来协助完成常见的调试和故障排除任务。回顾 SPIFFE 和 SPIRE 的收益，将 SPIFFE 引入你的组织应该赋予开发人员权力并消除路障。给利益相关者留下的印象是你在增加工作或制造摩擦，最终会减缓或停止更广泛的采用。为了减少这种情况，并确保文档和工具涵盖适当的主题，我们建议采取以下准备步骤。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;步骤&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;决定你将需要 SPIFFE 的哪些安全功能。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SPIFFE 身份可用于创建相互的 TLS 连接，用于授权，或其他功能，如审计日志。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定使用什么格式的 SVID，用于什么目的。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;最常见的是将 X509-SVID 用于相互 TLS，但要确定这是否适用以及 SVID 是否将用于任何其他应用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定需要身份认证的工作负载的数量。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不是每个工作负载都需要身份，特别是在早期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定需要的独立信任域的数量。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每个信任域都需要部署自己的 SPIRE 服务器。做出这一决定的细节在下一章。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;确定你的组织正在使用的语言、框架、IPC 技术等需要与 SPIFFE 兼容。&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;如果使用 X.509-SVID 进行相互 TLS，请确定你的组织中使用了哪些 Web 服务器（Apache HTTPD、NGINX、Tomcat、Jetty 等）以及使用了哪些客户端库。如果客户端库期望执行 DNS 主机名验证，请确保你的 SPIFFE 部署与这种期望兼容。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;了解性能影响&#34;&gt;了解性能影响&lt;/h3&gt;
&lt;p&gt;应将性能影响作为部署规划的一部分加以考虑。&lt;/p&gt;
&lt;p&gt;作为上线准备的一部分，你应该检查一系列工作负载的基准，这些工作负载代表了你的组织在生产中运行的各种应用。这可以确保你至少意识到，并希望能准备好解决在推广过程中可能出现的任何性能问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS 性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在许多组织中，开发人员和运维团队提出的第一个担忧是，在服务之间建立相互的 TLS 连接会太慢。在现代硬件上，通过现代的 TLS 实现，TLS 的性能影响是最小的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;在我们的生产前端机器上，SSL/TLS 占 CPU 负载的比例不到 1%，每个连接占内存的比例不到 10KB，网络开销不到 2%。许多人认为，SSL/TLS 需要大量的 CPU 时间，我们希望前面的数字能帮助消除这种想法。&amp;quot;——Adam Langley， Google，&lt;a href=&#34;https://www.imperialviolet.org/2010/06/25/overclocking-ssl.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Overlocking SSL&lt;/a&gt;，2010 年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“我们已经使用硬件和软件负载均衡器大规模地部署了 TLS。我们发现，在商用 CPU 上运行的基于软件的现代 TLS 实现，其速度足以处理繁重的 HTTPS 追踪负载，而不需要求助于专用加密硬件。&amp;quot;——Doug Beaver，Facebook，&lt;a href=&#34;https://lists.w3.org/Archives/Public/ietf-http-wg/2012JulSep/0251.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP2 Expression of Interest&lt;/a&gt;，2012 年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说，性能影响取决于多种因素，包括网络拓扑结构、API 网关、L4-L7 防火墙和其他许多因素。此外，你所使用的协议及其实现以及证书和密钥大小也可能影响性能，所以这是一个相当广泛的话题。&lt;/p&gt;
&lt;p&gt;下表提供了与 TCP 相比两个不同阶段的开销数据，特别是握手和数据传输阶段的数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;TLS 阶段&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;协议开销&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;延迟&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;CPU&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;内存&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;握手&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TLS 为 2 kB mTLS 为 3 kB +1 kB/add&amp;rsquo;l Cert&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;12 - 17 ms&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;比 TCP 多出约 0.5%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;10kb / 连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据传输&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;22B/packet&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;3 us&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;比 TCP 多不到 1%&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;10 kB / 连接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;向-spiffe-和-spire-转变&#34;&gt;向 SPIFFE 和 SPIRE 转变&lt;/h2&gt;
&lt;p&gt;关于组织如何对变化作出反应、影响和处理的研究有着丰富的历史。关于公众和组织对新技术的接受和采用，也有许多有趣的研究。对这些主题进行真正的公正研究超出了本书的范围，但如果我们不提及这些主题，那就是我们的失职，因为它们与 SPIFFE 的成功推广相关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;令人信服的变化发生&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有几种方法可以说服他人，在你的组织内必须发生变化。下面的清单概述了你可以通过 SPIFFE 和 SPIRE 追求这种变革的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提升感知价值&lt;/strong&gt;：展示 SPIFFE 对工作绩效的积极影响是关键，让人们相信它对他们有实质帮助。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化易用性&lt;/strong&gt;：为了让 SPIFFE 易于使用，必须投入大量精力来提升开发者和运维人员的用户体验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同行影响力&lt;/strong&gt;：重视受尊敬人士对于 SPIFFE 的看法以及他们是否采用它，这将在组织内积累政治资本。说服关键人物通常比说服所有人更为重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提升形象&lt;/strong&gt;：采用 SPIFFE 将对个人在组织中的地位产生显著影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自愿采用&lt;/strong&gt;：SPIFFE 潜在用户的自愿采用程度受公司文化和个性影响。在面对“被迫”采用者和拒绝采用者时，请务必牢记这一点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-56技术采用曲线改编自-roger-的钟形曲线和-gartner-的-hype-cycle图下的蓝色区域代表变化的数量和-spiffe-采用者的数量红线代表对采用-spiffe-的热情和期望&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-6.jpg&#34; alt=&#34;图 5.6：技术采用曲线（改编自 Roger 的钟形曲线和 Gartner 的 Hype Cycle）。图下的蓝色区域代表变化的数量和 SPIFFE 采用者的数量。红线代表对采用 SPIFFE 的热情和期望。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5.6：技术采用曲线（改编自 Roger 的钟形曲线和 Gartner 的 Hype Cycle）。图下的蓝色区域代表变化的数量和 SPIFFE 采用者的数量。红线代表对采用 SPIFFE 的热情和期望。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;采用者角色&#34;&gt;采用者角色&lt;/h3&gt;
&lt;p&gt;采用者与技术曲线相对应，可以帮助设定对如何向 SPIFFE 和 SPIRE 转变的预期。在此，我们列出了技术曲线中所涉及的采用者，并增加了两个你可能会遇到的采用者。&lt;/p&gt;
&lt;p&gt;关于技术采用曲线中的采用者的更多信息可以在本书之外找到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创新者&lt;/strong&gt;：把你自己看作是组织中的创新者，因为你采取了这些步骤来阅读本书，走到这一步，并决定继续前进。你基本上是在开拓将 SPIFFE 和 SPIRE 添加到你的架构中的进程，你需要帮助！你需要一个 &amp;quot; 白手套“级别的支持和和帮助，所以一定要从低垂的果实和先导类别（下文有介绍）中挑选志愿者，并与他们保持良好的关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;早期采用者&lt;/strong&gt;：重要的是要从给予创新者的“白手套 &amp;ldquo;手把手支持水平中吸取经验教训，并将这些经验提炼成易于获取和理解的文档、有用的工具和可扩展的支持渠道。可能需要做大量的工作来实现 SPIFFE 的&amp;rdquo; 先驱者和推动者”（在本章后面会详细介绍），以便开发者能够解除障碍，然后能够实现 SPIFFE 的服务和客户端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;早期和晚期大众&lt;/strong&gt;：当你进入早期多数服务的时候，SPIFFE 的启用过程已经是一台运转良好的机器了。所有常用的使能器，如 CI/CD、工作流引擎、编排器、容器平台和服务网格，都应该启用 SPIFFE，以确保应用开发者在整个应用生命周期中得到支持，无论应用如何运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;落后者&lt;/strong&gt;：由于团队文化、个人性格以及监管或合规要求，你的组织可能有保守的落后者。重要的是，不要对服务所有者为什么会落入这个类别下结论，而是要调查根本原因并适当解决。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ldquo;被迫&amp;rdquo; 转型&lt;/strong&gt;：最后一个采用 SPIFFE 的服务的客户可能会感到被迫转型。重要的是要为被迫转型者做好准备，确保他们采用 SPIFFE 的经验是积极的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滞留者&lt;/strong&gt;：他们会出现，所以要让他们容易接受并受到激励。突出其他人目前正在享受生产力平台的例子。你应该期望提供额外的支持和帮助，因为在这个过程中会有很多人犹豫不决。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;时机选择的考虑因素&#34;&gt;时机选择的考虑因素&lt;/h3&gt;
&lt;p&gt;在你选择谁来做的时候，在你的组织中保持最大的兼容性是至关重要的考虑。服务应保持其现有的 API 接口和端口，并在新的端口上引入其启用 SPIFFE 的 API。这样可以实现平稳过渡，并在需要时方便回滚。有许多来自其他服务团队客户端的服务团队应该期望在很长一段时间内（&amp;gt;6 个月）维护和支持这两个端点。&lt;/p&gt;
&lt;p&gt;一旦一项服务的所有客户端都启用了 SPIFFE，并且不再使用非 SPIFFE 的 API，那么非 SPIFFE 的 API 就可以被关闭。&lt;/p&gt;
&lt;p&gt;要注意不要过早地关闭遗留的端点。要特别注意批处理作业、计划任务和其他类型的不经常或不规则的调用模式。你不希望成为导致季度末或财务年度末对账工作失败的人。&lt;/p&gt;
&lt;p&gt;如果你的环境太大或者太复杂，无法一下子完成，那么在选择服务启用 SPIFFE 的顺序时，一定要深思熟虑。从大石头、最低的果实和 &amp;quot; 先驱者和推动者“的角度来考虑可能会有帮助，以加速采用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-57简化的微服务调用图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-7.jpg&#34; alt=&#34;图 5.7：简化的微服务调用图。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5.7：简化的微服务调用图。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大石头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大石头是指拥有最独特客户端的服务，以及与最多独特服务端连接的客户端。尽早处理大石头可能对加快采用速度很有诱惑力，但可能会导致得不偿失，造成问题，并使其他人不愿采用 SPIFFE。&lt;/p&gt;
&lt;p&gt;看一下上面的调用图，可以通过连接最多的节点来识别大石头。它们可能是被许多客户端调用的关键服务，如 Service 0；它们可能是调用许多服务端的客户端，如 Service 4。大石头还可能包括既是客户端又是服务端的服务，如 Service 7。应对这些服务的迁移，既有好处，也有风险。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;效益&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有吸引力的选择&lt;/li&gt;
&lt;li&gt;潜在的快速采用&lt;/li&gt;
&lt;li&gt;影响广泛的好处&lt;/li&gt;
&lt;li&gt;激励他人采用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;风险和挑战&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长期维护 2 个终端（传统的和支持 SPIFFE 的）&lt;/li&gt;
&lt;li&gt;只有在所有客户端都采用了 SPIFFE 之后，才会关闭传统的端点&lt;/li&gt;
&lt;li&gt;增加维护成本&lt;/li&gt;
&lt;li&gt;增加了复杂性&lt;/li&gt;
&lt;li&gt;扩展了组织能力&lt;/li&gt;
&lt;li&gt;强制采用&lt;/li&gt;
&lt;li&gt;不满的团队&lt;/li&gt;
&lt;li&gt;惊喜的是，角落里有一只乌龟！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;低垂的果实&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最低矮的果实是拥有一至几个客户端的服务，或与一个或几个服务连接的客户端。这些通常是最容易指导过渡的，并且是理想的第一批采用者。&lt;/p&gt;
&lt;p&gt;看一下上面的同一张图，低垂的果实是连接很少的节点。这些服务可能是单一的、其他服务的客户端，如 Service 2。低垂的果实也可能包括只有一个客户端的服务，比如 Service 8。在选择首先迁移哪些连接很少的服务时，明智的做法是选择那些最容易维持双端点的服务（传统的和 SPIFFE），或者那些必须在最短的时间内维持双堆栈的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效益&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果出了问题，风险更小&lt;/li&gt;
&lt;li&gt;由于需要较少的协调和规划，因此更容易从传统的方式完全转换到 SPIFFE 上&lt;/li&gt;
&lt;li&gt;良好做法和学习机会&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;风险和挑战&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推广工作可能被认为是缓慢的&lt;/li&gt;
&lt;li&gt;可能没有足够的可见性或影响力来激发关键服务所有者的采用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;加速采用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些先导因素和推动因素可以促进 SPIFFE 在复杂和异构环境中的采用。它们中的每一个都有一系列不同的好处和挑战需要考虑。上面的考虑因素也适用于此；选择影响最广泛的系统，在确定所有非 SPIFFE 的消费者都已转换之前，不要转而使用非 SPIFFE 功能。&lt;/p&gt;
&lt;p&gt;先行者包括帮助他人采用 SPIFFE 的工具和服务（如 CI/CD 和工作流引擎）。开发和运维工具应该提供给第一批采用者（创新者），并随着早期采用者的加入而反复改进。我们的目标是使工具和服务在早期大多数人加入的时候达到成熟。如果没有足够的前期投资，后期的大多数人和落伍者将陷入困境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发者工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拥有有助于提高生产力的工具是成功推广 SPIFFE 的关键。收集一份你的组织在应用生命周期中使用的现有工具清单，从开发到运维再到报废，并考虑哪些现有工具应该支持 SPIFFE，是否需要建立、购买或部署新的工具。花在创建、整合和改进工具上的时间和精力往往会产生倍增效应，为其他人节省时间和精力，从而帮助促进更顺利的过渡。&lt;/p&gt;
&lt;p&gt;值得注意的是，不应该孤立地建立或购买工具，而应该与他们的目标用户协商，最好是以渐进和迭代的方式。正确地做到这一点可能需要时间。&lt;/p&gt;
&lt;p&gt;选择什么时候一个工具对第一批和早期采用者来说足够好是一个判断。在极少数情况下，工具的第一次迭代对早期和后期的大多数人来说是足够好的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成和部署系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 CI/CD 工具中实施 SPIFFE 会对组织中其他服务部门采用这种 SPIFFE 产生很大的影响，因为大多数团队都会与 CI/CD 系统定期互动。然而，反过来说，这意味着要让 CI/CD 系统的所有消费者都能意识到 SPIFFE 是一项庞大的任务，所以可能需要很长的时间来关闭所有非 SPIFFE 的集成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的组织已经在使用容器编排器，如 Kubernetes，那么你就成功了一半！你的组织已经在使用容器编排器。编排器使你的工作负载很容易通过 SPIFFE 感知代理前置，这样你的开发者就不需要再费心了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务网格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大型微服务服务网格架构作为 SPIFFE 部署的推动者尤其重要，因为在服务网格中引入 SPIFFE 支持是一种推出广泛支持的好方法，而不必让开发团队参与进来。&lt;/p&gt;
&lt;p&gt;服务网格的相关性也伴随着一些风险和挑战。你可以想象，破坏服务网格可能会在一个环境中产生广泛的影响，并可能以灾难性的失败告终。&lt;/p&gt;
&lt;h2 id=&#34;规划-spire-行动&#34;&gt;规划 SPIRE 行动&lt;/h2&gt;
&lt;h3 id=&#34;日复一日地运行-spire&#34;&gt;日复一日地运行 SPIRE&lt;/h3&gt;
&lt;p&gt;建议负责管理和支持 SPIRE 基础设施的团队尽可能早地参与。根据你的组织结构，很可能是你的安全或平台团队将负责整个生命周期的工作。&lt;/p&gt;
&lt;p&gt;另一个需要考虑的方面是你如何分割涉及任何会影响系统安全、性能和可用性的改变的操作。在改变任何与你的 PKI、HSM、密钥轮换和相关操作有关的东西时，可能需要更严格的控制和门槛。你可能已经有一个围绕它的变更管理过程，如果没有，这是一个开始实施它的绝佳时机。&lt;/p&gt;
&lt;p&gt;你的团队需要为不同的故障场景创建 Runbook，并对其进行测试，以了解该怎么做，需要观察哪些基本指标，并创建监控和警报。你可能已经知道你将使用什么监控和警报系统，但了解 SPIRE 服务器和代理提供的遥测数据和指标，以及这些数据意味着什么，将有助于你的团队避免停机时间。&lt;/p&gt;
&lt;h3 id=&#34;测试复原力&#34;&gt;测试复原力&lt;/h3&gt;
&lt;p&gt;故障注入练习帮助操作人员分析系统在某些故障条件下的表现。你可能对你的系统将如何基于架构做出反应有某些假设。尽管如此，在 SPIRE 部署中仍有多个潜在的故障点值得触发，以测试你的假设，并可作为运营团队的良好实践，以确保他们有所有的警报和 Runbook。&lt;/p&gt;
&lt;p&gt;我们整理了一个清单，其中包括一些你想在你的故障测试程序中包括的情景。这不是一个完整的指南，只是为你的特定环境和部署模式建立检查表的一个起点。最好是用不同的停机时间来执行所有这些测试：短于配置的 TTL 的一半和更长的时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 SPIRE 的部署是使用一个单一的数据库实例，请关闭该数据库。&lt;/li&gt;
&lt;li&gt;如果 SPIRE 部署在一个集群中使用一个数据库，有一个写副本和多个读副本，请关闭写实例。&lt;/li&gt;
&lt;li&gt;模拟数据库丢失，测试数据恢复。如果你不能恢复数据或只能从一个月前的数据中恢复，怎么办？&lt;/li&gt;
&lt;li&gt;在 HA 部署中关闭几台 SPIRE 服务器。&lt;/li&gt;
&lt;li&gt;在 HA 部署中关闭负载均衡器。&lt;/li&gt;
&lt;li&gt;在代理被证明后关闭它，或完全模拟 SPIRE 服务器丢失。&lt;/li&gt;
&lt;li&gt;如果使用上游授权，模拟上游授权失败。&lt;/li&gt;
&lt;li&gt;模拟根和中间 CA 的破坏、轮换和撤销。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定义哪些指标在每个测试场景中是最有用的，记录这些数值的预期健康和危险范围，并随着时间的推移进行测量。&lt;/p&gt;
&lt;p&gt;这些场景应该被很好地记录下来，预期的输出被很好地定义，然后通过自动和定期运行的自动化测试来实现。&lt;/p&gt;
&lt;h3 id=&#34;日志&#34;&gt;日志&lt;/h3&gt;
&lt;p&gt;像所有系统一样，日志是 SPIRE 的一个重要组成部分。然而，SPIRE 产生的日志也可作为审计和安全事件的证据。包含身份签发信息以及可观察到的证明细节，可以用来证明某些工作负载和服务的状态。由于日志可以被视为证据，因此在组建日志解决方案时，你可能希望注意到以下几个注意事项。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录的保留应符合你的组织的法律要求&lt;/li&gt;
&lt;li&gt;日志系统在接纳日志和存储方面都应具有高可用性&lt;/li&gt;
&lt;li&gt;日志应该是防篡改的，必须能够提供证据&lt;/li&gt;
&lt;li&gt;记录系统应该能够提供一个监管链&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;监控&#34;&gt;监控&lt;/h3&gt;
&lt;p&gt;除了通常的 SPIRE 组件的健康状况以确保系统正常运行外，你应该设置对服务器、代理和信任包的配置的监控，以检测未经授权的更改，因为这些组件是系统安全的基础。此外，还可以对身份的发放以及服务器和代理之间的通信进行监控，以发现异常情况。然而，根据系统中发布的身份信息量，你可能希望重新考虑监控的范围。&lt;/p&gt;
&lt;p&gt;SPIRE 通过&lt;a href=&#34;https://en.wikipedia.org/wiki/Telemetry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;遥测&lt;/a&gt;技术为指标报告提供灵活的支持，允许使用多个收集器收集指标。目前支持的指标收集器有 Prometheus、Statsd、DogStatsd 和 M3。在服务器和代理中都可以同时配置多个采集器。&lt;/p&gt;
&lt;p&gt;SPIRE 上有许多指标，其记录涵盖了所有的 API 和功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器
&lt;ul&gt;
&lt;li&gt;管理 API 操作&lt;/li&gt;
&lt;li&gt;每个 API 的 DB 操作&lt;/li&gt;
&lt;li&gt;SVID 发行的 API 操作&lt;/li&gt;
&lt;li&gt;轮换和秘钥管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代理
&lt;ul&gt;
&lt;li&gt;与服务器的交互&lt;/li&gt;
&lt;li&gt;SVID 轮换和缓存维护&lt;/li&gt;
&lt;li&gt;工作负载证明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>设计一个 SPIRE 部署</title>
      <link>https://lib.jimmysong.io/spiffe/designing-a-spire-deployment/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/designing-a-spire-deployment/</guid>
      <description>&lt;p&gt;读者将了解到 SPIRE 部署的组成部分，有哪些部署模式，以及在部署 SPIRE 时需要考虑哪些性能和安全问题。&lt;/p&gt;
&lt;p&gt;你的 SPIRE 部署的设计应满足你的团队和组织的技术要求。它还应包括支持可用性、可靠性、安全性、可扩展性和性能的要求。该设计将作为你的部署活动的基础。&lt;/p&gt;
&lt;h2 id=&#34;身份命名方案&#34;&gt;身份命名方案&lt;/h2&gt;
&lt;p&gt;请记住，在前面的章节中，SPIFFE ID 是一个结构化的字符串，代表一个工作负载的身份名称，正如你在第四章中看到的那样。工作负载标识符部分（URI 的路径部分）附加在信任域名（URI 的主机部分）上，可以组成关于服务所有权的含义，以表示它在什么平台上运行，谁拥有它，它的预期目的，或其他惯例。它是特意为你定义的灵活和可定制的。&lt;/p&gt;
&lt;p&gt;你的命名方案可能是分层的，就像文件系统的路径。也就是说，为了减少歧义，命名方案不应该以尾部的正斜杠（&lt;code&gt;/&lt;/code&gt;）结束。下面你将看到一些不同的样例，它们遵循三种不同的约定，你可以遵循，或者如果你感到特别有灵感，也可以想出你自己的。&lt;/p&gt;
&lt;h3 id=&#34;直接命名服务&#34;&gt;直接命名服务&lt;/h3&gt;
&lt;p&gt;你可能会发现，作为软件开发生命周期的一部分，直接通过它从应用角度呈现的功能和它运行的环境来识别一个服务是很有用的。例如，管理员可能会规定，在特定环境中运行的任何进程都应该能够以特定身份出现。比如说。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://staging.example.com/payments/mysql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://staging.example.com/payments/web-fe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的两个 SPIFFE ID 指的是两个不同的组件 ——MySQL 数据库服务和一个 Web 前端 —— 在 staging 环境中运行的支付服务。&lt;code&gt;staging&lt;/code&gt; 的意思是一个环境，&lt;code&gt;payment&lt;/code&gt; 是一个高级服务。&lt;/p&gt;
&lt;p&gt;前面两个例子和下面两个例子是说明性的，不是规定性的。实施者应该权衡自己的选择，决定自己喜欢的行动方案。&lt;/p&gt;
&lt;h3 id=&#34;识别服务所有者&#34;&gt;识别服务所有者&lt;/h3&gt;
&lt;p&gt;通常更高级别的编排器和平台都有自己的内置身份概念（如 Kubernetes 服务账户，或 AWS/GCP 服务账户），能够直接将 SPIFFE 身份映射到这些身份是有帮助的。比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spiffe://k8s-workload-cluster.example.com/ns/staging/sa/default
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，信任域 &lt;code&gt;example.com&lt;/code&gt; 的管理员正在运行一个 Kubernetes 集群 &lt;code&gt;k8s-workload-cluster.example.com&lt;/code&gt;，它有一个 &lt;code&gt;staging&lt;/code&gt; 命名空间，在这个命名空间中，有一个名为 &lt;code&gt;default&lt;/code&gt; 的服务账户（SA）。&lt;/p&gt;
&lt;h3 id=&#34;不透明的-spiffe-身份&#34;&gt;不透明的 SPIFFE 身份&lt;/h3&gt;
&lt;p&gt;SPIFFE 路径可能是不透明的，然后元数据可以被保存在一个二级数据库中。这可以被查询以检索与 SPIFFE 标识符相关的任何元数据。比如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; spiffe://example.com/9eebccd2-12bf-40a6-b262-65fe0487d4
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;spire-的部署模式&#34;&gt;SPIRE 的部署模式&lt;/h2&gt;
&lt;p&gt;我们将概述在生产中运行 SPIRE 的三种最常见的方式。这并不意味着我们要在这里限制可用的选择，但为了本书的目的，我们将把范围限制在这些部署 SPIRE 服务器的常见方式上。我们将只关注服务器的部署架构，因为每个节点通常安装一个代理。&lt;/p&gt;
&lt;h3 id=&#34;数量大信任域与小信任域的对比&#34;&gt;数量：大信任域与小信任域的对比&lt;/h3&gt;
&lt;p&gt;信任域的数量预计是相对固定的，只是偶尔重访，而且预计不会随时间漂移太多。另一方面，一个给定的信任域中的节点数量和工作负载的数量，预计会根据负载和增长而频繁波动。&lt;/p&gt;
&lt;p&gt;选择集中到一个大的信任域的单一信任根，还是分布和隔离到多个信任域，将由许多因素决定。本章的安全考虑部分谈到了使用信任域进行隔离的问题。还有一些原因，你可以选择多个小的信任域而不是一个大的信任域，包括增加可用性和租户的隔离。管理域边界、工作负载数量、可用性要求、云供应商数量和认证要求等变量也会影响这里的决策。&lt;/p&gt;
&lt;p&gt;例如，你可以选择为每一个行政边界设置一个单独的信任域，以便在组织中可能有不同开发实践的不同小组之间进行自治。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类别&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单信任域&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;嵌套&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;联合&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;部署规模&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;非常大&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多云&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表 6.1: 信任域大小的决策表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一对一：单信任域中的单一 SPIRE 集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单一的 SPIRE 服务器，在高可用性的配置下，是单一信任域环境的最佳起点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-61-单一信任域&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-1.jpg&#34; alt=&#34;图 6.1: 单一信任域。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.1: 单一信任域。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然而，当将单个 SPIRE 服务器部署到跨越区域、平台和云提供商环境的信任域时，当 SPIRE 代理依赖于远处的 SPIRE 服务器时，会出现潜在的扩展问题。在单个部署将跨越多个环境的情况下，解决在单个信任域上使用共享数据存储的解决方案是将 SPIRE 服务器配置为嵌套拓扑结构。&lt;/p&gt;
&lt;h3 id=&#34;嵌套式-spire&#34;&gt;嵌套式 SPIRE&lt;/h3&gt;
&lt;p&gt;SPIRE 服务器的嵌套拓扑结构可使您尽可能保持 SPIRE 代理和 SPIRE 服务器之间的通信。&lt;/p&gt;
&lt;p&gt;在这种配置中，顶级 SPIRE 服务器持有根证书和密钥，而下游服务器请求中间签名证书，作为下游服务器的 X.509 签名授权。如果顶层发生故障，中间服务器继续运行，为拓扑结构提供弹性。&lt;/p&gt;
&lt;p&gt;嵌套拓扑结构很适合多云部署。由于能够混合和匹配节点验证器，下游服务器可以在不同的云提供商环境中驻留并为工作负载和代理提供身份。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-62嵌套式-spire-拓扑结构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-2.jpg&#34; alt=&#34;图 6.2：嵌套式 SPIRE 拓扑结构。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.2：嵌套式 SPIRE 拓扑结构。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;虽然嵌套式 SPIRE 是提高 SPIRE 部署的灵活性和可扩展性的理想方式，但它并不提供任何额外的安全性。由于 X.509 没有提供任何方法来限制中间证书颁发机构的权力，每个 SPIRE 服务器可以生成任何证书。即使你的上游证书颁发机构是你公司地下室混凝土掩体中的加固服务器，如果你的 SPIRE 服务器被破坏，你的整个网络可能会受到影响。这就是为什么必须确保每台 SPIRE 服务器都是安全的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-63具有一个上游-spire-服务器和两个嵌套-spire-服务器的公司架构说明两个嵌套的-spire-服务器中的每一个都可以有自己的配置与-aws-和-azure-有关如果其中任何一个出现故障另一个就不会受到影响&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-3.jpg&#34; alt=&#34;图 6.3：具有一个上游 SPIRE 服务器和两个嵌套 SPIRE 服务器的公司架构说明。两个嵌套的 SPIRE 服务器中的每一个都可以有自己的配置（与 AWS 和 Azure 有关），如果其中任何一个出现故障，另一个就不会受到影响。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.3：具有一个上游 SPIRE 服务器和两个嵌套 SPIRE 服务器的公司架构说明。两个嵌套的 SPIRE 服务器中的每一个都可以有自己的配置（与 AWS 和 Azure 有关），如果其中任何一个出现故障，另一个就不会受到影响。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;spire-联邦&#34;&gt;SPIRE 联邦&lt;/h3&gt;
&lt;p&gt;部署可能需要多个信任根基，也许是因为一个组织有不同的组织部门，有不同的管理员，或者因为他们有独立的暂存和生产环境，偶尔需要沟通。&lt;/p&gt;
&lt;p&gt;另一个用例是组织之间的 SPIFFE 互操作性，如云供应商和其客户之间。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-64使用联邦信任域的-spire-服务器&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-4.jpg&#34; alt=&#34;图 6.4：使用联邦信任域的 SPIRE 服务器。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.4：使用联邦信任域的 SPIRE 服务器。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些多个信任域和互操作性用例都需要一个定义明确、可互操作的方法，以便一个信任域中的工作负载能够认证不同信任域中的工作负载。在联合 SPIRE 中，不同信任域之间的信任是通过首先认证各自的捆绑端点，然后通过认证的端点检索外部信任域的捆绑来建立的。&lt;/p&gt;
&lt;h3 id=&#34;独立的-spire-服务器&#34;&gt;独立的 SPIRE 服务器&lt;/h3&gt;
&lt;p&gt;运行 SPIRE 的最简单方法是在专用服务器上，特别是如果有一个单一的信任域，而且工作负载的数量不大。在这种情况下，你可以在同一节点上共同托管一个数据存储，使用 SQLite 或 MySQL 作为数据库，简化部署。然而，当使用共同托管的部署模式时，记得要考虑数据库的复制或备份。如果你失去了节点，你可以迅速在另一个节点上运行 SPIRE 服务器，但如果你失去了数据库，你的所有代理和工作负载都需要重新测试以获得新的身份。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-65-单个专用的-spire-服务器&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-5.jpg&#34; alt=&#34;图 6.5: 单个专用的 SPIRE 服务器。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.5: 单个专用的 SPIRE 服务器。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免单点故障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保持简单有利也有弊。如果只有一台 SPIRE 服务器，而它丢失了，一切都会丢失，需要重建。拥有一个以上的服务器可以提高系统的可用性。仍然会有一个共享的数据存储和安全连接及数据复制。我们将在本章后面讨论这种决定的不同安全影响。&lt;/p&gt;
&lt;p&gt;要横向扩展 SPIRE 服务器，请将同一信任域中的所有服务器配置为对同一共享数据存储进行读和写。&lt;/p&gt;
&lt;p&gt;数据存储是 SPIRE 服务器保存动态配置信息的地方，如注册条目和身份映射策略。SQLite 与 SPIRE 服务器捆绑在一起，是默认的数据存储。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-66-多个-spire-服务器实例在-ha-上运行&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-6.jpg&#34; alt=&#34;图 6.6: 多个 SPIRE 服务器实例在 HA 上运行。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.6: 多个 SPIRE 服务器实例在 HA 上运行。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;数据存储建模&#34;&gt;数据存储建模&lt;/h2&gt;
&lt;p&gt;在进行数据存储设计时，你的首要关注点应该是冗余和高可用性。你需要确定每个 SPIRE 服务器集群是否有一个专用的数据存储，或者是否应该有一个共享的数据存储。&lt;/p&gt;
&lt;p&gt;数据库类型的选择可能受到整个系统可用性要求和你的运营团队能力的影响。例如，如果运维团队有支持和扩展 MySQL 的经验，这应该是首要选择。&lt;/p&gt;
&lt;h3 id=&#34;每个集群的专用数据存储&#34;&gt;每个集群的专用数据存储&lt;/h3&gt;
&lt;p&gt;多个数据存储允许系统的每个专用部分更独立。例如，AWS 和 GCP 云中的 SPIRE 集群可能有独立的数据存储，或者 AWS 中的每个 VPC 可能有一个专用数据存储。这种选择的好处是，如果一个地区或云提供商发生故障，在其他地区或云提供商中运行的 SPIRE 部署就不会受到影响。&lt;/p&gt;
&lt;p&gt;在发生重大故障时，每个集群的数据存储的缺点变得最为明显。如果一个地区的 SPIRE 数据存储（以及所有的 SPIRE 服务器）发生故障，就需要恢复本地数据存储，或者将代理切换到同一信任域的另一个 SPIRE 服务器集群上，假设信任域是跨区域的。&lt;/p&gt;
&lt;p&gt;如果有必要将代理切换到一个新的集群，必须特别考虑，因为新的集群将不知道另一个 SPIRE 集群发出的身份，或该集群包含的注册条目。代理将需要对这个新集群进行重新认证，并且需要通过备份或重建来恢复注册条目。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-67-如果你需要将一个集群中的所有代理迁移到另一个集群会发生什么&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-7.jpg&#34; alt=&#34;图 6.7: 如果你需要将一个集群中的所有代理迁移到另一个集群，会发生什么？&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.7: 如果你需要将一个集群中的所有代理迁移到另一个集群，会发生什么？
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;共享的数据存储&#34;&gt;共享的数据存储&lt;/h3&gt;
&lt;p&gt;拥有一个共享的数据存储可以解决上述拥有单独数据存储的问题。然而，它可能会使设计和操作更加复杂，并依赖其他系统来检测故障，并在发生故障时更新 DNS 记录。此外，该设计仍然需要为每个 SPIRE 可用域、每个区域或数据中心的数据库基础设施的碎片，这取决于具体的基础设施。请查看 &lt;a href=&#34;https://github.com/spiffe/spire/blob/master/doc/plugin_server_datastore_sql.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIRE 文档&lt;/a&gt;以了解更多细节。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-68使用全局数据存储方案的两个集群&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-8.jpg&#34; alt=&#34;图 6.8：使用全局数据存储方案的两个集群。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.8：使用全局数据存储方案的两个集群。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;管理失败&#34;&gt;管理失败&lt;/h2&gt;
&lt;p&gt;当基础设施发生故障时，主要的问题是如何继续向需要 SVID 才能正常运行的工作负载发放 SVID。SPIRE 代理的 SVID 内存缓存被设计为应对短期宕机的主要防线。&lt;/p&gt;
&lt;p&gt;SPIRE 代理定期从 SPIRE 服务器获取授权发布的 SVID，以便在工作负载需要时将其交付给它们。这个过程是在工作负载请求 SVID 之前完成的。&lt;/p&gt;
&lt;h3 id=&#34;性能和可靠性&#34;&gt;性能和可靠性&lt;/h3&gt;
&lt;p&gt;SVID 缓存有两个优点：性能和可靠性。当工作负载要求获得其 SVID 时，代理不需要请求和等待 SPIRE 服务器提供 SVID，因为它已经有了缓存，这就避免了到 SPIRE 服务器的往返代价。此外，如果 SPIRE 服务器在工作负载请求其 SVID 时不可用，也不会影响 SVID 的发放，因为代理已经将其缓存起来了。&lt;/p&gt;
&lt;p&gt;我们需要对 X509-SVID 和 JWT-SVID 进行区分。JWT-SVID 不能提前构建，因为代理不知道工作负载所需的 JWT-SVID 的具体受众，代理只预先缓存 X509-SVID。然而，SPIRE 代理确实维护着已发布的 JWT-SVID 的缓存，只要缓存的 JWT-SVID 仍然有效，它就可以向工作负载发布 JWT-SVID，而无需与 SPIRE 服务器联系。&lt;/p&gt;
&lt;h3 id=&#34;存活时间&#34;&gt;存活时间&lt;/h3&gt;
&lt;p&gt;SVID 的一个重要属性是其存活时间（TTL）。如果一个 SVID 的剩余寿命小于 TTL 的一半，SPIRE 代理将更新缓存中的 SVID。这向我们表明，SPIRE 在对底层基础设施能够提供 SVID 的信心方面是保守的。它还提供了一个暗示，即 SVID TTL 在抵御中断方面的作用。较长的 TTL 可以提供更多的时间来修复和恢复任何基础设施的中断，但是在选择 TTL 的时候，需要在安全性和可用性之间做出妥协。长的 TTL 将提供充足的时间来修复故障，但代价是在较长的时间内暴露 SVID（及相关密钥）。较短的 TTL 可以减少恶意行为者利用被破坏的 SVID 的时间窗口，但需要更快地对故障作出反应。不幸的是，没有什么 &amp;ldquo;神奇&amp;rdquo; 的 TTL 可以成为所有部署的最佳选择。在选择 TTL 时，必须考虑在必须解决中断问题的时间窗口和已发布的 SVID 的可接受曝光度之间，你愿意接受什么样的权衡。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的-spire&#34;&gt;Kubernetes 中的 SPIRE&lt;/h2&gt;
&lt;p&gt;本节介绍了在 Kubernetes 中运行 SPIRE 的细节。Kubernetes 是一个容器编排器，可以在许多不同的云供应商上管理软件部署和可用性，也可以在物理硬件上管理。SPIRE 包括几种不同形式的 Kubernetes 集成。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-中的-spire-代理&#34;&gt;Kubernetes 中的 SPIRE 代理&lt;/h3&gt;
&lt;p&gt;Kubernetes 包括 DaemonSet 的概念，这是一个自动部署在所有节点上的容器，每个节点有一个副本运行。这是运行 SPIRE 代理的一种完美方式，因为每个节点必须有一个代理。&lt;/p&gt;
&lt;p&gt;随着新的 Kubernetes 节点上线，调度器将自动轮换 SPIRE 代理的新副本。首先，每个代理需要一份引导信任包的副本。最简单的方法是通过 Kubernetes ConfigMap 来分发。&lt;/p&gt;
&lt;p&gt;一旦代理拥有启动信任包，它就必须向服务器证明自己的身份。Kubernetes 提供两种类型的认证令牌：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务账户令牌（SAT）&lt;/li&gt;
&lt;li&gt;预计服务账户令牌（PSAT）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务账户令牌的安全性并不理想，因为它们永远有效，而且范围无限。预测的服务账户令牌要安全得多，但它们确实需要最新版本的 Kubernetes 和一个特殊的功能标志才能启用。SPIRE 支持用于节点证明的 SAT 和 PSAT。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-中的-spire-服务器&#34;&gt;Kubernetes 中的 SPIRE 服务器&lt;/h3&gt;
&lt;p&gt;SPIRE 服务器以两种方式与 Kubernetes 交互。首先，每当它的信任包发生变化时，它必须将信任包发布到 Kubernetes ConfigMap。其次，当代理上线时，它必须使用 &lt;code&gt;TokenReview&lt;/code&gt; API 验证其 SAT 或 PSAT 令牌。这两者都是通过 SPIRE 插件配置的，需要相关的 Kubernetes API 权限。&lt;/p&gt;
&lt;p&gt;SPIRE 服务器可以完全在 Kubernetes 中运行，与工作负载一起。然而，为了安全起见，最好是在一个单独的 Kubernetes 集群上运行，或独立的硬件。这样一来，如果主集群被破坏，SPIRE 的私钥就不会有风险。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-69spire-服务器与工作负载在同一集群上&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-9.jpg&#34; alt=&#34;图 6.9：SPIRE 服务器与工作负载在同一集群上。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.9：SPIRE 服务器与工作负载在同一集群上。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-610为了安全起见spire-服务器在一个单独的集群上&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-10.jpg&#34; alt=&#34;图 6.10：为了安全起见，SPIRE 服务器在一个单独的集群上。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.10：为了安全起见，SPIRE 服务器在一个单独的集群上。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-工作负载证明&#34;&gt;Kubernetes 工作负载证明&lt;/h3&gt;
&lt;p&gt;SPIRE 代理包括一个 Kubernetes 工作负载验证器插件。该插件首先使用系统调用来识别工作负载的 PID。然后，它使用对 Kubelet 的本地调用来识别工作负载的 pod 名称、镜像和其他特征。这些特征可以作为注册条目的选择器。&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-负载条目自动注册&#34;&gt;Kubernetes 负载条目自动注册&lt;/h3&gt;
&lt;p&gt;一个名为 Kubernetes Workload Registrar 的 SPIRE 扩展可以自动创建节点和工作负载注册条目，充当 Kubernetes API 服务器和 SPIRE 服务器之间的桥梁。它支持几种不同的方法来识别正在运行的 pod，并在创建条目方面具有一定的灵活性。&lt;/p&gt;
&lt;h3 id=&#34;增加-sidecar&#34;&gt;增加 Sidecar&lt;/h3&gt;
&lt;p&gt;对于尚未适应使用工作负载 API 的工作负载（见第 7 章：与其他机构的集成中的本地 SPIFFE 支持一节），Kubernetes 可以很容易地添加支持的 sidecar。Sidecar 可以是一个 SPIFFE 感知的代理，比如 Envoy。或者，它可以是一个与 SPIRE 一起开发的 sidecar，名为“SPIFFE Helper&amp;quot;，它监控工作负载 API，并在其 SVID 发生变化时重新配置工作负载。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-611与-sidecar-容器一起部署的-kubernetes-集群中的工作负载&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-11.jpg&#34; alt=&#34;图 6.11：与 sidecar 容器一起部署的 Kubernetes 集群中的工作负载。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.11：与 sidecar 容器一起部署的 Kubernetes 集群中的工作负载。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;spire-的性能考虑因素&#34;&gt;SPIRE 的性能考虑因素&lt;/h2&gt;
&lt;p&gt;当连接到服务器的 SPIRE 代理数量增加时，也会给服务器、数据存储和网络本身带来更多的负荷。多个因素都会造成负载，包括节点数量和每个节点的工作负载，以及你轮换秘钥的频率。使用 JWT-SVID 与嵌套的 SPIRE 模型，公钥需要保持同步，这将增加代理和服务器之间需要传输的信息量。&lt;/p&gt;
&lt;p&gt;我们不想对每个代理的工作负载数量或每个服务器的代理数量提出具体的性能要求或建议，因为所有的数据 a）取决于硬件和网络特性，b）变化很快。仅举一例，最新的一个版本将数据的性能提高了 30%。&lt;/p&gt;
&lt;p&gt;正如你在前几章中所了解的，SPIRE 代理不断与服务器进行通信，以获得任何新的变化，如新工作负载的 SVID 或信任包的更新。在每次同步过程中，会有多个数据存储操作。默认情况下，同步时间为 5 秒，如果这对你的系统产生了太多的压力，你可以把它增加到一个更高的值来解决这些问题。&lt;/p&gt;
&lt;p&gt;非常短的 SVID TTL 可以减轻安全风险，但如果你使用非常短的 TTL，要准备好看到你的 SPIRE 服务器的额外负载，因为签名操作的数量与轮换频率成比例增加。&lt;/p&gt;
&lt;p&gt;另一个影响系统性能的关键因素可能是每个节点的工作负载数量。如果你在系统中的所有节点上增加一个新的工作负载，这将突然产生一个峰值，并对整个系统产生负荷。&lt;/p&gt;
&lt;p&gt;如果您的系统严重依赖 JWT-SVID 的使用，请记住，JWT-SVID 不是在代理端预先生成的，需要按要求进行签名。这可能会给 SPIRE 服务器和代理带来额外的负载，并在它们过载时增加延迟。&lt;/p&gt;
&lt;h2 id=&#34;验证器插件&#34;&gt;验证器插件&lt;/h2&gt;
&lt;p&gt;SPIRE 为节点和工作负载认证提供了各种验证器插件。选择使用哪种验证器插件取决于对认证的要求，以及底层基础设施 / 平台提供的可用支持。&lt;/p&gt;
&lt;p&gt;对于工作负载证明，这主要取决于被编排的工作负载的类型。例如，当使用 Kubernetes 集群时，Kubernetes 工作负载验证器将是合适的，同样，OpenStack 平台的 OpenStack 验证器也是如此。&lt;/p&gt;
&lt;p&gt;对于节点认证来说，确定安全和合规的要求是很重要的。有时需要执行工作负载的地理围栏。在这些情况下，使用来自云提供商的节点验证器，可以断言，将提供这些保证。&lt;/p&gt;
&lt;p&gt;在高度管制的行业，可能需要使用基于硬件的认证。这些机制通常依赖于底层基础设施提供支持，如 API 或像可信平台模块（TPM）的硬件模块。这可能包括对系统软件状态的测量，包括固件、内核版本、内核模块，甚至文件系统的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为不同的云平台设计证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在云环境中工作时，根据云提供商提供的元数据验证您的节点身份被认为是一种最佳做法。SPIRE 提供了一种简单的方法，通过专门为您的云设计的自定义节点验证器来实现这一点。大多数云提供商分配了一个 API，可以用来识别 API 调用者。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-612节点验证器的结构和流程&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-12.jpg&#34; alt=&#34;图 6.12：节点验证器的结构和流程。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.12：节点验证器的结构和流程。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;节点验证器和解析器可用于亚马逊网络服务（AWS）、Azure 和谷歌云平台（GCP）。云环境的节点验证器是特定于该云的。验证器的目的是在向运行在该节点上的 SPIRE 代理发布身份信息之前对节点进行验证。&lt;/p&gt;
&lt;p&gt;一旦建立了一个身份，SPIRE 服务器可能会安装一个 Resolver 插件，允许创建额外的选择器，与节点的元数据相匹配。可用的元数据是针对云的。&lt;/p&gt;
&lt;p&gt;在相反的范围内，如果云提供商不提供验明节点的能力，就有可能用加入令牌进行引导。然而，这提供了一套非常有限的保证，这取决于通过什么程序完成。&lt;/p&gt;
&lt;h2 id=&#34;注册条目的管理&#34;&gt;注册条目的管理&lt;/h2&gt;
&lt;p&gt;SPIRE 服务器支持两种不同的方式来添加注册条目：通过命令行界面或注册 API（只允许管理员访问）。SPIRE 需要注册条目来运作。一种选择是由管理员手动创建。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-613-工作负载手动登记&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-13.jpg&#34; alt=&#34;图 6.13: 工作负载手动登记。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.13: 工作负载手动登记。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在大型部署或基础设施快速增长的情况下，手动流程将无法扩展。此外，任何手动程序都容易出错，而且可能无法跟踪所有的变化。&lt;/p&gt;
&lt;p&gt;对于有大量注册条目的部署来说，使用自动流程来创建注册条目是一个更好的选择。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-614-使用与工作负载协调器通信的-ldquo身份运营商rdquo-自动创建工作负载注册条目的例子&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-14.jpg&#34; alt=&#34;图 6.14: 使用与工作负载协调器通信的 &amp;amp;ldquo;身份运营商&amp;amp;rdquo; 自动创建工作负载注册条目的例子。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.14: 使用与工作负载协调器通信的 &amp;amp;ldquo;身份运营商&amp;amp;rdquo; 自动创建工作负载注册条目的例子。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;将安全考虑因素和威胁建模考虑在内&#34;&gt;将安全考虑因素和威胁建模考虑在内&lt;/h2&gt;
&lt;p&gt;无论你做出什么样的设计和架构决定，都会影响到整个系统的威胁模型，也可能影响到与之互动的其他系统。&lt;/p&gt;
&lt;p&gt;下面是一些重要的安全考虑因素和你在设计阶段应该考虑的安全问题。&lt;/p&gt;
&lt;h3 id=&#34;公钥基础设施pki设计&#34;&gt;公钥基础设施（PKI）设计&lt;/h3&gt;
&lt;p&gt;你的 PKI 的结构是什么，你如何定义你的信任域以建立安全边界，你把你的私钥放在哪里，以及它们多久轮换一次，这些都是你在这一点上需要问自己的关键问题。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-615-一个具有三个信任域的-spire-部署示例每个信任域使用不同的企业证书颁发机构每个证书颁发机构使用相同的根证书颁发机构在每一层中证书的-ttl-较短&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-15.jpg&#34; alt=&#34;图 6.15: 一个具有三个信任域的 SPIRE 部署示例，每个信任域使用不同的企业证书颁发机构，每个证书颁发机构使用相同的根证书颁发机构。在每一层中，证书的 TTL 较短。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.15: 一个具有三个信任域的 SPIRE 部署示例，每个信任域使用不同的企业证书颁发机构，每个证书颁发机构使用相同的根证书颁发机构。在每一层中，证书的 TTL 较短。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;每个组织都会有不同的证书层次，因为每个组织有不同的要求。上图代表了一个潜在的证书层次结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TTL、撤销和更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在处理 PKI 时，围绕证书到期、重新签发和撤销的问题总是浮出水面。有几个考虑因素可以影响这里的决定。这些因素包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件过期 / 重新发行的性能开销&lt;/strong&gt;：可以容忍多少性能开销。TTL 越短，性能开销越大。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递送文件的延迟&lt;/strong&gt;：TTL 必须长于身份文件的预期递送延迟，以确保服务在验证自己时不会出现空档。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PKI 生态系统的成熟度&lt;/strong&gt;：是否有撤销机制？它们是否得到维护并保持更新？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组织的风险偏好&lt;/strong&gt;：如果不启用撤销功能，如果身份被破坏并被发现，可接受的有效时间是多少。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象的预期寿命&lt;/strong&gt;：根据对象的预期寿命，TTL 不应该被设置为太长的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;爆炸半径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 PKI 设计阶段，考虑其中一个组件的破坏会如何影响基础设施的其他部分是非常重要的。例如，如果你的 SPIRE 服务器将密钥保存在内存中，而服务器被攻破，那么所有下游的 SVID 都需要被取消并重新发行。为了尽量减少这种攻击的影响，你可以设计 SPIRE 基础设施，为不同的网段、虚拟私有云或云供应商提供多个信任域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保存你的私人钥匙的秘密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重要的是你把你的钥匙放在哪里。正如你先前可能已经了解到的，SPIRE 有一个密钥管理器的概念，它管理 CA 密钥。如果你打算把 SPIRE 服务器作为你的 PKI 的根，你可能想让你的根密钥具有持久性，但把它存储在磁盘上并不是一个好主意。&lt;/p&gt;
&lt;p&gt;存储 SPIRE 密钥的解决方案可能是一个软件或硬件密钥管理服务（KMS）。有独立的产品可以作为 KMS，也有每个主要云供应商的内置服务。&lt;/p&gt;
&lt;p&gt;将 SPIRE 与现有 PKI 集成的另一种可能的设计策略是使用 SPIRE 上游授权插件接口。在这种情况下，SPIRE 服务器通过使用支持的插件之一与现有的 PKI 进行通信来签署其中间 CA 证书。&lt;/p&gt;
&lt;h3 id=&#34;spire-数据存储的安全考虑&#34;&gt;SPIRE 数据存储的安全考虑&lt;/h3&gt;
&lt;p&gt;我们有意将 SPIRE 服务器的数据存储从第四章的威胁模型中删除。数据存储是 SPIRE 服务器保存动态配置的地方，如从 SPIRE 服务器 API 检索的注册条目和身份映射策略。SPIRE 服务器数据存储支持不同的数据库系统，它可以作为数据存储使用。数据存储的妥协将允许攻击者在任何节点上注册工作负载，并可能是节点本身。攻击者还将能够将密钥添加到信任捆绑中，并进入下游基础设施的信任链。&lt;/p&gt;
&lt;p&gt;攻击者的另一个可能的表面是对数据库或 SPIRE 服务器连接到数据库的拒绝服务攻击，这将导致对其他基础设施的拒绝服务。&lt;/p&gt;
&lt;p&gt;当你考虑为生产中的 SPIRE 服务器基础设施设计任何数据库时，你不可能使用数据库进程与服务器共存于同一主机的模式。尽管对数据库的有限访问，以及与服务器共存的模式大大限制了攻击面，但它很难在生产环境中扩展。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-616出于可用性和性能的考虑spire-服务器数据存储通常通过网络连接远程运行但这带来了安全挑战&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-16.jpg&#34; alt=&#34;图 6.16：出于可用性和性能的考虑，SPIRE 服务器数据存储通常通过网络连接远程运行，但这带来了安全挑战。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6.16：出于可用性和性能的考虑，SPIRE 服务器数据存储通常通过网络连接远程运行，但这带来了安全挑战。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;出于可用性和性能的考虑，SPIRE 数据存储通常会是一个网络连接的数据库。但你应该考虑以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这是一个与其他服务共享的数据库，还有谁可以访问它和管理它？&lt;/li&gt;
&lt;li&gt;SPIRE 服务器将如何对数据库进行认证？&lt;/li&gt;
&lt;li&gt;数据库连接是否允许 TLS 保护的安全通信？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是需要考虑的相关问题，因为 SPIRE 服务器如何连接到数据库在很大程度上决定了整个部署的安全程度。在使用 TLS 和基于密码的认证的情况下，SPIRE 服务器的部署应依靠秘密管理器或 KMS 来保证数据安全。&lt;/p&gt;
&lt;p&gt;在某些部署中，您可能需要添加另一个较低级别的&lt;strong&gt;元 PKI&lt;/strong&gt; 基础设施，使你能够确保与 SPIRE 服务器的所有低级别的依赖性的通信，包括您的配置管理或部署软件。&lt;/p&gt;
&lt;h3 id=&#34;spire-代理配置和信任包&#34;&gt;SPIRE 代理配置和信任包&lt;/h3&gt;
&lt;p&gt;你分配和部署 SPIRE 生态系统组件的方式，以及它在你的环境中的配置可能会对你的威胁模型和整个系统的安全模型产生严重的影响。这不仅是 SPIRE 的低级依赖，也是你所有安全系统的低级依赖，所以这里我们只关注 SPIFFE 和 SPIRE 特有的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信任包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有不同的方法来交付代理的&lt;strong&gt;引导信任包（bootstrap trust bundle）&lt;/strong&gt;。这是代理在最初启动时使用的信任包，以便对 SPIRE 服务器进行验证。如果攻击者能够将密钥添加到初始信任包中并进行中间人攻击，那么它将对工作负载进行同样的攻击，因为它们从受害代理那里接收 SVID 和信任包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIRE 代理的配置也需要保持安全。如果攻击者可以修改这个配置文件，那么他们可以将其指向被攻击的 SPIRE 服务器并控制代理。&lt;/p&gt;
&lt;h3 id=&#34;节点验证器插件的影响&#34;&gt;节点验证器插件的影响&lt;/h3&gt;
&lt;p&gt;通过多个独立的机制来证明信任，可以提供更大的信任断言。你选择的节点证明可能会大大影响你的 SPIRE 部署的安全性，并将它的信任根基转向另一个系统。当决定使用什么类型的证明时，你应该把它纳入你的威胁模型，并在每次发生变化时审查该模型。&lt;/p&gt;
&lt;p&gt;例如，任何其他基于占有证明的证明都会转移信任的根基，所以你要确保你作为下级依赖的系统符合你的组织的安全和可用性标准。&lt;/p&gt;
&lt;p&gt;当设计一个使用加入令牌的证明模式的系统时，仔细评估添加和使用令牌的操作程序，无论是由操作者还是供应系统。&lt;/p&gt;
&lt;h3 id=&#34;遥测和健康检查&#34;&gt;遥测和健康检查&lt;/h3&gt;
&lt;p&gt;SPIRE 服务器和代理都支持健康检查和不同类型的遥测。启用或错误配置健康检查和遥测可能会增加 SPIRE 基础设施的攻击面，这一点可能并不明显。SPIFFE 和 SPIRE 威胁模型假设代理只通过本地 Unix 套接字暴露工作负载 API 接口。该模型没有考虑到错误配置（或有意配置）的健康检查服务监听不在本地主机上，可能会使代理暴露于潜在的攻击，如 DoS、RCE 和内存泄漏。在选择遥测集成模型时，最好采取类似的预防措施，因为一些遥测插件（如 Prometheus）可能会暴露出额外的端口。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>与其他系统集成</title>
      <link>https://lib.jimmysong.io/spiffe/integrating-with-others/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/integrating-with-others/</guid>
      <description>&lt;p&gt;本章探讨了 SPIFFE 和 SPIRE 如何与环境集成。&lt;/p&gt;
&lt;p&gt;SPIFFE 从一开始就被设计成可插拔和可扩展的，所以将 SPIFFE 和 SPIRE 与其他软件系统集成的话题是一个广泛的话题。一个特定的集成的架构超出了本书的范围。相反，本章意在捕捉一些可能的常见集成，以及一个高层次的概述，以及进行集成工作的策略。&lt;/p&gt;
&lt;h2 id=&#34;使软件能够使用-svid&#34;&gt;使软件能够使用 SVID&lt;/h2&gt;
&lt;p&gt;在考虑如何调整软件以使用 SVID 时，有许多选项可供选择。本节介绍了其中的几个选项，以及与之相关的注意事项。&lt;/p&gt;
&lt;h3 id=&#34;本地-spiffe-支持&#34;&gt;本地 SPIFFE 支持&lt;/h3&gt;
&lt;p&gt;这种方法需要修改现有的服务，以使它们能够感知 SPIFFE。当所需的修改最小，或者可以在跨应用服务使用的通用库或框架中引入时，它是首选。对于那些对延迟敏感的数据平面服务，或希望在应用层利用身份的服务，本地集成是最好的方法。SPIFFE 提供了一些库，如用于 Go 编程语言的 GO-SPIFFE 和用于 Java 编程语言的 JAVA-SPIFFE，它们有助于开发支持 SPIFFE 的工作负载。&lt;/p&gt;
&lt;p&gt;当用支持 SPIFFE 库的语言构建软件时，这通常是利用 SPIFFE 最直接的方式。上面提到的 Go 和 Java 库有使用 SPIFFE 与 gRPC 和 HTTPS 客户端和服务器的例子。&lt;/p&gt;
&lt;p&gt;也就是说，应该注意的是，你并不局限于 Java 和 Go 语言的选择。这些库是在开放规范的基础上实现的。在撰写本文时，社区正在努力开发 Python、Rust 和 C 编程语言的 SPIFFE 库。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-感知代理&#34;&gt;SPIFFE 感知代理&lt;/h3&gt;
&lt;p&gt;通常情况下，重构的成本太高，或者服务正在运行一个不能被修改的第三方代码。在这些情况下，用一个支持 SPIFFE 的代理来前置应用，往往是一个务实的选择。根据应用程序的部署模式，它可以是一个独立的代理或一组集中的代理。共用代理的优点是代理和不安全的服务之间的追踪仍然是本地的 —— 如果使用独立的代理，代理和应用之间的安全问题仍然必须得到考虑。&lt;/p&gt;
&lt;p&gt;Envoy 是一个受欢迎的选择，Ghostunnel 是另一个不错的选择。虽然其他代理，如 NGINX 和 Apache 也可以工作，但它们与 SPIFFE 相关的功能是有限的。&lt;/p&gt;
&lt;p&gt;Ghostunnel 是一个 L3/L4 代理，享有对整个 SPIFFE 规范集的完全本地支持，包括对 SPIFFE Workload API 和联邦的支持。对于需要 L7 功能的应用，建议使用 Envoy。虽然 Envoy 不支持 SPIFFE Workload API，但 SPIRE 实现了 Secret Discovery Service API（或 SDS API），这是一个 Envoy API，用于检索和维护证书和私钥。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-71-两个-envoy-代理位于两个服务之间使用-spire-agent-sds-实现建立相互的-tls-的架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f7-1.jpg&#34; alt=&#34;图 7.1: 两个 Envoy 代理位于两个服务之间，使用 SPIRE Agent SDS 实现建立相互的 TLS 的架构图。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7.1: 两个 Envoy 代理位于两个服务之间，使用 SPIRE Agent SDS 实现建立相互的 TLS 的架构图。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;通过实施 SDS API，SPIRE 可以将 TLS 证书、私钥和可信 CA 证书直接推送到 Envoy。然后，SPIRE 会根据需要轮换短命的秘钥和证书，将更新推送到 Envoy，而不需要重新启动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务网格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;L7 代理（如 Envoy）可以执行 SPIFFE 安全以上的许多功能。例如，服务发现、请求授权和负载均衡都是 Envoy 带来的功能。在使用共享库比较困难的环境中（例如，当应用程序是用许多不同的语言编写的，或者不能被修改），将这种功能加载到代理上，可能特别有吸引力。这种方法也将代理的部署推向了集中的模式，即每个应用实例都有一个专门的代理运行在它旁边。&lt;/p&gt;
&lt;p&gt;然而，这又产生了一个问题：如何管理所有这些代理？&lt;/p&gt;
&lt;p&gt;服务网格是一个代理机群和相关代理控制平面的部署。它们通常允许在部署工作负载时自动注入和配置集中的代理，并提供对这些代理的持续管理。通过将许多平台关注点加载到服务网格中，可以使应用程序与这些功能不相干。&lt;/p&gt;
&lt;p&gt;迄今为止，大多数服务网格的实现都是利用 SPIFFE 认证来实现服务间的追踪。有些使用 SPIRE 来实现这一目标，有些则实现了特定产品的 SPIFFE 身份提供者。&lt;/p&gt;
&lt;h3 id=&#34;辅助程序&#34;&gt;辅助程序&lt;/h3&gt;
&lt;p&gt;于工作负载不支持 SPIFFE 工作负载 API，但仍然支持使用证书进行认证的情况，与工作负载一起运行的辅助程序可以弥补这一差距。&lt;a href=&#34;https://github.com/spiffe/spiffe-helper/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE Helper&lt;/a&gt; 就是一个例子。SPIFFE 辅助程序从 SPIFFE Workload API 中获取 SVID，并将其写入磁盘，以便应用程序能够接收它们。SPIFFE 辅助程序可以继续运行，确保磁盘上的证书在轮换时不断地被更新。当更新发生时，辅助程序可以向应用程序发出信号（或运行一个可配置的命令），这样，运行中的应用程序就可以接收到这些变化。&lt;/p&gt;
&lt;p&gt;许多支持 TLS 的现成的应用程序可以被配置成这样使用 SPIFFE。SPIFFE 辅助库有配置 MySQL 和 PostgreSQL 的例子。许多 Web 服务器，如 Apache HTTPD 和 NGINX 都可以进行类似的配置。这对客户端软件也很有用，它只能被配置为利用磁盘上的证书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openssl&lt;/li&gt;
&lt;li&gt;x509curl&lt;/li&gt;
&lt;li&gt;grpcurl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，这比本地 SPIFFE 集成的灵活性要低，因为特别是，它可能不允许相同的信任配置粒度。例如，当使用 SPIFFE Helper 来配置 Apache HTTPD 的相互 TLS 时，不可能将 &lt;code&gt;mod_ssl&lt;/code&gt; 配置为只接受具有特定 SPIFFE ID 的客户端。&lt;/p&gt;
&lt;h2 id=&#34;在无-spiffe-感知的软件中使用-svid&#34;&gt;在无 SPIFFE 感知的软件中使用 SVID&lt;/h2&gt;
&lt;p&gt;由于 SVID 是基于众所周知的文档类型，所以相对来说，遇到支持文档类型的软件是很常见的，但其本身并不一定能识别 SPIFFE。好消息是，这是一个相对预期的情况，而且 SPIFFE/SPIRE 已经被设计成可以很好地处理这种情况。&lt;/p&gt;
&lt;h3 id=&#34;x509-svid-双重用途&#34;&gt;X509-SVID 双重用途&lt;/h3&gt;
&lt;p&gt;许多非 SPIFFE 系统支持使用 TLS（或相互 TLS），但依赖于证书在证书主体的通用名称（CN）或主体替代名称（SAN）扩展的 DNS 名称中具有身份信息。SPIRE 支持签发具有特定 CN 和 DNS SAN 值的 X.509 证书，这些值可以在每个工作负载的基础上指定（作为注册条目的一部分）。&lt;/p&gt;
&lt;p&gt;这一功能是一个重要的细节，因为它允许在不直接理解如何使用 SPIFFE ID 的软件中使用 X509-SVID。例如，HTTPS 客户端往往希望所出示的证书与请求的 DNS 名称相匹配。在另一个例子中，MySQL 和 PostgreSQL 可以使用通用名称来识别相互的 TLS 客户端。通过利用这个 SPIRE 功能，以及 SPIFFE 总体上赋予的灵活性，这些用例可以用 SPIFFE 用例所使用的同样的 SVID 来适应。&lt;/p&gt;
&lt;h3 id=&#34;jwt-svid-双重用途&#34;&gt;JWT-SVID 双重用途&lt;/h3&gt;
&lt;p&gt;与 X509-SVID 可用于 SPIFFE 认证以及更传统的 X.509 用例的方式相似，JWT- SVID 也支持这种双重性。虽然 JWT-SVID 确实使用标准的主体（&lt;code&gt;sub&lt;/code&gt;）声明来存储 SPIFFE ID，但验证方法与 OpenID Connect（或 OIDC）类似并兼容。&lt;/p&gt;
&lt;p&gt;更具体地说，SPIFFE Federation API 通过由 HTTPS 端点提供的 JWKS 文档公开密钥，这与用于获取 OIDC 验证的公开密钥的机制相同。因此，任何支持 OIDC 身份联盟的技术也将支持接受 JWT-SVID，无论它们是否具有 SPIFFE 感知。&lt;/p&gt;
&lt;p&gt;支持这种身份联盟的集成的一个例子是亚马逊网络服务（AWS）身份和访问管理（IAM）。通过配置 AWS 账户中的 IAM，以接受来自 SPIRE 作为 OIDC 身份供应商的身份，就有可能使用 SPIFFE 工作负载 API 的 JWT-SVID 来承担 AWS IAM 的角色。当需要访问 AWS 资源的工作负载不在 AWS 中运行时，这一点特别强大，有效地否定了存储、共享和管理长期的 AWS 访问密钥的需要。关于如何实现这一目标的详细例子，请参见 SPIFFE 网站上的 &lt;a href=&#34;https://spiffe.io/spire/try/oidc-federation-aws/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWS OIDC 认证教程&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;可以在-spiffe-的基础上建立什么&#34;&gt;可以在 SPIFFE 的基础上建立什么&lt;/h2&gt;
&lt;p&gt;一旦 SPIFFE 作为一个通用的身份基础存在于你的生态系统中，并与你的应用程序集成，这可能是一个考虑在上面建立什么的好时机。在本节中，我们想介绍一下在 SPIFFE 和 SPIRE 的基础上可以建立什么。并不是说这个项目有所有的构件，可以让一切都开箱即用。有些集成件需要实施才能实现，而具体如何实现的细节会因部署而异。&lt;/p&gt;
&lt;h3 id=&#34;日志监测可观察性和-spiffe&#34;&gt;日志、监测、可观察性和 SPIFFE&lt;/h3&gt;
&lt;p&gt;SPIFFE 可以向其他系统提供可验证的身份证明，这对以下组件来说是一个优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础设施度量&lt;/li&gt;
&lt;li&gt;基础设施日志&lt;/li&gt;
&lt;li&gt;可观测性&lt;/li&gt;
&lt;li&gt;计量&lt;/li&gt;
&lt;li&gt;分布式追踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以使用 SVID 来确保这些系统的客户端 - 服务器通信安全。然而，你也可以扩展所有这些组件，用 SPIFFE ID 来充实数据。这样做有多种好处，例如，能够在多种类型的平台和运行时之间对事件进行关联。它甚至可以帮助识别仍然不使用 SPIFFE 身份的应用和服务，或者发现运行异常和攻击，而不管它们可能发生在基础设施的哪个角落。&lt;/p&gt;
&lt;h3 id=&#34;审计&#34;&gt;审计&lt;/h3&gt;
&lt;p&gt;对于任何安全系统，如你在 SPIRE 基础上建立的系统，日志不仅仅是帮助开发人员和操作员了解系统发生了什么的信息。任何安全系统的日志都是正在发生的事情的证据，所以有一个集中的位置来存储日志是一个好主意。在发生任何安全事件时，这些信息对取证分析非常有价值。&lt;/p&gt;
&lt;p&gt;SPIFFE 可以帮助增强审计数据，通过使用对集中式审计系统的认证调用来提供不可抵赖性。例如，在与审计系统建立会话时，通过使用 X509-SVID 和相互 TLS，我们可以确定日志行的来源 —— 攻击者不能简单地操纵正在发送的标签或其他数据。&lt;/p&gt;
&lt;h3 id=&#34;证书透明化&#34;&gt;证书透明化&lt;/h3&gt;
&lt;p&gt;证书透明化（Certificate Transparency）通过提供一个开放的框架，几乎实时地监控和审计 X.509 证书，帮助发现对证书基础设施的攻击。证书透明化允许检测从被破坏的证书颁发机构恶意获取的证书。它还可以识别那些已经变质并恶意签发证书的证书颁发机构。要了解更多关于证书透明化的信息，请阅读&lt;a href=&#34;https://www.certificate-transparency.org/what-is-ct&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;介绍文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;SPIRE 与证书透明度的整合有不同的可能性。通过这种整合，可以记录你的系统颁发的所有证书的信息，并用一种称为 Merkle Tree Hashes 的特殊加密机制来保护它，以防止篡改和不当行为。&lt;/p&gt;
&lt;p&gt;你可以考虑的另一个方法是在你的所有系统中强制执行证书透明化。这将防止与那些没有在证书透明化服务器中记录证书信息的应用程序和服务建立 TLS 和相互 TLS 连接。&lt;/p&gt;
&lt;p&gt;与证书透明化的整合已经超出了本书的范围。请查看 SPIFFE/SPIRE 社区，了解更多信息和最新更新。&lt;/p&gt;
&lt;h3 id=&#34;供应链安全&#34;&gt;供应链安全&lt;/h3&gt;
&lt;p&gt;大部分关于 SPIFFE 预期用途的报道都是关于在运行时保护软件系统之间的通信安全。然而，在软件部署前的各个阶段保护软件也是至关重要的。供应链妥协是一个潜在的攻击媒介。为此，最好能保护软件供应链的完整性，以防止恶意行为者在代码中引入后门或脆弱的库。验证软件工件的出处和管道中执行的一系列步骤是验证软件没有被篡改的一种方式。&lt;/p&gt;
&lt;p&gt;你可以考虑使用 SPIFFE 来提供签名的信任根。它也可用于向供应链系统的软件组件发放身份。有几种方法可以让它与更新框架（TUF）等补充软件或公证处等人工制品签署服务一起工作，或者与 In-Toto 等供应链日志一起利用。&lt;/p&gt;
&lt;p&gt;有可能在两个层面上将 SPIRE 与供应链组件整合。&lt;/p&gt;
&lt;p&gt;首先，你可以用它来识别这个供应链系统的不同元素，以确保机械和控制平面的安全。其次，通过定制选择器来确保只有已知出处的二进制文件被发出身份。作为后者的一个例子，在一个非常初级的水平上，这种属性可以作为标签传递到使用现有 docker 选择器的容器镜像中，或者通过开发一个可以检查供应链元数据的工作负载验证器。&lt;/p&gt;
&lt;h2 id=&#34;为用户集成-spiffe&#34;&gt;为用户集成 SPIFFE&lt;/h2&gt;
&lt;p&gt;SPIFFE 和 SPIRE 架构的主要重点是软件身份。它没有考虑到用户的身份，因为这个问题已经被认为得到了很好的解决，而且在如何向人类与软件发放身份方面存在重大差异。也就是说，这并不意味着你不能向用户分发 SPIFFE 的身份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为用户提供可验证的身份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户应该如何在一个支持 SPIFFE 的生态系统中交互？请记住，SPIFFE 是 Secure Production Identity Framework for Everyone 的缩写。虽然本书的大部分内容都集中在软件的身份上，但将 SPIFFE 可验证的身份（SVID）赋予用户也同样有效，甚至是可取的。这样一来，工作负载可以用 SVID 做的所有事情，人们也可以做，比如相互 TLS 访问服务。这对于正在构建软件并需要访问其软件部署后将使用的相同资源的开发者来说，可能特别有用。&lt;/p&gt;
&lt;p&gt;正如 SPIFFE 规范对 SPIFFE ID 的方案没有限制一样，你可以自行决定如何表示人类。把你的用户名作为 SPIFFE ID 路径可能就足够了，例如 &lt;code&gt;spiffe://example.com/users/zero_the_turtle&lt;/code&gt;。或者，你可以为用户与工作负载创建一个不同的信任域，例如 &lt;code&gt;spiffe://users.example.com/zero_the_turtle&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在一个理想的情况下，你现有的 SSO 提供商能够为你的用户产生 JWT，就像 OIDC 身份提供商的情况一样。在这种情况下，如果你能将你的 SSO 提供商配置为使用 SPIFFE ID 来进行 &lt;code&gt;sub&lt;/code&gt; 声明，你可能不需要做任何额外的工作来为你的用户产生 SVID。&lt;/p&gt;
&lt;p&gt;如果你无法直接从你的身份提供者那里获得 SPIFFE JWT，但你有办法获得可验证的身份令牌，你可以利用一个自定义的 SPIRE 验证器，接受来自你的提供者的身份令牌作为基本的证明手段。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-72使用-oidc-id-令牌进行-spire-认证的一个例子&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f7-2.jpg&#34; alt=&#34;图 7.2：使用 OIDC ID 令牌进行 SPIRE 认证的一个例子。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7.2：使用 OIDC ID 令牌进行 SPIRE 认证的一个例子。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果上述情况都不适用，你总是可以建立一个独特的服务，集成到你现有的 SSO 解决方案中，它可以根据用户的认证会话为他们产生 SVID。请查看 SPIFFE 网站上的&lt;a href=&#34;https://github.com/JackOfMostTrades/spiffe-user-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;示例项目&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用 SSH 使用 SPIFFE 和 SPIRE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OpenSSH 支持使用证书颁发机构（CA）和&lt;a href=&#34;https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;证书&lt;/a&gt;进行认证。尽管 OpenSSH 证书的格式与 X.509 不同，但人们可以建立一个使用 SVID 作为认证的 SSH 证书的服务。这使得你也可以利用你的 SPIFFE 身份进行 SSH。&lt;/p&gt;
&lt;p&gt;对于需要 SSH 访问你的生态系统中的工作负载的用户来说，这种模式为 SSH 访问提供了短暂的、短期的、可审计的凭证，也提供了一个单一的控制点，你可以用它来执行访问控制策略或多因素认证。&lt;/p&gt;
&lt;p&gt;这也允许工作负载检索服务器端（又称 &amp;ldquo;主机&amp;rdquo;）的 SSH 证书，允许工作负载向用户认证自己。使用这个证书，用户不再需要在第一次连接时被信任服务器的主机密钥的问题打断 SSH 连接。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-73-使用-svid-来引导-ssh-证书&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f7-3.jpg&#34; alt=&#34;图 7.3: 使用 SVID 来引导 SSH 证书。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7.3: 使用 SVID 来引导 SSH 证书。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微服务 UI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然本书的大部分内容都是关于工作负载之间的认证，但通常也需要用户对工作负载进行认证。如果用户是通过 CLI 或其他桌面工具进行认证，那么可以使用带有用户 SVID 的相互 TLS。然而，许多微服务也希望承载某种基于浏览器的用户界面。这可能是因为开发者正在为他们的服务访问一个专门的管理或管理界面，或者消费者可能正在使用像 &lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Swagger UI&lt;/a&gt; 这样的工具来探索和试验服务的 API。&lt;/p&gt;
&lt;p&gt;为具有基于浏览器的用户界面的服务提供良好的体验，需要在浏览器友好的认证形式和 SPIFFE 相互 TLS 认证之间架起桥梁。实现这一目标的最简单方法是有一个使用相互 TLS 的 API 端口和另一个接受浏览器友好认证方法的 API 端口，如现有的基于 Web 的 SSO 机制或 OAuth2/OIDC。&lt;/p&gt;
&lt;p&gt;对二级端口上的请求进行认证后过滤，应该在基于浏览器的认证主体和相应的 SPIFFE ID 之间提供一个转换层。如果你已经建立了一个机制让用户直接获得 SVID，如上所述，那么这里也应该使用同样的转换。这样一来，底层应用就与所使用的特定认证机制无关了，所以由某个用户提出的基于网络的请求在功能上等同于通过相互 TLS 使用该用户的 SVID 提出的相同请求。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 SPIFFE 身份通知授权</title>
      <link>https://lib.jimmysong.io/spiffe/using-spiffe-identities-to-inform-authorization/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/using-spiffe-identities-to-inform-authorization/</guid>
      <description>&lt;p&gt;本章解释了如何实施使用 SPIFFE 身份的授权策略。&lt;/p&gt;
&lt;h2 id=&#34;在-spiffe-的基础上建立授权&#34;&gt;在 SPIFFE 的基础上建立授权&lt;/h2&gt;
&lt;p&gt;SPIFFE 专注于软件安全加密身份的发布和互操作性，但正如本书前面提到的，它并不直接解决这些身份的使用或消费问题。&lt;/p&gt;
&lt;p&gt;SPIFFE 经常作为一个强大的授权系统的基石，而 SPIFFE ID 本身在这个故事中扮演着重要角色。在这一节中，我们将讨论使用 SPIFFE 来建立授权的选择。&lt;/p&gt;
&lt;h2 id=&#34;认证与授权authn-vs-authz&#34;&gt;认证与授权（AuthN Vs AuthZ）&lt;/h2&gt;
&lt;p&gt;一旦一个工作负载有了安全的加密身份，它就可以向其他服务证明其身份。向外部服务证明身份被称为认证（Authentication）。一旦通过认证，该服务就可以选择允许哪些行动。这个过程被称为授权（Authorization）。&lt;/p&gt;
&lt;p&gt;在一些系统中，任何被认证的实体也被授权。因为 SPIFFE 会在服务启动时自动授予其身份，所以清楚地认识到并不是每一个能够验证自己的实体都应该被授权，这一点至关重要。&lt;/p&gt;
&lt;h2 id=&#34;授权类型&#34;&gt;授权类型&lt;/h2&gt;
&lt;p&gt;有很多方法可以对授权进行建模。最简单的解决方案是在每个资源上附加一个授权身份的&lt;strong&gt;允许列表（allowlist）&lt;/strong&gt;。然而，随着我们的探索，我们会注意到在处理生态系统的规模和复杂性时，允许列表的方法有几个限制。我们将研究两个更复杂的模型：基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC）。&lt;/p&gt;
&lt;h3 id=&#34;允许列表&#34;&gt;允许列表&lt;/h3&gt;
&lt;p&gt;在小型生态系统中，或者在刚刚开始使用 SPIFFE 和 SPIRE 时，有时最好保持简单。例如，如果你的生态系统中只有十几个身份，对每个资源（即服务、数据库）的访问可以通过维护一个有访问权限的身份列表来管理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ghostunnel server --allow-uri spiffe://example.com/blog/web
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这里，ghostunnel 服务器仅根据客户的身份明确地授权访问。&lt;/p&gt;
&lt;p&gt;这种模式的优势在于它很容易理解。只要你有数量有限的身份不改变，就很容易定义和更新资源的访问控制。然而，可扩展性会成为一个障碍。如果一个组织有成百上千的身份，维护允许名单很快就会变得无法管理。例如，每次增加一个新的服务，可能需要运维团队更新许多允许列表。&lt;/p&gt;
&lt;h3 id=&#34;基于角色的访问控制rbac&#34;&gt;基于角色的访问控制（RBAC）&lt;/h3&gt;
&lt;p&gt;在基于角色的访问控制（RBAC）中，服务被分配给角色，然后根据角色来指定访问控制。然后，随着新服务的增加，只有相对较少的角色需要被编辑。&lt;/p&gt;
&lt;p&gt;虽然有可能将一个服务的角色编码到它的 SPIFFE ID 中，但这通常是一种不好的做法，因为 SPIFFE ID 是静态的，而它被分配到的角色可能要改变。相反，最好是使用 SPIFFE ID 到角色的外部映射。&lt;/p&gt;
&lt;h3 id=&#34;基于属性的访问控制abac&#34;&gt;基于属性的访问控制（ABAC）&lt;/h3&gt;
&lt;p&gt;基于属性的访问控制（ABAC）是一个模型，授权决定是基于与服务相关的属性。结合 RBAC，ABAC 可以成为一个强大的工具来加强授权策略。例如，为了满足法律要求，可能有必要限制来自特定地区的服务对数据库的访问。区域信息可以是 ABAC 模型中的一个属性，用于授权并在 SPIFFE ID 方案中编码。&lt;/p&gt;
&lt;h2 id=&#34;设计用于授权的-spiffe-id-方案&#34;&gt;设计用于授权的 SPIFFE ID 方案&lt;/h2&gt;
&lt;p&gt;SPIFFE 规范没有规定或限制你可以或应该将哪些信息编码到 SPIFFE ID 中。你需要注意的唯一限制来自于最大长度的 SAN 扩展和你被允许使用的字符。&lt;/p&gt;
&lt;div class=&#34;alert-note-title&#34;&gt;
    &lt;p&gt;忠告&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
    在将授权元数据编码成你的组织的 SPIFFE ID 格式时，要特别小心。下面的例子说明了如何做到这一点，因为我们并不想引入额外的授权概念。
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;SPIFFE 方案实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了对 SPIFFE 身份子串做出授权决定，我们必须定义身份的每一部分意味着什么。你可以用按顺序编码信息的格式来设计你的方案。在这种情况下，第一部分可能代表一个地区，第二部分代表环境，以此类推。&lt;/p&gt;
&lt;p&gt;下面是一个计划和身份的例子。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spiffe://trust.domain.org/&amp;lt;地区&amp;gt;/&amp;lt;dev,stage,prod&amp;gt;/&amp;lt;组织&amp;gt;/&amp;lt;工作负载名称&amp;gt;。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  id=&#34;figure-图-81一个组织的-spiffe-id-的组成部分和潜在含义&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f8-1.jpg&#34; alt=&#34;图 8.1：一个组织的 SPIFFE ID 的组成部分和潜在含义。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8.1：一个组织的 SPIFFE ID 的组成部分和潜在含义。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;身份方案不仅可以采取一系列固定字段的形式，还可以采取更复杂的结构，这取决于一个组织的需求。我们可以看的一个常见的例子是跨不同协调系统的工作负载身份。例如，在 Kubernetes 和 OpenShift 中，工作负载的命名规则是不同的。下面的图示就是一个例子。你可能注意到，这些字段不仅指的是不同的属性和对象，而且 SPIFFE ID 的结构也取决于上下文。&lt;/p&gt;
&lt;p&gt;消费者可以通过观察身份的前缀来区分方案的结构。例如，一个前缀为 &lt;code&gt;spiffe://trust.domain.org/Kubernetes/...&lt;/code&gt; 的身份将根据下图的方案结构被解析为一个 Kubernetes 身份。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-82另一个潜在的-spiffe-id-方案的说明&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f8-2.jpg&#34; alt=&#34;图 8.2：另一个潜在的 SPIFFE ID 方案的说明。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8.2：另一个潜在的 SPIFFE ID 方案的说明。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;方案变更&#34;&gt;方案变更&lt;/h3&gt;
&lt;p&gt;更多时候，组织会发生变化，对身份方案的要求也会发生变化。这可能是由于组织结构的调整，甚至是技术栈的转变。可能很难预测你的环境在几年后会有多大的变化。因此，在设计 SPIFFE 身份识别方案时，关键是要考虑到未来可能发生的变化，以及这些变化将如何影响基于 SPIFFE 身份识别的其他系统。你应该考虑如何将后向和前向兼容性纳入该方案。正如我们之前已经提到的，在一个有序的方案中，你只需要在你的 SPIFFE ID 的末端添加新的实体；但是如果你需要在中间添加一些东西呢？&lt;/p&gt;
&lt;p&gt;一种方法是用基于键值对的方案，另一种方法是我们都很熟悉的方法：版本管理！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于键值对的方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们注意到，上面的方案设计都是有序的。方案的评估是通过查看身份的前缀来决定如何评估后面的后缀。然而，我们注意到，由于这种排序，很难轻易地在方案中增加新的字段。&lt;/p&gt;
&lt;p&gt;键值对，就其性质而言，是无序的，这也是一种方法，可以轻松地将字段扩展到身份识别方案中，而不需要太多改变。例如，你可以使用带有已知分隔符的键值对，例如，身份内的列&lt;code&gt;：&lt;/code&gt;字符。在这种情况下，上面的标识可能被编码为以下方式。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spiffe://trust.domain.org/environment:dev/region:us/organization:zero/name:turtle
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为身份的消费者将其处理成一组键值对，所以可以在不改变方案的基本结构的情况下增加更多的键。另外，SPIFFE 还有可能在将来支持将键值对纳 SVID。&lt;/p&gt;
&lt;p&gt;像往常一样，应该考虑结构化和非结构化数据类型之间的权衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里可能的解决方案之一是将版本控制纳入方案。版本可以是你的方案中的第一个项目，也是最关键的部分。其余的系统在处理 SPIFFE ID 数据时需要遵循版本和编码实体之间的映射关系。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spiffe://trust.domain.org/v1/region/environment/organization/workload
v1 scheme:
0 = version
1 = region
2 = environment
3 = organization
4 = workload
spiffe://trust.domain.org/v2/region/datacenter/environment/organization/wor
kload
v2 scheme:
0 = version
1 = region
2 = datacenter
3 = environment
4 = organization
5 = workload
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 SPIFFE 中，一个工作负载可以有多个身份。然而，由你的工作负载来决定使用哪个身份。为了保持授权的简单性，每个工作负载最好先有一个身份，必要时再增加。&lt;/p&gt;
&lt;h2 id=&#34;使用-hashicorp-vault-的授权示例&#34;&gt;使用 HashiCorp Vault 的授权示例&lt;/h2&gt;
&lt;p&gt;让我们通过一个工作负载可能希望与之对话的服务的例子：Hashicorp Vault。我们将通过一个 RBAC 的例子和一个 ABAC 的例子，并涵盖一些使用 SPIFFE/SPIRE 执行授权时的问题和注意事项。&lt;/p&gt;
&lt;p&gt;Vault 是一个&lt;strong&gt;秘密存储器（secret store）&lt;/strong&gt;：管理员可以用它来安全地存储秘密，如密码、API 密钥和服务可能需要的私人密钥。由于许多组织仍然需要安全地存储秘密，即使在使用 SPIFFE 提供安全身份之后，使用 SPIFFE 来访问 Vault 是一个常见的请求。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spiffe://example.org/&amp;lt;区域&amp;gt;/&amp;lt;dev,stage,prod&amp;gt;/&amp;lt;组织&amp;gt;/&amp;lt;工作负载名称&amp;gt;。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;为-spiffe-身份配置-vault&#34;&gt;为 SPIFFE 身份配置 Vault&lt;/h3&gt;
&lt;p&gt;在处理客户请求时，Vault 同时处理身份的认证和授权任务。像许多其他处理资源（在这里是指秘密）管理的应用程序一样，它有一个可插入各种认证和授权机制的接口。&lt;/p&gt;
&lt;p&gt;在 Vault 中，这是通过 &lt;a href=&#34;https://www.vaultproject.io/api/auth/cert&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TLS 证书认证方法&lt;/a&gt;或 &lt;a href=&#34;https://www.vaultproject.io/api-docs/auth/jwt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JWT/OIDC 认证方法&lt;/a&gt;，可以配置为识别和验证从 SPIFFE 生成的 JWT 和 X509-SVID。为了使 Vault 能够使用 SPIFFE 身份来使用，信任包需要配置这些可插拔的接口，以便它能够验证 SVID。&lt;/p&gt;
&lt;p&gt;这就解决了认证问题，但我们仍然需要配置它来执行授权。要做到这一点，需要为 Vault 制定一套授权规则，以决定哪些身份可以访问秘密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个 SPIFFE RBAC 的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在下面的例子中，我们将假设我们使用的是 X509-SVID。Vault 允许创建规则，它可以表达哪些身份可以访问哪些秘密。这通常包括创建一组访问权限，并创建一个将其与访问绑定的规则。&lt;/p&gt;
&lt;p&gt;例如，一个简单的 RBAC 策略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;display_name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;medical-access-role&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;allowed_common_names&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/eu-de/prod/medical/data-proc-1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/eu-de/prod/medical/data-proc-2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;token_policies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;medical-use&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这编码了一条规则，说明如果身份为 &lt;code&gt;spiffe://example.org/eu-de/prod/medical/data-proc-1&lt;/code&gt;，或 &lt;code&gt;spiffe://example.org/eu-de/prod/medical/data-proc-2&lt;/code&gt; 的客户能够获得一组权限（&lt;code&gt;medical-use&lt;/code&gt;），它将授予医疗数据的访问权。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们已经授予这两个身份对秘密的访问权。Vault 负责将两个不同的 SPIFFE ID 映射到相同的访问控制策略中，这使得这成为 RBAC 而不是 allowlist。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个 SPIFFE ABAC 的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在某些情况下，基于属性而不是基于角色来设计授权策略是比较容易的。通常情况下，当有多个不同的属性集可以单独与策略相匹配时，就需要这样做，而要创建足够多的独特角色来匹配每种情况是很有挑战性的。&lt;/p&gt;
&lt;p&gt;根据上述例子，我们可以创建一个策略，授权具有某个 SPIFFE ID 前缀的工作负载。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;display_name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;medical-access-role&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;allowed_common_names&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/eu/prod/medical/batch-job*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;token_policies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;medical-use&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该策略规定，所有前缀为 &lt;code&gt;spiffe://example.org/eu/prod/medical/batch-job&lt;/code&gt; 的工作负载将被授权访问该秘密。这可能很有用，因为批处理工作是短暂的，可能会被随机分配一个后缀。&lt;/p&gt;
&lt;p&gt;另一个例子是一个有以下内容的策略：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;display_name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;medical-access-role&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;allowed_common_names&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://example.org/eu-*/prod/medical/data-proc&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;token_policies&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;medical-use&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该政策的预期效果是说明只有任何欧盟数据中心的 &lt;code&gt;data-proc&lt;/code&gt; 工作负载可以访问医疗秘密。因此，如果在欧盟的一个新数据中心启动一个新的工作负载，任何 &lt;code&gt;data-proc&lt;/code&gt; 工作负载将被授权访问医疗秘密。&lt;/p&gt;
&lt;h3 id=&#34;open-policy-agent&#34;&gt;Open Policy Agent&lt;/h3&gt;
&lt;p&gt;开放策略代理（OPA）是云原生计算基金会（CNCF）的一个项目，执行高级授权。它使用一种名为 Rego 的特定领域编程语言，有效地评估传入请求的属性，并确定它应该被允许访问哪些资源。有了 Rego，就可以设计详细的授权策略和规则，包括 ABAC 和 RBAC。它还可以考虑到与 SPIFFE 无关的连接属性，例如传入请求的用户 ID。Rego 策略存储在文本文件中，因此它们可以通过持续集成系统集中维护和部署，甚至可以进行单元测试。&lt;/p&gt;
&lt;p&gt;这里有一个例子，它编码了对某个数据库服务的访问，该服务应该只被某个 SPIFFE ID 所允许。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;允许后端服务访问数据库服务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;allow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;err&#34;&gt;http_request.path&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;/good/db&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;err&#34;&gt;http_request.method&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;GET&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;err&#34;&gt;svc_spiffe_id&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;spiffe://domain.test/eu-du/backend-server&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果需要实施更详细的授权策略，那么 OPA 是一个不错的选择。Envoy 代理同时集成了 SPIRE 和 OPA，因此可以在不改变服务代码的情况下立即开始使用。要阅读更多关于使用 OPA 进行授权的细节，请查阅 OPA 文档。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;授权本身就是一个巨大而复杂的话题，远远超出了本书的范围。然而，就像生态系统中与身份交互的许多其他方面一样，了解身份与授权（以及更广泛的策略）的关系是非常有用的。&lt;/p&gt;
&lt;p&gt;在本章中，我们介绍了使用 SPIFFE 身份认证的几种思考方式，以及与身份认证有关的设计考虑。这将有助于更好地了解你的身份解决方案的设计，以迎合你的组织的授权和策略需求。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>9. SPIFFE 与其他安全技术对比</title>
      <link>https://lib.jimmysong.io/spiffe/comparing-spiffe-to-other-security-technologies/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/comparing-spiffe-to-other-security-technologies/</guid>
      <description>&lt;p&gt;本章将 SPIFFE 与其他解决类似问题的技术进行了比较。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;SPIFFE 和 SPIRE 所解决的问题并不新鲜。每一个分布式系统都必须有某种形式的身份认证才是安全的。网络公钥基础设施、Kerberos/Active Directory、OAuth、秘密存储和服务网格就是例子。&lt;/p&gt;
&lt;p&gt;然而，这些现有的身份识别形式并不适合用于识别组织内的内部服务。网络 PKI 的实施具有挑战性，对于典型的内部部署来说也是不安全的。Kerberos，Active Directory 的认证组件，需要一个永远在线的票证授予服务器，并且没有任何同等的证明。服务网格、秘密管理器和覆盖网络都解决了服务身份的部分难题，但并不完整。SPIFFE 和 SPIRE 是目前服务身份问题的唯一完整解决方案。&lt;/p&gt;
&lt;h2 id=&#34;网络公钥基础设施&#34;&gt;网络公钥基础设施&lt;/h2&gt;
&lt;p&gt;网络公钥基础设施（Web PKI）是广泛使用的从我们的网络浏览器连接到安全网站的方法。它利用 X.509 证书来断言用户正在连接到他们打算访问的网站。由于你可能对这种模式很熟悉，所以有理由问：为什么我们不能在我们的组织内使用 Web PKI 进行服务识别？&lt;/p&gt;
&lt;p&gt;在传统的 Web PKI 中，证书的发放和更新完全是手工操作。这些手工过程不适合现代基础设施，因为在现代基础设施中，服务实例可能随时动态地增长和缩小。然而，在过去的几年里，网络 PKI 已经转向了一种自动的证书颁发和更新过程，称为域名验证（Domain Validation）。&lt;/p&gt;
&lt;p&gt;在域名验证中，证书颁发机构向证书请求者发送一个令牌。证书请求者使用 HTTP 服务器共享这个令牌。证书颁发机构访问该令牌，对其进行验证，然后签署该证书。&lt;/p&gt;
&lt;p&gt;这种安排的第一个问题是，内部服务经常没有单独的 DNS 名称或 IP 地址。如果你想在所有服务之间进行相互的 TLS，那么即使是&lt;strong&gt;客户端&lt;/strong&gt;也需要 DNS 名称来获得证书，这对配置来说是个挑战。为在一台主机上运行的多个服务分配身份需要单独的 DNS 名称，这对配置来说也是一个挑战。&lt;/p&gt;
&lt;p&gt;一个更微妙的问题是，任何能够成功响应请求的人都可以成功获得证书。这可能是在同一台服务器上运行的不同服务，甚至是在可以篡改本地二层网络的不同服务器上。&lt;/p&gt;
&lt;p&gt;一般来说，虽然网络 PKI 对互联网上的安全网站很有效，但它并不适合用于服务身份。许多需要证书的内部服务并没有 DNS 名称。如果攻击者成功渗透到本地网络的任何服务中，目前可用的做证书验证的过程很容易被破坏。&lt;/p&gt;
&lt;h2 id=&#34;active-directoryad和-kerberos&#34;&gt;Active Directory（AD）和 Kerberos&lt;/h2&gt;
&lt;p&gt;Kerberos 是一个认证协议，最初于 20 世纪 80 年代末在 MIT 开发。最初，它被设计为允许使用一个集中的用户数据库进行人对服务的认证。后来，Kerberos 被扩展到支持服务对服务的认证，以及除了用户账户之外还可以使用机器账户。Kerberos 协议本身是与帐户数据库无关的。然而，Kerberos 最常见的用法是在 Windows 域中进行认证，使用 Active Directory (AD) 作为账户数据库。&lt;/p&gt;
&lt;p&gt;Kerberos 的核心凭证被称为 &lt;strong&gt;票据（ticket）&lt;/strong&gt;。一个票据是一个可以被单个客户用来访问单个资源的凭证。客户端通过调用 Ticket Granting Service (TGS) 获得票据。客户端在访问每一个资源时都需要一个新的票据。这种设计导致了更多的聊天协议并降低了可靠性。&lt;/p&gt;
&lt;p&gt;所有服务都与 TGS 建立了信任关系。当一个服务在 TGS 注册时，它与 TGS 共享密钥材料，如对称秘密或公钥。TGS 使用密钥材料来创建票据，以验证对该服务的访问。轮换密钥材料需要服务和 TGS 之间的协调。服务必须接受以前的密钥材料，并保持对它的了解，以便现有的票据保持有效。&lt;/p&gt;
&lt;h3 id=&#34;spire-如何缓解-kerberos-和-ad-的弊端&#34;&gt;SPIRE 如何缓解 Kerberos 和 AD 的弊端&lt;/h3&gt;
&lt;p&gt;在 SPIRE 中，每个客户端和资源将调用 SPIRE 服务器一次，以获得其凭证（SVID），所有资源都可以在信任域（和联合信任域）中验证这些凭证，而无需再调用 SPIRE 服务器。SPIRE 的架构避免了为每个需要访问的资源获取新凭证的所有开销。&lt;/p&gt;
&lt;p&gt;基于 PKI 的认证机制，如 SPIRE，使凭证轮换更简单，因为这种服务和集中式验证器之间的密钥材料协调并不存在。&lt;/p&gt;
&lt;p&gt;最后，值得注意的是，Kerberos 协议将服务与主机名紧密结合在一起，这使得每个主机和集群的多个服务变得复杂。另一方面，SPIRE 很容易支持每个工作负载和集群的多个 SVID。也有可能将同一个 SVID 分配给多个工作负载。这些特性提供了一个强大的、高度可扩展的身份识别方法。&lt;/p&gt;
&lt;h2 id=&#34;oauth-和-openid-connectoidc&#34;&gt;OAuth 和 OpenID Connect（OIDC）&lt;/h2&gt;
&lt;p&gt;OAuth 是一个旨在实现访问 ** 委托（delegation）** 协议，而不一定是作为一个实现认证本身的协议。OIDC 的主要目的是允许人类允许一个二级网站（或移动应用程序）代表他们对不同的一级网站采取行动。在实践中，该协议能够在二级网站上对用户进行认证，因为被委托的访问凭证（OAuth 协议中的访问令牌）是来自一级网站的证明，即用户针对该网站进行了认证。&lt;/p&gt;
&lt;p&gt;如果主网站包括用户信息或提供了一种使用访问令牌检索用户信息的方法，那么二级网站可以使用主网站的令牌来验证用户。OpenID Connect 是 OAuth 的一种观点，是一个很好的例子。&lt;/p&gt;
&lt;p&gt;OAuth 是为人类设计的，而不是为非人类实体设计的。OAuth 的登录过程需要浏览器的重定向与交互式密码。OAuth 2.0 与其前身相似，包括对非人类实体的支持，通常是通过创建服务账户（即代表工作负载而不是人类的用户身份）。当一个工作负载想要获得 OAuth 访问令牌以访问远程系统时，它必须使用 OAuth 客户端的秘密、密码或刷新令牌来验证 OAuth 提供者并接收访问令牌。工作负载都应该有独立的凭证，以实现工作负载身份的高度精细化。对于弹性计算来说，这些凭证的管理很快就会变得复杂和困难，因为每个工作负载和身份都必须向 OAuth 提供商注册。当秘密必须被撤销时，长期存在的秘密会带来更多的复杂性。由于轮换，秘密在环境中的传播减少了基础设施的流动性，在某些情况下，如果开发人员手动管理秘密，可能会出现攻击的载体。&lt;/p&gt;
&lt;h3 id=&#34;spiffe-和-spire-如何减轻-oauth-和-oidc-的复杂性&#34;&gt;SPIFFE 和 SPIRE 如何减轻 OAuth 和 OIDC 的复杂性&lt;/h3&gt;
&lt;p&gt;依靠预先存在的凭证来识别工作负载，如 OAuth 客户秘密或刷新令牌，无法解决底层乌龟的问题（如第 1 章所解释）。在这些情况下，利用 SPIRE 作为身份提供者，允许在与 OAuth 基础设施联系之前发布引导凭证（bootstrap credential）或底层乌龟。SPIRE 极大地提高了安全性，因为没有长期的静态凭证需要与工作负载本身共同部署。SPIFFE 可以作为 OAuth 的补充。它消除了直接管理 OAuth 客户端凭证的需要 —— 应用程序可以根据需要使用他们的 SPIFFE ID 来验证 OAuth 提供商。事实上，OAuth 访问令牌本身可以是 SVID，允许用户以与工作负载相同的方式对 SPIFFE 生态系统中的服务进行认证。参见与 OIDC 的集成来了解更多。&lt;/p&gt;
&lt;h2 id=&#34;秘密管理者&#34;&gt;秘密管理者&lt;/h2&gt;
&lt;p&gt;秘密管理器通常代表工作负载或管理员控制、审计和安全地存储敏感信息（共享秘密，通常是密码）。一些秘密管理器可以执行额外的功能，如加密和解密数据。许多秘密管理器的一个共同特征是中央存储，即所谓的&lt;em&gt;保险库（vault）&lt;/em&gt;，它对数据进行加密。工作负载在执行秘密检索或数据解密等操作前必须单独对保险库进行认证。&lt;/p&gt;
&lt;p&gt;部署秘密管理器的一个典型的架构挑战是如何安全地存储工作负载用来验证秘密管理器本身的凭证。这有时被称为 &amp;ldquo;零号凭证&amp;rdquo;、“引导凭证”，或者更广泛地说，安全引入的过程。&lt;/p&gt;
&lt;p&gt;通过提供一个可以存储、检索、轮换和撤销这些秘密的安全位置，使用一个秘密管理器极大地改善了依赖共享秘密的系统的安全状况。然而，大量的使用会使共享秘密的使用永久化，而不是使用强大的身份识别。&lt;/p&gt;
&lt;h3 id=&#34;如何利用-spiffe-和-spire-来减轻秘密管理人员的挑战&#34;&gt;如何利用 SPIFFE 和 SPIRE 来减轻秘密管理人员的挑战&lt;/h3&gt;
&lt;p&gt;如果你确实需要使用一个秘密管理器，它可以被配置为使用 SPIFFE 证书进行认证。这允许你在服务之间使用相同的 SPIFFE 证书进行直接认证，并检索秘密来与非 SPIFFE 证书对话。&lt;/p&gt;
&lt;h2 id=&#34;服务网格&#34;&gt;服务网格&lt;/h2&gt;
&lt;p&gt;服务网格旨在通过提供自动认证、授权和强制执行工作负载之间的相互 TLS 来简化工作负载之间的通信。服务网格通常提供集成的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定工作负载。&lt;/li&gt;
&lt;li&gt;调解工作负载之间的通信，通常通过部署在每个工作负载附近的代理（sidecar 模式）。&lt;/li&gt;
&lt;li&gt;确保每个相邻的代理执行一致的认证和授权策略（一般通过授权策略引擎）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有主要的服务网格都包括一个原生的平台特定服务认证机制。&lt;/p&gt;
&lt;p&gt;虽然服务网格可以在没有加密身份平面的情况下运行，但为了允许服务间的通信和发现，不可避免地要创建弱形式的身份。本实施方案中的服务网格不提供安全功能，也不解决前面讨论的现有信任根身份问题。&lt;/p&gt;
&lt;p&gt;许多服务网格实现了自己的加密身份平面，或与现有的身份解决方案集成，以提供过境通信安全和信任根的解决。大多数服务网格实现了 SPIFFE 或其部分内容。许多服务网格实现都采用了 SPIFFE 规范的部分实现（包括 Istio 和 Consul），并可被视为 SPIFFE 身份提供商。有些将 SPIRE 作为其解决方案的一个组成部分（如 GreyMatter 或 Network Service Mesh）。&lt;/p&gt;
&lt;p&gt;例如，Istio 使用 SPIFFE 进行节点识别，但其身份模型与 Kubernetes 的特定基元紧密耦合，并完全基于 Kubernetes。没有办法在 Istio 中基于 Kubernetes 之外的属性来识别服务。IBM 解释了&lt;a href=&#34;https://developer.ibm.com/articles/istio-identity-spiffe-spire/%23why-the-current-istio-mechanism-is-not-enough&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;为什么目前的 Istio 机制是不够的&lt;/a&gt;。与 SPIRE 这样的通用身份控制平面相比，当希望获得更丰富的证明机制时，或者当服务需要使用通用身份系统在 Istio 之外认证时，这对 Istio 构成了制约因素。使用 SPIRE 进行工作负载身份认证的另一个优势是，它可以确保不受服务网格控制的通信。出于这样的原因，组织有时会将 SPIRE 与 Istio 集成，并使用 SPIFFE 身份而不是内置的 Istio 身份。IBM 发布了一个例子，位于 &lt;a href=&#34;https://github.com/IBM/istio-spire&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM/istio-spire：Istio 身份与 SPIFFE/SPIRE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;服务网格不是 SPIFFE/SPIRE 的直接替代品，相反，它们是互补的 SPIFFE/SPIRE 作为网格内更高层次抽象的身份解决方案。&lt;/p&gt;
&lt;p&gt;专门实现 SPIFFE 工作负载 API 的服务网格解决方案支持任何期望该 API 可用的软件。能够为其工作负载提供 SVID 并支持 SPIFFE Federation API 的服务网格解决方案可以在网格识别的工作负载和运行 SPIRE 或运行在不同网格实现的工作负载之间自动建立信任。&lt;/p&gt;
&lt;h2 id=&#34;覆盖网络&#34;&gt;覆盖网络&lt;/h2&gt;
&lt;p&gt;覆盖网络（Overlay Network）模拟了一个单一的统一网络，用于跨多个平台的服务。与服务网格不同，覆盖网络使用标准的网络概念，如 IP 地址和路由表来连接服务。数据被封装并跨过其他网络进行路由，创建一个建立在现有网络之上的节点和逻辑链接的虚拟网络。&lt;/p&gt;
&lt;p&gt;虽然最常见的覆盖网络没有认证功能，但最新的网络有。然而，它们在允许服务连接之前仍然不能证明它们的身份。通常情况下，它们依赖于一个预先存在的证书。SPIFFE 很适合为覆盖网络节点提供证书。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10. 业界案例</title>
      <link>https://lib.jimmysong.io/spiffe/practitioners-stories/</link>
      <pubDate>Fri, 07 Oct 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/spiffe/practitioners-stories/</guid>
      <description>&lt;p&gt;本章包括五个业界案例，他们是现实世界中部署了 SPIFFE 和 SPIRE 的企业的工程师。&lt;/p&gt;
&lt;h2 id=&#34;uber用加密身份确保下一代和传统基础设施的安全&#34;&gt;Uber：用加密身份确保下一代和传统基础设施的安全&lt;/h2&gt;
&lt;p&gt;Ryan Turner，软件工程师，Uber&lt;/p&gt;
&lt;p&gt;在过去十年中，Uber 已经成为爆炸性增长的典型代表。随着软件服务的数量和我们运营的地理规模的增长，复杂性和风险也在增加。为了满足不断增长的需求，我们开始建立我们的下一代基础设施平台。同时，几年前，我们看到开源项目 SPIFFE 和 SPIRE 的一些早期动力。&lt;/p&gt;
&lt;p&gt;我们立即看到了 SPIFFE 所能带来的价值，使我们能够加强我们的下一代基础设施安全态势。我们在 Uber 上线了 SPIRE，现在正使用它在各种工作负载环境中使用可加密验证的身份建立信任。我们从一些应用服务和内部服务开始，比如一个工作流引擎，它通过访问整个平台的数据，旋转多个动态工作负载来完成特定任务。SPIRE 向我们的工作负载提供 SPIFFE 身份，跨越我们的应用周期。SPIFFE 用于验证服务，帮助我们避免可能导致生产问题的错误配置。&lt;/p&gt;
&lt;h3 id=&#34;使用-spire-改造传统堆栈&#34;&gt;使用 SPIRE 改造传统堆栈&lt;/h3&gt;
&lt;p&gt;SPIRE 现在是 Uber 的下一个基础设施的关键组成部分，但我们也在使用 sidecar 的方法，将认证改造成传统的基础设施。虽然 SPIFFE 和 SPIRE 通常都是在现代的云原生架构中工作，但我们可以将这些项目迅速适应我们专有的遗留堆栈。SPIRE 可以在 Uber 的下一代和传统基础设施中提供一个关键的信任桥梁，并对内部安全和开发人员的效率产生积极影响。&lt;/p&gt;
&lt;p&gt;在我们的旅程中，SPIFFE 社区一直非常支持我们，帮助我们找到解决方案。因此，我们的工程师也积极为项目做出代码贡献。&lt;/p&gt;
&lt;h3 id=&#34;安全开发和审计团队正在受益于-spiffe&#34;&gt;安全、开发和审计团队正在受益于 SPIFFE&lt;/h3&gt;
&lt;p&gt;SPIFFE 使我们的安全团队对后端基础设施更有信心，对基于网络的安全控制的依赖性更低。由于我们处理的是金融数据，而且是跨地域经营，我们必须控制对金融和客户数据的访问。有了 SPIRE，我们可以为访问控制提供一个强有力的证明身份。它帮助我们满足这些要求，并在这个过程中减少审计团队的负担。&lt;/p&gt;
&lt;p&gt;我们 Uber 的开发团队使用一致的客户端库，使用基于 SPIFFE 的身份创建 AuthZ 策略。这些项目使开发团队能够利用 X.509 和 JWT 等工作量大的身份基元，而不需要深入了解信任引导、安全引入、凭证供应或轮换等复杂主题。&lt;/p&gt;
&lt;h2 id=&#34;pinterest用-spiffe-克服身份危机&#34;&gt;Pinterest：用 SPIFFE 克服身份危机&lt;/h2&gt;
&lt;p&gt;Jeremy Krach，高级安全工程师，Pinterest&lt;/p&gt;
&lt;p&gt;2015 年，Pinterest 出现了身份危机。该公司的基础设施正在向不同的方向发展。每个新系统都以其独特的方式解决认证 —— 身份问题。开发人员每个月都要花几个小时的时间在会议和安全审查上，以设计、建立威胁模型和实施他们的定制身份解决方案，或将他们的新服务与不同的身份模型的依赖关系整合。很明显，安全团队需要建立一个通用的基础设施，以一种通用的方式提供身份，可以在我们的异构服务中使用。&lt;/p&gt;
&lt;p&gt;这个系统的最初草案将身份委托给机器，作为基于主机名的 X.509 证书。它被大量用于秘密管理（见 &lt;a href=&#34;https://github.com/pinterest/knox&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Knox&lt;/a&gt;），但还没有出现更广泛的采用。随着我们不断扩大规模，特别是像 Kubernetes 这样的多租户系统，我们需要更精细的身份，这些身份并不与我们基础设施中的特定主机相联系，而是与服务本身的身份相联系。进入 SPIFFE。&lt;/p&gt;
&lt;h3 id=&#34;用-spiffe-将复杂的问题扁平化&#34;&gt;用 SPIFFE 将复杂的问题扁平化&lt;/h3&gt;
&lt;p&gt;SPIFFE 现在为我们的大部分基础设施提供统一的身份。我们最初从 Kubernetes 开始，因为在那个多租户环境中需求是最明确的。后来，我们将其他基础设施转移到 SPIFFE，作为其主要的身份识别形式。因此，Pinterest 的几乎每个服务都有一个标准化的名字，我们可以使用，没有晦涩的惯例或不连贯的方案。它帮助我们统一和规范了我们的身份惯例，这与其他内部项目保持一致，以确定服务属性，如服务所有权。&lt;/p&gt;
&lt;p&gt;我们利用 SPIFFE 作为 ACL 中的身份，用于秘密管理、TLS 服务之间的相互通信，甚至是通用授权策略（通过 &lt;a href=&#34;https://www.openpolicyagent.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OPA&lt;/a&gt;，另一个 CNCF 项目）。Knox，Pinterest 的开源秘密管理服务，使用 SPIFFE X.509 身份文件作为支持的认证方法之一。请看我们关于 &lt;a href=&#34;https://medium.com/pinterest-engineering/secret-management-in-multi-tenant-environments-debc9236a744&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Knox 中添加 SPIFFE 支持的博文&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;开发安全和运维又开始和谐相处了&#34;&gt;开发、安全和运维又开始和谐相处了&lt;/h3&gt;
&lt;p&gt;SPIFFE 使安全团队更容易编写授权策略。开发者的速度明显提高，因为我们的工程师不必担心自定义方案或不同的集成认证。由于我们现在有一个标准的方式来解释我们整个基础设施的身份，所以计费和所有权团队更容易确定谁拥有一项服务。有了强大的身份意识，对于记录和追踪一致性也很方便。我们对 SPIFFE 项目的未来感到兴奋，并感谢它能够帮助我们解决身份危机！。&lt;/p&gt;
&lt;h2 id=&#34;字节跳动为网络规模的服务提供拨号音认证&#34;&gt;字节跳动：为网络规模的服务提供拨号音认证&lt;/h2&gt;
&lt;p&gt;Eli Nesterov，安全工程经理，字节跳动&lt;/p&gt;
&lt;p&gt;TikTok 背后的公司字节跳动已经在全球范围内建立和部署了大规模的互联网服务，为数百万用户提供服务。我们支持这些服务的基础设施是私有数据中心和公共云供应商的组合。我们的应用程序以数千个微服务的形式在多个 Kubernetes 集群和跨平台的专用节点上运行。&lt;/p&gt;
&lt;p&gt;随着我们规模的扩大，我们的平台上有多种认证机制，包括 PKI、JWT 令牌、Kerberos、OAuth 和自定义框架。在这些认证机制中加入大量的编程语言，操作的复杂性和风险就更大了。对我们的安全和运维团队来说，管理这些认证方案在操作上变得复杂。在认证框架出现已知漏洞的情况下，我们无法迅速采取行动，因为每个框架都必须单独处理。在某些情况下，他们有代码级的依赖性，这使得改变变得更加困难。跨地域的审计和合规性是一个挑战，因为每个平台特定的认证方法都必须被单独审查和管理。&lt;/p&gt;
&lt;p&gt;总体上走向基于零信任的架构，以及努力提高我们的开发人员的生产力，迫使我们为我们的服务建立一个统一的身份管理平面，以满足我们不断增长的需求。&lt;/p&gt;
&lt;h3 id=&#34;使用-spire-构建网络规模的-pki&#34;&gt;使用 SPIRE 构建网络规模的 PKI&lt;/h3&gt;
&lt;p&gt;要建立一个能在不同的基础设施岛屿或像我们这样的平台上工作的身份系统是很难的。我们可以创建自己的，但这需要大量的努力。我们选择了 SPIRE，因为它在支持我们需要的各种平台和网络规模方面提供了规模和灵活性。由于它提供了基于标准 X.509 证书的加密身份，它可以帮助我们轻松地启用相互 TLS，在默认情况下，它符合许多合规性要求。可扩展性和开源性是另一个优点，因为我们可以很容易地将它与我们现有的控制平面和数据堆栈集成。&lt;/p&gt;
&lt;h3 id=&#34;透明的认证简化了操作&#34;&gt;透明的认证简化了操作&lt;/h3&gt;
&lt;p&gt;有了 SPIRE，我们可以在我们所有的平台上部署一致的“拨号音 &amp;ldquo;认证。现在，认证和安全的负担从开发人员那里被封装起来，因此他们可以专注于业务或应用逻辑。这从整体上提高了我们的部署速度。我们也不太可能因为配置问题而出现&amp;rdquo; 生产错误 &amp;ldquo;，例如在生产中使用开发凭证。&lt;/p&gt;
&lt;p&gt;使用 SPIRE 的标准化认证也简化了合规性和审计，因为我们有跨信任域和平台的相互 TLS。SPIRE 还允许我们在身份分配方面转向一个更半分散的模式，即身份系统是本地的，比如一个数据中心。这提高了我们的整体可用性，使我们能够很好地恢复。&lt;/p&gt;
&lt;p&gt;有了 SPIRE，我们几乎是“面向未来 &amp;quot; 的，因为它可以扩展和适应，以满足我们不断增长的业务需求。&lt;/p&gt;
&lt;h2 id=&#34;anthem用-spiffe-保护云原生医疗应用的安全&#34;&gt;Anthem：用 SPIFFE 保护云原生医疗应用的安全&lt;/h2&gt;
&lt;p&gt;Bobby Samuel，Anthem 人工智能工程副总裁&lt;/p&gt;
&lt;p&gt;行业内不断上升的医疗成本迫使像 Anthem 这样的组织迅速创新，重新思考我们与供应商、雇主团体和个人的互动方式。作为这一举措的一部分，我们正在开发大量的应用程序，这些应用程序将帮助我们通过安全地开放医疗数据的访问来推动成本下降。我们已经开始在 Kubernetes 等云原生技术的基础上建立配套的下一代基础设施。这个新的基础设施将推动快速创新，并吸引更广泛的组织和开发人员的生态系统。这方面的一个例子是我们的 HealthOS 平台。HealthOS 将使第三方能够建立 HealthApp 能力，以提供到前端界面，利用去识别的健康数据的海洋。&lt;/p&gt;
&lt;p&gt;但是，在几乎每一个大型企业，特别是医疗机构，都有人试图以恶意的方式获取他们的数据。受保护的医疗信息（PHI）的售价比金融信息高得多；因此，黑客和脚本小子等恶意行为者发现医疗系统和相应的健康信息非常有利可图。随着云原生架构的采用，风险和复杂性进一步上升。由于威胁半径大大增加，而人工安全审查和流程成为云规模的抑制因素，因此发生漏洞的风险更高。&lt;/p&gt;
&lt;h3 id=&#34;为零信任架构打下基础&#34;&gt;为零信任架构打下基础&lt;/h3&gt;
&lt;p&gt;我们不能依靠传统的基于参数的安全工具和流程来保护我们的下一代应用程序和基础设施。零信任是一种精细的、自动化的安全方法，对我们来说很有意义，特别是在未来，因为我们计划跨组织边界和云供应商进行操作。用户和服务的身份和认证是零信任安全模型的核心原则之一。零信任使我们能够减少对基于网络的控制的依赖，而不是对每个系统或工作负载进行认证。SPIFFE 和 SPIRE 为我们的零信任安全架构提供了一个基础认证层。它们允许每个工作负载在开始通信之前以加密方式证明 &amp;quot; 他们是谁”。&lt;/p&gt;
&lt;h3 id=&#34;摆脱秘密管理&#34;&gt;摆脱秘密管理&lt;/h3&gt;
&lt;p&gt;通常，当你想到认证时，你会想到用户名、密码和 bear token。不幸的是，这些类型的凭证正在成为 Amthem 的风险和复杂性的来源。它们往往是长期存在的，对它们的管理或轮换是很棘手的。我们想摆脱这种一般的秘密管理做法。与其问一项服务 &amp;ldquo;你有什么”，我们想问的是&amp;rdquo; 你是谁 &amp;ldquo;。简而言之，我们想转向加密身份，如 SPIFFE。我们可以看到未来使用强证明身份的额外好处，比如在工作负载之间建立相互的 TLS，并将身份传导到应用程序中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f10-0.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;利用-spiffe-将安全作为基础设施的一部分来建设&#34;&gt;利用 SPIFFE 将安全作为基础设施的一部分来建设&lt;/h3&gt;
&lt;p&gt;安全往往被开发团队认为是部署的障碍。DevOps 团队希望能更快地部署新的创新功能。然而，他们不得不通过与安全控制有关的人工工单、流程、集成和审查。在 Anthem，我们加倍努力为我们的开发团队消除障碍，使安全成为基础设施的一项功能。随着 SPIFFE 等技术的采用，我们可以将安全控制的复杂性从开发团队中抽象出来，并在各种平台上提供一致的规则。SPIFFE 以及其他基于零信任的技术，将帮助我们在大多数情况下将系统供应时间从三个月缩短到两周以内。在 SPIFFE 的引领下，安全正在成为 Anthem 的一个推动因素。&lt;/p&gt;
&lt;h2 id=&#34;square将信任扩展到云端&#34;&gt;Square：将信任扩展到云端&lt;/h2&gt;
&lt;p&gt;Michael Weissbacher 和 Mat Byczkowski，高级安全工程师，Square&lt;/p&gt;
&lt;p&gt;Square 提供各种各样的金融服务。在其生命周期中，该公司从内部发展了新的业务部门，如资本和现金，但也收购了 Weebly 和 Stitch Labs 等公司。不同的业务部门使用不同的技术，可以从不同的数据中心和云端运作，同时仍然需要无缝沟通。&lt;/p&gt;
&lt;p&gt;我们内部开发的服务识别系统需要扩展到 Square 为其数据中心开发的内部架构之外。我们希望将该系统扩展到云端，我们希望提供一个同样安全的系统，并在未来几年内为我们提供良好的服务。我们最理想的是寻找一个基于开放标准的工具，同时能与 Envoy 代理无缝集成。SPIFFE 和 SPIRE 都支持我们的发展目标，以及与多个云和部署工具合作的独立平台。&lt;/p&gt;
&lt;h3 id=&#34;一个能与流行的开源项目合作的开放标准&#34;&gt;一个能与流行的开源项目合作的开放标准&lt;/h3&gt;
&lt;p&gt;由于 SPIFFE 是基于现有的开放标准，如 X.509 证书，它为我们的服务身份提供了一条清晰的升级路径。Envoy 是 Square 的应用程序如何进行通信的基础构建块。由于 SPIRE 支持 Envoy 的 Secrets Discovery API，因此获得 X509-SVID 很容易。Envoy 内置访问控制，可以使用 SPIFFE 身份来决定允许哪些应用程序进行通信。&lt;/p&gt;
&lt;p&gt;我们将 SPIRE 架构与现有的服务身份识别系统并行部署，然后对各种内部工具和框架进行修改，以支持这两个系统。接下来，我们将 SPIRE 与部署系统集成，在 SPIRE 中注册所有服务。这意味着我们可以对 SPIRE 的频繁的 SVID 轮换进行压力测试。最后，我们使用功能标志来慢慢选择服务，使其在服务与服务的调用中开始使用 SVID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨云和数据中心的无缝、安全连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPIFFE 和 SPIRE 使我们的安全基础设施团队能够提供一个重要的桥梁，安全地连接不同的平台和技术。我们仍处于转移到 SPIRE 的早期迁移阶段，但我们所做的改变使我们能够将我们的生产型 AWS EKS 基础设施与部署在 Square 数据中心的服务无缝连接。我们现在正在努力在我们的信任域之间进行自动联合，因为我们之前只是手动进行联合。我们使用 SPIFFE 身份作为标准，甚至用于我们公司的定制身份工作。&lt;/p&gt;
&lt;p&gt;我们也非常高兴能参与到 SPIFFE 社区中来，在我们的旅程中，每个人都很友好，也很有帮助。这个社区还提供了一个额外的好处，那就是为一般的零信任系统提供了一个很好的讨论系统设计想法的地方。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
