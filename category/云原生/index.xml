<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>云原生 | 云原生资料库</title>
    <link>https://lib.jimmysong.io/category/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
      <atom:link href="https://lib.jimmysong.io/category/%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml" />
    <description>云原生</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Fri, 10 Mar 2023 12:00:00 +0800</lastBuildDate>
    <image>
      <url>https://lib.jimmysong.io/media/sharing.png</url>
      <title>云原生</title>
      <link>https://lib.jimmysong.io/category/%E4%BA%91%E5%8E%9F%E7%94%9F/</link>
    </image>
    
    <item>
      <title>什么是 Kubernetes?</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/kubernetes/what-is-kubernetes/</link>
      <pubDate>Wed, 25 May 2022 10:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/kubernetes/what-is-kubernetes/</guid>
      <description>&lt;h2 id=&#34;kubernetes-是云原生时代的-posix&#34;&gt;Kubernetes 是云原生时代的 POSIX&lt;/h2&gt;
&lt;p&gt;在单机时代，POSIX 是类 UNIX 系统的通用 API，而在云原生时代，Kubernetes 是云操作系统的的 POSIX，它定义了基于云的分布式系统的 API。下表将 Kubernetes 与 POSIX 进行了对比。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对比项&lt;/th&gt;
&lt;th&gt;Linux&lt;/th&gt;
&lt;th&gt;Kubernetes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;隔离单元&lt;/td&gt;
&lt;td&gt;进程&lt;/td&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬件&lt;/td&gt;
&lt;td&gt;单机&lt;/td&gt;
&lt;td&gt;数据中心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;并发&lt;/td&gt;
&lt;td&gt;线程&lt;/td&gt;
&lt;td&gt;容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;资源管理&lt;/td&gt;
&lt;td&gt;进程内存&amp;amp;CPU&lt;/td&gt;
&lt;td&gt;内存、CPU Limit/Request&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存储&lt;/td&gt;
&lt;td&gt;文件&lt;/td&gt;
&lt;td&gt;ConfigMap、Secret、Volume&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络&lt;/td&gt;
&lt;td&gt;端口绑定&lt;/td&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;终端&lt;/td&gt;
&lt;td&gt;tty、pty、shell&lt;/td&gt;
&lt;td&gt;kubectl exec&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络安全&lt;/td&gt;
&lt;td&gt;IPtables&lt;/td&gt;
&lt;td&gt;NetworkPolicy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;权限&lt;/td&gt;
&lt;td&gt;用户、文件权限&lt;/td&gt;
&lt;td&gt;ServiceAccount、RBAC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;alert-note-title&#34;&gt;
    &lt;p&gt;注意&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
    我们不能说 Linux 就是 POSIX，只能说 Linux 是 UNIX 兼容的。
&lt;/div&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://home.robusta.dev/blog/kubernetes-is-the-new-posix/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes is the POSIX of the cloud - home.robusta.dev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/foreword/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/foreword/</guid>
      <description>&lt;p&gt;还记得有一次告警电话半夜把我吵醒，发现是生产环境离线了。原来是系统瘫痪了，我们不得不要赔钱，这是我的错。&lt;/p&gt;
&lt;p&gt;从那一刻起，我就一直痴迷于构建坚如磐石的基础架构和基础架构管理系统，这样我就不会重蹈覆辙了。在我的职业生涯中，我为 Terraform、Kubernetes，一些编程语言和 Kops 做出过贡献，并创建了 Kubicorn。我不仅见证了系统基础架构的发展，而且我也帮助它完善。随着基础架构行业的发展，我们发现企业基础架构现在正以新的、令人兴奋的方式通过应用层管理。到目前为止，Kubernetes 是这种管理基础架构的新范例的最成熟的例子。&lt;/p&gt;
&lt;p&gt;我与人合著了这本书，部分地介绍了将基础架构作为云原生软件的新范例。此外，我希望鼓励基础架构工程师开始编写云原生应用程序。在这本书中，我们探讨了管理基础架构的丰富历史，并为云原生技术的未来定义了管理基础架构的模式。我们解释了基础架构由软件化 API 驱动的重要性。我们还探索了创建复杂系统的第一个基础架构组件的引导问题，并教授了扩展和测试基础架构的重要性。&lt;/p&gt;
&lt;p&gt;我于 2017 年加入 Heptio，担任资深布道师，并且很高兴能与行业中最聪明的系统工程师密切合作。构建纯粹的开源技术对我来说一直都很重要，Heptio 也拥有这种激情。我很荣幸能在这样一个环境中工作，让我更热爱这个行业。我希望你喜欢这本书，就像 Justin 和我喜欢写这本书一样。&lt;/p&gt;
&lt;p&gt;——Kris Nova&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>什么是服务网格？</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/what-is-service-mesh/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/what-is-service-mesh/</guid>
      <description>&lt;p&gt;Service Mesh 又译作 “服务网格”，作为服务间通信的基础设施层。Buoyant 公司的 CEO Willian Morgan 在他的这篇文章 &lt;a href=&#34;https://buoyant.io/what-is-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WHAT’S A SERVICE MESH? AND WHY DO I NEED ONE?&lt;/a&gt; 中解释了什么是 Service Mesh，为什么云原生应用需要 Service Mesh。&lt;/p&gt;
&lt;p&gt;服务网格是用于处理服务间通信的专用基础设施层。它负责通过包含现代云原生应用程序的复杂服务拓扑来可靠地传递请求。实际上，服务网格通常通过一组轻量级网络代理来实现，这些代理与应用程序代码一起部署，而不需要感知应用程序本身。—— &lt;a href=&#34;https://twitter.com/wm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Willian Morgan&lt;/a&gt; Buoyant CEO&lt;/p&gt;
&lt;p&gt;服务网格（Service Mesh）这个术语通常用于描述构成这些应用程序的微服务网络以及应用之间的交互。随着规模和复杂性的增长，服务网格越来越难以理解和管理。它的需求包括服务发现、负载均衡、故障恢复、指标收集和监控以及通常更加复杂的运维需求，例如 A/B 测试、金丝雀发布、限流、访问控制和端到端认证等。&lt;/p&gt;
&lt;h2 id=&#34;服务网格的特点&#34;&gt;服务网格的特点&lt;/h2&gt;
&lt;p&gt;服务网格有如下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序间通讯的中间层&lt;/li&gt;
&lt;li&gt;轻量级网络代理&lt;/li&gt;
&lt;li&gt;应用程序无感知&lt;/li&gt;
&lt;li&gt;解耦应用程序的重试 / 超时、监控、追踪和服务发现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前两款流行的服务网格开源软件 &lt;a href=&#34;https://linkerd.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Linkerd&lt;/a&gt; 和 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio&lt;/a&gt; 都可以直接在 Kubernetes 中集成，其中 Linkerd 是 CNCF 成员项目，并在 2021 年 7 月毕业。Istio 在 2018 年 7 月 31 日宣布 1.0，并在 2020 年 7 月将 &lt;a href=&#34;https://istio.io/latest/blog/2020/open-usage/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;商标捐献&lt;/a&gt;给 &lt;a href=&#34;https://openusage.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Usage Commons&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;理解服务网格&#34;&gt;理解服务网格&lt;/h2&gt;
&lt;p&gt;如果用一句话来解释什么是服务网格，可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控。对于编写应用程序来说一般无须关心 TCP/IP 这一层（比如通过 HTTP 协议的 RESTful 应用），同样使用服务网格也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给服务网格就可以了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://philcalcado.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Phil Calçado&lt;/a&gt; 在他的这篇博客 &lt;a href=&#34;http://philcalcado.com/2017/08/03/pattern_service_mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pattern: Service Mesh&lt;/a&gt; 中详细解释了服务网格的来龙去脉：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从最原始的主机之间直接使用网线相连&lt;/li&gt;
&lt;li&gt;网络层的出现&lt;/li&gt;
&lt;li&gt;集成到应用程序内部的控制流&lt;/li&gt;
&lt;li&gt;分解到应用程序外部的控制流&lt;/li&gt;
&lt;li&gt;应用程序的中集成服务发现和断路器&lt;/li&gt;
&lt;li&gt;出现了专门用于服务发现和断路器的软件包 / 库，如 &lt;a href=&#34;https://finagle.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter 的 Finagle&lt;/a&gt; 和 &lt;a href=&#34;https://code.fb.com/networking-traffic/introducing-proxygen-facebook-s-c-http-framework/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Facebook 的 Proxygen&lt;/a&gt;，这时候还是集成在应用程序内部&lt;/li&gt;
&lt;li&gt;出现了专门用于服务发现和断路器的开源软件，如 &lt;a href=&#34;https://netflix.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix OSS&lt;/a&gt;、Airbnb 的 &lt;a href=&#34;https://github.com/airbnb/synapse&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;synapse&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/airbnb/nerve&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;nerve&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;最后作为微服务的中间层服务网格出现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务网格的架构如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-service-mesh-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/e6c9d24ely1h1vepo7kzfj20id0bpgmm.jpg&#34; alt=&#34;Service Mesh 架构图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Service Mesh 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
图片来自：&lt;a href=&#34;http://philcalcado.com/2017/08/03/pattern_service_mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pattern: Service Mesh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;服务网格作为 sidecar 运行，对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 serivce mesh 中实现。&lt;/p&gt;
&lt;h2 id=&#34;服务网格如何工作&#34;&gt;服务网格如何工作？&lt;/h2&gt;
&lt;p&gt;下面以 Istio 为例讲解服务网格如何在 Kubernetes 中工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Istio 将服务请求路由到目的地址，根据中的参数判断是到生产环境、测试环境还是 staging 环境中的服务（服务可能同时部署在这三个环境中），是路由到本地环境还是公有云环境？所有的这些路由信息可以动态配置，可以是全局配置也可以为某些服务单独配置。&lt;/li&gt;
&lt;li&gt;当 Istio 确认了目的地址后，将流量发送到相应服务发现端点，在 Kubernetes 中是 service，然后 service 会将服务转发给后端的实例。&lt;/li&gt;
&lt;li&gt;Istio 根据它观测到最近请求的延迟时间，选择出所有应用程序的实例中响应最快的实例。&lt;/li&gt;
&lt;li&gt;Istio 将请求发送给该实例，同时记录响应类型和延迟数据。&lt;/li&gt;
&lt;li&gt;如果该实例挂了、不响应了或者进程不工作了，Istio 将把请求发送到其他实例上重试。&lt;/li&gt;
&lt;li&gt;如果该实例持续返回 error，Istio 会将该实例从负载均衡池中移除，稍后再周期性得重试。&lt;/li&gt;
&lt;li&gt;如果请求的截止时间已过，Istio 主动失败该请求，而不是再次尝试添加负载。&lt;/li&gt;
&lt;li&gt;Istio 以 metric 和分布式追踪的形式捕获上述行为的各个方面，这些追踪信息将发送到集中 metric 系统。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;为何使用服务网格&#34;&gt;为何使用服务网格？&lt;/h2&gt;
&lt;p&gt;服务网格并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在云原生的 Kubernetes 环境下的实现。&lt;/p&gt;
&lt;p&gt;在传统的 MVC 三层 Web 应用程序架构下，服务之间的通讯并不复杂，在应用程序内部自己管理即可，但是在现今的复杂的大型网站情况下，单体应用被分解为众多的微服务，服务之间的依赖和通讯十分复杂，出现了 Twitter 开发的 &lt;a href=&#34;https://twitter.github.io/finagle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Finagle&lt;/a&gt;、Netflix 开发的 &lt;a href=&#34;https://github.com/Netflix/Hystrix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hystrix&lt;/a&gt; 和 Google 的 Stubby 这样的 “胖客户端” 库，这些就是早期的服务网格，但是它们都近适用于特定的环境和特定的开发语言，并不能作为平台级的服务网格支持。&lt;/p&gt;
&lt;p&gt;在云原生架构下，容器的使用给予了异构应用程序的更多可行性，Kubernetes 增强的应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过分关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情而专注于程序开发，赋予开发者更多的创造性。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/attest-engineering/Istio-a-service-mesh-for-aws-ecs-937f201f847a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio: A service mesh for AWS ECS - medium.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/latest/news/releases/0.x/announcing-0.1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;初次了解 Istio - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.christianposta.com/microservices/application-network-functions-with-esbs-api-management-and-now-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Network Functions With ESBs, API Management, and Now.. Service Mesh? - blog.christianposta.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://philcalcado.com/2017/08/03/pattern_service_mesh.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pattern: Service Mesh - philcalcado.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/envoy/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy 官方文档中文版 - cloudnative.to&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 官方文档 - istio.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>什么是云原生？</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/intro/what-is-cloud-native/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/intro/what-is-cloud-native/</guid>
      <description>&lt;p&gt;云原生（Cloud Native）这个词汇由来已久，以致于何时出现已无据可考。云原生开始大规模出现在受众视线中，与 Pivotal 提出的云原生应用的理念有着莫大的关系。我们现在谈到云原生，更多的指的是&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;一种文化&lt;/a&gt;，而不具象为哪些技术体系。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pivotal 推出过 Pivotal Cloud Foundry 云原生应用平台和 &lt;a href=&#34;https://spring.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Spring&lt;/a&gt; 开源 Java 开发框架，成为云原生应用架构中先驱者和探路者。Pivotal 是云原生应用平台第一股，2018 年在纽交所上市，2019 年底被 VMWare 以 27 亿美元收购，加入到 VMware 新的产品线 &lt;a href=&#34;https://tanzu.vmware.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tanzu&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;pivotal-最初的定义&#34;&gt;Pivotal 最初的定义&lt;/h2&gt;
&lt;p&gt;早在 2015 年 Pivotal 公司的 Matt Stine 写了一本叫做 &lt;a href=&#34;https://jimmysong.io/migrating-to-cloud-native-application-architectures/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;迁移到云原生应用架构&lt;/a&gt; 的小册子，其中探讨了云原生应用架构的几个主要特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符合 12 因素应用&lt;/li&gt;
&lt;li&gt;面向微服务架构&lt;/li&gt;
&lt;li&gt;自服务敏捷架构&lt;/li&gt;
&lt;li&gt;基于 API 的协作&lt;/li&gt;
&lt;li&gt;抗脆弱性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者已于 2017 年翻译了本书，详见 &lt;a href=&#34;https://jimmysong.io/migrating-to-cloud-native-application-architectures/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;迁移到云原生应用架构&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;cncf-最初的定义&#34;&gt;CNCF 最初的定义&lt;/h2&gt;
&lt;p&gt;到了 2015 年 Google 主导成立了云原生计算基金会（CNCF），起初 CNCF 对云原生（Cloud Native）的定义包含以下三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用容器化&lt;/li&gt;
&lt;li&gt;面向微服务架构&lt;/li&gt;
&lt;li&gt;应用支持容器的编排调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重定义&#34;&gt;重定义&lt;/h2&gt;
&lt;p&gt;到了 2018 年，随着近几年来云原生生态的不断壮大，所有主流云计算供应商都加入了该基金会，且从 &lt;a href=&#34;https://i.cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Landscape&lt;/a&gt; 中可以看出云原生有意蚕食原先非云原生应用的部分。CNCF 基金会中的会员以及容纳的项目越来越多，该定义已经限制了云原生生态的发展，CNCF 为云原生进行了重新定位。&lt;/p&gt;
&lt;p&gt;以下是 CNCF 对云原生的&lt;a href=&#34;https://github.com/cncf/toc/blob/main/DEFINITION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;重新定义&lt;/a&gt;（中英对照）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;关于什么是云原生的争论还在进行中，在笔者看来云原生是一种行为方式和设计理念，究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的。云计算的发展史就是一部云原生化的历史。Kubernetes 开启了云原生的序幕，服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务，serverless 的再次兴起，使得云原生从基础设施层不断向应用架构层挺进，我们正处于一个云原生的新时代。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cncf/toc/blob/master/DEFINITION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF Cloud Native Definition v1.0 - github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/cloud-native-culture-not-container/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生关乎文化，而不是容器 - cloudnative.to&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>云原生计算基金会（CNCF）</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/community/cncf/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/community/cncf/</guid>
      <description>&lt;p&gt;CNCF，全称Cloud Native Computing Foundation（云原生计算基金会），成立于 2015 年7月21日（&lt;a href=&#34;https://www.cncf.io/announcement/2015/06/21/new-cloud-native-computing-foundation-to-drive-alignment-among-container-technologies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;于美国波特兰OSCON 2015上宣布&lt;/a&gt;），其最初的口号是&lt;strong&gt;坚持和整合开源技术来让编排容器作为微服务架构的一部分&lt;/strong&gt;，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。&lt;/p&gt;
&lt;p&gt;CNCF作为一个厂商中立的基金会，致力于Github上的快速成长的开源技术的推广，如Kubernetes、Prometheus、Envoy等，帮助开发人员更快更好的构建出色的产品。CNCF 维护了一个全景图项目，详见 &lt;a href=&#34;https://github.com/cncf/landscape&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关于CNCF的使命与组织方式请参考&lt;a href=&#34;https://www.cncf.io/about/charter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF章程&lt;/a&gt;，概括的讲CNCF的使命包括以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器化包装。&lt;/li&gt;
&lt;li&gt;通过中心编排系统的动态资源管理。&lt;/li&gt;
&lt;li&gt;面向微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CNCF这个角色的作用是推广技术，形成社区，开源项目管理与推进生态系统健康发展。&lt;/p&gt;
&lt;p&gt;另外CNCF组织由以下部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会员&lt;/strong&gt;：白金、金牌、银牌、最终用户、学术和非赢利成员，不同级别的会员在治理委员会中的投票权不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理事会&lt;/strong&gt;：负责事务管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TOC（技术监督委员会）&lt;/strong&gt;：技术管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户社区&lt;/strong&gt;：推动CNCF技术的采纳并选举最终用户技术咨询委员会&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终用户技术咨询委员会&lt;/strong&gt;：为最终用户会议或向理事会提供咨询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;营销委员会&lt;/strong&gt;：市场推广&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cncf项目成熟度分级与毕业条件&#34;&gt;CNCF项目成熟度分级与毕业条件&lt;/h2&gt;
&lt;p&gt;每个CNCF项目都需要有个成熟度等级，申请成为CNCF项目的时候需要确定项目的成熟度级别。&lt;/p&gt;
&lt;p&gt;成熟度级别（Maturity Level）包括以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sandbox（初级）&lt;/li&gt;
&lt;li&gt;incubating（孵化中）&lt;/li&gt;
&lt;li&gt;graduated（毕业）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是否可以成为CNCF项目需要通过Technical Oversight Committee (技术监督委员会）简称&lt;a href=&#34;https://github.com/cncf/toc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TOC&lt;/a&gt;，投票采取fallback策略，即&lt;strong&gt;回退策略&lt;/strong&gt;，先从最高级别（graduated）开始，如果2/3多数投票通过的话则确认为该级别，如果没通过的话，则进行下一低级别的投票，如果一直到inception级别都没得到2/3多数投票通过的话，则拒绝其进入CNCF项目。&lt;/p&gt;
&lt;p&gt;当前所有的CNCF项目可以访问&lt;a href=&#34;https://www.cncf.io/projects/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/projects/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;项目所达到相应成熟度需要满足的条件和投票机制见下图：&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cncf项目成熟度级别&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/cncf-graduation-criteria-v2.jpg&#34; alt=&#34;CNCF项目成熟度级别&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      CNCF项目成熟度级别
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;toc技术监督委员会&#34;&gt;TOC（技术监督委员会）&lt;/h2&gt;
&lt;p&gt;TOC（Technical Oversight Committee）作为CNCF中的一个重要组织，它的作用是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义和维护技术视野&lt;/li&gt;
&lt;li&gt;审批新项目加入组织，为项目设定概念架构&lt;/li&gt;
&lt;li&gt;接受最终用户的反馈并映射到项目中&lt;/li&gt;
&lt;li&gt;调整组件间的访问接口，协调组件之间兼容性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TOC成员通过选举产生，见&lt;a href=&#34;https://github.com/cncf/toc/blob/master/process/election-schedule.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;选举时间表&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;参考 CNCF TOC：&lt;a href=&#34;https://github.com/cncf/toc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/toc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cncf-ambassador&#34;&gt;CNCF Ambassador&lt;/h2&gt;
&lt;p&gt;CNCF Ambassador（CNCF 大使），人员名单详见 &lt;a href=&#34;https://www.cncf.io/people/ambassadors/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.cncf.io/people/ambassadors/&lt;/a&gt;，笔者很荣幸作为第二位成为 CNCF Ambassador 的中国人。&lt;/p&gt;
&lt;h3 id=&#34;如何成为-cncf-ambassador&#34;&gt;如何成为 CNCF Ambassador&lt;/h3&gt;
&lt;p&gt;可以通过以下方式成为 CNCF Ambassador：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成为 CNCF 会员或对成为某个 CNCF 的项目的贡献者&lt;/li&gt;
&lt;li&gt;以 contributor、blogger、演讲者等身份参与 CNCF 社区项目&lt;/li&gt;
&lt;li&gt;在社区中演讲或撰写博客&lt;/li&gt;
&lt;li&gt;主持云原生社区 meetup&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cncf.io/announcement/2015/06/21/new-cloud-native-computing-foundation-to-drive-alignment-among-container-technologies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AT&amp;amp;T, Box, Cisco, Cloud Foundry Foundation, CoreOS, Cycle Computing, Docker, eBay, Goldman Sachs, Google, Huawei, IBM, Intel, Joyent, Kismatic, Mesosphere, Red Hat, Switch SUPERNAP, Twitter, Univa, VMware and Weaveworks join new effort to build and maintain cloud native distributed systems - cncf.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>介绍</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/introduction/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/introduction/</guid>
      <description>&lt;p&gt;基础设施技术的历史向来引人入胜。由于基础设施的规模巨大，它已经经历了一次快速的颠覆性变革。除了计算机和互联网的早期，基础设施可谓日新月异。这些创新使基础架构更快，更可靠，更有价值。&lt;/p&gt;
&lt;p&gt;有些公司的人将基础设施推到了极限，他们已经找到了自动化和抽象的方法，提取基础设施更多商业价值。通过提供灵活的可用资源，他们将曾经是昂贵的成本中心转变为所需的商业公用事业。&lt;/p&gt;
&lt;p&gt;然而，公共事业公司很少为企业提供财务价值，这意味着基础设施往往被忽略并被视为不必要的成本。这使得投入创新或改进的时间和金钱很少。&lt;/p&gt;
&lt;p&gt;这样一个如此简单且令人着迷的业务栈怎么可以被轻易忽略？当基础设施出现故障时，业务显然会受到重视，那么为什么基础设施很难改善呢？&lt;/p&gt;
&lt;p&gt;基础设施已经达到了使消费者都感到无聊的成熟度。然而，它的潜力和新挑战又激发了实施者和工程师们新的激情。&lt;/p&gt;
&lt;p&gt;扩展基础设施并使用新的业务方式让来自不同行业的工程师都能找到解决方案。开源软件（OSS）和社区间的互相协作，这股力量又促使了创新的激增。&lt;/p&gt;
&lt;p&gt;如果管理得当，今天基础设施和应用方面的挑战将会不一样。这使得基础设施建设者和维护人员可以取得进展并开展新的有意义的工作。&lt;/p&gt;
&lt;p&gt;有些公司克服了诸如可扩展性、可靠性和灵活性等挑战。他们创建并封装了一些项目，封装了可供他人遵循的模式。这些模式有时很容易被实现者发现，但在其他情况下，它们不太明显。&lt;/p&gt;
&lt;p&gt;在本书中，我们将分享来自云原生技术前沿的公司的经验教训，使您能够有效解决可靠运行可伸缩应用程序的问题。现代商业发展非常迅速。本书中的模式将使您的基础设施能够跟上业务的速度和敏捷性需求。更重要的是，我们会让您自行决定何时采用这些模式。&lt;/p&gt;
&lt;p&gt;这些模式中有很多都已经在开源项目中得到了体现。其中一些项目由云原生计算基金会（CNCF）维护。这些项目和基金会并不是模式的唯一体现，但忽视它们会让你失去理智。以它们为例，但要自己进行尽职调查，以审核您所采用的每个解决方案。&lt;/p&gt;
&lt;p&gt;我们将向您展示云原生基础设施的益处以及可扩展系统和应用程序的基本模式。我们将向您展示如何测试您的基础设施，以及如何创建一个可以适应您需求的灵活的基础设施。您将了一些重要方面和未来发展。&lt;/p&gt;
&lt;p&gt;这本书可以激励你继续前进并自由分享你在社区中学到的知识。&lt;/p&gt;
&lt;h2 id=&#34;谁应该读这本书&#34;&gt;谁应该读这本书&lt;/h2&gt;
&lt;p&gt;如果您是开发基础设施或基础设施管理工具的工程师，那么本书就是为您准备的。本书将帮助您了解创建旨在在云环境中运行的基础设施的模式、流程和实践。通过了解应该怎么做，您可以更好地了解应用程序的作用，以及应该何时构建基础设施或使用云服务。&lt;/p&gt;
&lt;p&gt;应用程序工程师从本书中还可以发现哪些服务应该是其应用程序的一部分，哪些服务应该由基础设施提供。通过本书了解应用开发者和管理基础设施的工程师应该共同承担的责任。&lt;/p&gt;
&lt;p&gt;希望提升技能并系统地在设计基础设施和维护云网关基础设施方面发挥更大作用的系统管理员也可以从本书中学到很多。&lt;/p&gt;
&lt;p&gt;你是否在公有云中运行所有的基础设施？本书将帮助您了解何时使用云服务以及何时构建自己的抽象或服务。&lt;/p&gt;
&lt;p&gt;运行在数据中心还是本地云？我们将概述现代应用对基础设施的期望，并将帮助您了解利用当前投资的必要服务。&lt;/p&gt;
&lt;p&gt;这本书不是一本教程，除了给出实现示例之外，我们没有指出特定的产品。对于经理、董事和高管来说，这可能太过技术性，但可能会有所帮助，具体取决于该角色的参与和技术专长。&lt;/p&gt;
&lt;p&gt;最重要的是，如果您想了解基础设施如何影响业务，请阅读本书，以及如何创建经证实可为具备全球互联网运营规模的企业服务的基础设施。即使您的应用程序不需要扩展到这种规模，如果您的基础设施是使用此处描述的模式构建的，并且考虑到灵活性和可操作性，这本书仍然值得一读。&lt;/p&gt;
&lt;h2 id=&#34;为什么我们写了这本书&#34;&gt;为什么我们写了这本书&lt;/h2&gt;
&lt;p&gt;我们希望通过专注于模式和实践而不是特定产品和供应商来帮助您了解。当前存在太多的解决方案而人们不了解它们本身到底要解决什么问题。&lt;/p&gt;
&lt;p&gt;我们相信通过云原生应用程序管理云原生基础设施的好处，并且我们希望所有人都具有这种意识。&lt;/p&gt;
&lt;p&gt;我们希望回馈社区，推动行业向前发展。我们发现这样做的最好方式是解释业务和基础设施之间的关系，阐明问题并解释发现它们的工程师和组织所做的解决方案。&lt;/p&gt;
&lt;p&gt;以不涉及产品的方式解释模式并不总是很容易，但了解产品存在的原因很重要。我们经常使用产品作为模式的例子，但只有当它们会帮助您提供解决方案的实施示例时才会提到。&lt;/p&gt;
&lt;p&gt;如果没有无数人数万小时的自愿编写代码，帮助他人以及投资社区，我们就不会走到这里。我们非常感谢那些帮助我们了解这些模式的人们，我们希望能够回馈并帮助下一代工程师。这本书就是我们表达谢意的方式。&lt;/p&gt;
&lt;h2 id=&#34;浏览本书&#34;&gt;浏览本书&lt;/h2&gt;
&lt;p&gt;本书的组织结构如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 章介绍云原生基础设施是什么以及我们如何走到当前这一步。&lt;/li&gt;
&lt;li&gt;第 2 章可以帮助您决定是否以及何时采用后面章节中预先描述的模式。&lt;/li&gt;
&lt;li&gt;第 3 章和第 4 章展示了应该如何部署基础设施以及如何编写应用程序来管理它。&lt;/li&gt;
&lt;li&gt;第 5 章将教你如何从测试开始就设计可靠的基础设施。&lt;/li&gt;
&lt;li&gt;第 6 章和第 7 章展示了如何管理基础设施和应用程序。&lt;/li&gt;
&lt;li&gt;第 8 章总结并提供了一些有关未来发展的见解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你像我们一样，不会从前到后完整看完本书。以下是关于本书主题的一些建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果您是一位专注于创建和维护基础设施的工程师，您应该至少阅读第 3 章至第 6 章。&lt;/li&gt;
&lt;li&gt;应用程序开发人员可以专注于第 4、5 和 7 章关于将基础架构工具开发为云原生应用程序。&lt;/li&gt;
&lt;li&gt;所有不构建云原生基础设施的人都将从第 1、2、8 章中受益匪浅。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;在线资源&#34;&gt;在线资源&lt;/h2&gt;
&lt;p&gt;您应该通过访问 CNCF 网站熟悉云原生计算基金会（CNCF）及其托管项目。本书中的许多项目都被用作示例。&lt;/p&gt;
&lt;p&gt;您还可以通过查看 CNCF 景观项目（参见图 P-1），了解项目这些项目的全局视图。&lt;/p&gt;
&lt;p&gt;云原生应用程序是从 Heroku 的 12 因素的定义开始的。我们会解释它们之间的相似之处，但你应该熟悉下 12 因素是什么（参见 &lt;a href=&#34;http://12factor.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://12factor.net&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;还有许多关于 DevOps 的书籍、文章和演讲。尽管本书不关注 DevOps 实践，但是在实现云原生基础设施时，如果没有 DevOps 规定的工具、实践和文化，将很难实现。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-cloud-native-landscape&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://landscape.cncf.io/images/landscape.png&#34; alt=&#34;Cloud Native Landscape&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Cloud Native Landscape
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;致谢&#34;&gt;致谢&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Justin Garrison&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感谢 Beth、Logan、我的朋友、家人以及在此过程中支持我们的同事。感谢那些帮助我们的社区和社区领袖以及给予宝贵反馈的评论者。感谢 Kris 让这本书变得更好，感谢读者花点时间阅读本书并提高你的技能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kris Nova&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感谢 Allison、Bryan、Charlie、Justin、Kjersti、Meghann 和 Patrick 为我写这本书所作出的帮助。我爱你们，永远感激你们为我所做的一切。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生的设计哲学</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/intro/cloud-native-philosophy/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/intro/cloud-native-philosophy/</guid>
      <description>&lt;p&gt;云原生一词已经被过度的采用，很多软件都号称是云原生，很多打着云原生旗号的会议也如雨后春笋般涌现。&lt;/p&gt;
&lt;p&gt;云原生本身甚至不能称为是一种架构，它首先是一种基础设施，运行在其上的应用称作云原生应用，只有符合云原生设计哲学的应用架构才叫云原生应用架构。&lt;/p&gt;
&lt;h2 id=&#34;云原生的设计理念&#34;&gt;云原生的设计理念&lt;/h2&gt;
&lt;p&gt;云原生系统的设计理念如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向分布式设计（Distribution）：容器、微服务、API 驱动的开发；&lt;/li&gt;
&lt;li&gt;面向配置设计（Configuration）：一个镜像，多个环境配置；&lt;/li&gt;
&lt;li&gt;面向韧性设计（Resistancy）：故障容忍和自愈；&lt;/li&gt;
&lt;li&gt;面向弹性设计（Elasticity）：弹性扩展和对环境变化（负载）做出响应；&lt;/li&gt;
&lt;li&gt;面向交付设计（Delivery）：自动拉起，缩短交付时间；&lt;/li&gt;
&lt;li&gt;面向性能设计（Performance）：响应式，并发和资源高效利用；&lt;/li&gt;
&lt;li&gt;面向自动化设计（Automation）：自动化的 DevOps；&lt;/li&gt;
&lt;li&gt;面向诊断性设计（Diagnosability）：集群级别的日志、metric 和追踪；&lt;/li&gt;
&lt;li&gt;面向安全性设计（Security）：安全端点、API Gateway、端到端加密；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的设计理念很多都是继承自分布式应用的设计理念。虽然有如此多的理念但是我们仍然无法辨认什么样的设施才是云原生基础设施，不过可以先用排除法，我将解释什么不是云原生基础设施。&lt;/p&gt;
&lt;h2 id=&#34;什么不是云原生基础设施&#34;&gt;什么不是云原生基础设施？&lt;/h2&gt;
&lt;p&gt;云原生基础设施不等于在公有云上运行的基础设施。光是租用服务器并不会使您的基础设施云原生化。管理 IaaS 的流程与运维物理数据中心没什么两样，将现有架构迁移到云上也未必能获得回报。&lt;/p&gt;
&lt;p&gt;云原生不是指在容器中运行应用程序。Netflix 率先推出云原生基础设施时，几乎所有应用程序部署在虚拟机中，而不是在容器中。改变应用程序的打包方式并不意味着就会增加自治系统的可扩展性和优势。即使应用程序是通过 CI/CD 渠道自动构建和部署的，也不意味着您就可以从增强 API 驱动部署的基础设施中受益。&lt;/p&gt;
&lt;p&gt;这也并不意味着您只能运行容器编排器（例如 Kubernetes 和 Mesos）。容器编排器提供了云原生基础设施所需的许多平台功能，但并未按预期方式使用这些功能，这意味着您的应用程序会在一组服务器上运行，被动态调度。这是一个非常好的起步，但仍有许多工作要做。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;调度器与编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;术语 “调度器” 和 “编排器” 通常可以互换使用。&lt;/p&gt;
&lt;p&gt;在大多数情况下，编排器负责集群中的所有资源利用（例如：存储，网络和 CPU）。该术语典型地用于描述执行许多任务的产品，如健康检查和云自动化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调度器是编排平台的一个子集，仅负责选择运行在每台服务器上的进程和服务。&lt;/p&gt;
&lt;p&gt;云原生不是微服务或基础设施即代码。微服务意味着更快的开发周期和更小的独特功能，但是单体应用程序可以具有相同的功能，使其能够通过软件有效管理，并且还可以从云原生基础设施中受益。&lt;/p&gt;
&lt;p&gt;基础设施即代码以机器可解析语言或领域特定语言（DSL）定义、自动化您的基础设施。将代码应用于基础架构的传统工具包括配置管理工具（例如 Chef 和 Puppet）。这些工具在自动执行任务和提供一致性方面有很大帮助，但是它们在提供必要的抽象来描述超出单个服务器的基础设施方面存在缺陷。&lt;/p&gt;
&lt;p&gt;配置管理工具一次自动化一台服务器，并依靠人员将服务器提供的功能绑定在一起。这将人类定位为基础设施规模的潜在瓶颈。这些工具也不会使构建完整系统所需的云基础设施（例如存储和网络）的额外部分自动化。&lt;/p&gt;
&lt;p&gt;尽管配置管理工具为操作系统的资源（例如软件包管理器）提供了一些抽象，但它们并没有抽象出足够的底层操作系统来轻松管理它。如果一位工程师想要管理系统中的每个软件包和文件，这将是一个非常艰苦的过程，并且对于每个配置变体都是独一无二的。同样，定义不存在或不正确的资源的配置管理仅消耗系统资源并且不能提供任何价值。&lt;/p&gt;
&lt;p&gt;虽然配置管理工具可以帮助自动化部分基础设施，但它们无法更好地管理应用程序。我们将在后面的章节中通过查看部署，管理，测试和操作基础架构的流程，探讨云原生基础设施的不同之处，但首先，我们将了解哪些应用程序是成功的以及应该何时与原生基础设施一起使用。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用程序&#34;&gt;云原生应用程序&lt;/h2&gt;
&lt;p&gt;就像云改变了业务和基础设施之间的关系一样，云原生应用程序也改变了应用程序和基础设施之间的关系。我们需要了解与传统应用程序相比，云本身有什么不同，因此我们需要了解它们与基础设施的新关系。&lt;/p&gt;
&lt;p&gt;为了写好本书，也为了有一个共享词汇表，我们需要定义 “云原生应用程序” 是什么意思。云原生与 12 因素应用程序不同，即使它们可能共享一些类似的特征。如果你想了解更多细节，请阅读 Kevin Hoffman 撰写的 “超越 12 因素应用程序”（O&amp;rsquo;Reilly，2012）。&lt;/p&gt;
&lt;p&gt;云原生应用程序被设计为在平台上运行，并设计用于弹性，敏捷性，可操作性和可观测性。弹性包含失败而不是试图阻止它们；它利用了在平台上运行的动态特性。敏捷性允许快速部署和快速迭代。可操作性从应用程序内部控制应用程序生命周期，而不是依赖外部进程和监视器。可观测性提供信息来回答有关应用程序状态的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;云原生定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生应用程序的定义仍在发展中。还有像 CNCF 这样的组织可以提供其他的定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生应用程序通过各种方法获取这些特征。它通常取决于应用程序的运行位置以及企业流程和文化。以下是实现云原生应用程序所需特性的常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务&lt;/li&gt;
&lt;li&gt;健康报告&lt;/li&gt;
&lt;li&gt;遥测数据&lt;/li&gt;
&lt;li&gt;弹性&lt;/li&gt;
&lt;li&gt;声明式的，而不是命令式的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;微服务&#34;&gt;微服务&lt;/h3&gt;
&lt;p&gt;作为单个实体进行管理和部署的应用程序通常称为单体应用。最初开发应用程序时，单体有很多好处。它们更易于理解，并允许您在不影响其他服务的情况下更改主要功能。&lt;/p&gt;
&lt;p&gt;随着应用程序复杂性的增长，单体应用的益处逐渐减少。它们变得更难理解，而且失去了敏捷性，因为工程师很难推断和修改代码。&lt;/p&gt;
&lt;p&gt;对付复杂性的最好方法之一是将明确定义的功能分成更小的服务，并让每个服务独立迭代。这增加了应用程序的灵活性，允许根据需要更轻松地更改部分应用程序。每个微服务可以由单独的团队进行管理，使用适当的语言编写，并根据需要进行独立扩缩容。&lt;/p&gt;
&lt;p&gt;只要每项服务都遵守强有力的合约，应用程序就可以快速改进和改变。当然，转向微服务架构还有许多其他的考虑因素。其中最不重要的是弹性通信，我们在附录 A 中有讨论。&lt;/p&gt;
&lt;p&gt;我们无法考虑转向微服务的所有考虑因素。拥有微服务并不意味着您拥有云原生基础设施。如果您想阅读更多，我们推荐 Sam Newman 的 Building Microservices（O&amp;rsquo;Reilly，2015）。虽然微服务是实现您的应用程序灵活性的一种方式，但正如我们之前所说的，它们不是云原生应用程序的必需条件。&lt;/p&gt;
&lt;h3 id=&#34;健康报告&#34;&gt;健康报告&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;停止逆向工程应用程序并开始从内部进行监控。 —— Kelsey Hightower，Monitorama PDX 2016：healthz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有人比开发人员更了解应用程序需要什么才能以健康的状态运行。很长一段时间，基础设施管理员都试图从他们负责运行的应用程序中找出 “健康” 该怎么定义。如果不实际了解应用程序的健康状况，他们尝试在应用程序不健康时进行监控并发出警报，这往往是脆弱和不完整的。&lt;/p&gt;
&lt;p&gt;为了提高云原生应用程序的可操作性，应用程序应该暴露健康检查。开发人员可以将其实施为命令或过程信号，以便应用程序在执行自我检查之后响应，或者更常见的是：通过应用程序提供 Web 服务，返回 HTTP 状态码来检查健康状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Google Borg 示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Google 的 Borg 报告中列出了一个健康报告的例子：&lt;/p&gt;
&lt;p&gt;几乎每个在 Borg 下运行的任务都包含一个内置的 HTTP 服务器，该服务器发布有关任务运行状况和数千个性能指标（如 RPC 延迟）的信息。Borg 会监控运行状况检查 URL 并重新启动不及时响应或返回 HTTP 错误代码的任务。其他数据由监控工具跟踪，用于仪表板和服务级别目标（SLO）违规警报。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将健康责任转移到应用程序中使应用程序更容易管理和自动化。应用程序应该知道它是否正常运行以及它依赖于什么（例如，访问数据库）来提供业务价值。这意味着开发人员需要与产品经理合作来定义应用服务的业务功能并相应地编写测试。&lt;/p&gt;
&lt;p&gt;提供健康检查的应用程序示例包括 Zookeeper 的 ruok 命令和 etcd 的 HTTP / 健康端点。&lt;/p&gt;
&lt;p&gt;应用程序不仅仅有健康或不健康的状态。它们将经历一个启动和关闭过程，在这个过程中它们应该通过健康检查，报告它们的状态。如果应用程序可以让平台准确了解它所处的状态，平台将更容易知道如何操作它。&lt;/p&gt;
&lt;p&gt;一个很好的例子就是当平台需要知道应用程序何时可以接收流量。在应用程序启动时，如果它不能正确处理流量，它就应该表现为未准备好。此额外状态将防止应用程序过早终止，因为如果运行状况检查失败，平台可能会认为应用程序不健康，并且会反复停止或重新启动它。&lt;/p&gt;
&lt;p&gt;应用程序健康只是能够自动化应用程序生命周期的一部分。除了知道应用程序是否健康之外，您还需要知道应用程序是否正在进行哪些工作。这些信息来自遥测数据。&lt;/p&gt;
&lt;h3 id=&#34;遥测数据&#34;&gt;遥测数据&lt;/h3&gt;
&lt;p&gt;遥测数据是进行决策所需的信息。确实，遥测数据可能与健康报告重叠，但它们有不同的用途。健康报告通知我们应用程序生命周期状态，而遥测数据通知我们应用程序业务目标。&lt;/p&gt;
&lt;p&gt;您测量的指标有时称为服务级指标（SLI）或关键性能指标（KPI）。这些是特定于应用程序的数据，可以确保应用程序的性能处于服务级别目标（SLO）内。如果您需要更多关于这些术语的信息以及它们与您的应用程序、业务需求的关系，我们推荐你阅读来自 Site Reliability Engineering（O&amp;rsquo;Reilly）的第 4 章。&lt;/p&gt;
&lt;p&gt;遥测和度量标准用于解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序每分钟收到多少请求？&lt;/li&gt;
&lt;li&gt;有没有错误？&lt;/li&gt;
&lt;li&gt;什么是应用程序延迟？&lt;/li&gt;
&lt;li&gt;订购需要多长时间？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常会将数据刮取或推送到时间序列数据库（例如 Prometheus 或 InfluxDB）进行聚合。遥测数据的唯一要求是它将被收集数据的系统格式化。&lt;/p&gt;
&lt;p&gt;至少，可能最好实施度量标准的 RED 方法，该方法收集应用程序的速率，错误和执行时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收到了多少个请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序有多少错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多久才能收到回复&lt;/p&gt;
&lt;p&gt;遥测数据应该用于提醒而非健康监测。在动态的、自我修复的环境中，我们更少关注单个应用程序实例的生命周期，更多关注关于整体应用程序 SLO 的内容。健康报告对于自动应用程序管理仍然很重要，但不应该用于页面工程师。&lt;/p&gt;
&lt;p&gt;如果 1 个实例或 50 个应用程序不健康，只要满足应用程序的业务需求，我们可能不会收到警报。度量标准可让您知道您是否符合您的 SLO，应用程序的使用方式以及对于您的应用程序来说什么是 “正常”。警报有助于您将系统恢复到已知的良好状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果它移动，我们跟踪它。有时候我们会画出一些尚未移动的图形，以防万一它决定为它运行。&lt;/p&gt;
&lt;p&gt;——Ian Malpass，衡量所有，衡量一切&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;警报也不应该与日志记录混淆。记录用于调试，开发和观察模式。它暴露了应用程序的内部功能。度量有时可以从日志（例如错误率）计算，但需要额外的聚合服务（例如 ElasticSearch）和处理。&lt;/p&gt;
&lt;h3 id=&#34;弹性&#34;&gt;弹性&lt;/h3&gt;
&lt;p&gt;一旦你有遥测和监测数据，你需要确保你的应用程序对故障有适应能力。弹性是基础设施的责任，但云原生应用程序也需要承担部分工作。&lt;/p&gt;
&lt;p&gt;基础设施被设计为抵制失败。硬件用于需要多个硬盘驱动器，电源以及全天候监控和部件更换以保持应用程序可用。使用云原生应用程序，应用程序有责任接受失败而不是避免失败。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在任何平台上，尤其是在云中，最重要的特性是其可靠性。&lt;/p&gt;
&lt;p&gt;——David Rensin，e ARCHITECT Show：来自 Google 的关于云计算的速成课程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计具有弹性的应用程序可能是整本书本身。我们将在云原生应用程序中考虑弹性的两个主要方面：为失败设计和优雅降级。&lt;/p&gt;
&lt;h4 id=&#34;为失败设计&#34;&gt;为失败设计&lt;/h4&gt;
&lt;p&gt;唯一永远不会失败的系统是那些让你活着的系统（例如心脏植入物和刹车系统）。如果您的服务永远不会停止运行，您需要花费太多时间设计它们来抵制故障，并且没有足够的时间增加业务价值。您的 SLO 确定服务需要多长时间。您花费在工程设计上超出 SLO 的正常运行时间的任何资源都将被浪费掉。&lt;/p&gt;
&lt;p&gt;您应该为每项服务测量两个值，即平均无故障时间（MTBF）和平均恢复时间（MTTR）。监控和指标可以让您检测您是否符合您的 SLO，但运行应用程序的平台是保持高 MTBF 和低 MTTR 的关键。&lt;/p&gt;
&lt;p&gt;在任何复杂的系统中，都会有失败。您可以管理硬件中的某些故障（例如，RAID 和冗余电源），以及某些基础设施中的故障（例如负载平衡器）。但是因为应用程序知道他们什么时候健康，所以他们也应该尽可能地管理自己的失败。&lt;/p&gt;
&lt;p&gt;设计一个以失败期望为目标的应用程序将比假定可用性的应用程序更具防御性。当故障不可避免时，将会有额外的检查，故障模式和日志内置到应用程序中。&lt;/p&gt;
&lt;p&gt;知道应用程序可能失败的每种方式是不可能的。假设任何事情都可能并且可能会失败，这是一种云原生应用程序的模式。&lt;/p&gt;
&lt;p&gt;您的应用程序的最佳状态是健康状态。第二好的状态是失败状态。其他一切都是非二进制的，难以监控和排除故障。 Honeycomb 首席执行官 CharityMajors 在她的文章 “Ops：现在每个人都在工作” 中指出：“分布式系统永远不会起作用；它们处于部分退化服务的持续状态。接受失败，设计弹性，保护和缩小关键路径。”&lt;/p&gt;
&lt;p&gt;无论发生什么故障，云原生应用程序都应该是可适应的。他们期望失败，所以他们在检测到时进行调整。&lt;/p&gt;
&lt;p&gt;有些故障不能也不应该被设计到应用程序中（例如，网络分区和可用区故障）。该平台应自主处理未集成到应用程序中的故障域。&lt;/p&gt;
&lt;h4 id=&#34;优雅降级&#34;&gt;优雅降级&lt;/h4&gt;
&lt;p&gt;云原生应用程序需要有一种方法来处理过载，无论它是应用程序还是负载下的相关服务。处理负载的一种方式是优雅降级。 “站点可靠性工程” 一书中描述了应用程序的优雅降级，因为它提供的响应在负载过重的情况下 “不如正常响应准确或含有较少数据的响应，但计算更容易”。&lt;/p&gt;
&lt;p&gt;减少应用程序负载的某些方面由基础设施处理。智能负载平衡和动态扩展可以提供帮助，但是在某些时候，您的应用程序可能承受的负载比它可以处理的负载更多。云原生应用程序需要知道这种必然性并作出相应的反应。&lt;/p&gt;
&lt;p&gt;优雅降级的重点是允许应用程序始终返回请求的答案。如果应用程序没有足够的本地计算资源，并且依赖服务没有及时返回信息，则这是正确的。依赖于一个或多个其他服务的服务应该可用于应答请求，即使依赖于服务不是。当服务退化时，返回部分答案或使用本地缓存中的旧信息进行答案是可能的解决方案。&lt;/p&gt;
&lt;p&gt;尽管优雅的降级和失败处理都应该在应用程序中实现，但平台的多个层面应该提供帮助。如果采用微服务，则网络基础设施成为需要在提供应用弹性方面发挥积极作用的关键组件。有关构建弹性网络层的更多信息，请参阅附录 A。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;可用性数学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生应用程序需要在基础设施之上建立一个平台，以使基础设施更具弹性。如果您希望将现有应用程序 “提升并转移” 到云中，则应检查云提供商的服务级别协议（SLA），并考虑在使用多个服务时会发生什么情况。&lt;/p&gt;
&lt;p&gt;让我们拿运行我们的应用程序的云来进行假设。&lt;/p&gt;
&lt;p&gt;计算基础设施的典型可用性是每月 99.95％的正常运行时间。这意味着您的实例每天可能会缩短到 43.2 秒，并且仍在您的云服务提供商的 SLA 中。&lt;/p&gt;
&lt;p&gt;另外，实例的本地存储（例如 EBS 卷）也具有 99.95％的可用性正常运行时间。如果幸运的话，他们都会同时出现故障，但最糟糕的情况是他们可能会在不同的时间停机，让您的实例只有 99.9％的可用性。&lt;/p&gt;
&lt;p&gt;您的应用程序可能还需要一个数据库，而不是自己安装一个计算可能的停机时间为 1 分 26 秒（99.9％可用性）的情况下，选择可靠性为 99.95％的更可靠的托管数据库。这使您的应用程序的可靠性达到 99.85％，或者每天可能发生 2 分钟和 9 秒的宕机时间。&lt;/p&gt;
&lt;p&gt;将可用性乘到一起可以快速了解为什么应以不同方式处理云。真正不好的部分是，如果云提供商不符合其 SLA，它将退还其账单中一定比例的退款。&lt;/p&gt;
&lt;p&gt;虽然您不必为停机支付费用，但我们并不知道世界上存在云计算信用的单一业务。如果您的应用程序的可用性不足以超过您收到的信用额度，那么您应该真正考虑是否应该运行这个应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;声明式非反应式&#34;&gt;声明式，非反应式&lt;/h3&gt;
&lt;p&gt;因为云原生应用程序被设计为在云环境中运行，所以它们与基础设施以及相关依赖应用程序的交互方式不同于传统应用程序。在云原生应用程序中，与任何事物的通信都需要通过网络来进行。很多时候，网络通信是通过 RESTful HTTP 调用完成的，但是也可以通过其他接口实现，比如远程过程调用 (RPC)。&lt;/p&gt;
&lt;p&gt;传统的应用程序会通过向消息队列发送消息、在共享存储上写入文件或触发本地 shell 脚本来执行自动化任务。通信方法基于发生的事件作出反应（例如，如果用户单击提交，运行提交脚本）并且通常需要存在于同一物理或虚拟服务器上的信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Serverless&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无服务器平台是云原生化的，并被设计为对事件做出反应。他们在云中工作得很好的原因是他们通过 HTTP API 进行通信，（这些 API）是单一用途的函数，并且在它们的调用中是声明性的。该平台还使它们可伸缩并可从云内访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传统应用程序中的反应式通信通常是构建弹性的一种尝试。如果应用程序（以反应式的方式）在磁盘上或消息队列中写入了一个文件，然后应用程序死亡，那么该消息或文件的结果仍然可以完成。&lt;/p&gt;
&lt;p&gt;这里并不是说不应该使用像消息队列这样的技术，而是说在动态且经常出现故障的系统中，不能将它们作为惟一的弹性层来依赖。从根本上说，在云原生环境之中，应用程序之间的通信方法应该有所变化 - 这不仅是因为还存在其他方法来构建通信弹性（请参阅附录 A），而且还因为如果要让传统的通信方法在云中实现复制，我们往往需要做更多工作。&lt;/p&gt;
&lt;p&gt;当应用程序可以信任通信的弹性时，它们应该放弃反应式并使用声明式。声明式通信信任网络会将消息送达。它也相信应用程序将返回成功或错误。这并不是说让应用程序观察变化不重要。Kubernetes 的控制器对 API 服务器做的就是这个。但是，一旦发现变更，他们就会声明一个新的状态，并相信 API 服务器和 kubelets 会做必要的事情。&lt;/p&gt;
&lt;p&gt;声明式通信模型由于多种原因而变得更加健壮。最重要的是，它规范了通信模型，并且它将（如何从某种状态到达期望状态的）功能实现从应用程序转移到远程 API 或服务端点。这有助于简化应用程序，并使它们彼此的行为更具可预测性。&lt;/p&gt;
&lt;h3 id=&#34;云原生应用程序如何影响基础设施&#34;&gt;云原生应用程序如何影响基础设施？&lt;/h3&gt;
&lt;p&gt;希望你可以知道云原生应用程序与传统应用程序不同。云原生应用程序不能直接在 PaaS 上运行或与服务器的操作系统紧密耦合。它们期望在一个拥有大多数自治系统的动态环境中运行。&lt;/p&gt;
&lt;p&gt;云原生基础设施在提供自主应用管理的 IaaS 之上创建了一个平台。该平台建立在动态创建的基础设施之上，以抽象出单个服务器并促进动态资源分配调度。&lt;/p&gt;
&lt;p&gt;自动化与自治不一样。自动化使人类对他们所采取的行动产生更大的影响。&lt;/p&gt;
&lt;p&gt;云原生是关于不需要人类做出决定的自治系统。它仍然使用自动化，但只有在决定了所需的操作之后。只有在系统不能自动确定正确的事情时才应该通知人。&lt;/p&gt;
&lt;p&gt;具有这些特征的应用程序需要一个能够实际监控，收集度量标准并在发生故障时做出反应的平台。云原生应用程序不依赖于人员设置 ping 检查或创建 Syslog 规则。他们需要从选择基本操作系统或软件包管理器的过程中提取自助服务资源，并依靠服务发现和强大的网络通信来提供丰富的功能体验。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.heptio.com/i-still-remember-the-first-time-i-logged-into-a-production-server-over-ssh-and-telling-myself-i-53ab1d1e7f46&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“Cloud Native Infrastructure”, a Free O’Reilly eBook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>云原生社区（中国）</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/community/cnc/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/community/cnc/</guid>
      <description>&lt;p&gt;云原生社区是由 &lt;a href=&#34;https://jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;宋净超（Jimmy Song）&lt;/a&gt; 于 2020 年 5 月发起的，企业中立的云原生终端用户社区。社区秉持 “共识、共治、共建、共享” 的原则。社区的宗旨是：连接、中立、开源。立足中国，面向世界，企业中立，关注开源，回馈开源。了解更多请访问云原生社区官网：&lt;a href=&#34;https://cloudnative.to&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cloudnative.to&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;成立背景&#34;&gt;成立背景&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Software is eating the world. —— Marc Andreessen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“软件正在吞噬这个世界” 已被大家多次引用，随着云原生（Cloud Native）的崛起，我们想说的是 “Cloud Native is eating the software”。随着越来越多的企业将服务迁移上云，企业原有的开发模式以及技术架构已无法适应云的应用场景，其正在被重塑，向着云原生的方向演进。&lt;/p&gt;
&lt;p&gt;那么什么是云原生？云原生是一系列架构、研发流程、团队文化的最佳实践组合，以此支撑更快的创新速度、极致的用户体验、稳定可靠的用户服务、高效的研发效率。开源社区与云原生的关系密不可分，正是开源社区尤其是终端用户社区的存在，极大地促进了以容器、服务网格、微服务等为代表的云原生技术的持续演进！&lt;/p&gt;
&lt;p&gt;随着云计算的不断发展，云原生技术在全球范围内变得越来越受关注，同时国内社区同学也展现了对云原生技术热爱。近些年中国已经孕育众多的云原生技术爱好者，也有自发组织的一些相关技术交流和 meetup，同时在云原生领域也涌现了众多优秀的开源项目，在这样的背景下，一个有理想，有组织，有温度的云原生社区应运而生。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/cnc-announcement/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区成立 - cloudnative.to&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>什么是 Istio?</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/what-is-istio/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/what-is-istio/</guid>
      <description>&lt;p&gt;Istio 是一个服务网格的开源实现。Istio 支持以下功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流量管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用配置，我们可以控制服务间的流量。设置断路器、超时或重试都可以通过简单的配置改变来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可观测性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Istio 通过跟踪、监控和记录让我们更好地了解你的服务，它让我们能够快速发现和修复问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Istio 可以在代理层面上管理认证、授权和通信的加密。我们可以通过快速的配置变更在各个服务中执行政策。&lt;/p&gt;
&lt;h2 id=&#34;istio-组件&#34;&gt;Istio 组件&lt;/h2&gt;
&lt;p&gt;Istio 服务网格有两个部分：数据平面和控制平面。&lt;/p&gt;
&lt;p&gt;在构建分布式系统时，将组件分离成控制平面和数据平面是一种常见的模式。数据平面的组件在请求路径上，而控制平面的组件则帮助数据平面完成其工作。&lt;/p&gt;
&lt;p&gt;Istio 中的数据平面由 Envoy 代理组成，控制服务之间的通信。网格的控制平面部分负责管理和配置代理。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-istio-架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/istio-arch.jpg&#34; alt=&#34;Istio 架构&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Istio 架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;envoy数据平面&#34;&gt;Envoy（数据平面）&lt;/h3&gt;
&lt;p&gt;Envoy 是一个用 C++ 开发的高性能代理。Istio 服务网格将 Envoy 代理作为一个 sidecar 容器注入到你的应用容器旁边。然后该代理拦截该服务的所有入站和出站流量。注入的代理一起构成了服务网格的数据平面。&lt;/p&gt;
&lt;p&gt;Envoy 代理也是唯一与流量进行交互的组件。除了前面提到的功能 —— 负载均衡、断路器、故障注入等。Envoy 还支持基于 WebAssembly（WASM）的可插拔扩展模型。这种可扩展性使我们能够执行自定义策略，并为网格中的流量生成遥测数据。&lt;/p&gt;
&lt;h3 id=&#34;istiod控制平面&#34;&gt;Istiod（控制平面）&lt;/h3&gt;
&lt;p&gt;Istiod 是控制平面组件，提供服务发现、配置和证书管理功能。Istiod 采用 YAML 编写的高级规则，并将其转换为 Envoy 的可操作配置。然后，它把这个配置传播给网格中的所有 sidecar。&lt;/p&gt;
&lt;p&gt;Istiod 内部的 Pilot 组件抽象出特定平台的服务发现机制（Kubernetes、Consul 或 VM），并将其转换为 sidecar 可以使用的标准格式。&lt;/p&gt;
&lt;p&gt;使用内置的身份和凭证管理，我们可以实现强大的服务间和终端用户认证。通过授权功能，我们可以控制谁可以访问你的服务。&lt;/p&gt;
&lt;p&gt;控制平面的部分以前被称为 Citadel，作为一个证书授权机构，生成证书，允许数据平面中的代理之间进行安全的 mTLS 通信。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 1 章：什么是云原生基础架构？</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/what-is-cloud-native-infrastructure/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/what-is-cloud-native-infrastructure/</guid>
      <description>&lt;p&gt;基础架构是指支持应用程序的所有软件和硬件，包括数据中心、操作系统、部署流水线、配置管理以及支持应用程序生命周期所需的任何系统或软件。&lt;/p&gt;
&lt;p&gt;已经有无数的时间和金钱花在了基础架构上。通过多年来不断的技术演化和实践提炼，有些公司已经能够运行大规模的基础架构和应用程序，并且拥有卓越的敏捷性。高效运行的基础架构可以使得迭代更快，缩短投向市场的时间，从而加速业务发展。&lt;/p&gt;
&lt;p&gt;使用云原生基础架构是有效运行云原生应用程序的要求。如果没有正确的设计和实践来管理基础架构，即使是最好的云原生应用程序也会浪费。本书中的实践并不一定需要有巨大的基础架构规模，但如果您想从云计算中获取回报，您应该听从开创了这些模式的人的经验。&lt;/p&gt;
&lt;p&gt;在我们探索如何构建云中运行的应用程序的基础架构之前，我们需要了解我们是如何走到这一步。首先，我们将讨论采用云原生实践的好处。接下来，我们将看一下基础架构的简历，然后讨论下一阶段的功能，称为 “云原生”，以及它与您的应用程序、运行的平台及业务之间的关系。&lt;/p&gt;
&lt;p&gt;在明白了这一点后，我们将向您展示解决方案及实现。&lt;/p&gt;
&lt;h2 id=&#34;云原生的优势&#34;&gt;云原生的优势&lt;/h2&gt;
&lt;p&gt;采用本书中的模式有很多好处。它们仿照谷歌、Netflix 和亚马逊这些成功的公司 —— 不是单靠模式保证它们的成功，而是它们提供了这些公司成功所需的可扩展性和敏捷性。&lt;/p&gt;
&lt;p&gt;通过选择在公有云中运行基础架构，您可以更快地创造价值并专注于业务目标。只需构建您的产品所需的内容，并从其他提供商那里获得服务，就可以缩短交付时间，提高灵活性。有些人可能因为 “供应商锁定” 而犹豫不决，但最糟糕的锁定是您自己建立的锁定。有关不同类型的锁定，以及您应该如何处理的更多信息，请参阅附录 B。&lt;/p&gt;
&lt;p&gt;消费服务还可让您使用所需服务构建定制平台（有时称为服务即平台 [SaaP]）。当您使用云托管的服务时无需精专于管理应用程序所需要的每项服务。这极大地加强了业务变更和业务增值的能力。&lt;/p&gt;
&lt;p&gt;当您无法使用服务时，您应该构建应用程序来管理基础架构。当您这样做时，规模瓶颈不再取决于每个运维工程师可以管理多少台服务器。相反，您可以像扩展应用程序一样来扩展您的基础架构。换句话说，如果您能够运行可扩展的应用程序，则可以使用应用程序扩展您的基础架构。&lt;/p&gt;
&lt;p&gt;同样的好处适用于构建灵活且易于调试的基础架构。您可以使用与管理业务应用程序相同的工具来洞察您的基础架构。&lt;/p&gt;
&lt;p&gt;云原生实践还可以缩小传统工程角色之间的差距（DevOps 的共同目标）。系统工程师将能够从应用程序中学习最佳实践，开发工程师可以拥有应用程序运行所在的基础架构的所有权。&lt;/p&gt;
&lt;p&gt;云原生基础架构的解决方案不一定适用于所有问题，您有责任了解它是否适合您的环境（参见第 2 章）。然而，在创造了这些实践的公司以及采用以该模式创建的工具的公司中，云原生基础架构的成功可以说显而易见。请参见附录 C 的一个例子。&lt;/p&gt;
&lt;p&gt;在深入了解解决方案之前，先让我是探究一下是什么问题导致这些模式的出现。&lt;/p&gt;
&lt;h2 id=&#34;服务器&#34;&gt;服务器&lt;/h2&gt;
&lt;p&gt;在互联网早期，Web 基础架构始于物理服务器。服务器庞大，吵闹且昂贵，需要大量的电力和人员投入以保持它们的运行。需要细心照料，尽可能保持长时间运行。 与云基础架构相比，购买这些设备让应用程序运行在上面会更困难。&lt;/p&gt;
&lt;p&gt;一旦您买了服务器，它就是您的了，无论好坏，都要维护。使用物理服务器适合已确定成本的业务。持有物理服务器并运行的时间越长，您花费的钱越多。做适当的产能规划并确保您获得最佳的投资回报是很重要的。&lt;/p&gt;
&lt;p&gt;物理服务器非常棒，因为它们功能强大，可以根据需要进行配置。故障率相对较低，使用冗余电源供应，风扇和 RAID 控制器来避免出现故障。也可以持续运行很长时间。企业可以通过延长保修和更换零部件，从购买的硬件中挤出额外的价值。&lt;/p&gt;
&lt;p&gt;但是，物理服务器会导致浪费。服务器不仅没有被充分利用，而且还带来了很多开销。在同一台服务器上运行多个应用程序是很困难的。当在同一台服务器上最大限度得部署多个应用程序时，软件冲突，网络路由和用户访问都变得更加复杂。&lt;/p&gt;
&lt;p&gt;硬件虚拟化承诺可以解决其中的一些问题。&lt;/p&gt;
&lt;h2 id=&#34;虚拟化&#34;&gt;虚拟化&lt;/h2&gt;
&lt;p&gt;虚拟化使用软件来模拟物理服务器的硬件。虚拟服务器可以按需创建，完全可以通过软件编程，只要您可以模拟硬件，就永远不会出现损耗。&lt;/p&gt;
&lt;p&gt;使用 hypervisor 可以增加这些优势，因为您可以在物理服务器上运行多个虚拟机（VM）。它还使得应用程序可移植，因为您可以将虚拟机从一台物理服务器移动到另一台物理服务器。&lt;/p&gt;
&lt;p&gt;然而，运行自己的虚拟化平台的一个问题是虚拟机仍然需要硬件来运行。公司仍然需要拥有运行物理服务器所需的所有人员和流程，但是现在容量规划变得更加困难，因为他们还必须考虑到虚拟机的开销。至少，公有云出现之前就是如此。&lt;/p&gt;
&lt;h2 id=&#34;基础架构即服务&#34;&gt;基础架构即服务&lt;/h2&gt;
&lt;p&gt;基础架构即服务（IaaS）是云提供商的众多产品之一。它提供了原始的网络、存储和计算能力，客户可以根据需要使用它们。它还包括一些支持服务，如身份和访问管理（IAM）、供应和库存系统。&lt;/p&gt;
&lt;p&gt;IaaS 允许公司摆脱他们的所有硬件，并从别人那里租用虚拟机或物理服务器。这释放了大量人力资源，摆脱了购买、维护以及在某些情况下容量规划所需的流程。&lt;/p&gt;
&lt;p&gt;IaaS 从根本上改变了基础架构与业务的关系。不是随着时间的推移受益的资本支出，而是运营业务的运营支出。企业可以像支付电力和人们的时间一样支付基础架构。通过基于消费的计费，您越早摆脱基础架构，运营成本就越低。&lt;/p&gt;
&lt;p&gt;托管的基础架构还为客户提供了可消费的 HTTP 应用编程接口（API），以便按需创建和管理基础架构。工程师不需要购买订单并等待物品出货，就可以进行 API 调用，并创建服务器。服务器可以轻松删除和丢弃。&lt;/p&gt;
&lt;p&gt;在云中运行基础架构不会使您的基础架构成为云原生。IaaS 仍然需要基础架构管理。在购买和管理物理资源之外，您可以（也有许多公司）认为 IaaS 与过去购买服务器在自己的数据中心架设的传统基础架构一模一样。&lt;/p&gt;
&lt;p&gt;即使没有 “货架和堆叠”，仍然有大量的操作系统、监控软件和支持工具。自动化工具帮助减少了运行应用程序所需的时间，但通常根深蒂固的流程会削弱 IaaS 的优势。&lt;/p&gt;
&lt;h2 id=&#34;平台即服务&#34;&gt;平台即服务&lt;/h2&gt;
&lt;p&gt;就像 IaaS 对 VM 消费者隐藏了物理服务器一样，平台即服务（PaaS）也对应用程序隐藏了操作系统。开发人员编写应用程序代码并定义应用程序的依赖关系，平台负责创建运行，管理和暴露它所必要的基础架构。与需要基础架构管理的 IaaS 不同，PaaS 中的基础架构由平台提供商管理。&lt;/p&gt;
&lt;p&gt;事实证明，PaaS 限制要求开发人员以不同的方式编写应用程序，以便平台可以有效管理。应用程序必须包含允许由平台管理而不访问底层操作系统的功能。工程师不能再依赖 SSH 登入到服务器来读取磁盘上的日志文件。现在应用程序的生命周期和管理由 PaaS 控制，工程师和应用程序需要适应这个流程。&lt;/p&gt;
&lt;p&gt;这些限制带来了很大的好处。应用程序开发周期变短了，因为工程师不需要花时间管理基础架构。在平台上运行的应用程序是我们现在称为 “云原生应用程序” 的开始。利用代码中的平台限制，已经一定程度上改变了当今编写应用程序的方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;12 因素应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Heroku 是提供公有 PaaS 的早期先驱之一。通过自己平台的多年扩展，该公司能够确定帮助应用程序在其环境中更好运行的模式。Heroku 定义了应用程序时应实现的 12 个主要因素。&lt;/p&gt;
&lt;p&gt;这 12 个因素是通过将代码逻辑与数据分离来使开发人员更高效，尽可能自动化，独立的构建、传输和运行阶段过程；并声明所有的应用程序的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您使用 PaaS 提供商所提供的基础架构，恭喜您已拥有云原生基础架构的诸多优势。这包括 Google App Engine、AWS Lambda 和 Azure Cloud Services 等平台。任何成功的云原生基础架构都将向应用工程师展示自助服务平台，以部署和管理代码。&lt;/p&gt;
&lt;p&gt;但是，许多 PaaS 平台不足以满足业务需求。它们通常会限制平台运行的语言、库和功能以实现从应用程序中抽离基础架构的承诺。公有 PaaS 提供商还将限制哪些服务可以与应用程序集成以及这些应用程序可以在哪里运行。&lt;/p&gt;
&lt;p&gt;公有平台牺牲了应用程序的灵活性，使基础架构成为别人的问题。图 1-1 是如果您运行自己的数据中心，在 IaaS 中创建基础架构，在 PaaS 上运行应用程序或通过软件即服务（SaaS）运行应用程序时需要管理的组件的直观表示。&lt;/p&gt;
&lt;p&gt;您需要运行的基础架构组件越少越好；但是在公有 PaaS 提供商中运行所有应用程序可能不是一种选择。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-f-1-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-1-1.jpg&#34; alt=&#34;f-1-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      f-1-1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;云原生基础架构&#34;&gt;云原生基础架构&lt;/h2&gt;
&lt;p&gt;“云原生” 是一个过度使用的术语。尽管它已被市场所劫持，但仍具有工程和管理上的意义。对我们来说，它意味着在这个公有云提供商的世界中正发生的技术变革。&lt;/p&gt;
&lt;p&gt;云原生基础架构是隐藏在有用的抽象背后的基础架构，由 API 控制，由软件管理并具有运行应用程序的目的。利用这些特征运行基础架构，能以可扩展高效的方式管理该基础架构。&lt;/p&gt;
&lt;p&gt;当它们成功地向消费者隐藏复杂性时，抽象是有用的。它们可以实现技术的更复杂的使用，但是它们也限制了技术的使用方式。它们适用于底层技术，例如 TCP 如何提取 IP 或更高级别的技术，如虚拟机如何抽象物理服务器。抽象应该总是允许消费者 “向上移动堆栈” 而不是重新实现底层。&lt;/p&gt;
&lt;p&gt;云原生基础架构需要抽象基础 IaaS 产品以提供自己的抽象。新层负责控制它下面的 IaaS，并将自己的 API 暴露给消费者控制。&lt;/p&gt;
&lt;p&gt;由软件管理的基础架构是云中的一个关键区别点。软件控制的基础架构使基础架构能够扩展，并且在弹性、供应和可维护性方面也发挥着重要作用。软件需要了解基础架构的抽象概念，并知道如何获取抽象资源并相应地在可消费的 IaaS 组件中实现它。&lt;/p&gt;
&lt;p&gt;这些模式不仅影响基础架构的运行方式，而且在云原生基础架构上运行的应用程序类型、在其上工作的人员类型与传统基础架构中是不同的。&lt;/p&gt;
&lt;p&gt;如果云原生基础架构看起来很像 PaaS 产品，那么我们如何才能知道构建自己的产品时需要注意什么？我将快速描述一些领域，它们可能看起来像是云原生解决方案，但不提供云原生基础架构的所有方面。&lt;/p&gt;
&lt;h2 id=&#34;什么不是云原生基础架构&#34;&gt;什么不是云原生基础架构？&lt;/h2&gt;
&lt;p&gt;云原生基础架构不等于在公有云上运行基础架构。仅租用服务器并不会使您的基础架构云原生化。管理 IaaS 的流程与运行物理数据中心通常没有什么不同，许多将现有基础架构迁移到云的公司都未能获得回报。&lt;/p&gt;
&lt;p&gt;云原生不等于在容器中运行应用程序。Netflix 最先推出云原生基础架构时，几乎所有应用程序都部署在虚拟机中，而不是在容器中。使用容器的方式打包应用程序并不能意味着拥有了自治系统的可扩展性和优势。即使应用程序是通过持续集成和持续交付渠道自动构建和部署的，也不等于就可以从 API 驱动部署的基础架构中受益。&lt;/p&gt;
&lt;p&gt;也不是说只要您运行了容器编排器（例如 Kubernetes 和 Mesos）就是云原生架构。容器编排器提供了云原生基础架构所需的平台功能，但如果未按预期方式使用这些功能的话，那也只是将应用程序会动态调度到一组服务器上而已。这是一个非常好的起步，但仍有很多工作要做。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;调度器与编排器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“调度器” 和 “编排器” 这两个术语通常可以互换使用。&lt;/p&gt;
&lt;p&gt;在大多数情况下，编排器负责集群中的所有资源使用（例如：存储，网络和 CPU）。该术语通常用于描述执行许多任务的产品，如健康检查和云自动化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调度器是编排平台的一个子集，仅负责为进程和服务选择所运行的服务器。&lt;/p&gt;
&lt;p&gt;云原生不等于微服务或基础架构即代码。微服务意味着更快的开发周期和更小的独立功能，但是单体应用程序可以具有相同的功能，使其能够通过软件有效管理，并且还可以从云原生基础架构中受益。&lt;/p&gt;
&lt;p&gt;基础架构即代码以机器可解析的语言或领域特定语言（DSL）定义、使基础架构自动化。使用代码管理基础架构的传统工具包括配置管理工具，例如 Chef 和 Puppet。这些工具在自动执行任务和提供一致性方面很有用，但是对于为超出单个服务器的基础架构提供必要的抽象描述方面存在缺陷。&lt;/p&gt;
&lt;p&gt;配置管理工具一次只自动化一台服务器，并靠人将服务器提供的功能绑定在一起。人成了管理大规模基础架构的潜在瓶颈。这些工具也不会使构建完整系统所需的云基础架构（例如存储和网络）的额外部分自动化。&lt;/p&gt;
&lt;p&gt;尽管配置管理工具为操作系统的资源（例如软件包管理器）提供了一些抽象，但它们对底层操作系统的抽象还不足以轻松管理软件包。如果有工程师想要管理系统中的所有软件包和文件，这将是一个非常痛苦的过程，因为软件包对于每个配置变体来说都是独一无二的。同样，定义不存在或不正确的资源配置管理只会白白的消耗系统资源而不能给我们提供任何价值。&lt;/p&gt;
&lt;p&gt;虽然配置管理工具可以帮助自动化部分基础架构，但它们无法更好地管理应用程序。我们将在后面的章节中通过查看部署、管理、测试和操作基础架构的流程，探讨云原生基础架构与配置管理工具的不同之处，但在此之前我们将了解何为成功的应用以及使用云原生基础架构的时机。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用程序&#34;&gt;云原生应用程序&lt;/h2&gt;
&lt;p&gt;就像云改变了业务和基础架构之间的关系一样，云原生应用程序也改变了应用程序和基础架构之间的关系。我们需要了解与传统应用程序相比，云本身有什么不同，因此我们需要了解它们与基础架构的新关系。&lt;/p&gt;
&lt;p&gt;为了写好本书，也为了有一个共享词汇表，我们需要定义 “云原生应用程序” 是什么意思。云原生与 12 因素应用程序不同，即使它们可能共享一些类似的特征。如果您想了解更多细节，请阅读 Kevin Hoffman 撰写的 &lt;em&gt;Beyond the Twelve-Factor App&lt;/em&gt;（O&amp;rsquo;Reilly，2012）。&lt;/p&gt;
&lt;p&gt;云原生应用程序被设计为在平台上运行，具有弹性、敏捷性、可操作性和可观测性。弹性能够容忍故障而不是试图阻止故障，利用了在平台上运行的动态特性。敏捷性允许快速部署和快速迭代。可操作性从应用程序内部控制应用程序生命周期，而不是依赖外部进程和监视器。可观测性提供信息来回答有关应用程序状态的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;云原生定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;云原生应用程序的定义仍在发展中。还有像 CNCF 这样的组织可以提供其他的定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生应用程序的这些特征是通过各种方式获取的。它通常取决于应用程序的运行位置以及企业流程和文化。以下是实现云原生应用程序所需特性的常用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务&lt;/li&gt;
&lt;li&gt;健康报告&lt;/li&gt;
&lt;li&gt;遥测数据&lt;/li&gt;
&lt;li&gt;弹性&lt;/li&gt;
&lt;li&gt;声明式的，而不是反应式的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;微服务&#34;&gt;微服务&lt;/h3&gt;
&lt;p&gt;作为单个实体进行管理和部署的应用程序通常称为单体应用。最开始开发应用程序时，单体有很多好处。它们更易于理解，并允许您在不影响其他服务的情况下更改主要功能。&lt;/p&gt;
&lt;p&gt;随着应用程序复杂性的增长，单体应用的优势也在逐渐减小。它们变得更难理解，而且失去了敏捷性，因为工程师很难推断和修改代码。&lt;/p&gt;
&lt;p&gt;对付复杂性的最好方法之一是将明确定义的功能分成更小的服务，并让每个服务独立迭代。这增加了应用程序的灵活性，允许根据需要更轻松地更改部分应用程序。每个微服务可以由单独的团队进行管理，使用适当的语言编写，并根据需要进行独立扩缩容。&lt;/p&gt;
&lt;p&gt;只要每项服务都遵守强有力的合约，应用程序就可以快速改进和改变。当然，转向微服务架构还有许多其他的考虑因素。最后才考虑的是弹性通信，我们在附录 A 中有讨论。&lt;/p&gt;
&lt;p&gt;我们无法考虑到迁移到微服务的所有考虑因素。使用微服务并不意味着就是云原生基础架构。如果您想拓展阅读，我们推荐 Sam Newman 的 Building Microservices（O&amp;rsquo;Reilly，2015）。虽然微服务是实现应用程序灵活性的一种方式，但正如我们之前所说的，它们不是云原生应用程序的必需条件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;健康报告&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;停止逆向工程并开始从应用内部进行监控。&lt;/p&gt;
&lt;p&gt;——Kelsey Hightower，Monitorama PDX 2016：healthz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有人能比开发者更了解应用程序需要哪些条件才能健康运行了。曾经基础架构管理员都试图为自己负责运行的应用程序定义 “健康” 状态。在不了解是什么因素真正使应用程序的健康的情况下，监控和告警应用程序的不健康时状态往往是脆弱和不完整的。&lt;/p&gt;
&lt;p&gt;为了提高云原生应用程序的可操作性，应用程序应该暴露健康检查。开发人员可以以命令或过程信号的方式实现，以便应用程序在执行自我检查之后响应，或者更常见的是：通过应用程序提供 Web 服务，返回 HTTP 状态码来检查健康状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Google Borg 示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Google 的 Borg 报告中列出了一个健康报告的例子：&lt;/p&gt;
&lt;p&gt;几乎每个在 Borg 下运行的任务都包含一个内置的 HTTP 服务器，该服务器发布有关任务运行状况和数千个性能指标（如 RPC 延迟）的信息。Borg 会监控运行状况检查 URL 并重新启动不及时响应或返回 HTTP 错误代码的任务。其他数据由监控工具跟踪，用于仪表板和服务级别目标（SLO）的告警。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将监控应用健康的责任转移到应用程序内部，这使得应用程序更容易管理和自动化。应用程序应该知道自己是否在正常运行以及自己的依赖（例如，访问数据库）。开发人员需要与产品经理合作来定义应用服务的业务功能并相应地编写测试。&lt;/p&gt;
&lt;p&gt;提供健康检查的应用程序示例例如 Zookeeper 的 ruok 命令和 etcd 的 HTTP 健康端点。&lt;/p&gt;
&lt;p&gt;应用程序不仅仅有健康或不健康的状态。它们将经历一个启动和关闭过程，在这个过程中它们应该通过健康检查，报告它们的状态。如果应用程序可以让平台准确了解它所处的状态，平台将更容易知道如何操作。&lt;/p&gt;
&lt;p&gt;平台需要知道应用程序何时可以接收流量，这就是一个很好的例子。在应用程序启动时，如果它不能正确处理流量，它就应该表现为未准备好。此额外状态将防止应用程序过早终止，因为如果运行状况检查故障，平台可能会认为应用程序不健康，并且会反复重启它。&lt;/p&gt;
&lt;p&gt;应用程序健康只是自动化应用程序生命周期的一部分。除了知道应用程序是否健康之外，您还需要知道应用程序正在进行哪些工作。这些信息来自遥测数据。&lt;/p&gt;
&lt;h3 id=&#34;遥测数据&#34;&gt;遥测数据&lt;/h3&gt;
&lt;p&gt;我们使用遥测数据（telemetry）来进行决策。遥测数据可能与健康报告重叠，但它们用途不同。健康报告汇报应用程序的生命周期状态，而遥测数据汇报应用程序的业务目标。&lt;/p&gt;
&lt;p&gt;我们测量的指标有服务等级指标（SLI）或关键性能指标（KPI）。这些是特定于应用程序的数据，可以确保应用程序的性能处于服务级别目标（SLO）内。如果您需要更多关于这些术语的信息以及与应用程序、业务需求的关系，我们推荐您阅读来自 Site Reliability Engineering（O&amp;rsquo;Reilly）的第 4 章。&lt;/p&gt;
&lt;p&gt;遥测和度量标准用于解决以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序每分钟收到多少请求？&lt;/li&gt;
&lt;li&gt;有没有错误？&lt;/li&gt;
&lt;li&gt;应用程序延迟怎么样？&lt;/li&gt;
&lt;li&gt;下单需要多长时间？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常会将数据抽取或推送到时间序列数据库（例如 Prometheus 或 InfluxDB）进行聚合。遥测数据需要被收集数据的系统格式化。&lt;/p&gt;
&lt;p&gt;至少需要实施度量标准的 RED（Rate、Error、Duration）方法，该方法收集应用程序的到达率、错误和执行时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到达率（Rate）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收到了多少个请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误（Error）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序有多少错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续时间（Duration）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多久才能收到回复&lt;/p&gt;
&lt;p&gt;遥测数据应该用于告警而不是健康监测。在能够动态自我修复的环境中，我们不关注应用程序单个实例的生命周期，更关注的是应用程序的整体 SLO。健康报告对于自动应用程序管理仍然很重要，但不应该用于站点工程师。&lt;/p&gt;
&lt;p&gt;不管应用程序是 1 个实例还是 50 个实例不健康，只要满足应用程序的业务需求，我们就可能不会收到警报。Metric 会告诉您是否满足 SLO，应用程序的使用方式以应用程序是否是 “正常”。告警有助于您将系统恢复到已知的良好状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它移动，我们就追踪。如果没有移动我们就也会画一些图形，以防它突然开始运动。&lt;/p&gt;
&lt;p&gt;——Ian Malpass，Measure Anything, Measure Everything&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;警报（Alert）不应该与日志记录混淆。记录（Logging）用于调试、开发和观察。记录暴露了应用程序的内部功能。Metric 有时可以根据日志（例如错误率）计算，但需要额外的聚合服务（例如 ElasticSearch）和处理。&lt;/p&gt;
&lt;h3 id=&#34;弹性&#34;&gt;弹性&lt;/h3&gt;
&lt;p&gt;有了遥测和监控数据后，还要确保应用程序有故障自适应能力。弹性是基础架构的责任，但云原生应用程序也需要承担部分工作。&lt;/p&gt;
&lt;p&gt;基础架构设计之初就是要抵御故障（failure）。硬件通常需要有多个硬盘驱动器、电源以及全天候监控和可更换的部件以保持应用程序可用。云原生应用程序应当正视故障而不是避免故障。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在任何平台上，尤其是云上，可靠性都是其最重要的特性。&lt;/p&gt;
&lt;p&gt;——David Rensin，e ARCHITECT Show：来自 Google 的关于云计算的速成课程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;光是讲如何设计弹性的应用程序可能就可以写一本书了。我们将在云原生应用程序中考虑弹性的两个主要方面：面向故障设计和优雅降级。&lt;/p&gt;
&lt;h3 id=&#34;面向故障设计&#34;&gt;面向故障设计&lt;/h3&gt;
&lt;p&gt;唯一永远不会故障的系统是那些与您的生命安全息息相关的系统（例如心脏植入物和刹车系统）。如果想要让服务永远运行，您需要花费太多时间设计服务来抵御故障，那样就没有足够的时间增加业务价值。SLO 确定服务需要运行多长时间。您花费在工程设计上超出 SLO 的正常运行时间的任何资源都将被浪费掉。&lt;/p&gt;
&lt;p&gt;每项服务您可以测量两个值，平均无故障时间（MTBF，Mean Time Between Failure）和平均恢复时间（MTTR，Mean Time To Recovery）。通过监控和 metric 可以知道是否达到 SLO，但运行应用程序的平台是保持高 MTBF 和低 MTTR 的关键。&lt;/p&gt;
&lt;p&gt;在任何复杂的系统中，都会有故障。您可以管理硬件中的某些故障（例如，RAID 和冗余电源），以及某些基础架构中的故障（例如负载平衡器）。但是因为应用程序知道他们什么时候健康，所以他们也应该尽可能地管理自己的故障。&lt;/p&gt;
&lt;p&gt;设计一个以故障期望为目标的应用程序将比假定可用性的应用程序更具防御性。当故障不可避免时，将会有额外的检查，故障模式和日志内置到应用程序中。&lt;/p&gt;
&lt;p&gt;没人可以预料应用程序所有可能的故障。假设所有东西都可能会故障，这是一种云原生应用程序的模式。&lt;/p&gt;
&lt;p&gt;应用程序的最佳状态是健康状态。第二好的状态是故障状态。其他一切都是非二元的，难以监控和排除故障。Honeycomb 首席执行官 Charity Majors 在她的一篇题为 “Ops: It’s Everyone’s Job Now” 的文章中指出：“分布式系统永远不会起作用；它们处于部分退化服务的持续状态。接受故障，面向设计设计，保护和缩小关键路径。“&lt;/p&gt;
&lt;p&gt;无论发生什么故障，云原生应用程序都应该是可适应的。它们预期故障，所以他们在检测到时进行调整。&lt;/p&gt;
&lt;p&gt;有些故障不能也不应该被设计到应用程序中（例如，网络分区和可用区故障）。该平台应自主处理未集成到应用程序中的故障域。&lt;/p&gt;
&lt;h3 id=&#34;优雅降级&#34;&gt;优雅降级&lt;/h3&gt;
&lt;p&gt;云原生应用程序需要有一种方法来处理过载，无论是应用程序还是负载下的相关服务。处理负载的一种方式是优雅降级。 “站点可靠性工程” 一书中描述了应用程序的优雅降级，因为它提供的响应在负载过重的情况下 “不如正常响应准确或含有较少数据的响应，但计算更容易”。&lt;/p&gt;
&lt;p&gt;减少应用程序负载的某些方面由基础架构处理。智能负载均衡和动态扩展有助于减轻应用程序的负载，但有的时候，应用程序可以承受的负载比它可以处理的负载更多。云原生应用程序应知道这种必然性并作出相应的反应。&lt;/p&gt;
&lt;p&gt;优雅降级的重点是允许应用程序始终返回请求的响应。如果应用程序没有足够的本地计算资源，并且依赖服务没有及时返回信息，则这是正确的。如果一个服务依赖于一个或多个其他服务，即使依赖的服务无应答，该应用程序也应该可以应答。还有种解决方案是，当服务降级时，返回部分应答或使用本地缓存中的旧信息应答。&lt;/p&gt;
&lt;p&gt;尽管优雅的降级和故障处理都应该在应用程序中实现，但是平台的多个层面也应该提供帮助。如果采用微服务，则网络基础架构将是在提供应用弹性方面发挥积极作用的关键组件。有关构建弹性网络层的更多信息，请参阅附录 A。&lt;/p&gt;
&lt;h3 id=&#34;可用性数学&#34;&gt;可用性数学&lt;/h3&gt;
&lt;p&gt;云原生应用程序需要在基础架构之上建立一个平台，以使基础架构更具弹性。如果您希望将现有应用程序 “提升并转移” 到云中，则应检查云提供商的服务级别协议（SLA），并考虑在使用多个服务时会发生什么情况。&lt;/p&gt;
&lt;p&gt;如果在云上运行应用程序，我们来看下可用性会是怎样。&lt;/p&gt;
&lt;p&gt;计算基础架构的典型可用性是每月 99.95％的正常运行时间。这意味着您的实例每天可能会停机 43.2 秒，这仍在您的云服务提供商的 SLA 中。&lt;/p&gt;
&lt;p&gt;另外，实例的本地存储（例如 EBS 卷）也具有 99.95％的正常可用时间。如果幸运的话，他们都会同时出现故障，但最糟糕的情况是他们可能会在不同的时间停机，让您的实例只有 99.9％的可用性。&lt;/p&gt;
&lt;p&gt;您的应用程序可能还需要一个数据库，而不是自己安装数据库，可能的停机时间为 1 分 26 秒（99.9％可用性）的情况下，选择可靠性为 99.95％的更可靠的托管数据库。这使您的应用程序的可靠性达到 99.85％，或者每天可能发生 2 分钟 9 秒的停机时间。&lt;/p&gt;
&lt;p&gt;将可用性乘到一起可以快速了解为什么应以不同方式处理云。如果云提供商不符合其 SLA，会退还您账单中一定比例的费用。&lt;/p&gt;
&lt;p&gt;虽然您不必为停机支付费用，但您的业务必须能够容忍云计算的信用保证。如果云平台的可用性保证无法满足您的应用程序的可用性需求，那么您应该考虑是否该在云上运行这个应用程序。&lt;/p&gt;
&lt;h3 id=&#34;声明式非反应式&#34;&gt;声明式，非反应式&lt;/h3&gt;
&lt;p&gt;由于云原生应用程序设计为在云环境中运行，因此它们与基础架构和支持应用程序的交互方式与传统应用程序不同。在云原生应用程序中，与任何事物进行通信都是通过网络进行的。很多时候，网络通信都是通过 RESTful HTTP 调用完成的，也可以通过其他接口，如远程过程调用（RPC）来实现。&lt;/p&gt;
&lt;p&gt;传统的应用程序会通过消息队列，写在共享存储上的文件或触发 shell 命令的本地脚本来自动执行任务。通信方法对发生的事件作出反应（例如，如果用户单击提交，运行提交脚本）并且通常需要存在于同一物理或虚拟服务器上的信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Serverless&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Serverless 平台是云原生化的，面向事件响应而设计。通过 HTTP API 进行通信使得它们在云中工作得很好，是单用途函数，在它们的函数调用中声明。该平台还可以通过在云中进行扩展和访问来提供帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传统应用程序中的反应性通信常常是通过增强弹性。如果应用程序在磁盘或消息队列中写入文件，然后应用程序崩溃，则消息或文件的结果仍可能完成。&lt;/p&gt;
&lt;p&gt;这并不是说不应该使用像消息队列这样的技术，而是说不应该将它们作为动态和不断发生故障的系统中的唯一弹性层。从根本上讲，应用程序之间的通信应该在云原生环境中改变 —— 不仅因为还有其他方法来构建通信弹性（请参阅附录 A），还因为在云中复制传统通信方法往往需要更多工作。&lt;/p&gt;
&lt;p&gt;当应用程序可以信任通信的弹性时，应该停止使用反应式并开始使用声明式。声明式通信相信网络将传递消息，也相信应用程序将返回成功或错误。这并不是说应用程序监视变化并不重要。Kubernetes 的控制器正是这样做到 API Server。但是，一旦发现变更，它们就会声明一个新的状态，并相信 API Server 和 kubelet 会做必要的事情。&lt;/p&gt;
&lt;p&gt;声明式通信模型由于多种原因而变得更加健壮。最重要的是，它规范了通信模型，并且它将功能实现从应用程序转移到远程 API 或服务端点，从而让实现某种状态到达期望状态。这有助于简化应用程序，并使它们彼此的行为更具可预测性。&lt;/p&gt;
&lt;h3 id=&#34;云原生应用程序如何影响基础架构&#34;&gt;云原生应用程序如何影响基础架构？&lt;/h3&gt;
&lt;p&gt;希望您已经了解云原生应用程序与传统应用程序不同。云原生应用程序不能直接在 PaaS 上运行或与服务器的操作系统紧密耦合。它们期望在一个拥有大多数自治系统的动态环境中运行。&lt;/p&gt;
&lt;p&gt;云原生基础架构在提供自主应用管理的 IaaS 之上创建了一个平台。该平台建立在动态创建的基础架构之上，以抽象出单个服务器并促进动态资源分配调度。&lt;/p&gt;
&lt;p&gt;自动化与自治不一样。自动化允许人类对控制系统采取更多行动。&lt;/p&gt;
&lt;p&gt;云原生是关于不需要人类做出决定的自治系统。它仍然使用自动化，但只有在决定了所需的操作之后。只有在系统不能自动确定正确的事情时才应该通知人。&lt;/p&gt;
&lt;p&gt;具有这些特征的应用程序需要一个能够实际监控，收集度量标准并在发生故障时做出反应的平台。云原生应用程序不依赖于人为设置 ping 检查或创建 Syslog 规则。它们需要从选择基本操作系统或软件包管理器的过程中提取自助服务资源，并依靠服务发现和强大的网络通信来提供丰富的功能体验。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;运行云原生应用程序所需的基础架构与传统应用程序不同。基础架构的许多责任已经转移到应用程序中。&lt;/p&gt;
&lt;p&gt;云原生应用程序通过分解为更小的服务来简化其代码复杂性。这些服务提供直接构建到应用程序中的监控、指标和弹性。需要新的工具来自动管理服务数量的激增和应用的生命周期。&lt;/p&gt;
&lt;p&gt;现在基础架构负责整体资源管理、动态协调、服务发现等等。需要提供一个平台，使服务不依赖于单个组件，而是依赖于 API 和自治系统。第 2 章将更详细地讨论云原生基础架构功能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>什么是云原生应用？</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/intro/define-cloud-native-app/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/intro/define-cloud-native-app/</guid>
      <description>&lt;p&gt;本文参考的是 &lt;a href=&#34;https://github.com/oam-dev/spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OAM 规范&lt;/a&gt;中对云原生应用的定义，并做出了引申。&lt;/p&gt;
&lt;p&gt;云原生应用是一个相互关联但又不独立的组件（service、task、worker）的集合，这些组件与配置结合在一起并在适当的运行时实例化后，共同完成统一的功能目的。&lt;/p&gt;
&lt;h2 id=&#34;云原生应用模型&#34;&gt;云原生应用模型&lt;/h2&gt;
&lt;p&gt;下图是 OAM 定义的云原生应用模型示意图，为了便于理解，图中相同颜色的部分为同一类别的对象定义。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-云原生应用模型&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/cloud-native-app-model.png&#34; alt=&#34;云原生应用模型&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      云原生应用模型
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OAM 的规范中定义了以下对象，它们既是 OAM 规范中的基本术语也是云原生应用的基本组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Workload（工作负载）&lt;/strong&gt;：应用程序的工作负载类型，由平台提供。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Component组件）&lt;/strong&gt;：定义了一个 &lt;code&gt;Workload&lt;/code&gt; 的实例，并以基础设施中立的术语声明其运维特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Trait（特征）&lt;/strong&gt;：用于将运维特性分配给组件实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationScope（应用作用域）&lt;/strong&gt;：用于将组件分组成具有共同特性的松散耦合的应用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ApplicationConfiguration（应用配置）&lt;/strong&gt;：描述 &lt;code&gt;Component&lt;/code&gt; 的部署、&lt;code&gt;Trait&lt;/code&gt; 和 &lt;code&gt;ApplicationScope&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关注点分离&#34;&gt;关注点分离&lt;/h2&gt;
&lt;p&gt;下图是不同角色对于该模型的关注点示意图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-云原生应用模型中的目标角色&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/roles.png&#34; alt=&#34;云原生应用模型中的目标角色&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      云原生应用模型中的目标角色
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们可以看到对于一个云原生应用来说，不同的对象是由不同的角色来负责的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础设施运维：提供不同的 &lt;code&gt;Workload&lt;/code&gt; 类型供开发者使用；&lt;/li&gt;
&lt;li&gt;应用运维：定义适用于不同 &lt;code&gt;Workload&lt;/code&gt; 的运维属性 &lt;code&gt;Trait&lt;/code&gt; 和管理 &lt;code&gt;Component&lt;/code&gt; 的 &lt;code&gt;ApplicationScope&lt;/code&gt; 即作用域；&lt;/li&gt;
&lt;li&gt;应用开发者：负责应用组件 &lt;code&gt;Component&lt;/code&gt; 的定义；&lt;/li&gt;
&lt;li&gt;应用开发者和运维：共同将 &lt;code&gt;Component&lt;/code&gt; 与运维属性 &lt;code&gt;Trait&lt;/code&gt; 绑定在一起，维护应用程序的生命周期；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于 OAM 中的对象定义的云原生应用可以充分利用平台能力自由组合，开发者和运维人员的职责可以得到有效分离，组件的复用性得到大幅提高。&lt;/p&gt;
&lt;h2 id=&#34;定义标准&#34;&gt;定义标准&lt;/h2&gt;
&lt;p&gt;CNCF 中的有几个定义标准的「开源项目」，其中有的项目都已经毕业。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/servicemeshinterface/smi-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SMI（Service Mesh Interface）&lt;/a&gt;：服务网格接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cloudevents/spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Events&lt;/a&gt;：Serverless 中的事件标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/theupdateframework/specification&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TUF&lt;/a&gt;：更新框架标准&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spiffe/spiffe&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SPIFFE&lt;/a&gt;：身份安全标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这其中唯独没有应用定义标准，&lt;a href=&#34;https://github.com/cncf/sig-app-delivery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CNCF SIG App delivery&lt;/a&gt; 即是要做这个的。当然既然要指定标准，自然要对不同平台和场景的逻辑做出更高级别的抽象（这也意味着你在掌握了底层逻辑的情况下还要学习更多的概念），这样才能屏蔽底层差异。&lt;/p&gt;
&lt;h2 id=&#34;oam-简介&#34;&gt;OAM 简介&lt;/h2&gt;
&lt;p&gt;OAM 全称是 Open Application Model，从名称上来看它所定义的就是一种模型，同时也实现了基于 OAM 的我认为这种模型旨在定义了云原生应用的标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放（Open）：支持异构的平台、容器运行时、调度系统、云供应商、硬件配置等，总之与底层无关&lt;/li&gt;
&lt;li&gt;应用（Application）：云原生应用&lt;/li&gt;
&lt;li&gt;模型（Model）：定义标准，以使其与底层平台无关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然要制定标准，自然要对不同平台和场景的逻辑做出更高级别的抽象（这也意味着你在掌握了底层逻辑的情况下还要学习更多的概念），这样才能屏蔽底层差异。本文将默认底层平台为 Kubernetes。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是从管理大量 &lt;a href=&#34;../../GLOSSARY.html#crd&#34;&gt;CRD&lt;/a&gt; 中汲取的经验。&lt;/li&gt;
&lt;li&gt;业务和研发的沟通成本，比如 YAML 配置中很多字段是开发人员不关心的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计原则&#34;&gt;设计原则&lt;/h2&gt;
&lt;p&gt;OAM 规范的设计遵循了以下&lt;a href=&#34;https://github.com/oam-dev/spec/blob/master/9.design_principles.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;原则&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关注点分离：根据功能和行为来定义模型，以此划分不同角色的职责，&lt;/li&gt;
&lt;li&gt;平台中立：OAM 的实现不绑定到特定平台；&lt;/li&gt;
&lt;li&gt;优雅：尽量减少设计复杂性；&lt;/li&gt;
&lt;li&gt;复用性：可移植性好，同一个应用程序可以在不同的平台上不加改动地执行；&lt;/li&gt;
&lt;li&gt;不作为编程模型：OAM 提供的是应用程序模型，描述了应用程序的组成和组件的拓扑结构，而不关注应用程序的具体实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是 OAM 规范示意图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-oam-规范示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/oam-spec.png&#34; alt=&#34;OAM 规范示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OAM 规范示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;oam-工作原理&#34;&gt;OAM 工作原理&lt;/h2&gt;
&lt;p&gt;OAM 的工作原理如下图所示（图片引用自孙健波在《OAM: 云原生时代的应用模型与 下一代 DevOps 技术》中的分享）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-oam-的原理&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/oam-principle.jpg&#34; alt=&#34;OAM 的原理&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      OAM 的原理
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;OAM Spec 定义了云原生应用的规范（使用一些 &lt;a href=&#34;../../GLOSSARY.html#crd&#34;&gt;CRD&lt;/a&gt; 定义）， &lt;a href=&#34;https://kubevela.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeVela&lt;/a&gt; 可以看做是 OAM 规范的解析器，将应用定义翻译为 Kubernetes 中的资源对象。可以将上图分为三个层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;汇编层&lt;/strong&gt;：即人工或者使用工具来根据 OAM 规范定义汇编出一个云原生应用的定义，其中包含了该应用的工作负载和运维能力配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转义层&lt;/strong&gt;：汇编好的文件将打包为 YAML 文件，由 &lt;a href=&#34;https://kubevela.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KubeVela&lt;/a&gt; 或其他 OAM 的实现将其转义为 Kubernetes 或其他云服务（例如 Istio）上可运行的资源对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行层&lt;/strong&gt;：执行经过转义好的云平台上的资源对象并执行资源配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oam-dev/spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Open Application Model specification - github.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>云原生快速入门</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/intro/quick-start/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/intro/quick-start/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 一词来自希腊语，意思是 “飞行员” 或 “舵手”。这个名字很贴切，Kubernetes 可以帮助你在波涛汹涌的容器海洋中航行。&lt;/p&gt;
&lt;p&gt;Kubernetes 是做什么的？什么是 Docker？什么是容器编排？Kubernetes 是如何工作和扩展的？你可能还有很多其他的问题，本文将一一为你解答。&lt;/p&gt;
&lt;p&gt;这篇文章适合初学者，尤其是那些工作忙碌，没有办法抽出太多时间来了解 Kubernetes 和云原生的开发者们，希望本文可以帮助你进入 Kubernetes 的世界。&lt;/p&gt;
&lt;p&gt;简而言之，Kubernetes 提供了一个平台或工具来帮助你快速协调或扩展容器化应用，特别是在 &lt;a href=&#34;https://docker.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;/a&gt; 容器。让我们深入了解一下这些概念。&lt;/p&gt;
&lt;h2 id=&#34;容器和容器化&#34;&gt;容器和容器化&lt;/h2&gt;
&lt;p&gt;那么什么是容器呢？&lt;/p&gt;
&lt;p&gt;要讨论容器化首先要谈到虚拟机 (VM)，顾名思义，虚拟机就是可以远程连接的虚拟服务器，比如 AWS 的 EC2 或阿里云的 ECS。&lt;/p&gt;
&lt;p&gt;接下来，假如你要在虚拟机上运行一个网络应用 —— 包括一个 MySQL 数据库、一个 Vue 前端和一些 Java 库，在 Ubuntu 操作系统 (OS) 上运行。你不用熟悉其中的每一个技术 —— 你只要记住，一个应用程序由各种组件、服务和库组成，它们运行在操作系统上。&lt;/p&gt;
&lt;p&gt;现在，将应用程序打包成一个虚拟机镜像，这个镜像中包括了 Ubuntu 操作系统。这使得虚拟机变得非常笨重 —— 通常有几个 G 的大小。&lt;/p&gt;
&lt;p&gt;虚拟机镜像包含了整个操作系统及所有的库，对应用程序来说，这个镜像过于臃肿，其中大部分组件并没有被应用程序直接调用。如果你需要重新创建、备份或扩展这个应用程序，就需要复制整个环境（虚拟机镜像），在新环境中启动应用通常需要几十秒甚至几分钟时间。如果你想单独升级应用中的某个组件，比如说 Vue 应用，就需要重建整个虚拟机镜像。另外，如果你的两个应用依赖同一个底层镜像，升级底层镜像会同时影响这两个应用，而有时候，你只需要升级其中一个应用的依赖而已。这就是所谓的 “依赖陷阱”。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法就是容器。容器是继虚拟机之后更高层次的抽象，在这层抽象中，整个应用程序的每个组件被单独打包成一个个独立的单元，这个单元就是所谓的容器。通过这种方式，可以将代码和应用服务从底层架构中分离出来，实现了完全的可移植性（在任何操作系统或环境上运行应用的能力）。所以在上面的例子中，Ubuntu 操作系统就是一个单元（容器）。MySQL 数据库是另一个容器，Vue 环境和随之而来的库也是一个容器。&lt;/p&gt;
&lt;p&gt;但是，MySQL 数据库是如何自己 “运行” 的？数据库本身肯定也要在操作系统上运行吧？没错！&lt;/p&gt;
&lt;p&gt;更高层次的容器，比如 MySQL 容器，实际上会包含必要的库来与底层的操作系统容器通信和集成。所以你可以把容器看成是整个应用堆栈中的一层，每层都依赖于下层的单元。而这就类似于船舶或港口中集装箱的堆叠方式，每个容器的稳定性都依赖于下面的容器的支持。所以应用容器的核心是一个受控的执行环境。它们允许你从头开始定义整个环境，从操作系统开始，到你要使用的各个版本的库，再到你要添加的代码版本。&lt;/p&gt;
&lt;p&gt;与容器相关的一个重要概念是&lt;strong&gt;微服务&lt;/strong&gt;。将应用程序的各个组件拆分并打包成独立的服务，这样每个组件都可以很容易地被替换、升级、调试。上面的例子中，我们会为 Vue 前端创建一个微服务，为 MySQL 数据库创建另一个微服务，为 Java 中间件部分创建另一个微服务，以此类推。很明显，微服务与容器化是相辅相成的。&lt;/p&gt;
&lt;h2 id=&#34;从-docker-开始&#34;&gt;从 Docker 开始&lt;/h2&gt;
&lt;p&gt;现在你已经对容器有一定了解了吧？Docker 是最常用的容器化工具，也是最流行的容器运行时。&lt;/p&gt;
&lt;p&gt;Docker 开源于 2013 年。用于打包和创建容器，管理基于容器的应用。所有 Linux 发行版、Windows 和 macOS 都支持 Docker。&lt;/p&gt;
&lt;p&gt;还有其他的容器化工具，如 &lt;a href=&#34;https://coreos.com/rkt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS rkt&lt;/a&gt;、&lt;a href=&#34;https://mesos.apache.org/documentation/latest/mesos-containerizer/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Mesos Containerizer&lt;/a&gt; 和 &lt;a href=&#34;https://linuxcontainers.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LXC&lt;/a&gt;。但是目前，绝大多数的容器化应用都是在 Docker 上运行的。&lt;/p&gt;
&lt;h2 id=&#34;再到-kubernetes&#34;&gt;再到 Kubernetes&lt;/h2&gt;
&lt;p&gt;首先，简单介绍一下历史。Kubernetes 是 Google 基于其内部容器调度平台 Borg 的经验开发的。2014 年开源，并作为 CNCF（云原生计算基金会）的核心发起项目。&lt;/p&gt;
&lt;p&gt;那么 Kubernetes 又跟容器是什么关系呢？让我们再回到上面的例子。假设我们的应用爆火，每天的注册用户越来越多。&lt;/p&gt;
&lt;p&gt;现在，我们需要增加后端资源，使浏览我们网站的用户在浏览页面时加载时间不会过长或者超时。最简单的方式就是增加容器的数量，然后使用负载均衡器将传入的负载（以用户请求的形式）分配给容器。&lt;/p&gt;
&lt;p&gt;这样做虽然行之有效，但也只能在用户规模有限的情况下使用。当用户请求达到几十万或几百万时，这种方法也是不可扩展的。你需要管理几十个也许是几百个负载均衡器，这本身就是另一个令人头疼的问题。如果我们想对网站或应用进行任何升级，也会遇到问题，因为负载均衡不会考虑到应用升级的问题。我们需要单独配置每个负载均衡器，然后升级该均衡器所服务的容器。想象一下，当你有 20 个负载均衡器和每周 5 或 6 个小的更新时，你将不得不进行大量的手工劳动。&lt;/p&gt;
&lt;p&gt;我们需要的是一种可以一次性将变更传递给所有受控容器的方法，同时也需要一种可以轻松地调度可用容器的方法，这个过程还必须要是自动化的，这正是 Kubernetes 所做的事情。&lt;/p&gt;
&lt;p&gt;接下来，我们将探讨 Kubernetes 究竟是如何工作的，它的各种组件和服务，以及更多关于如何使用 Kubernetes 来编排、管理和监控容器化环境。为了简单起见，假设我们使用的是 Docker 容器，尽管如前所述，Kubernetes 除了支持 Docker 之外，还支持其他几种容器平台。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-架构和组件&#34;&gt;Kubernetes 架构和组件&lt;/h2&gt;
&lt;p&gt;首先，最重要的是你需要认识到 Kubernetes 利用了 “期望状态” 原则。就是说，你定义了组件的期望状态，而 Kubernetes 要将它们始终调整到这个状态。&lt;/p&gt;
&lt;p&gt;例如，你想让你的 Web 服务器始终运行在 4 个容器中，以达到负载均衡的目的，你的数据库复制到 3 个不同的容器中，以达到冗余的目的。这就是你想要的状态。如果这 7 个容器中的任何一个出现故障，Kubernetes 引擎会检测到这一点，并自动创建出一个新的容器，以确保维持所需的状态。&lt;/p&gt;
&lt;p&gt;现在我们来定义一些 Kubernetes 的重要组件。&lt;/p&gt;
&lt;p&gt;当你第一次设置 Kubernetes 时，你会创建一个集群。所有其他组件都是集群的一部分。你也可以创建多个虚拟集群，称为命名空间 (namespace)，它们是同一个物理集群的一部分。这与你可以在同一物理服务器上创建多个虚拟机的方式非常相似。如果你不需要，也没有明确定义的命名空间，那么你的集群将在始终存在的默认命名空间中创建。&lt;/p&gt;
&lt;p&gt;Kubernetes 运行在节点 (node) 上，节点是集群中的单个机器。如果你有自己的硬件，节点可能对应于物理机器，但更可能对应于在云中运行的虚拟机。节点是部署你的应用或服务的地方，是 Kubernetes 工作的地方。有 2 种类型的节点 ——master 节点和 worker 节点，所以说 Kubernetes 是主从结构的。&lt;/p&gt;
&lt;p&gt;主节点是一个控制其他所有节点的特殊节点。一方面，它和集群中的任何其他节点一样，这意味着它只是另一台机器或虚拟机。另一方面，它运行着控制集群其他部分的软件。它向集群中的所有其他节点发送消息，将工作分配给它们，工作节点向主节点上的 API Server 汇报。&lt;/p&gt;
&lt;p&gt;Master 节点本身也包含一个名为 API Server 的组件。这个 API 是节点与控制平面通信的唯一端点。API Server 至关重要，因为这是 worker 节点和 master 节点就 pod、deployment 和所有其他 Kubernetes API 对象的状态进行通信的点。&lt;/p&gt;
&lt;p&gt;Worker 节点是 Kubernetes 中真正干活的节点。当你在应用中部署容器或 pod（稍后定义）时，其实是在将它们部署到 worker 节点上运行。Worker 节点托管和运行一个或多个容器的资源。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的逻辑而非物理的工作单位称为 pod。一个 pod 类似于 Docker 中的容器。记得我们在前面讲到，容器可以让你创建独立、隔离的工作单元，可以独立运行。但是要创建复杂的应用程序，比如 Web 服务器，你经常需要结合多个容器，然后在一个 pod 中一起运行和管理。这就是 pod 的设计目的 —— 一个 pod 允许你把多个容器，并指定它们如何组合在一起来创建应用程序。而这也进一步明确了 Docker 和 Kubernetes 之间的关系 —— 一个 Kubernetes pod 通常包含一个或多个 Docker 容器，所有的容器都作为一个单元来管理。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的 service 是一组逻辑上的 pod。把一个 service 看成是一个 pod 的逻辑分组，它提供了一个单一的 IP 地址和 DNS 名称，你可以通过它访问服务内的所有 pod。有了服务，就可以非常容易地设置和管理负载均衡，当你需要扩展 Kubernetes pod 时，这对你有很大的帮助，我们很快就会看到。&lt;/p&gt;
&lt;p&gt;ReplicationController 或 ReplicaSet 是 Kubernetes 的另一个关键功能。它是负责实际管理 pod 生命周期的组件 —— 当收到指令时或 pod 离线或意外停止时启动 pod，也会在收到指示时杀死 pod，也许是因为用户负载减少。所以换句话说，ReplicationController 有助于实现我们所期望的指定运行的 pod 数量的状态。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubectl&#34;&gt;什么是 Kubectl？&lt;/h2&gt;
&lt;p&gt;kubectl 是一个命令行工具，用于与 Kubernetes 集群和其中的 pod 通信。使用它你可以查看集群的状态，列出集群中的所有 pod，进入 pod 中执行命令等。你还可以使用 YAML 文件定义资源对象，然后使用 kubectl 将其应用到集群中。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-中的自动扩展&#34;&gt;Kubernetes 中的自动扩展&lt;/h2&gt;
&lt;p&gt;请记住，我们使用 Kubernetes 而不是直接使用 Docker 的原因之一，是因为 Kubernetes 能够自动扩展应用实例的数量以满足工作负载的需求。&lt;/p&gt;
&lt;p&gt;自动缩放是通过集群设置来实现的，当服务需求增加时，增加节点数量，当需求减少时，则减少节点数量。但也要记住，节点是 “物理” 结构 —— 我们把 “物理” 放在引号里，因为要记住，很多时候，它们实际上是虚拟机。&lt;/p&gt;
&lt;p&gt;无论如何，节点是物理机器的事实意味着我们的云平台必须允许 Kubernetes 引擎创建新机器。各种云提供商对 Kubernetes 支持基本都满足这一点。&lt;/p&gt;
&lt;p&gt;我们再继续说一些概念，这次是和网络有关的。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kubernetes-ingress-和-egress&#34;&gt;什么是 kubernetes Ingress 和 Egress？&lt;/h2&gt;
&lt;p&gt;外部用户或应用程序与 Kubernetes pod 交互，就像 pod 是一个真正的服务器一样。我们需要设置安全规则允许哪些流量可以进入和离开 “服务器”，就像我们为托管应用程序的服务器定义安全规则一样。&lt;/p&gt;
&lt;p&gt;进入 Kubernetes pod 的流量称为 Ingress，而从 pod 到集群外的出站流量称为 egress。我们创建入口策略和出口策略的目的是限制不需要的流量进入和流出服务。而这些策略也是定义 pod 使用的端口来接受传入和传输传出数据 / 流量的地方。&lt;/p&gt;
&lt;h2 id=&#34;什么是-ingress-controller&#34;&gt;什么是 Ingress Controller？&lt;/h2&gt;
&lt;p&gt;但是在定义入口和出口策略之前，你必须首先启动被称为 Ingress Controller（入口控制器）的组件；这个在集群中默认不启动。有不同类型的入口控制器，Kubernetes 项目默认只支持 Google Cloud 和开箱即用的 Nginx 入口控制器。通常云供应商都会提供自己的入口控制器。&lt;/p&gt;
&lt;h2 id=&#34;什么是-replica-和-replicaset&#34;&gt;什么是 Replica 和 ReplicaSet？&lt;/h2&gt;
&lt;p&gt;为了保证应用程序的弹性，需要在不同节点上创建多个 pod 的副本。这些被称为 Replica。假设你所需的状态策略是 “让名为 webserver-1 的 pod 始终维持在 3 个副本”，这意味着 ReplicationController 或 ReplicaSet 将监控活动副本的数量，如果其中有任何一个 replica 因任何原因不可用（例如节点的故障），那么 Deployment Controller 将自动创建一个新的系统（定义如下）。&lt;/p&gt;
&lt;p&gt;所需状态是在 deployment 中定义的。 Master 节点的中有一个子系统叫做 Deployment Controller，负责实际执行并使当前状态不断趋向于所需状态。&lt;/p&gt;
&lt;p&gt;因此，举例来说，如果你目前有 2 个 pod 的副本，而你所希望的状态应该有 3 个，那么 Replication Controller 或 ReplicaSet 会自动检测到这个要求，并指示 Deployment Controller 根据预定义的设置部署一个新的 pod。&lt;/p&gt;
&lt;h2 id=&#34;什么是服务网格&#34;&gt;什么是服务网格？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/what-is-a-service-mesh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;服务网格 (Service Mesh)&lt;/a&gt; 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 &lt;a href=&#34;https://jimmysong.io/blog/post-kubernetes-era/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 次世代的云原生应用&lt;/a&gt; 的重要组成部分。&lt;/p&gt;
&lt;p&gt;服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）—— 就是 MySQL 数据库、Node.js 前端、负载均衡器等。&lt;/p&gt;
&lt;p&gt;所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更 —— 这些变更对其他容器是完全透明的。&lt;/p&gt;
&lt;p&gt;如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。&lt;/p&gt;
&lt;p&gt;在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。关于服务网格的更多内容请参考 &lt;a href=&#34;https://jimmysong.io/istio-handbook/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Istio 服务网格》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下一部分中，我们将展开更多关于 Kubernetes 的话题：如何开始学习 Kubernetes，如何在本地安装和测试 Kubernetes，以及 Kubernetes 的一些优秀的监控工具。&lt;/p&gt;
&lt;h2 id=&#34;如何学习-kubernetes&#34;&gt;如何学习 Kubernetes？&lt;/h2&gt;
&lt;p&gt;自学 Kubernetes 知识基本上有三种不同的途径，我们在这里只提供了一个指导大纲。&lt;/p&gt;
&lt;h3 id=&#34;一从零开始学习和安装-kubernetes&#34;&gt;一、从零开始学习和安装 Kubernetes&lt;/h3&gt;
&lt;p&gt;要想真正掌握 Kubernetes，最好的办法莫过于自己从头开始安装 Kubernetes。不过要注意的是，从零开始安装 Kubernetes 并不是一件容易的事情。安装 Kubernetes 并不是简单的 “下载文件 -&amp;gt; 点击安装” 式的操作，Kubernetes 由多个组件组成，这些组件必须单独安装和配置。而在此之前，你也需要相当的技术储备来做安装前的准备，比如熟悉 Linux 操作系统。如果你决定使用这种方式学习的话，推荐你阅读 &lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。此外，请记住，尽管 Kubernetes 作为一个开源解决方案在技术上是免费的，但它确实有一些隐藏的成本，只不过对初学者来说可能并不明显。&lt;/p&gt;
&lt;h3 id=&#34;二kubernetes-自托管解决方案&#34;&gt;二、Kubernetes 自托管解决方案&lt;/h3&gt;
&lt;p&gt;这些解决方案样是一些工具和实用程序，大大简化了在本地计算机上安装和配置小型 Kubernetes 集群的任务。它们是学习 Kubernetes 的好方法，同时对于新手来说也不会太难，又足够小巧可以到安装在个人电脑上。最流行的自托管 Kubernetes 工具和环境是 &lt;a href=&#34;https://github.com/kubernetes/minikube&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minikube&lt;/a&gt;、&lt;a href=&#34;https://github.com/ubuntu/microk8s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MicroK8s&lt;/a&gt;、&lt;a href=&#34;https://docs.docker.com/docker-for-windows/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Desktop&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes-sigs/kind&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kind&lt;/a&gt;。这些解决方案往往有一些限制，例如，Minikube 只允许创建一个节点。尽管有这些缺点，但这些工具还是非常值得推荐，因为它们将易学性和成本效益结合起来，对于刚开始使用 Kubernetes 的初学者来说，是一个很好的选择。&lt;/p&gt;
&lt;h3 id=&#34;三云托管的解决方案&#34;&gt;三、云托管的解决方案&lt;/h3&gt;
&lt;p&gt;如今各大云供应商都提供了定制化的 Kubernetes 解决方案来。你也可以通过线上教学平台如 &lt;a href=&#34;https://katacoda.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Katacoda&lt;/a&gt; 上的免费课程来学习 Kubernetes，它们都是云托管的，你不需要自己安装，只不过你需要云供应商的集群需要付费。&lt;/p&gt;
&lt;h2 id=&#34;本地测试和调试-kubernetes&#34;&gt;本地测试和调试 Kubernetes&lt;/h2&gt;
&lt;p&gt;作为本地安装 Kubernetes 的一部分，你很可能还需要一些测试和调试能力，以确保一切都在顺利运行，特别是定义入口和出口策略等棘手的任务。此外，还有 Kubernetes 附加组件的生态系统，你可能想使用这些组件来扩展 Kubernetes 集群的功能。添加所有这些都需要进行更多的测试，以确保它们能与你的 Kubernetes 集群完美的集成。&lt;/p&gt;
&lt;p&gt;用于在本地开发和调试 Kubernetes 服务的工具有：&lt;a href=&#34;https://github.com/microsoft/mindaro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Microsoft Bridge to Kubernetes&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/telepresenceio/telepresence&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;telepresence&lt;/a&gt;。这些工具可以让你在本地运行单个服务，同时将该服务连接到远程 Kubernetes 集群。这样你就可以让自己的本地机器作为 Kubernetes 集群中的一部分来运行 —— 这对于在本地而不是在生产集群上开发服务非常有用。&lt;/p&gt;
&lt;p&gt;Kubernetes 项目也了解到了 Kubernetes 安装对端到端 (E2E) 测试的需求。为此，项目核心团队一直在确保在最近的版本中更恰当地支持 E2E 测试。这包括诸如允许测试重用和纳入更多附加组件和驱动程序的测试等。&lt;/p&gt;
&lt;h2 id=&#34;kubernetes-监控工具&#34;&gt;Kubernetes 监控工具&lt;/h2&gt;
&lt;p&gt;Kubernetes 提供了应用程序在集群的每个层次上的资源使用情况的详细信息 —— 容器、pod、服务。这些详细信息使你能够评估应用程序的性能，确定哪些瓶颈可以解决以提高整体性能。&lt;/p&gt;
&lt;p&gt;毕竟，监控可以帮助你了解应用和集群运行情况的详细信息，这对于学习 Kubernetes 是十分有帮助的。&lt;/p&gt;
&lt;p&gt;Kubernetes 包含两个内置度量收集工具用于监控：资源管道和全度量管道。资源管道是一个较低级和较有限的工具，主要集中在与各种控制器相关的指标上。全指标管道，顾名思义，从几乎所有集群组件中获取并显示更丰富的指标。&lt;/p&gt;
&lt;p&gt;还有一些第三方工具可以安装并集成到 Kubernetes 集群中。对于 Kubernetes 来说，最普遍使用的两个工具是 Prometheus 和 Grafana。&lt;/p&gt;
&lt;h3 id=&#34;prometheus-监控&#34;&gt;Prometheus 监控&lt;/h3&gt;
&lt;p&gt;Prometheus 是一个功能丰富的开源监控和警报工具。Prometheus 包含一个内部数据存储用来收集指标，如生成的时间序列数据。Prometheus 还拥有众多插件，允许它将数据暴露给各种外部解决方案，并从其他数据源导入数据，包括所有主要公有云监控解决方案。&lt;/p&gt;
&lt;h3 id=&#34;grafana-仪表盘&#34;&gt;Grafana 仪表盘&lt;/h3&gt;
&lt;p&gt;Grafana 是一个优秀的仪表盘、分析和数据可视化工具。它没有 Prometheus 的全功能数据收集能力，但 Prometheus 又没有 Grafana 的数据呈现界面。事实上，他们最好是结合在一起使用 ——Prometheus 负责数据收集和汇总，Grafana 负责数据展示。它们共同创造了一个强大的组合，涵盖了数据收集、基本警报和可视化。&lt;/p&gt;
&lt;h3 id=&#34;高级警报&#34;&gt;高级警报&lt;/h3&gt;
&lt;p&gt;对于高级警报，你可以添加 &lt;a href=&#34;https://www.nagios.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nagios&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/prometheus/alertmanager&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus Alertmanager&lt;/a&gt; 等工具。这些警报工具通常有大量的集成。你可以为自定义值班团队，然后定义你想要监控的参数，例如 “当任何 pod 不可用时” 或 “当任何节点无法访问时”、“当容量达到 90%” 等，然后通过电子邮件、短信、手机应用提醒、电话呼叫等方式向值班人员发送自定义通知。你还可以创建升级策略，比如，如果一个被定义为 “危急” 的警报在 10 分钟内没有值班人员确认，那么就将警报升级（发送警报）到该人员的经理。&lt;/p&gt;
&lt;p&gt;现在，你应该已经对 Docker 和 Kubernetes 有了大体的认识。了解了 Kubernetes 的作用，知道它是如何进行容器化应用部署和管理的。&lt;/p&gt;
&lt;p&gt;调试和监控技术不仅仅是运维需要，你也可以把它当作学习方式。有什么比边做边学更好呢？&lt;/p&gt;
&lt;p&gt;请记住，如果你的应用规模太小，而且预计用户需求不会有太大变化或重大波动（比如一个只在公司内部使用的应用），那么 Kubernetes 对你来说可能没有必要，这种情况下，直接使用 Docker 就足够了。&lt;/p&gt;
&lt;h2 id=&#34;更多&#34;&gt;更多&lt;/h2&gt;
&lt;p&gt;云原生领域的开源项目众多（见 &lt;a href=&#34;https://jimmysong.io/awesome-cloud-native&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Awesome Cloud Native / 云原生开源项目大全&lt;/a&gt;），其中有大量的优秀项目可供我们学习。此外，Kubernetes 开源已经多年时间，网上有大量的学习资料，业界出版过很多&lt;a href=&#34;https://jimmysong.io/cloud-native/note/books/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;书籍&lt;/a&gt;，建议大家通过阅读&lt;a href=&#34;https://kubernetes.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官方文档&lt;/a&gt;和实践来学习，也可以参考我编写的 &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Handbook——Kubernetes 中文指南 / 云原生架构实践手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;推荐大家加入笔者发起创办的&lt;a href=&#34;https://cloudnative.to/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生社区&lt;/a&gt;，这是一个立足中国，放眼世界的云原生终端用户社区，致力于云原生技术的传播和应用。云原生社区主办的&lt;a href=&#34;https://github.com/cloudnativeto/academy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生学院&lt;/a&gt;定期邀请云原生和开源领域的大咖进行直播分享，成员自发组织了多个 SIG（特别兴趣小组）进行讨论学习。欢迎加入我们，共同学习和交流云原生技术。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>你是否需要 Istio？</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/do-you-need-a-service-mesh/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/do-you-need-a-service-mesh/</guid>
      <description>&lt;p&gt;你可能参加过各种云原生、服务网格相关的 meetup，在社区里看到很多人在分享和讨论 Istio，但是对于自己是否真的需要 Istio 感到踌躇，甚至因为它的复杂性而对服务网格的前景感到怀疑。那么，在你继阅读 Istio SIG 后续文章之前，请先仔细阅读本文，审视一下自己公司的现状，看看你是否有必要使用服务网格，处于 Istio 应用的哪个阶段。&lt;/p&gt;
&lt;p&gt;本文不是对应用服务网格的指导，而是根据社区里经常遇到的问题而整理。在使用 Istio 之前，请先考虑下以下因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的团队里有多少人？&lt;/li&gt;
&lt;li&gt;你的团队是否有使用 Kubernetes、Istio 的经验？&lt;/li&gt;
&lt;li&gt;你有多少微服务？&lt;/li&gt;
&lt;li&gt;这些微服务使用什么语言？&lt;/li&gt;
&lt;li&gt;你的运维、SRE 团队是否可以支持服务网格管理？&lt;/li&gt;
&lt;li&gt;你有采用开源项目的经验吗？&lt;/li&gt;
&lt;li&gt;你的服务都运行在哪些平台上？&lt;/li&gt;
&lt;li&gt;你的应用已经容器化并使用 Kubernetes 管理了吗？&lt;/li&gt;
&lt;li&gt;你的服务有多少是部署在虚拟机、有多少是部署到 Kubernetes 集群上，比例如何？&lt;/li&gt;
&lt;li&gt;你的团队有制定转移到云原生架构的计划吗？&lt;/li&gt;
&lt;li&gt;你想使用 Istio 的什么功能？&lt;/li&gt;
&lt;li&gt;Istio 的稳定性是否能够满足你的需求？&lt;/li&gt;
&lt;li&gt;你是否可以忍受 Istio 带来的性能损耗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio 作为目前最流行的 Service Mesh 技术之一，拥有活跃的社区和众多的落地案例。但如果你真的想在你的生产环境大规模落地 Isito，这看似壮观美好的冰山下，却是暗流涌动，潜藏着无数凶险。&lt;/p&gt;
&lt;h2 id=&#34;使用-istio-无法做到完全对应用透明&#34;&gt;使用 Istio 无法做到完全对应用透明&lt;/h2&gt;
&lt;p&gt;服务通信和治理相关的功能迁移到 Sidecar 进程中后， 应用中的 SDK 通常需要作出一些对应的改变。&lt;/p&gt;
&lt;p&gt;比如 SDK 需要关闭一些功能，例如重试。一个典型的场景是，SDK 重试 m 次，Sidecar 重试 n 次，这会导致 m * n 的重试风暴，从而引发风险。&lt;/p&gt;
&lt;p&gt;此外，诸如 trace header 的透传，也需要 SDK 进行升级改造。如果你的 SDK 中还有其它特殊逻辑和功能，这些可能都需要小心处理才能和 Isito Sidecar 完美配合。&lt;/p&gt;
&lt;h2 id=&#34;istio-对非-kubernetes-环境的支持有限&#34;&gt;Istio 对非 Kubernetes 环境的支持有限&lt;/h2&gt;
&lt;p&gt;在业务迁移至 Istio 的同时，可能并没有同步迁移至 Kubernetes，而还运行在原有 PAAS 系统之上。 这会带来一系列挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原有 PAAS 可能没有容器网络，Istio 的服务发现和流量劫持都可能要根据旧有基础设施进行适配才能正常工作&lt;/li&gt;
&lt;li&gt;如果旧有的 PAAS 单个实例不能很好的管理多个容器（类比 Kubernetes 的 Pod 和 Container 概念），大量 Istio Sidecar 的部署和运维将是一个很大的挑战&lt;/li&gt;
&lt;li&gt;缺少 Kubernetes webhook 机制，Sidecar 的注入也可能变得不那么透明，而需要耦合在业务的部署逻辑中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;只有-http-协议是一等公民&#34;&gt;只有 HTTP 协议是一等公民&lt;/h2&gt;
&lt;p&gt;Istio 原生对 HTTP 协议提供了完善的全功能支持，但在真实的业务场景中，私有化协议却非常普遍，而 Istio 却并未提供原生支持。&lt;/p&gt;
&lt;p&gt;这导致使用私有协议的一些服务可能只能被迫使用 TCP 协议来进行基本的请求路由，这会导致很多功能的缺失，这其中包括 Istio 非常强大的基于内容的消息路由，如基于 header、 path 等进行权重路由。&lt;/p&gt;
&lt;h2 id=&#34;扩展-istio-的成本并不低&#34;&gt;扩展 Istio 的成本并不低&lt;/h2&gt;
&lt;p&gt;虽然 Istio 的总体架构是基于高度可扩展而设计，但由于整个 Istio 系统较为复杂，如果你对 Istio 进行过真实的扩展，就会发现成本不低。&lt;/p&gt;
&lt;p&gt;以扩展 Istio 支持某一种私有协议为例，首先你需要在 Istio 的 api 代码库中进行协议扩展，其次你需要修改 Istio 代码库来实现新的协议处理和下发，然后你还需要修改 xds 代码库的协议，最后你还要在 Envoy 中实现相应的 Filter 来完成协议的解析和路由等功能。&lt;/p&gt;
&lt;p&gt;在这个过程中，你还可能面临上述数个复杂代码库的编译等工程挑战（如果你的研发环境不能很好的使用 Docker 或者无法访问部分国外网络的情况下）。&lt;/p&gt;
&lt;p&gt;即使做完了所有的这些工作，你也可能面临这些工作无法合并回社区的情况，社区对私有协议的扩展支持度不高，这会导致你的代码和社区割裂，为后续的升级更新带来隐患。&lt;/p&gt;
&lt;h2 id=&#34;istio-在集群规模较大时的性能问题&#34;&gt;Istio 在集群规模较大时的性能问题&lt;/h2&gt;
&lt;p&gt;Istio 默认的工作模式下，每个 Sidecar 都会收到全集群所有服务的信息。如果你部署过 Istio 官方的 Bookinfo 示例应用，并使用 Envoy 的 config dump 接口进行观察，你会发现，仅仅几个服务，Envoy 所收到的配置信息就有将近 20w 行。&lt;/p&gt;
&lt;p&gt;可以想象，在稍大一些的集群规模，Envoy 的内存开销、Istio 的 CPU 开销、XDS 的下发时效性等问题，一定会变得尤为突出。&lt;/p&gt;
&lt;p&gt;Istio 这么做一是考虑这样可以开箱即用，用户不用进行过多的配置，另外在一些场景，可能也无法梳理出准确的服务之间的调用关系，因此直接给每个 Sidecar 下发了全量的服务配置，即使这个 Sidecar 只会访问其中很小一部分服务。&lt;/p&gt;
&lt;p&gt;当然这个问题也有解法，你可以通过 Sidecar CRD 来显示定义服务调用关系，使 Envoy 只得到他需要的服务信息，从而大幅降低 Envoy 的资源开销，但前提是在你的业务线中能梳理出这些调用关系。&lt;/p&gt;
&lt;h2 id=&#34;xds-分发没有分级发布机制&#34;&gt;XDS 分发没有分级发布机制&lt;/h2&gt;
&lt;p&gt;当你对一个服务的策略配置进行变更的时候，XDS 不具备分级发布的能力，所有访问这个服务的 Envoy 都会立即收到变更后的最新配置。这在一些对变更敏感的严苛生产环境，可能是有很高风险甚至不被允许的。&lt;/p&gt;
&lt;p&gt;如果你的生产环境严格要求任何变更都必须有分级发布流程，那你可能需要考虑自己实现一套这样的机制。&lt;/p&gt;
&lt;h2 id=&#34;istio-组件故障时是否有退路&#34;&gt;Istio 组件故障时是否有退路？&lt;/h2&gt;
&lt;p&gt;以 Istio 为代表的 Sidecar 架构的特殊性在于，Sidecar 直接承接了业务流量，而不像一些其他的基础设施那样，只是整个系统的旁路组件（比如 Kubernetes）。&lt;/p&gt;
&lt;p&gt;因此在 Isito 落地初期，你必须考虑，如果 Sidecar 进程挂掉，服务怎么办？是否有退路？是否能 fallback 到直连模式？&lt;/p&gt;
&lt;p&gt;在 Istio 落地过程中，是否能无损 fallback，通常决定了核心业务能否接入 Service Mesh。&lt;/p&gt;
&lt;h2 id=&#34;isito-技术架构的成熟度还没有达到预期&#34;&gt;Isito 技术架构的成熟度还没有达到预期&lt;/h2&gt;
&lt;p&gt;虽然 Istio 1.0 版本已经发布了很久，但是如果你关注社区每个版本的迭代，就会发现，Istio 目前架构依然处于不太稳定的状态，尤其是 1.5 版本前后的几个大版本，先后经历了去除 Mixer 组件、合并为单体架构、仅支持高版本 Kubernetes 等等重大变动，这对于已经在生产环境中使用了 Istio 的用户非常不友好，因为升级会面临各种不兼容性问题。&lt;/p&gt;
&lt;p&gt;好在社区也已经意识到这一问题，2021 年社区也成立了专门的小组，重点改善 Istio 的兼容性和用户体验。&lt;/p&gt;
&lt;h2 id=&#34;istio-缺乏成熟的产品生态&#34;&gt;Istio 缺乏成熟的产品生态&lt;/h2&gt;
&lt;p&gt;Istio 作为一套技术方案，却并不是一套产品方案。&lt;/p&gt;
&lt;p&gt;如果你在生产环境中使用，你可能还需要解决可视化界面、权限和账号系统对接、结合公司已有技术组件和产品生态等问题，仅仅通过命令行来使用，可能并不能满足你的组织对权限、审计、易用性的要求。&lt;/p&gt;
&lt;p&gt;而 Isito 自带的 Kiali 功能还十分简陋，远远没有达到能在生产环境使用的程度，因此你可能需要研发基于 Isito 的上层产品。&lt;/p&gt;
&lt;h2 id=&#34;istio-目前解决的问题域还很有限&#34;&gt;Istio 目前解决的问题域还很有限&lt;/h2&gt;
&lt;p&gt;Istio 目前主要解决的是分布式系统之间服务调用的问题，但还有一些分布式系统的复杂语义和功能并未纳入到 Istio 的 Sidecar 运行时之中，比如消息发布和订阅、状态管理、资源绑定等等。&lt;/p&gt;
&lt;p&gt;云原生应用将会朝着多 Sidecar 运行时或将更多分布式能力纳入单 Sidecar 运行时的方向继续发展，以使服务本身变得更为轻量，让应用和基础架构彻底解耦。&lt;/p&gt;
&lt;p&gt;如果你的生产环境中，业务系统对接了非常多和复杂的分布式系系统中间件，Istio 目前可能并不能完全解决你的应用的云原生化诉求。&lt;/p&gt;
&lt;h2 id=&#34;写在最后&#34;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;看到这里，你是否感到有些沮丧，而对 Isito 失去信心？&lt;/p&gt;
&lt;p&gt;别担心，上面列举的这些问题，实际上并不影响 Isito 依然是目前最为流行和成功的 Service Mesh 技术选型之一。Istio 频繁的变动，一定程度上也说明它拥有一个活跃的社区，我们应当对一个新的事物报以信心，Isito 的社区也在不断听取来自终端用户的声音，朝着大家期待的方向演进。&lt;/p&gt;
&lt;p&gt;同时，如果你的生产环境中的服务规模并不是很大，服务已经托管于 Kubernetes 之上，也只使用那些 Istio 原生提供的能力，那么 Istio 依然是一个值得尝试的开箱即用方案。&lt;/p&gt;
&lt;p&gt;但如果你的生产环境比较复杂，技术债务较重，专有功能和策略需求较多，亦或者服务规模庞大，那么在开始使用 Istio 之前，你需要仔细权衡上述这些要素，以评估在你的系统之中引入 Istio 可能带来的复杂度和潜在成本。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudnative.to/blog/the-facts-of-using-istio/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在生产环境使用 Istio 前的若干考虑要素 - cloudnative.to&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>什么是 Envoy？</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/what-is-envoy/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/what-is-envoy/</guid>
      <description>&lt;p&gt;IT 行业正在向微服务架构和云原生解决方案发展。由于使用不同的技术开发了成百上千的微服务，这些系统可能变得复杂，难以调试。&lt;/p&gt;
&lt;p&gt;作为一个应用开发者，你考虑的是业务逻辑——购买产品或生成发票。然而，任何像这样的业务逻辑都会导致不同服务之间的多个服务调用。每个服务可能都有它的超时、重试逻辑和其他可能需要调整或微调的网络特定代码。&lt;/p&gt;
&lt;p&gt;如果在任何时候最初的请求失败了，就很难通过多个服务来追踪，准确地指出失败发生的地方，了解请求为什么失败。是网络不可靠吗？是否需要调整重试或超时？或者是业务逻辑问题或错误？&lt;/p&gt;
&lt;p&gt;服务可能使用不一致的跟踪和记录机制，使这种调试的复杂性增加。这些问题使你很难确定问题发生在哪里，以及如何解决。如果你是一个应用程序开发人员，而调试网络问题不属于你的核心技能，那就更是如此。&lt;/p&gt;
&lt;p&gt;将网络问题从应用程序堆栈中抽离出来，由另一个组件来处理网络部分，让调试网络问题变得更容易。这就是 Envoy 所做的事情。&lt;/p&gt;
&lt;p&gt;在每个服务实例旁边都有一个 Envoy 实例在运行。这种类型的部署也被称为 &lt;strong&gt;Sidecar 部署&lt;/strong&gt;。Envoy 的另一种模式是&lt;strong&gt;边缘代理&lt;/strong&gt;，用于构建 API 网关。&lt;/p&gt;
&lt;p&gt;Envoy 和应用程序形成一个原子实体，但仍然是独立的进程。应用程序处理业务逻辑，而 Envoy 则处理网络问题。&lt;/p&gt;
&lt;p&gt;在发生故障的情况下，分离关注点可以更容易确定故障是来自应用程序还是网络。&lt;/p&gt;
&lt;p&gt;为了帮助网络调试，Envoy 提供了以下高级功能。&lt;/p&gt;
&lt;h2 id=&#34;进程外架构&#34;&gt;进程外架构&lt;/h2&gt;
&lt;p&gt;Envoy 是一个独立的进程，旨在与每个应用程序一起运行 —— 也就是我们前面提到的 Sidecar 部署模式。集中配置的 Envoy 的集合形成了一个透明的服务网格。&lt;/p&gt;
&lt;p&gt;路由和其他网络功能的责任被推给了 Envoy。应用程序向一个虚拟地址（localhost）而不是真实地址（如公共 IP 地址或主机名）发送请求，不知道网络拓扑结构。应用程序不再承担路由的责任，因为该任务被委托给一个外部进程。&lt;/p&gt;
&lt;p&gt;与其让应用程序管理其网络配置，不如在 Envoy 层面上独立于应用程序管理网络配置。在一个组织中，这可以使应用程序开发人员解放出来，专注于应用程序的业务逻辑。&lt;/p&gt;
&lt;p&gt;Envoy 适用于任何编程语言。你可以用 Go、Java、C++ 或其他任何语言编写你的应用程序，而 Envoy 可以在它们之间架起桥梁。Envoy 的行为是相同的，无论应用程序的编程语言或它们运行的操作系统是什么。&lt;/p&gt;
&lt;p&gt;Envoy 还可以在整个基础设施中透明地进行部署和升级。这与为每个单独的应用程序部署库升级相比，后者可能是非常痛苦和耗时的。&lt;/p&gt;
&lt;p&gt;进程外架构是有益的，因为它使我们在不同的编程语言 / 应用堆栈中保持一致，我们可以免费获得独立的应用生命周期和所有的 Envoy 网络功能，而不必在每个应用中单独解决这些问题。&lt;/p&gt;
&lt;h2 id=&#34;l3l4-过滤器结构&#34;&gt;L3/L4 过滤器结构&lt;/h2&gt;
&lt;p&gt;Envoy 是一个 L3/L4 网络代理，根据 IP 地址和 TCP 或 UDP 端口进行决策。它具有一个可插拔的过滤器链，可以编写你的过滤器来执行不同的 TCP/UDP 任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过滤器链（Filter Chain）&lt;/strong&gt; 的想法借鉴了 Linux shell，即一个操作的输出被输送到另一个操作中。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ls -l &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;Envoy*.cc&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; wc -l
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Envoy 可以通过堆叠所需的过滤器来构建逻辑和行为，形成一个过滤器链。许多过滤器已经存在，并支持诸如原始 TCP 代理、UDP 代理、HTTP 代理、TLS 客户端认证等任务。Envoy 也是可扩展的，我们可以编写我们的过滤器。&lt;/p&gt;
&lt;h2 id=&#34;l7-过滤器结构&#34;&gt;L7 过滤器结构&lt;/h2&gt;
&lt;p&gt;Envoy 支持一个额外的 HTTP L7 过滤器层。我们可以在 HTTP 连接管理子系统中插入 HTTP 过滤器，执行不同的任务，如缓冲、速率限制、路由 / 转发等。&lt;/p&gt;
&lt;h2 id=&#34;一流的-http2-支持&#34;&gt;一流的 HTTP/2 支持&lt;/h2&gt;
&lt;p&gt;Envoy 同时支持 HTTP/1.1 和 HTTP/2，并且可以作为一个透明的 HTTP/1.1 到 HTTP/2 的双向代理进行操作。这意味着任何 HTTP/1.1 和 HTTP/2 客户端和目标服务器的组合都可以被桥接起来。即使你的传统应用没有通过 HTTP/2 进行通信，如果你把它们部署在 Envoy 代理旁边，它们最终也会通过 HTTP/2 进行通信。&lt;/p&gt;
&lt;p&gt;推荐在所有的服务间配置的 Envoy 使用 HTTP/2，以创建一个持久连接的网格，请求和响应可以在上面复用。&lt;/p&gt;
&lt;h2 id=&#34;http-路由&#34;&gt;HTTP 路由&lt;/h2&gt;
&lt;p&gt;当以 HTTP 模式操作并使用 REST 时，Envoy 支持路由子系统，能够根据路径、权限、内容类型和运行时间值来路由和重定向请求。在将 Envoy 作为构建 API 网关的前台 / 边缘代理时，这一功能非常有用，在构建服务网格（sidecar 部署模式）时，也可以利用这一功能。&lt;/p&gt;
&lt;h2 id=&#34;grpc-准备就绪&#34;&gt;gRPC 准备就绪&lt;/h2&gt;
&lt;p&gt;Envoy 支持作为 gRPC 请求和响应的路由和负载均衡底层所需的所有 HTTP/2 功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gRPC 是一个开源的远程过程调用（RPC）系统，它使用 HTTP/2 进行传输，并将协议缓冲区作为接口描述语言（IDL），它提供的功能包括认证、双向流和流量控制、阻塞 / 非阻塞绑定，以及取消和超时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;服务发现和动态配置&#34;&gt;服务发现和动态配置&lt;/h2&gt;
&lt;p&gt;我们可以使用静态配置文件来配置 Envoy，这些文件描述了服务间通信方式。&lt;/p&gt;
&lt;p&gt;对于静态配置 Envoy 不现实的高级场景，Envoy 支持动态配置，在运行时自动重新加载配置。一组名为 xDS 的发现服务可以用来通过网络动态配置 Envoy，并为 Envoy 提供关于主机、集群 HTTP 路由、监听套接字和加密信息。&lt;/p&gt;
&lt;h2 id=&#34;健康检查&#34;&gt;健康检查&lt;/h2&gt;
&lt;p&gt;负载均衡器有一个特点，那就是只将流量路由到健康和可用的上游服务。Envoy 支持健康检查子系统，对上游服务集群进行主动健康检查。然后，Envoy 使用服务发现和健康检查信息的组合来确定健康的负载均衡目标。Envoy 还可以通过异常点检测子系统支持被动健康检查。&lt;/p&gt;
&lt;h2 id=&#34;高级负载均衡&#34;&gt;高级负载均衡&lt;/h2&gt;
&lt;p&gt;Envoy 支持自动重试、断路、全局速率限制（使用外部速率限制服务）、影子请求（或流量镜像）、异常点检测和请求对冲。&lt;/p&gt;
&lt;h2 id=&#34;前端--边缘代理支持&#34;&gt;前端 / 边缘代理支持&lt;/h2&gt;
&lt;p&gt;Envoy 的特点使其非常适合作为边缘代理运行。这些功能包括 TLS 终端、HTTP/1.1、HTTP/2 和 HTTP/3 支持，以及 HTTP L7 路由。&lt;/p&gt;
&lt;h2 id=&#34;tls-终止&#34;&gt;TLS 终止&lt;/h2&gt;
&lt;p&gt;应用程序和代理的解耦使网格部署模型中所有服务之间的 TLS 终止（双向 TLS）成为可能。&lt;/p&gt;
&lt;h2 id=&#34;一流的可观测性&#34;&gt;一流的可观测性&lt;/h2&gt;
&lt;p&gt;为了便于观察，Envoy 会生成日志、指标和追踪。Envoy 目前支持 statsd（和兼容的提供者）作为所有子系统的统计。得益于可扩展性，我们也可以在需要时插入不同的统计提供商。&lt;/p&gt;
&lt;h2 id=&#34;http3alpha&#34;&gt;HTTP/3（Alpha）&lt;/h2&gt;
&lt;p&gt;Envoy 1.19.0 支持 HTTP/3 的上行和下行，并在 HTTP/1.1、HTTP/2 和 HTTP/3 之间进行双向转义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 2 章：采纳云原生基础架构的时机</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/when-to-adopt-cloud-native/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/when-to-adopt-cloud-native/</guid>
      <description>&lt;p&gt;云原生基础架构并不适合所有人。任何架构设计都经过了一系列的权衡。您只有熟悉自己的需求才能决定哪些权衡是有益的，哪些是有害的。&lt;/p&gt;
&lt;p&gt;不要在不了解架构的影响和限制的情况下采用工具或设计。我们相信云原生基础架构有很多好处，但需要意识到不应该盲目的采用。我们不愿意引导大家通过错误的方式来满足需求。&lt;/p&gt;
&lt;p&gt;怎么知道是否应该使用云原生基础架构设计？确定云原生基础架构是否适合您，下面是一些需要了解的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;您有云原生应用程序吗？(有关可从云原生基础架构中受益的应用程序功能，请参阅第 1 章)&lt;/li&gt;
&lt;li&gt;您的工程团队是否愿意且能够编写出体现其作业功能的生产质量代码？&lt;/li&gt;
&lt;li&gt;您在本地或公有云是否拥有基于 API 驱动的基础架构（IaaS）？&lt;/li&gt;
&lt;li&gt;您的业务是否需要更快的开发迭代或非线性人员 / 系统缩放比例？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您对所有这些问题都回答 “yes”，那么您可能会从本书其余部分介绍的基础架构中受益。如果您对这些问题中的某个问题回答是 “no”，这并不意味着您无法从某些云原生实践中受益，但是您可能需要做更多工作，然后才能从此类基础架构中充分受益。&lt;/p&gt;
&lt;p&gt;在业务准备好之前武断地采用云原生基础架构效果会很糟糕，因为这会强制使用一个不正确的解决方案。在没有充分调查的情况下可能会失败，您可以能会把云原生架构看做是有缺陷或毫无用处的。鉴于之前尝试的云原生方案的失败，今后该方案也可能很难再次采用，无论它是否是正确的解决方案。&lt;/p&gt;
&lt;p&gt;在您准备将组织和技术转变为云原生时，我们将讨论一些需要关注的领域。要考虑的事情有很多，关键领域是您的应用程序、组织中的人员、基础架构系统和您的业务。&lt;/p&gt;
&lt;h2 id=&#34;应用程序&#34;&gt;应用程序&lt;/h2&gt;
&lt;p&gt;应用程序是准备工作中最简单的部分。设计模式已经很完善，自公共云出现以来，工具性能得到了显着提升。如果您无法构建云原生应用程序并通过自动部署管道来验证它们的话，则不应继续采用云原生基础架构。&lt;/p&gt;
&lt;p&gt;构建云原生应用程序并不一定需要微服务。这并不意味着您必须用最流行的语言开发所有软件。您必须编写可以由软件管理的软件。&lt;/p&gt;
&lt;p&gt;在开发过程中，人只会与云原生应用程序进行交互。其他一切都应该由基础架构或其他应用程序来管理。&lt;/p&gt;
&lt;p&gt;应用程序应该可以动态地扩展出多个实例。扩展通常意味着负载均衡器后运行着同一个应用程序有多个副本。假定应用程序将状态存储在存储服务（即数据库）中，并且不需要运行实例之间的复杂协调。&lt;/p&gt;
&lt;p&gt;动态应用程序管理意味着不需要人参与这项工作。应用程序度量触发了基础架构操作扩展应用程序。这是大多数云环境的基本特征。运行动态伸缩的资源组并不意味着您拥有云原生基础架构；但如果您的应用程序可以自动伸缩，它可能表明您的应用程序已准备就绪了。&lt;/p&gt;
&lt;p&gt;为了使应用程序受益，编写应用程序和配置基础架构的人员需要支持这种工作方法。如果没有人愿意放弃对软件的控制，您将永远无法实现它的好处。&lt;/p&gt;
&lt;h2 id=&#34;人&#34;&gt;人&lt;/h2&gt;
&lt;p&gt;人是云原生基础架构中最难的部分。&lt;/p&gt;
&lt;p&gt;如果您想建立一个能够用软件取代人们职能和决策的架构，那么您需要确保人们了解您有最大的诉求。不仅需要人们接受变化，还需要他们自己主动寻求改变。&lt;/p&gt;
&lt;p&gt;开发应用程序很困难，运维基础架构很难。应用程序开发人员经常相信他们可以用工具和自动化取代基础架构运维，运维人员希望应用程序开发人员能够编写更可靠的代码，并提供自动调试和恢复。这些紧张关系是 DevOps 的基础，DevOps 有许多其他书籍，包括由 Jennifer Davis 和 Katherine Daniels 撰写的 &lt;em&gt;Effective DevOps&lt;/em&gt;（O’Reilly，2016）。&lt;/p&gt;
&lt;p&gt;人们不会扩大规模，也不擅长重复无聊的工作。&lt;/p&gt;
&lt;p&gt;应用程序和系统工程师的目标应该是消除无聊和重复的任务，以便他们可以专注于更有趣的问题。他们需要具备开发可以包含业务逻辑和决策的软件的技能。需要有足够的工程师来编写所需的软件，更重要的是维护它。&lt;/p&gt;
&lt;p&gt;最关键的方面是他们需要一起工作。如果没有其他方面的支持，工程的一方无法迁移到运行和管理应用程序的新方式。团队组织和沟通结构非常重要。&lt;/p&gt;
&lt;p&gt;我们会尽快将团队准备好，但首先，我们必须确定基础架构迁移到云原生的时机。&lt;/p&gt;
&lt;h2 id=&#34;系统&#34;&gt;系统&lt;/h2&gt;
&lt;p&gt;云原生应用程序需要系统抽象。应用程序不应该关注单个硬编码主机名。如果您的应用程序无法在个别主机上运行，那就说明您的系统尚未准备好使用于云原生基础架构。&lt;/p&gt;
&lt;p&gt;使用单个服务器（虚拟机或物理机）运行操作系统，并将其转换为访问资源的方法，这就是我们所说的 “抽象”。单个系统不应该是应用程序部署的目标。资源（CPU、内存和磁盘）应该集中在所有可用的机器上，然后由平台根据应用程序的请求进行分配。&lt;/p&gt;
&lt;p&gt;在云原生基础架构中，您必须隐藏底层系统以提高可靠性。云计算基础架构（如应用程序）会预期基础组件故障，并且可以优雅地处理此类故障。这是必要的，因为基础架构工程师不再控制堆栈中的所有内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 云原生基础架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 是一个框架，它使云的方式管理应用程序变得更加容易。但是，您也可以用一种非云原生的方式使用 Kubernetes。&lt;/p&gt;
&lt;p&gt;Kubernetes 公开了基于其核心功能的扩展，但这不是您的基础架构的最终目标。其他项目 (例如，OpenShift) 建立在它之上，将 Kubernetes 从开发人员和应用程序中抽象出来。&lt;/p&gt;
&lt;p&gt;应用程序应该运行在平台上。云原生基础架构并且鼓励这样运行基础架构的方式。&lt;/p&gt;
&lt;p&gt;如果您的应用程序是动态的，但基础架构是静态的，那么您很快就会陷入单靠 Kubernetes 无法解决的僵局。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当这不再是一个挑战时，基础架构已经准备好成为云原生的了。一旦基础架构变得简单，自动化、自助服务和动态，就有可能被忽略。当系统可以被忽略，并且技术变得单调时，是时候向上移动堆栈了。&lt;/p&gt;
&lt;p&gt;如果您的系统管理依赖于硬件定制或在 “混合云” 中运行，则您的系统可能还没有准备好。可能需要管理一个数据中心，并且私有化。您需要保持警惕，将建立数据中心的责任与管理基础架构的责任分开。&lt;/p&gt;
&lt;p&gt;谷歌、Facebook、亚马逊和微软都发现通过开放的计算项目从头开始创建硬件是有好处的。之所以创建自己的硬件是因为有性能和成本的限制。因为硬件设计和基础架构构建者之间存在明确的责任分离，这些公司能够在创建定制硬件的同时运行云原生基础架构。它们不会受到 “内部部署” 的阻碍。相反，他们可以共同优化其硬件和软件，以获得更高的效率和性能。&lt;/p&gt;
&lt;p&gt;管理自己的数据中心需要大量时间和金钱的投入。创建私有云也是如此。两者都需要建立和管理数据中心团队、创建和维护 API 的团队以及在 IaaS API 之上创建抽象的团队。&lt;/p&gt;
&lt;p&gt;所有这些都可以完成，决定管理整个堆栈是否有价值取决于您的业务。&lt;/p&gt;
&lt;p&gt;现在，我们看看业务领域需要做哪些准备才能迁移到云原生。&lt;/p&gt;
&lt;h2 id=&#34;业务&#34;&gt;业务&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果系统的架构和组织的架构不一致，则组织的架构会胜出。&lt;/p&gt;
&lt;p&gt;—— 鲁斯马兰，“康威定律”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;企业变革速度非常缓慢。当通过扩展人员来管理扩展系统不再有效时，以及产品开发需要更多灵活性时，他们可能已经准备好采用云原生实践了。&lt;/p&gt;
&lt;p&gt;人无法无限扩展。对于增加管理更多服务器或开发更多代码的每个人来说，支持他们的人力基础架构（例如办公室空间）都有一定的压力。因为需要更多的沟通和协调，还会有更多额外的开销。&lt;/p&gt;
&lt;p&gt;正如我们在第 1 章中讨论的那样，通过使用公有云，您可以通过租用服务器来减少一些流程和人员开销。即使使用公有云，您仍然会需要管理基础架构详细信息的人员（例如服务器，服务和用户帐户）。&lt;/p&gt;
&lt;p&gt;当沟通结构反映业务需要创建的基础架构和应用程序时，业务已准备好采用云原生实践。这包括反映像微服务这样架构的沟通结构。他们可能是小型的独立团队，无需通过层层管理与其他团队交流或合作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;DevOps 和 Cloud Native&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DevOps 可以补充团队合作的方式，并影响使用的工具类型。公司采用后有很多好处，包括快速原型化和提高部署速度。它也非常注重组织的文化。&lt;/p&gt;
&lt;p&gt;云原生需要高性能组织，但更注重于设计、架构和健康度，而不是团队工作流程和文化。如果您原以为必须解决应用程序开发人员、基础架构运维以及技术部门中任何人员之间的交互问题，才可以成功地实现云原生模式的话，那么您可能会对此感到意外。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;迫使业务变化的另一个限制因素是应用程序对敏捷性的要求更高了。企业不仅需要快速部署，还需要彻底改变部署的内容。&lt;/p&gt;
&lt;p&gt;部署的原始数量无关紧要。重要的是尽可能快地提供客户价值。相信部署的软件将第一次，甚至是第 100 次，满足所有客户的需求，这是一个谬论。&lt;/p&gt;
&lt;p&gt;当业务意识到需要频繁迭代和更改时，它可能已经准备好采用云原生应用程序了。只要在人员效率和流程方面遇到限制，且可以随时更改它，就可以准备迁移到云原生基础架构了。&lt;/p&gt;
&lt;p&gt;所有那些表明何时采用云原生的因素都不能说明全部情况。任何设计都需要权衡折衷。因此，在某些情况下，云原生基础架构不是正确的选择。&lt;/p&gt;
&lt;h2 id=&#34;什么情况下不需要云原生基础架构&#34;&gt;什么情况下不需要云原生基础架构&lt;/h2&gt;
&lt;p&gt;只有了解了系统有哪些限制，再清楚系统可以带来的好处才有用。也就是说，是否采用一个系统的决定性因素是它的限制而使用它可以带来的利益。&lt;/p&gt;
&lt;p&gt;记住需求随时间变化也很重要。现在的关键功能可能在未来并不是。同样，如果下面的情况目前并不理想，那么您可以不采用云原生。&lt;/p&gt;
&lt;h3 id=&#34;技术限制&#34;&gt;技术限制&lt;/h3&gt;
&lt;p&gt;就像应用程序一样，在基础架构中，最简单的是技术性限制。如果您知道什么时候应该采用有技术优势的云原生基础架构，那么您可以思考下何时不应该采用云原生基础架构。&lt;/p&gt;
&lt;p&gt;第一个限制是没有云原生应用程序。正如在第一章中讨论的那样，如果您的应用程序需要人工交互，无论是调度、重新启动还是搜索日志，云原生基础架构都没有多大好处。&lt;/p&gt;
&lt;p&gt;即使您有一个可以动态调度的应用程序，也不会使其成为云原生。如果您的应用程序在 Kubernetes 上运行，但仍需要人工设置监控、日志收集和负载均衡，则它不是云原生。只是将应用程序部署在 Kubernetes 运行并不意味着云原生。&lt;/p&gt;
&lt;p&gt;如果您有一个编排调度器，重要的是看看它是如何运行的。您是否需要下订单、创建工单或发送电子邮件以获取服务器？&lt;/p&gt;
&lt;p&gt;这些是您没有自助服务基础架构的指标，这是云计算的一项要求。&lt;/p&gt;
&lt;p&gt;在云中，您只需提供帐单信息并调用 API。即使您在内部运行服务器，您也应该有一个可以构建 IaaS 的团队，然后将云原生基础架构分层布局。&lt;/p&gt;
&lt;p&gt;如果您要在自己的数据中心中构建云环境，图 2-1 显示了您的基础架构组件适合的示例。所有原始组件（例如，计算、存储、网络）都应该可以从自助式 IaaS API 中获得。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图2-1-云原生基础架构的示例图层&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-2-1.jpg&#34; alt=&#34;图2-1. 云原生基础架构的示例图层&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图2-1. 云原生基础架构的示例图层
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在公有云中，您拥有 IaaS 和托管服务，但这并不意味着您的业务已准备好使用公有云。&lt;/p&gt;
&lt;p&gt;当您构建运行应用程序的平台时，了解您正在进行的操作非常重要。最初的开发只是构建和维护平台所需花费的一小部分，特别是对业务至关重要的平台。&lt;/p&gt;
&lt;p&gt;维护通常会消耗大约 40％到 80％（平均 60％）的软件成本。因此，这可能是最重要的生命周期阶段，发现业务需求和建立开发所需的技能可能对于一个小团队来说太过分了。一旦您掌握了开发所需平台的技能，您仍然需要投入时间来改进和维护系统。这需要比初始开发更长的时间。&lt;/p&gt;
&lt;p&gt;公有云提供商的产品为企业提供绝佳的运行环境。如果您不能或者不愿意让您的平台成为业务，那么您不应该自己创建一个平台。&lt;/p&gt;
&lt;p&gt;请记住，您不必自己构建一切。您可以使用可以组装到所需平台的服务或产品。&lt;/p&gt;
&lt;p&gt;可靠性仍然是基础架构的关键特性。如果您还没有准备好放弃对底层基础架构堆栈的控制，并且仍然通过接受故障来制造可靠的产品，那么云原生基础架构并不是正确的选择。&lt;/p&gt;
&lt;p&gt;非技术限制同样重要，可能超出您的控制范围。&lt;/p&gt;
&lt;h3 id=&#34;业务限制&#34;&gt;业务限制&lt;/h3&gt;
&lt;p&gt;如果现有流程不支持更改基础架构，则需要首先克服该障碍。幸运的是，您不必一个人做。&lt;/p&gt;
&lt;p&gt;本书希望有助于向需要说服力的人清楚地解释云原生的好处和流程。还有许多案例研究和公司分享他们采用这些做法的经验。本书附录 C 中将提供一个案例研究，您还可以找到相关示例并与同行和管理层分享。&lt;/p&gt;
&lt;p&gt;如果企业还没有实验的途径和支持尝试新事物的文化（以及伴随失败而来的后果），那么改变流程可能是不可能的。在这种情况下，您的需要等待达到必须改变的临界点，或者说服管理层认为改变是必要的。&lt;/p&gt;
&lt;p&gt;以一个外部的视角准确辨别一个企业是否准备好采用云原生是不可能的。不过，下面这些流程可以明确指示一个公司未准备接纳云原生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要人工干预的资源请求&lt;/li&gt;
&lt;li&gt;定期安排需要人工操作的维护窗口&lt;/li&gt;
&lt;li&gt;手动库存跟踪和资源分配&lt;/li&gt;
&lt;li&gt;电子表格清单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果调度、部署、升级或监控服务，这些流程除了负责服务的团队以外还有其他人员参与的话，则可能需要在迁移到云原生基础架构之前或迁移期间解决这些流程。&lt;/p&gt;
&lt;p&gt;有时也有业务无法控制的过程，例如行业法规。可悲的是，这些变化甚至比内部流程更难和更慢。&lt;/p&gt;
&lt;p&gt;如果行业法规限制了发展的速度或敏捷性，我们就没有任何建议，只能尽您所能。如果法规不允许业务在公有云中运行，请尽量使用技术来运行内部部署。管理层将需要为任何管理机构制定的法规制定一个案例。&lt;/p&gt;
&lt;p&gt;云原生基础架构还有另一个非技术障碍。在一些公司中，有一种不使用第三方服务的文化&lt;/p&gt;
&lt;p&gt;如果您的公司不愿意或无法通过使用第三方托管服务的流程，则可能不适合采用云原生基础架构。我们将在附录 B 中更详细地讨论何时使用托管服务。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;要成功，单靠计划是不够的。还需要即兴发挥。&lt;/p&gt;
&lt;p&gt;——Isaac Asimov&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本章中，我们讨论了何时采用云原生基础架构的注意事项。有许多需要记住的领域，每种情况都是独一无二的。希望这些指导原则可以帮助您发现变革的适当时机。&lt;/p&gt;
&lt;p&gt;如果您的公司已经采用了一些云原生实践，这些问题可以帮助确定可以采用这种架构的其他领域。当您在权衡云原生是否为正确的解决方案，以及如何开始时，了解这一点非常重要。&lt;/p&gt;
&lt;p&gt;如果您尚未将云原生实践应用于工作，则没有捷径。企业和员工需要共同决定云原生是否是正确的解决方案，并共同取得进展。没有人独自成功。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>服务网格的部署模式</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/service-mesh-patterns/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/service-mesh-patterns/</guid>
      <description>&lt;p&gt;我们在前面看到了通过&lt;strong&gt;客户端库&lt;/strong&gt;来治理服务的架构图，那是我们在改造成服务网格架构前使用微服务架构通常的形式，下图是使用服务网格架构的最终形式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-服务网格架构示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/006tNbRwly1fubs6ts3sgj30vo0osdnj.jpg&#34; alt=&#34;服务网格架构示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      服务网格架构示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当然在达到这一最终形态之前我们需要将架构一步步演进，下面给出的是参考的演进路线。&lt;/p&gt;
&lt;h2 id=&#34;ingress-或边缘代理&#34;&gt;Ingress 或边缘代理&lt;/h2&gt;
&lt;p&gt;如果你使用的是 Kubernetes 做容器编排调度，那么在进化到服务网格架构之前，通常会使用 Ingress Controller，做集群内外流量的反向代理，如使用 Traefik 或 Nginx Ingress Controller。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ingress-或边缘代理架构示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/006tNbRwly1fubsk4v16hj30vo0bq75z.jpg&#34; alt=&#34;Ingress 或边缘代理架构示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Ingress 或边缘代理架构示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这样只要利用 Kubernetes 的原有能力，当你的应用微服务化并容器化需要开放外部访问且只需要 L7 代理的话这种改造十分简单，但问题是无法管理服务间流量。&lt;/p&gt;
&lt;h2 id=&#34;路由器网格&#34;&gt;路由器网格&lt;/h2&gt;
&lt;p&gt;Ingress 或者边缘代理可以处理进出集群的流量，为了应对集群内的服务间流量管理，我们可以在集群内加一个 &lt;code&gt;Router&lt;/code&gt; 层，即路由器层，让集群内所有服务间的流量都通过该路由器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-路由器网格架构示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/006tNbRwly1fubsxrph3dj30vq0duq53.jpg&#34; alt=&#34;路由器网格架构示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      路由器网格架构示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这个架构无需对原有的单体应用和新的微服务应用做什么改造，可以很轻易的迁移进来，但是当服务多了管理起来就很麻烦。&lt;/p&gt;
&lt;h2 id=&#34;proxy-per-node&#34;&gt;Proxy per Node&lt;/h2&gt;
&lt;p&gt;这种架构是在每个节点上都部署一个代理，如果使用 Kubernetes 来部署的话就是使用 &lt;code&gt;DaemonSet&lt;/code&gt; 对象，Linkerd 第一代就是使用这种方式部署的，一代的 Linkerd 使用 Scala 开发，基于 JVM 比较消耗资源，二代的 Linkerd 使用 Go 开发。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-proxy-per-node-架构示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/006tNbRwly1fubt5a97h7j30vq0bcq5p.jpg&#34; alt=&#34;Proxy per node 架构示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Proxy per node 架构示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种架构有个好处是每个节点只需要部署一个代理即可，比起在每个应用中都注入一个 sidecar 的方式更节省资源，而且更适合基于物理机 / 虚拟机的大型单体应用，但是也有一些副作用，比如粒度还是不够细，如果一个节点出问题，该节点上的所有服务就都会无法访问，对于服务来说不是完全透明的。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-代理--fabric-模型&#34;&gt;Sidecar 代理 / Fabric 模型&lt;/h2&gt;
&lt;p&gt;这个一般不会成为典型部署类型，当企业的服务网格架构演进到这一步时通常只会持续很短时间，然后就会增加控制平面。跟前几个阶段最大的不同就是，应用程序和代理被放在了同一个部署单元里，可以对应用程序的流量做更细粒度的控制。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sidecar代理fabric模型示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/006tNbRwly1fubvi0dnhlj30vo0ekwhx.jpg&#34; alt=&#34;Sidecar代理/Fabric模型示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Sidecar代理/Fabric模型示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这已经是最接近服务网格架构的一种形态了，唯一缺的就是控制平面了。所有的 sidecar 都支持热加载，配置的变更可以很容易的在流量控制中反应出来，但是如何操作这么多 sidecar 就需要一个统一的控制平面了。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-代理--控制平面&#34;&gt;Sidecar 代理 / 控制平面&lt;/h2&gt;
&lt;p&gt;下面的示意图是目前大多数服务网格的架构图，也可以说是整个服务网格架构演进的最终形态。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sidecar-代理控制平面架构示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/006tNbRwly1fubvr83wvgj30vq0mmdip.jpg&#34; alt=&#34;Sidecar 代理/控制平面架构示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Sidecar 代理/控制平面架构示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种架构将代理作为整个服务网格中的一部分，使用 Kubernetes 部署的话，可以通过以 sidecar 的形式注入，减轻了部署的负担，可以对每个服务的做细粒度权限与流量控制。但有一点不好就是为每个服务都注入一个代理会占用很多资源，因此要想方设法降低每个代理的资源消耗。&lt;/p&gt;
&lt;h2 id=&#34;多集群部署和扩展&#34;&gt;多集群部署和扩展&lt;/h2&gt;
&lt;p&gt;以上都是单个服务网格集群的架构，所有的服务都位于同一个集群中，服务网格管理进出集群和集群内部的流量，当我们需要管理多个集群或者是引入外部的服务时就需要网格扩展和多集群配置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 3 章：云原生部署的演变</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/evolution-of-cloud-native-developments/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/evolution-of-cloud-native-developments/</guid>
      <description>&lt;p&gt;我们在前一章中讨论了在采用云原生基础架构的前提。在部署之前，需要有由 API 驱动的基础架构（IaaS）供给。&lt;/p&gt;
&lt;p&gt;在本章中，我们将探讨云原生基础架构拓扑的概念，并在云中实现它们。我们将学习可以帮助运维人员控制其基础架构的常用工具和模式。&lt;/p&gt;
&lt;p&gt;部署基础架构的第一步应该是能够将其表述出来。传统上，可以在白板上处理，或者如果幸运的话，可以在公司 wiki 上存储的文档中处理。今天，一切都变得更加程序化，基础架构表述通常以便于应用程序解释的方式记录。无论如何表述，全面的表述基础架构的需求是不变的。&lt;/p&gt;
&lt;p&gt;正如人们所期望的那样，精巧的云基础架构可以从简单的设计到非常复杂的设计。无论复杂性如何，必须对基础架构的表现给予高度的重视，以确保设计的可重复性。能够清晰地传递想法更为重要。因此，明确、准确和易于理解的基础架构级资源表述势在必行。&lt;/p&gt;
&lt;p&gt;我们也将从制作精良的表述中获得很多好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随着时间的推移，基础架构设计可以共享和版本化。&lt;/li&gt;
&lt;li&gt;基础架构设计可以被 fork 和修改以适应特殊情况。&lt;/li&gt;
&lt;li&gt;表述隐含的是文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着本章向前推进，我们将看到基础架构表述是如何成为基础架构部署的第一步。我们将以不同的方式探索表述基础架构的能力和潜在缺陷。&lt;/p&gt;
&lt;h2 id=&#34;表述基础架构&#34;&gt;表述基础架构&lt;/h2&gt;
&lt;p&gt;首先，我们需要理解表述基础架构的两个角色：作者和观众。&lt;/p&gt;
&lt;p&gt;作者将定义基础架构，通常是人类运维人员或管理员。观众将负责解释基础架构表述。有时候，这是一个运维人员执行手动步骤，但希望它是一个可以自动分析和创建基础架构的部署工具。作者在准确表达基础架构方面表现得越好，我们就可以在听众解释表达的能力中获得更多的信心。&lt;/p&gt;
&lt;p&gt;创作基础架构表述时主要关心的是要让观众了解它。如果目标受众是人，则表述可能以技术图或抽象代码的形式出现。如果目标受众是一个程序，那么表示可能需要更详细的信息和具体的实施步骤。&lt;/p&gt;
&lt;p&gt;尽管有观众，作者应该让观众更容易使用。随着复杂性的增加以及人与程序共同使用基础架构，这将变得非常困难。&lt;/p&gt;
&lt;p&gt;表示法需要易于理解，以便能够对其进行准确分析。易于阅读但分析不准确的表述否定了整个工作。观众应该总是努力去解释他们的表述，而不是做出假设。&lt;/p&gt;
&lt;p&gt;为了使表达成功，解释需要可预测。如果作者忽略了一个重要的细节，那么最好的观众就会很快失败。具有可预测性将在应用变更时减少错误的发生，并有助于在作者和受众之间建立信任。&lt;/p&gt;
&lt;h3 id=&#34;基础架构即图&#34;&gt;基础架构即图&lt;/h3&gt;
&lt;p&gt;我们用到了白板，开始绘制一张基础架构图。通常情况下，这个过程始于在角落上代表互联网的云形状，以及一些指向方框的箭头。每个框代表系统中的一个组件，箭头表示它们之间的交互。图 3-1 是基础架构图的一个例子。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3-1-简单的基础架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-3-1.jpg&#34; alt=&#34;图 3-1. 简单的基础架构图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3-1. 简单的基础架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这是一个非常有效的头脑风暴和将想法传达给其他人的方法。它允许对复杂的基础架构设计进行快速而强大的表示。&lt;/p&gt;
&lt;p&gt;图片适用于人类，大量人群和 CEO。这些图也适用，因为它们使用常用语来表示关系。例如，此框可能会将数据发送到那个框，但不会将数据发送到其他框。&lt;/p&gt;
&lt;p&gt;不幸的是，图表对于计算机来说几乎是不可能理解的。在计算机视觉迎头赶上之前，基础架构图仍然是一个代表，可以用眼球来解释，而不是代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从图中进行部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在例 3-1 中，我们看一个来自 bash_history 文件的熟悉的代码片段。它代表一个基础架构运营商，作为描述基础服务器与网络、存储和转租服务运行的图表的受众。&lt;/p&gt;
&lt;p&gt;运维人员已经手动部署了一台新的虚拟机，并通过 SSH 连接到了该机器并开始配置它。在这种情况下，人类充当图解释者，然后在基础架构环境中采取行动。&lt;/p&gt;
&lt;p&gt;大多数基础架构工程师在他们的职业生涯中都这样做了，而且这些步骤对于某些系统管理员来说应该是非常熟悉的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-1. bash_history&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo emacs /etc/networking/interfaces
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ifdown eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ifup eth0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo fdisk -l
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo emacs /etc/fstab
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo mount -a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo systemctl &lt;span class=&#34;nb&#34;&gt;enable&lt;/span&gt; kubelet
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基础架构即脚本&#34;&gt;基础架构即脚本&lt;/h3&gt;
&lt;p&gt;如果您是一个系统管理员，您工作的一部分是在复杂系统中进行更改；确保这些更改是正确的也是您的责任。需要将这些变化传播到广阔的系统中是非常现实的。不幸的是，人为错误也是如此。管理员为这项工作编写便利脚本并不奇怪。&lt;/p&gt;
&lt;p&gt;脚本可以帮助减少重复任务中人为错误的数量，但自动化是一把双刃剑。这并不意味着准确性或成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于 SRE，自动化可以让你力量倍增，单它不是万能药。当然，加倍的力量并不会自然地改变应用力的准确性：不经意地进行自动化可能会产生很多的问题。&lt;/p&gt;
&lt;p&gt;——Niall Murphy、John Looney 和 Kacirek，自动化在谷歌的演变&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编写脚本是自动执行步骤以产生所需结果的好方法。该脚本可以执行各种任务，例如安装 HTTP 服务器，配置并运行它。但是，脚本中的步骤在调用时很少考虑到它们的结果或系统的状态。&lt;/p&gt;
&lt;p&gt;在这种情况下，脚本是编码数据，表示创建所需基础架构应该发生的情况。另一位运维人员或管理员可以评估您的脚本，并希望了解脚本正在做什么。换句话说，他们会解释你的基础架构表示。了解所需的基础架构需要了解步骤如何影响系统。&lt;/p&gt;
&lt;p&gt;脚本的运行时会按照它们定义的顺序执行这些步骤，但运行时不知道它正在生成什么。脚本是代码，脚本的执行结果希望是所需的基础架构。&lt;/p&gt;
&lt;p&gt;这适用于普遍的场景，但这种方法存在一些缺陷。最明显的缺陷是运行相同的脚本可能获得两个不同的结果。&lt;/p&gt;
&lt;p&gt;如果脚本第一次运行的环境与第二次运行的环境大不相同？从科学的角度来说，这将类似于程序中的缺陷，并会使实验数据无效。&lt;/p&gt;
&lt;p&gt;使用脚本来表示基础架构的另一个缺陷是缺少声明状态。脚本的运行时不理解结束状态，因为它只提供了执行步骤。人类需要从步骤中解释理想的结果，以了解如何进行改变。&lt;/p&gt;
&lt;p&gt;我们看到过很多人类难以理解的代码。随着配置脚本复杂性的增长，我们解释脚本的能力就会减弱。此外，您的基础架构页需要随时间而变化，脚本将不可避免地需要更改。&lt;/p&gt;
&lt;p&gt;如果不将步骤抽象为声明性状态，为了给每个可能的初始状态创建过程，脚本将不断增长。这包括抽象出操作系统（例如 apt 和 DNF）之间的步骤和差异，以及验证可以安全地跳过哪些步骤。&lt;/p&gt;
&lt;p&gt;基础架构即代码带来了一些工具，这些工具提供了一些抽象，以帮助减轻使用脚本管理基础架构的负担。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从脚本部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建基础架构的下一个发展是开始采用先前手动管理基础架构的流程，并通过将工作封装在脚本中来简化它。想象一下，我们有一个名为 createVm.sh 的 bash 脚本，它将在我们的本地工作站中创建一台虚拟机。&lt;/p&gt;
&lt;p&gt;该脚本需要两个参数。第一个是分配给虚拟机上的网络接口的静态 IP 地址。第二个是以千兆字节为单位的大小，用于创建卷并将其挂载到虚拟机。&lt;/p&gt;
&lt;p&gt;示例 3-2 将基础架构的基本表示形式显示为脚本。该脚本将提供新的基础架构，并在新创建的基础架构上运行任意配置脚本。该脚本可能演变为高度可定制的，并且可能是（危险地）自动化的，只需点击一下按钮即可运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-2. 基础架构即脚本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Create a VM with a NIC on 10.0.0.17 and a 100gb volume&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;createVm.sh 10.0.0.17 &lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Transfer the bootstrapping script&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;scp ~/vm_provision.sh user@10.0.0.17:vm_provision.sh -v
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Run the bootstrap script&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh user@10.0.0.17 sh ~/vm_provision.sh
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基础架构即代码&#34;&gt;基础架构即代码&lt;/h3&gt;
&lt;p&gt;配置管理曾经是代表基础架构的主要角色。我们可以将配置管理视为抽象脚本，自动考虑初始状态以执行正确的过程。最重要的是，配置管理允许作者声明节点的期望状态，而不是实现它所需的每一步。&lt;/p&gt;
&lt;p&gt;配置管理是基础架构即代码的第一步，但相关工具很少超出单个服务器的范围。配置管理工具在定义特定资源和他们的状态方面做得非常出色，但由于基础架构需要资源之间的协调，所以出现了复杂性。&lt;/p&gt;
&lt;p&gt;例如，服务的 DNS 条目在提供服务之前不可用。在主机可用之前不应该提供该服务。如果不能在独立节点之间协调多个资源，则配置管理提供的抽象化是不足的。有些工具增加了协调资源之间配置的能力，但协调通常是程序性的，责任落到了人们的协调资源和理解所需状态上。&lt;/p&gt;
&lt;p&gt;您的基础架构不包含没有通信的独立实体。代表基础架构的工具需要考虑到这一点。因此，需要另一种表示来管理低级别抽象（例如操作系统）以及供应和协调。&lt;/p&gt;
&lt;p&gt;2014 年 7 月，有个开源工具在代码发布的时候采用了更高级别的基础架构抽象概念。这个名为 Terraform 的工具非常成功。它在配置管理完善并且公有云的采用呈上升趋势的时间节点发布。用户看到了新环境中工具的局限性，Terraform 很好的满足了他们的需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 2011 年时，我们最初将基础架构视代码。我们注意到我们正在编写工具来解决许多项目的基础架构问题，并希望将流程标准化。&lt;/p&gt;
&lt;p&gt;——Hashicorp 首席执行官兼 Terraform 创始人 Mitchell Hashimoto&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Terraform 使用专门的领域特定语言（DSL）表示基础架构，它在人类可理解的图像和机器可分析的代码之间做了良好的折衷。Terraform 最成功的部分是抽象的基础架构视图，资源协调以及应用时利用现有工具的能力。Terraform 与云 API 进行通信以配置基础架构，并可在必要时使用配置管理来配置节点。&lt;/p&gt;
&lt;p&gt;这是该行业的根本性转变，因为我们看到一次性配置脚本正在消失。越来越多的运营商开始在新的 DSL 中开发基础架构表示。过去在基础架构上手动操作的工程师现在正在开发代码。&lt;/p&gt;
&lt;p&gt;新的 DSL 解决了将基础架构表示为脚本的问题，并成为表示基础架构的标准。工程师发现他们正在开发更好的基础架构代码，并允许 Terraform 对其进行解释。与配置管理代码一样，工程师们开始将他们的基础架构表述存储在版本控制系统中，并将基础架构与软件等同看待。&lt;/p&gt;
&lt;p&gt;通过表述基础架构的标准化方式，我们摆脱了学习各种专有云 API 的痛苦。尽管并非所有云资源都可以用单一表示抽象出来，但大多数用户可以接受其代码中的云锁定。拥有人类可读并且机器可解析的基础架构表示，而不仅仅是独立的资源声明，这一点永远得改变了行业。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从代码部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在面临将基础架构部署为脚本的挑战之后，我们已经创建了一个程序来解析输入并针对我们的基础架构采取行动。&lt;/p&gt;
&lt;p&gt;例 3-3 显示了从 Terraform 开源库中获取的 Terraform 配置。注意代码中有变量，需要在运行时解析。&lt;/p&gt;
&lt;p&gt;基础架构的声明性表示很重要，因为它没有定义创建基础架构的各个步骤。这使我们能够分离需要调配的部分和调配的部分。这就是使这种基础架构代表成为新范例的原因；这也是向软件基础架构演进的第一步。&lt;/p&gt;
&lt;p&gt;以这种方式来表示基础架构对于工程师来说是一种常见的强大做法。用户可以使用 Terraform 来应用基础架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-3. example.tf&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Create our DNSimple record&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;resource &lt;span class=&#34;s2&#34;&gt;&amp;#34;dnsimple_record&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;web&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;var&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.dnsimple_domain&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;terraform&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;CNAME&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;ttl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;3600&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基础架构即软件&#34;&gt;基础架构即软件&lt;/h3&gt;
&lt;p&gt;基础架构即代码是朝着正确方向发展的强大举措。但是代码是基础架构的静态表示，并且有其局限性。您可以自动执行部署代码更改的过程，但除非部署工具持续运行，否则仍会出现配置漂移。传统上，部署工具只能在一个方向上工作：它只能创建新对象，并且不能轻易删除或修改现有对象。&lt;/p&gt;
&lt;p&gt;为了掌握基础架构，我们的部署工具需要根据基础架构的初始表示进行工作，并对数据进行变更以创建更灵活的系统。当我们开始将基础架构表示视为一个可持续执行所需状态的可版本化数据体时，下一步就是将基础架构视为软件。&lt;/p&gt;
&lt;p&gt;Terraform 从配置管理中吸取教训并改进了这一概念，以更好地配置基础架构和协调资源。应用程序需要一个抽象层来更有效地利用资源。正如我们在第 1 章中所解释的那样，应用程序不能直接在 IaaS 上运行，而需要在可以管理资源和运行应用程序的平台上运行。&lt;/p&gt;
&lt;p&gt;IaaS 将原始组件作为临时 API 端点呈现，平台呈现更容易被应用程序使用的资源的 API。其中一些资源可能提供 IaaS 组件（例如，负载均衡器或磁盘卷），但其中许多资源将由平台管理（例如，计算资源）。&lt;/p&gt;
&lt;p&gt;平台揭示了一个新的基础架构层，并不断强化所需的状态。平台的组件也是应用程序本身，可以使用相同的期望状态声明进行管理。&lt;/p&gt;
&lt;p&gt;API 机制允许用户获得将基础架构标准化为代码的好处，并增加了随着时间的推移版本化和更改表示的能力。API 允许通过标准实践（如 API 版本控制）消费资源的新方式。API 的使用者可以将其应用程序构建到特定的版本，并相信在使用新的 API 版本之前，它们的使用不会中断。其中有些做法是以前基础架构即代码工具所缺少的重要功能。&lt;/p&gt;
&lt;p&gt;通过持续强化表示的软件，我们现在可以保证我们系统的当前状态。通过提供正确的抽象，平台层变得更加易于使用。&lt;/p&gt;
&lt;p&gt;您可能正在绘制基础架构演变与软件演进之间的相似之处。堆栈中的这两层以非常相似的方式进化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;软件正在吞噬世界。&lt;/p&gt;
&lt;p&gt;——Marc Andreessen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;封装基础架构并将其视为版本化的 API 将会非常强大。这极大地提高了负责解释表示的软件项目的速度。由平台提供的抽象是跟上快速增长的云所必需的。这种新模式是当今的模式，并且已经被证明可以扩展到难以估量的基础架构和应用程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从软件部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基础架构即代码和基础架构与软件之间的根本区别在于，软件能够改变数据存储，从而改变基础架构的表示。这是由软件来管理基础架构，代表是运营商和软件之间的交换。&lt;/p&gt;
&lt;p&gt;在例 3-4 中，我们看看使用 YAML 表示的基础架构。我们可以信任该软件来解释这种表示，并为呈现 YAML 的结果。&lt;/p&gt;
&lt;p&gt;就像与我们开发基础架构代码时一样，我们从基础架构的表示开始。但在这个例子中，软件会持续运行，并确保表示会随时间的推移。从某种意义上说，这仍然是只读的，但是软件可以扩展这个定义来添加自己的元信息，比如标记和资源创建时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 3-4. infrastructure.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;New York 1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;dns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fqdn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;172.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/12&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serverPools&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bootstrapScript&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/home/user/bootstrap.sh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;diskSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;40gb&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;firewalls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ingressFromPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressProtocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tcp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressToPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;minCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;centos-amd64-7&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subnets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;172.0.100.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/24&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;部署工具&#34;&gt;部署工具&lt;/h2&gt;
&lt;p&gt;我们现在了解部署基础架构的两个角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义基础架构的组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观众&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署工具解释表示并采取行动&lt;/p&gt;
&lt;p&gt;我们可以通过很多途径来表述基础架构，采取行动的组成部分是对最初表示的逻辑反映。准确地表示适当的基础架构层并尽可能消除该层的复杂性非常重要。通过简单、有针对性的发布，我们将能够更加准确地应用所需的更改。&lt;/p&gt;
&lt;p&gt;《站点可靠性工程》（O&amp;rsquo;Reilly，2016）总结说：“简单版本通常比复杂版本更好。衡量和理解单一变更的影响，而不是同时发布的一批变更要容易得多。“&lt;/p&gt;
&lt;p&gt;随着我们对基础架构的表示随着时间的推移而变化，以便从底层组件中抽象出来，我们的部署工具已经发生变化，以匹配新的抽象目标。&lt;/p&gt;
&lt;p&gt;我们正在将基础架构视为软件边界，并且可以注意到基础架构部署工具新时代的早期迹象。互联网上的开源项目正在出现，声称能够随着时间的推移管理基础架构。工程师的工作是了解项目管理的基础架构层以及它如何影响其现有工具和其他基础架构层。&lt;/p&gt;
&lt;p&gt;云原生基础架构方向的第一步是采用配置脚本并安排它们持续运行。有些工程师会故意设计这些脚本，以便随着时间的推移安排好。我们开始看到精心设计的全局锁定机制、高级调度策略和分布式调度方法。&lt;/p&gt;
&lt;p&gt;这基本上是配置管理承诺的，尽管在更具资源特定的抽象中。感谢云计算，管理基础架构的自动化脚本的日子已经过去了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自动化已死。&lt;/p&gt;
&lt;p&gt;——Honeycomb 首席执行官 Charity Majors&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们正在想象一个我们开始以完全不同的方式看待基础架构工具的世界。如果您的基础架构旨在运行在云上，那么 IaaS 不是您应该解决的问题。使用云提供的 API，并构建可直接由应用程序使用的新基础架构层。&lt;/p&gt;
&lt;p&gt;我们在基础架构发展方面处于特殊地位，我们从第一天开始就将基础架构部署工具设计为优雅的应用程序。&lt;/p&gt;
&lt;p&gt;良好的部署工具是可以快速从基础架构的人性化表示到可工作基础架构的工具。更好的部署工具是撤销任何与初始表示不一致的变更的工具。最好的部署工具可以完成所有这些工作，而无需人工参与。&lt;/p&gt;
&lt;p&gt;在我们构建这些应用程序时，我们不能忘记从处理复杂系统至关重要的专业工具和软件实践中学到的重要经验。&lt;/p&gt;
&lt;p&gt;我们将看到的部署工具的一些关键方面是幂等性和处理失败。&lt;/p&gt;
&lt;h3 id=&#34;幂等性&#34;&gt;幂等性&lt;/h3&gt;
&lt;p&gt;软件应该是幂等的，这意味着持续输入相同的输入，必须并始终获得相同的输出。&lt;/p&gt;
&lt;p&gt;在技术上，这个想法被超文本传输协议（HTTP）通过像 PUT 和 DELETE 这样的幂等方法而著名。这个想法飞非常强大，并且在软件中宣传幂等性的保证可以塑造出更佳复杂的软件应用程序。&lt;/p&gt;
&lt;p&gt;我们从早期的配置管理工具中学到的经验之一就是幂等性。我们需要记住这个功能为基础架构工程师提供的价值，并且继续将这种模式构建到我们的工具中。&lt;/p&gt;
&lt;p&gt;能够自动创建、更新或删除基础架构，保证无论您运行任务的频率如何，始终都会输出相同的结果，这非常令人兴奋。它允许运维人员开始自动化任务和杂事。过去对于运维人员来说，过去相当大量的工作现在可以像在网页中点击按钮一样简单。&lt;/p&gt;
&lt;p&gt;幂等保证也有助于运营商在其基础架构上执行质量科学。运营商可以在许多物理位置开始复制基础架构，并知道别人重复他们的程序会得到同样的结果。&lt;/p&gt;
&lt;p&gt;我们开始注意到围绕这种自动执行任意任务以实现可重复性的思想构建的整个框架和工具链。&lt;/p&gt;
&lt;p&gt;就像软件一样，基础架构也是如此。运营商开始使用这些表示和部署工具自动管理整个管理基础架构的流水线。现在，运维人员的工作变成了开发自动执行这些任务的工具，而不再是自己执行任务。&lt;/p&gt;
&lt;h3 id=&#34;处理失败&#34;&gt;处理失败&lt;/h3&gt;
&lt;p&gt;任何软件工程师都可以告诉你在代码中处理故障和边缘案例的重要性。作为基础架构管理员我们自然而然就要考虑这些问题。&lt;/p&gt;
&lt;p&gt;如果部署作业在执行过程中失败，更重要的是在这种情况下会发生什么，会发生什么情况？&lt;/p&gt;
&lt;p&gt;在考虑失败的情况下设计我们的部署工具是朝着正确方向迈出的又一步。失败时发送消息或在监控系统中注册警报。我们保存了自动化任务的详细日志。在失败的情况下，我们甚至将逻辑连接在一起。&lt;/p&gt;
&lt;p&gt;我们沉迷于失败。我们在失败的情况下开始采取行动，并在事件发生时采取行动。&lt;/p&gt;
&lt;p&gt;但围绕单个组件可能出现故障的想法来构建系统与构建组件以使其更容易出故障完全不同。根据故障重试组件或调整其方法是将系统的弹性进一步深入到软件中。这允许更稳定的系统并减少系统本身所需的整体支持。&lt;/p&gt;
&lt;p&gt;面向故障而设计组件，而不是系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最终一致性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以设计失败的组件为名，我们需要学习一个描述处理失败的常用方法的术语。&lt;/p&gt;
&lt;p&gt;最终的一致性意味着企图随着时间的推移调和一个系统。较大的系统和较小的组件都可以遵循这种随时间推移重试失败过程的理念。&lt;/p&gt;
&lt;p&gt;最终一致的系统的好处之一是运维人员可以确信它最终会达到预期的状态。这些系统的一个担忧是，有时他们可能花费不恰当的时间来达到所需的状态。&lt;/p&gt;
&lt;p&gt;知道什么时候选择一个稳定但缓慢的系统与一个不可靠但快速的系统是管理员必须做出的技术决策。在这个决定中要注意的重要关系是系统交换速度的可靠性。这并不容易，但如果有疑问，请始终选择可靠的系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与最终一致的系统相反的是原子系统，这是一项保证交易，决定了整个工作的成功。如果作业无法完成，则会恢复所做的更改并完全失败。&lt;/p&gt;
&lt;p&gt;想象一下需要创建 10 个虚拟机的工作。工作到达第七台虚拟机，出现问题。根据最终的一致性方法，我们只会反复尝试这项工作，希望最终获得 10 个虚拟机。&lt;/p&gt;
&lt;p&gt;了解我们只能创建 7 个虚拟机的原因非常重要。想象一下，云计算允许我们创建多少个虚拟机是有限制的。最终一致性模型将继续尝试创建另外三台机器，并且不可避免地会失败每次。&lt;/p&gt;
&lt;p&gt;如果这项工作是设计成原子的，那么它将在第七台机器上达到极限，并意识到这是一场灾难性的失败。这项工作将负责删除部分系统。&lt;/p&gt;
&lt;p&gt;因此，运维人员可以放心，他们或者完全按照预期建立系统，或者根本不会创建任何东西。这是一个很有意义的想法，因为为了能让系统正常工作，基础架构中的许多组件都依赖于系统中的其他部分。&lt;/p&gt;
&lt;p&gt;我们可以引入信心来换取不便。也就是说，管理员会相信他们的系统状态永远不会改变，除非可以应用完美的改变。为了交换这个完美的系统，运维人员可能会面临很大的不便，因为系统可能需要很多工作才能保持平稳运行。&lt;/p&gt;
&lt;p&gt;选择一个原子系统是安全的，但可能不是我们想要的。工程师需要知道他们想要什么系统，以及何时选择原子性与最终一致性。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;部署基础架构的模式很简单，并且在云可用之前一直保持不变。我们代表基础架构，然后使用一些设备，将基础架构变为现实。&lt;/p&gt;
&lt;p&gt;基础架构层与软件应用层具有惊人的类似历史。云原生基础架构也不例外。我们开始发现自己在重复历史，并以新的方式学习古老的教训。&lt;/p&gt;
&lt;p&gt;如果我们已经知道其软件对手的未来，那么对于预测基础架构行业未来的能力还有什么要说的？&lt;/p&gt;
&lt;p&gt;云原生基础架构是基础架构演变的一种自然而可能预期的结果。能够以可靠和可重复的方式部署、表示和管理它是必要的。随着时间的推移，我们能够部署我们的部署工具，并转移我们的工作方式，这对于将我们的基础架构保持在一个能够支持其应用层的空间中至关重要。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Envoy 的构建模块</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/envoy-building-blocks/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/envoy-building-blocks/</guid>
      <description>&lt;p&gt;在这一节中，我们将解释 Envoy 的基本构建模块。&lt;/p&gt;
&lt;p&gt;Envoy 配置的根被称为引导配置。它包含了一些字段，我们可以在这里提供静态或动态的资源和高级别的 Envoy 配置（例如，Envoy 实例名称、运行时配置、启用管理界面等等）。&lt;/p&gt;
&lt;p&gt;为了开始学习，我们将主要关注静态资源，在课程的后面，我们将介绍如何配置动态资源。&lt;/p&gt;
&lt;p&gt;Envoy 输出许多统计数据，这取决于启用的组件和它们的配置。我们会在整个课程中提到不同的统计信息，在课程后面的专门模块中，我们会更多地讨论统计信息。&lt;/p&gt;
&lt;p&gt;下图显示了通过这些概念的请求流。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-envoy-构建块&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jimmysong.io/envoy-handbook/images/008i3skNly1gz9kd0lwv0j31hc0u0my9.jpg&#34; alt=&#34;Envoy 构建块&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Envoy 构建块
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这一切都从监听器开始。Envoy 暴露的监听器是命名的网络位置，可以是一个 IP 地址和一个端口，也可以是一个 Unix 域套接字路径。Envoy 通过监听器接收连接和请求。考虑一下下面的 Envoy 配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;static_resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;listener_0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;filter_chains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;{}&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过上面的 Envoy 配置，我们在  0.0.0.0 地址的 10000 端口上声明了一个名为 listener_0 的监听器。这意味着 Envoy 正在监听 0.0.0.0:10000 的传入请求。&lt;/p&gt;
&lt;p&gt;每个监听器都有不同的部分需要配置。然而，唯一需要的设置是地址。上述配置是有效的，你可以用它来运行 Envoy—— 尽管它没有用，因为所有的连接都会被关闭。&lt;/p&gt;
&lt;p&gt;我们让 filter_chains 字段为空，因为在接收数据包后不需要额外的操作。&lt;/p&gt;
&lt;p&gt;为了进入下一个构件（路由），我们需要创建一个或多个网络过滤器链（filter_chains），至少要有一个过滤器。&lt;/p&gt;
&lt;p&gt;网络过滤器通常对数据包的有效载荷进行操作，查看有效载荷并对其进行解析。例如，Postgres 网络过滤器解析数据包的主体，检查数据库操作的种类或其携带的结果。&lt;/p&gt;
&lt;p&gt;Envoy 定义了三类过滤器：监听器过滤器、网络过滤器和 HTTP 过滤器。监听器过滤器在收到数据包后立即启动，通常对数据包的头信息进行操作。监听器过滤器包括代理监听器过滤器（提取 PROXY 协议头），或 TLS 检查器监听器过滤器（检查流量是否为 TLS，如果是，则从 TLS 握手中提取数据）。&lt;/p&gt;
&lt;p&gt;每个通过监听器进来的请求可以流经多个过滤器。我们还可以写一个配置，根据传入的请求或连接属性选择不同的过滤器链。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-过滤器链&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jimmysong.io/envoy-handbook/images/008i3skNly1gz9kd15t7tj318r0u0go4.jpg&#34; alt=&#34;过滤器链&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      过滤器链
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一个特殊的、内置的网络过滤器被称为 &lt;strong&gt;HTTP 连接管理器&lt;/strong&gt;过滤器（HTTP Connection Manager Filter）或 &lt;strong&gt;HCM&lt;/strong&gt;。HCM 过滤器能够将原始字节转换为 HTTP 级别的消息。它可以处理访问日志，生成请求 ID，操作头信息，管理路由表，并收集统计数据。我们将在以后的课程中对 HCM 进行更详细的介绍。&lt;/p&gt;
&lt;p&gt;就像我们可以为每个监听器定义多个网络过滤器（其中一个是 HCM）一样，Envoy 也支持在 HCM 过滤器中定义多个 HTTP 级过滤器。我们可以在名为 &lt;code&gt;http_filters&lt;/code&gt; 的字段下定义这些 HTTP 过滤器。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-hcm-过滤器&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jimmysong.io/envoy-handbook/images/008i3skNly1gz9kd0buajj31hc0u0mza.jpg&#34; alt=&#34;HCM 过滤器&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      HCM 过滤器
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;HTTP 过滤器链中的最后一个过滤器必须是路由器过滤器（&lt;code&gt;envoy.filters.HTTP.router&lt;/code&gt;）。路由器过滤器负责执行路由任务。这最终把我们带到了第二个构件 —— &lt;strong&gt;路由&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们在 HCM 过滤器的 &lt;code&gt;route_config&lt;/code&gt; 字段下定义路由配置。在路由配置中，我们可以通过查看元数据（URI、Header 等）来匹配传入的请求，并在此基础上，定义流量的发送位置。&lt;/p&gt;
&lt;p&gt;路由配置中的顶级元素是虚拟主机。每个虚拟主机都有一个名字，在发布统计数据时使用（不用于路由），还有一组被路由到它的域。&lt;/p&gt;
&lt;p&gt;让我们考虑下面的路由配置和域的集合。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;route_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my_route_config&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;virtual_hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tetrate_hosts&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;domains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;tetrate.io&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;test_hosts&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;domains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;test.tetrate.io&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;qa.tetrate.io&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果传入请求的目的地是 &lt;code&gt;tetrate.io&lt;/code&gt;（即 &lt;code&gt;Host/Authority&lt;/code&gt; 标头被设置为其中一个值），则 &lt;code&gt;tetrate_hosts &lt;/code&gt; 虚拟主机中定义的路由将得到处理。&lt;/p&gt;
&lt;p&gt;同样，如果 &lt;code&gt;Host/Authority&lt;/code&gt; 标头包含 &lt;code&gt;test.tetrate.io&lt;/code&gt; 或 &lt;code&gt;qa.tetrate.io&lt;/code&gt;，&lt;code&gt;test_hosts&lt;/code&gt; 虚拟主机下的路由将被处理。使用这种设计，我们可以用一个监听器（&lt;code&gt;0.0.0.0:10000&lt;/code&gt;）来处理多个顶级域。&lt;/p&gt;
&lt;p&gt;如果你在数组中指定多个域，搜索顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;精确的域名（例如：&lt;code&gt;tetrate.io&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;后缀域名通配符（如 &lt;code&gt;*.tetrate.io）&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;前缀域名通配符（例如：&lt;code&gt;tetrate.*&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;匹配任何域的特殊通配符（&lt;code&gt;*&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Envoy 匹配域名后，是时候处理所选虚拟主机中的 &lt;code&gt;routes&lt;/code&gt; 字段了。这是我们指定如何匹配一个请求，以及接下来如何处理该请求（例如，重定向、转发、重写、发送直接响应等）的地方。&lt;/p&gt;
&lt;p&gt;我们来看看一个例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;static_resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;listener_0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;filter_chains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;filters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.filters.network.http_connection_manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;typed_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;@type&amp;#34;: &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stat_prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;hello_world_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http_filters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.filters.http.router&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my_first_route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;virtual_hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;direct_response_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;domains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;direct_response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;inline_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;yay&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配置的顶部部分与我们之前看到的一样。我们已经添加了 HCM 过滤器、统计前缀（&lt;code&gt;hello_world_service&lt;/code&gt;）、单个 HTTP 过滤器（路由器）和路由配置。&lt;/p&gt;
&lt;p&gt;在虚拟主机内，我们要匹配任何域名。在 &lt;code&gt;routes&lt;/code&gt; 下，我们匹配前缀（&lt;code&gt;/&lt;/code&gt;），然后我们可以发送一个响应。&lt;/p&gt;
&lt;p&gt;当涉及到匹配请求时，我们有多种选择。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;路由匹配&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前缀必须与&lt;code&gt;:path&lt;/code&gt; 头的开头相符。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/hello&lt;/code&gt; 与 &lt;code&gt;hello.com/hello&lt;/code&gt;、&lt;code&gt;hello.com/helloworld&lt;/code&gt; 和 &lt;code&gt;hello.com/hello/v1&lt;/code&gt; 匹配。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;path&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;路径必须与&lt;code&gt;:path&lt;/code&gt; 头完全匹配。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/hello &lt;/code&gt;匹配 &lt;code&gt;hello.com/hello&lt;/code&gt;，但不匹配 &lt;code&gt;hello.com/helloworld &lt;/code&gt;或 &lt;code&gt;hello.com/hello/v1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;safe_regex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所提供的正则表达式必须与&lt;code&gt;:path&lt;/code&gt; 头匹配。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/\{3}&lt;/code&gt; 匹配任何以 &lt;code&gt;/&lt;/code&gt; 开头的三位数。例如，与 &lt;code&gt;hello.com/123&lt;/code&gt; 匹配，但不能匹配 &lt;code&gt;hello.com/hello&lt;/code&gt; 或 &lt;code&gt;hello.com/54321。&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;connect_matcher&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配器只匹配 CONNECT 请求。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一旦 Envoy 将请求与路由相匹配，我们就可以对其进行路由、重定向或返回一个直接响应。在这个例子中，我们通过 &lt;code&gt;direct_response&lt;/code&gt; 配置字段使用&lt;strong&gt;直接响应&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你可以把上述配置保存到 &lt;code&gt;envoy-direct-response.yaml&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;我们将使用一个名为 &lt;a href=&#34;https://func-e.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;func-e&lt;/a&gt; 的命令行工具。func-e 允许我们选择和使用不同的 Envoy 版本。&lt;/p&gt;
&lt;p&gt;我们可以通过运行以下命令下载 func-e CLI。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl https://func-e.io/install.sh &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo bash -s -- -b /usr/local/bin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们用我们创建的配置运行 Envoy。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func-e run -c envoy-direct-response.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一旦 Envoy 启动，我们就可以向 &lt;code&gt;localhost:10000&lt;/code&gt; 发送一个请求，以获得我们配置的直接响应。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl localhost:10000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;yay
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样，如果我们添加一个不同的主机头（例如 &lt;code&gt;-H &amp;quot;Host: hello.com&amp;quot;&lt;/code&gt;）将得到相同的响应，因为 &lt;code&gt;hello.com&lt;/code&gt; 主机与虚拟主机中定义的域相匹配。&lt;/p&gt;
&lt;p&gt;在大多数情况下，从配置中直接发送响应是一个很好的功能，但我们会有一组端点或主机，我们将流量路由到这些端点或主机。在 Envoy 中做到这一点的方法是通过定义&lt;strong&gt;集群&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;集群（Cluster）是一组接受流量的上游类似主机。这可以是你的服务所监听的主机或 IP 地址的列表。&lt;/p&gt;
&lt;p&gt;例如，假设我们的 hello world 服务是在 &lt;code&gt;127.0.0.0:8000&lt;/code&gt; 上监听。然后，我们可以用一个单一的端点创建一个集群，像这样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;clusters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;hello_world_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;load_assignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;hello_world_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lb_endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;集群的定义与监听器的定义在同一级别，使用 &lt;code&gt;clusters&lt;/code&gt; 字段。我们在路由配置中引用集群时，以及在导出统计数据时，都会使用集群。该名称在所有集群中必须是唯一的。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;load_assignment&lt;/code&gt; 字段下，我们可以定义要进行负载均衡的端点列表，以及负载均衡策略设置。&lt;/p&gt;
&lt;p&gt;Envoy 支持多种负载均衡算法（round-robin、Maglev、least-request、random），这些算法是由静态引导配置、DNS、动态 xDS（CDS 和 EDS 服务）以及主动 / 被动健康检查共同配置的。如果我们没有通过 &lt;code&gt;lb_policy&lt;/code&gt; 字段明确地设置负载均衡算法，它默认为 round-robin。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;endpoints&lt;/code&gt; 字段定义了一组属于特定地域的端点。使用可选的 &lt;code&gt;locality&lt;/code&gt; 字段，我们可以指定上游主机的运行位置，然后在负载均衡过程中使用（即，将请求代理到离调用者更近的端点）。&lt;/p&gt;
&lt;p&gt;添加新的端点指示负载均衡器在一个以上的接收者之间分配流量。通常情况下，负载均衡器对所有端点一视同仁，但集群定义允许在端点内建立一个层次结构。&lt;/p&gt;
&lt;p&gt;例如，端点可以有一个 &lt;strong&gt;权重（weight）&lt;/strong&gt; 属性，这将指示负载均衡器与其他端点相比，向这些端点发送更多 / 更少的流量。&lt;/p&gt;
&lt;p&gt;另一种层次结构类型是基于&lt;strong&gt;地域性的（locality）&lt;/strong&gt;，通常用于定义故障转移架构。这种层次结构允许我们定义地理上比较接近的 &amp;ldquo;首选&amp;rdquo; 端点，以及在 &amp;ldquo;首选&amp;rdquo; 端点变得不健康的情况下应该使用的 &amp;ldquo;备份&amp;rdquo; 端点。&lt;/p&gt;
&lt;p&gt;由于我们只有一个端点，所以我们还没有设置 locality。在 &lt;code&gt;lb_endpoints&lt;/code&gt; 字段下，可以定义 Envoy 可以路由流量的实际端点。&lt;/p&gt;
&lt;p&gt;我们可以在 Cluster 中配置以下可选功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动健康检查（&lt;code&gt;health_checks&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;断路器 (&lt;code&gt;circuit_breakers&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;异常点检测（&lt;code&gt;outlier_detection&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在处理上游的 HTTP 请求时有额外的协议选项&lt;/li&gt;
&lt;li&gt;一组可选的网络过滤器，应用于所有出站连接等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和监听器的地址一样，端点地址可以是一个套接字地址，也可以是一个 Unix 域套接字。在我们的例子中，我们使用一个套接字地址，并在 &lt;code&gt;127.0.0.1:8000&lt;/code&gt; 为我们的服务定义端点。一旦选择了端点，请求就会被代理到该端点的上游。&lt;/p&gt;
&lt;p&gt;让我们看看我们定义的集群是如何与其他配置结合起来的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;static_resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;listener_0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;filter_chains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;filters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.filters.network.http_connection_manager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;typed_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;#34;@type&amp;#34;: &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;stat_prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;hello_world_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http_filters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;envoy.filters.http.router&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route_config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;my_first_route&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;virtual_hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;direct_response_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;domains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;routes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;hello_world_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;clusters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;hello_world_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connect_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;5s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;load_assignment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;hello_world_service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;lb_endpoints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;socket_address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们已经添加了集群配置，我们没有使用 &lt;code&gt;direct_response&lt;/code&gt;，而是使用 &lt;code&gt;routes&lt;/code&gt; 字段并指定集群名称。&lt;/p&gt;
&lt;p&gt;为了尝试这种配置，让我们在 &lt;code&gt;8000&lt;/code&gt; 端口启动一个 hello-world Docker 镜像。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker run -dit -p 8000:3000 gcr.io/tetratelabs/hello-world:1.0.0 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以向 &lt;code&gt;127.0.0.1:8000&lt;/code&gt; 发送一个请求，以检查我们是否得到 &amp;ldquo;Hello World&amp;rdquo; 的响应。&lt;/p&gt;
&lt;p&gt;接下来，让我们把上述 Envoy 配置保存到 &lt;code&gt;envoy-clusters.yaml中&lt;/code&gt;，并启动 Envoy 代理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func-e run -c envoy-cluster.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 Envoy 代理启动时，向 &lt;code&gt;0.0.0.0:10000&lt;/code&gt; 发送一个请求，让 Envoy 代理请求到 hello world 端点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ curl -v 0.0.0.0:10000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; GET / HTTP/1.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; Host: localhost:10000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; User-Agent: curl/7.64.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; Accept: */*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; HTTP/1.1 &lt;span class=&#34;m&#34;&gt;200&lt;/span&gt; OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; date: Wed, &lt;span class=&#34;m&#34;&gt;30&lt;/span&gt; Jun &lt;span class=&#34;m&#34;&gt;2021&lt;/span&gt; 23:53:47 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; content-length: &lt;span class=&#34;m&#34;&gt;11&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; content-type: text/plain&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;charset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;utf-8
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; x-envoy-upstream-service-time: &lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt; server: envoy
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;* Connection &lt;span class=&#34;c1&#34;&gt;#0 to host localhost left intact&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello World
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从冗长的输出中，我们会注意到由 Envoy 代理设置的响应头 &lt;code&gt;x-envoy-upstream-service-time&lt;/code&gt; 和 &lt;code&gt;server: envoy&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 4 章：设计基础架构应用程序</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/designing-infrastructure-applicaitons/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/designing-infrastructure-applicaitons/</guid>
      <description>&lt;p&gt;在前一章中，我们了解了基础架构的各种表示以及围绕其部署工具的各种方法。在本章中，我们将看看如何设计部署和管理基础架构的应用程序。在上一章中我们重点关注基础架构即软件的开放世界，有时称为基础架构即应用。&lt;/p&gt;
&lt;p&gt;在云原生环境中，传统的基础架构运维人员需要转变为基础架构软件工程师。与过去的其他运维角色不同，这仍然是一种新兴的做法。我们迫切需要开始探索这种模式和制定标准。&lt;/p&gt;
&lt;p&gt;基础架构即软件与基础架构即代码之间的根本区别在于，软件会持续运行，并会根据调节器模式创建或改变基础架构，我们将在本章后面对其进行解释。此外，基础架构即软件的新范例是，软件现在与数据存储具有更传统的关系，并公开用于定义所需状态的API。例如，该软件可能会根据数据存储中的需要改变基础架构的表示形式，并且可以很好地管理数据存储本身！希望进行协调的状态更改通过API发送到软件，而不是通过运行静态代码库中的程序。&lt;/p&gt;
&lt;p&gt;迈向基础架构即软件的第一步是让基础架构的运维人员意识到自己是软件工程师。我们热烈欢迎您来到这个领域！先前的工具（例如配置管理）也有类似的改变基础架构运维人员的工作职能的目标，但是运维人员通常只会在狭窄的应用范围内编写有限的DSL（即单一节点抽象）。&lt;/p&gt;
&lt;p&gt;作为一名基础架构工程师，您的任务不仅是掌握设计、管理和运维基础架构的基本原则，还需要具有将您的专业知识封装成坚如磐石的应用程序的能力。这些应用程序代表了我们将要管理和改变的基础架构。&lt;/p&gt;
&lt;p&gt;构建管理基础架构软件工程不是一件容易的事情。我们有管理传统应用的所有问题和担忧，而且我们正处于一个尴尬的境地。基础架构软件工程看上去似乎很荒谬，构建软件来部署基础架构，这样就可以在新创建的基础架构之上运行相同的软件，这很尴尬。&lt;/p&gt;
&lt;p&gt;首先，我们需要了解这个新领域中工程软件的细微差别。我们将研究在云原生社区中得到验证的模式，以了解在应用程序中编写干净和逻辑代码的重要性。但首先，基础架构从哪里来？&lt;/p&gt;
&lt;h2 id=&#34;自举问题&#34;&gt;自举问题&lt;/h2&gt;
&lt;p&gt;1987年3月22日，周日，Richard M. Stallman发送了一封电子邮件到GCC邮件列表，报告成功使用C编译器完成了自行编译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该编译器在68020上编译正确，最近又在vax上进行了编译。最近在68020上正确编译了Emacs，并且还编译了tex-in-C和Kyoto Common Lisp。但是，可能仍然有许多错误，希望你能帮我找到。&lt;/p&gt;
&lt;p&gt;我将离开一个月，所以现在报告的错误将得不到处理。——Richard M. Stallman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是软件历史上的一个重要转折点，因为工程软件首次完成了自举（Bootstrap）。Stallman开创了一个可以自行编译的编译器。即使在哲学上接受这个表述可能也是困难的。&lt;/p&gt;
&lt;p&gt;今天我们正在解决与基础架构相同的问题。工程师必须想办法解决几乎不可能的系统自举问题，并在运行时生效。&lt;/p&gt;
&lt;p&gt;有一种方法是手动创建云计算和基础架构应用程序中的第一个基础架构。尽管这种方法确实有效，但它通常伴随着警告，即运维人员应该在部署更合适的基础架构后销毁初始引导基础架构。这种方法乏味、难以重复且容易出现人为错误。&lt;/p&gt;
&lt;p&gt;解决这个问题的更优雅和云原生方法是做出（通常是正确的）假设，即试图引导基础架构软件的任何人都有本地机器，我们可以利用这个本地机器。现有机器（您的计算机）可作为第一个部署工具，自动在云中创建基础架构。基础架构就位后，您的本地部署工具可以将其自身部署到新创建的基础架构并持续运行。良好的部署工具可以让你在完成后轻松清理。&lt;/p&gt;
&lt;p&gt;在初始基础架构引导问题解决后，我们可以使用基础架构应用程序来引导新的基础架构。现在本地计算机已经被排除在外，现在我们完全运行在云端。&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;在前面的章节中，我们讨论了表示基础架构的各种方法。在本章中，我们将探讨为基础架构提供API的概念。&lt;/p&gt;
&lt;p&gt;当用软件实现API时，很可能会通过数据结构来完成。因此，根据您使用的编程语言，将API视为类、字典、数组、对象或结构体是安全的。&lt;/p&gt;
&lt;p&gt;API将是数据值的任意定义，可能是字符串、整数或布尔值。API将通过JSON或YAML格式进行编码和解码甚至可能存储在数据库中。&lt;/p&gt;
&lt;p&gt;对于大多数软件工程师来说，为程序提供可版本化的API是很常见的做法。这允许程序随着时间移动、改变和增长。工程师可以声称支持较旧的API版本并提供向后兼容性保证。在基础架构即软件中，由于这些原因，使用API是首选的。&lt;/p&gt;
&lt;p&gt;寻找一个API作为基础架构的接口是用户使用基础架构即软件的许多线索之一。传统上，基础架构即代码是用户将要管理的基础架构的直接表示，而API是对要管理的具体底层资源之上的抽象。&lt;/p&gt;
&lt;p&gt;最终，API只是代表基础架构的数据结构。&lt;/p&gt;
&lt;h2 id=&#34;状态&#34;&gt;状态&lt;/h2&gt;
&lt;p&gt;在基础架构即软件工具的环境中，我们要管理的对象是基础架构。因此，对象状态只是我们的程序对软件的审计表示。&lt;/p&gt;
&lt;p&gt;对象的状态最终将回到基础架构表示的内存中。这些内存中的表示应映射到用于声明基础架构的原始API。审计的API或对象状态通常需要保存。&lt;/p&gt;
&lt;p&gt;存储介质（有时称为状态存储）可用于存储新审计的API。介质可以是任何传统存储系统，例如本地文件系统、云对象存储或数据库。如果数据存储在类似文件系统的存储中，那么该工具将很可能以逻辑方式对数据进行编码，以便可以在运行时轻松对数据进行编码和解码。常见的编码包括JSON、YAML和TOML。&lt;/p&gt;
&lt;p&gt;当设计程序时您可能会想要将用于存储其他数据的特权信息存储起来。这究竟是不是最佳实践具体取决于您的安全性要求以及您计划存储数据的位置。&lt;/p&gt;
&lt;p&gt;记住存储机密可能是一个漏洞，这一点很重要。在设计软件来控制堆栈最基本的部分时，安全性至关重要。所以通常值得额外的努力来确保机密信息是安全的。&lt;/p&gt;
&lt;p&gt;除了存储有关程序和云提供商凭证的元信息之外，工程师还需要存储有关基础架构的信息。重要的是要记住，基础架构将以某种方式呈现，理想情况下，该程序易于解码。记住对系统进行更改不会立即发生，而随着时间的推移也很重要。&lt;/p&gt;
&lt;p&gt;存储这些数据并能够轻松访问是设计基础架构管理应用程序的重要部分。仅基础架构定义很可能就已经是系统中最具智慧价值的部分。我们来看一个基本的例子，看看这些数据和程序如何一起工作。&lt;/p&gt;
&lt;p&gt;重新审视例4-1至4-4，因为它们被用作本章进一步演示的具体例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件系统状态存储示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想象一下，数据存储在一个名为state的目录中。在该目录中，有三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;meta_information.yaml&lt;/li&gt;
&lt;li&gt;secrets.yaml&lt;/li&gt;
&lt;li&gt;infrastructure.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个简单的数据存储可以准确地封装需要保留的信息，以便有效管理基础架构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;secrets.yaml&lt;/code&gt;和&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件存储基础架构的表示形式，&lt;code&gt;meta_information.yaml&lt;/code&gt;文件（示例4-1）存储其他重要信息，例如基础架构上次调配时间，调配时间和日志信息。&lt;/p&gt;
&lt;p&gt;例4-1. state/meta_information.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;lastExecution&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exitCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;timestamp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;ld&#34;&gt;2017-08-01 15:32:11 +00&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;00&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kris&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;logFile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/log/infra.log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二个文件&lt;code&gt;secrets.yaml&lt;/code&gt;保存私人信息，用于在程序执行过程中以任意方式验证（例4-2）。&lt;/p&gt;
&lt;p&gt;重申一下，以这种方式存储机密可能是不安全的。我们仅以&lt;code&gt;secrets.yaml&lt;/code&gt;为例。&lt;/p&gt;
&lt;p&gt;例4-2. state/secrets.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiAccessToken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;a8233fc28d09a9c27b2e2f&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiSecret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;8a2976744f239eaa9287f83b23309023d&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;privateKeyPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;~/.ssh/id_rsa&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第三个文件&lt;code&gt;infrastructure.yaml&lt;/code&gt;将包含API的编码表示形式，包括使用的API版本（示例4-3）。我们可以在这里找到基础架构表示，例如网络和DNS信息，防火墙规则和虚拟机定义。&lt;/p&gt;
&lt;p&gt;例4-3. state/infrastructure.yaml&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;San Francisco 2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;dns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fqdn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/12&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serverPools&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bootstrapScript&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/opt/infra/bootstrap.sh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;diskSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;large&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subnetHostsCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;firewalls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ingressFromPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressProtocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tcp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressToPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ubuntu-16-04-x64&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;起初&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件可能看起来只不过是基础架构代码的一个例子。但是，如果仔细观察，您会发现许多定义的指令都是具体基础架构之上的抽象。例如，&lt;code&gt;subnetHostsCount&lt;/code&gt;指令是一个整数值并定义了子网中主机的预定数量。该程序将设法为运维人员划分网络中定义的更大的无类别域间路由（CIDR）值。运维人员不会声明子网，只需要声明有多少主机。软件会帮运维人员完成剩下的操作。&lt;/p&gt;
&lt;p&gt;程序运行时可能会更新API并将新的表示写入数据存储区（本案例中仅是一个文件）。继续我们的&lt;code&gt;subnetHostsCount&lt;/code&gt;示例，假设程序确实为我们挑选了一个子网CIDR。新的数据结构可能如例4-4所示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;San Francisco 2&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;dns&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fqdn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;infra.example.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;network&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/12&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serverPools&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;bootstrapScript&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/opt/infra/bootstrap.sh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;diskSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;large&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;workload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;medium&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subnetHostsCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;assignedSubnetCIDR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.0.100.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/24&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;firewalls&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ingressFromPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressProtocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tcp&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingressToPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ubuntu-16-04-x64&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意程序如何编写assignedSubnetCIDR指令，而不是由运维人员操作。另外，请记住应用程序如何更新API是用户以软件方式与基础架构进行交互的标志。&lt;/p&gt;
&lt;p&gt;现在，请记住，这只是一个例子，并不一定主张使用抽象计算子网CIDR。不同的用例可能需要在应用程序中进行不同的抽象和实现。关于构建基础架构应用程序的一个好处是，用户可以以任何他们认为可以解决自己问题的方式设计软件。&lt;/p&gt;
&lt;p&gt;数据存储（&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件）现在可以被认为是软件工程领域的传统数据存储。也就是说，该程序可以对文件进行完全的写入控制。&lt;/p&gt;
&lt;p&gt;我们会发现，这会带来风险，但对工程师来说也是一个巨大的胜利。基础架构表示不必存储在文件系统的文件中。相反，它可以存储在任何数据存储中，如传统数据库或键/值存储系统。&lt;/p&gt;
&lt;p&gt;为了理解软件如何处理这种新的基础架构表示的复杂性，我们必须理解系统中的两种状态——API形式的预期状态，可在&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件中找到，另一种可以在现实（或审计）中观察到的实际状态。&lt;/p&gt;
&lt;p&gt;在这个例子中，软件还没有做任何事情或者采取任何行动，而我们正处于管理时间线的开始。因此，实际状态将是什么都没有，而预期状态将是封装在&lt;code&gt;infrastructure.yaml&lt;/code&gt;文件中的任何状态。&lt;/p&gt;
&lt;h2 id=&#34;调节器模式&#34;&gt;调节器模式&lt;/h2&gt;
&lt;p&gt;调节器模式（reconciler pattern）是一种软件模式，可用于管理云原生基础架构。该模式强化了基础架构的两种表现形式——第一种是基础架构的实际状态，第二种是基础架构的预期状态。&lt;/p&gt;
&lt;p&gt;调节器模式将迫使工程师以两个独立的途径忘记这些表示，以及实现一个解决方案，以协调实际状态达到预期状态。&lt;/p&gt;
&lt;p&gt;调节器模式可以被认为是一套四种方法和四种哲学规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的输入和输出都使用数据结构。&lt;/li&gt;
&lt;li&gt;确保数据结构是不可变的。&lt;/li&gt;
&lt;li&gt;保持资源映射简单。&lt;/li&gt;
&lt;li&gt;使实际状态符合预期状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些模式的消费者可以依靠这些强大的保证。此外，他们将消费者从实施细节中解放出来。&lt;/p&gt;
&lt;h3 id=&#34;规则1为所有输入和输出使用数据结构&#34;&gt;规则1：为所有输入和输出使用数据结构&lt;/h3&gt;
&lt;p&gt;实现调节器模式的方法只能接受和返回数据结构。结构必须在调节器实现的上下文之外定义，但实现必须知道它。&lt;/p&gt;
&lt;p&gt;通过仅接受用于输入的数据结构并将其作为输出返回，消费者可以协调其数据存储中定义的任何结构，而不必担心该协调如何发生。这也允许在运行时或者程序的不同版本中改变、修改或切换实现。&lt;/p&gt;
&lt;p&gt;尽管我们希望尽可能经常遵守第一条规则，但是永远不要将数据结构和代码库紧密结合也非常重要。始终遵守最佳的抽象和分离实践，绝不使用API的子集来传递函数或类。&lt;/p&gt;
&lt;h3 id=&#34;规则2确保数据结构不可变&#34;&gt;规则2：确保数据结构不可变&lt;/h3&gt;
&lt;p&gt;考虑像合同或担保这样的数据结构。在调节器模式的上下文中，实际和期望的结构在运行时设置在内存中。这保证了在调节之前结构是准确的。在协调基础架构的过程中，如果结构发生变化，则必须创建一个具有相同保证的新结构。明智的基础架构应用程序将强制数据结构的不变性，即使工程师试图改变数据结构，它也不会工作，或者程序会出错（甚至可能会编译不过）。&lt;/p&gt;
&lt;p&gt;基础架构应用程序的核心组件是将表示映射到一组资源的能力。资源是需要运行以满足基础架构要求的单个任务。这些任务中的每一个都将负责以某种方式更改基础架构。&lt;/p&gt;
&lt;p&gt;部署新虚拟机是基本示例，设置新网络或配置现有虚拟机。这些工作单元中的每一个都将被称为资源。每个数据结构都应映射到一定数量的资源。应用程序负责推理结构并创建资源集。图4-1中显示了API映射到单个资源的示例。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图4-1-将结构映射到资源的图表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-4-1.jpg&#34; alt=&#34;图4-1. 将结构映射到资源的图表&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图4-1. 将结构映射到资源的图表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;调节器模式演示了一种处理数据结构的稳定方法，因为它会改变资源。由于调节器模式需要比较资源状态，所以数据结构必须是不可变的。这意味着无论何时需要更新数据结构，都必须创建新的数据结构。&lt;/p&gt;
&lt;p&gt;注意基础架构的变化。每次发生突变时，实际的数据结构都是陈旧的。一个聪明的基础架构应用程序将意识到这个问题并相应地处理它。&lt;/p&gt;
&lt;p&gt;一种简单的解决方案是在发生突变时更新内存中的数据结构。如果每次突变都更新实际状态，则可以观察调节过程，因为实际状态会随时间经历一系列更改，直到最终匹配预期状态并且调节完成。&lt;/p&gt;
&lt;h3 id=&#34;规则3保持资源映射简单&#34;&gt;规则3：保持资源映射简单&lt;/h3&gt;
&lt;p&gt;在调节者的幕后，这个模式就是一个实现。一个实现只是一组代码，具有创建、修改和删除基础结构的方法。一个程序可能有很多实现。&lt;/p&gt;
&lt;p&gt;每个实现最终都需要将数据结构映射到一组资源。这组资源需要按逻辑方式组合在一起，以便程序可以推断每个资源。&lt;/p&gt;
&lt;p&gt;除了创建资源的基本模型之外，您必须非常注意每个资源的依赖关系。许多资源依赖于其他资源，这意味着许多基础架构都依赖于其他部分。例如，在将虚拟机放入网络之前，网络需要存在。&lt;/p&gt;
&lt;p&gt;调节器模式规定应该使用用于分组资源的最简单的数据结构。&lt;/p&gt;
&lt;p&gt;解决资源映射问题是一个工程决策，每个实现都可能会发生变化。仔细挑选数据结构非常重要，因为从工程角度看，调节器需要稳定且易于理解。&lt;/p&gt;
&lt;p&gt;映射数据的两种常见结构是集合和图形。&lt;/p&gt;
&lt;p&gt;一组是可以迭代的资源的平面列表。在许多编程语言中，这些被称为列表、集合、数组等。&lt;/p&gt;
&lt;p&gt;图形是通过指针链接在一起的顶点（vertex）的集合。根据编程语言，图的顶点通常是结构或类。顶点通过在顶点某处定义的指针有一个到另一个顶点的链接。图形实现可以通过指针从一个跳到另一个来访问每个顶点。&lt;/p&gt;
&lt;p&gt;例4-5是Go编程语言中一个基本顶点的例子。&lt;/p&gt;
&lt;p&gt;例4-5. 示例顶点&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Vertex是表示图中单点的数据结构。一个Vertex可以有N个子点或一个也没有。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Vertex&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Children&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Vertex&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;遍历图的例子可能像迭代遍历每个子元素一样简单。这种遍历有时被称为“walking the graph”。&lt;/p&gt;
&lt;p&gt;例4-6是通过Go中写入的深度优先遍历递归访问图中每个顶点的示例。&lt;/p&gt;
&lt;p&gt;例4-6. 深度优先遍历&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// recursiveWalk将递归地挖掘所有子级，并相应地搜索其子级，并将当前正在访问的顶点的名称回显到STDOUT。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;recursiveWalk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Vertex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Currently visiting vertex: %s\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Children&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;recursiveWalk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先，图的简单实现似乎是解决资源图的合理选择，因为可以通过逻辑方式构建图来处理依赖关系。虽然图会起作用，但它也会带来风险和复杂性。实施图来绘制资源的最大风险是在图中有环。一个循环是当一个图的一个顶点通过一条以上的路径指向另一个顶点时，这意味着遍历该图是一个无止境的操作。&lt;/p&gt;
&lt;p&gt;必要时可以使用图，但在大多数情况下，调节器模式应该映射一组资源，而不是图。通过使用一个集合，调节器可以程序化地遍历资源，并提供线性方法来解决映射问题。此外，撤销或删除基础架构的过程与通过反向遍历集合一样简单。&lt;/p&gt;
&lt;h3 id=&#34;规则4使实际状态符合预期状态&#34;&gt;规则4：使实际状态符合预期状态&lt;/h3&gt;
&lt;p&gt;协调器模式中提供的保证是，用户可以准确得到预期的结果或错误。这是使用调节器的工程师可以依赖的保证。这很重要，因为消费者不必担心验证调节人突变是幂等的并且按预期结束。实现最终负责解决此问题。有了这种保证，在更复杂的操作中使用调节器模式，如控制器或operator，现在变得更加简单。&lt;/p&gt;
&lt;p&gt;在返回调用代码之前，实现应检查新调节的实际数据结构是否与最初预期的数据结构匹配。如果没有，它应该是错误的。消费者不应该关心验证API，并且应该相信如果出现问题调节器会报错。&lt;/p&gt;
&lt;p&gt;因为数据结构是不可变的，并且如果协调器模式不成功，API也会出错，因此我们可以高度信任API。对于复杂的系统，重要的是，您必须相信软件可以以可预测的方式工作或失败。&lt;/p&gt;
&lt;h2 id=&#34;调节器模式的方法&#34;&gt;调节器模式的方法&lt;/h2&gt;
&lt;p&gt;根据我们刚刚解释的调节器模式的信息和规则，让我们看看这些规则是如何实现的。我们将通过查看实现调节器模式的应用程序所需的方法来执行此操作。&lt;/p&gt;
&lt;p&gt;调节器模式的第一种方法是&lt;code&gt;GetActual()&lt;/code&gt;。这种方法有时称为审计，用于查询基础架构的实际状态。该方法通过生成资源映射，然后程序地调用每个资源以查看存在什么（如果有的话）。该方法将根据查询结果更新数据结构，并返回表示实际正在运行的程序状态以填充数据结构。&lt;/p&gt;
&lt;p&gt;一个更简单的方法&lt;code&gt;GetExpected()&lt;/code&gt;将从数据存储中读取对象的预期状态。在&lt;code&gt;infrastructure.yaml&lt;/code&gt;示例（例4-4）中，&lt;code&gt;GetExpected()&lt;/code&gt;将简单地解组这个YAML并将其以内存中的数据结构的形式返回。在这一步没有进行资源审计。&lt;/p&gt;
&lt;p&gt;最令人兴奋的方法是&lt;code&gt;Reconcile()&lt;/code&gt;方法，其中调节器实现将获得对象的实际状态和预期状态。&lt;/p&gt;
&lt;p&gt;这是调节器模式的意图驱动行为的核心。底层调节器实现将使用在&lt;code&gt;GetActual()&lt;/code&gt;中使用的相同资源映射逻辑来定义一组资源。然后协调执行将对这些资源进行操作，独立协调每一个资源。&lt;/p&gt;
&lt;p&gt;了解每个资源调节步骤的复杂性非常重要。调节器实现必须以两种方式工作。&lt;/p&gt;
&lt;p&gt;首先，从所需和实际状态获取资源属性。接下来，将更改应用到最小的一组属性，以使实际状态与所需的状态匹配。&lt;/p&gt;
&lt;p&gt;只要这两个基础架构的表示有冲突，调节器执行必须采取行动并改变基础架构。协调步骤完成后，调节器实施必须创建一个新的表示，然后转到下一个资源。在所有资源调和后，调节器实现将新的数据结构返回给接口的调用者。现在这个新的数据结构准确地代表了对象的实际状态，并应该保证它与原始的实际数据结构相匹配。&lt;/p&gt;
&lt;p&gt;调节器模式的最后一个方法是&lt;code&gt;Destroy()&lt;/code&gt;方法。&lt;code&gt;wordDestroy()&lt;/code&gt;是故意选择在&lt;code&gt;Delete()&lt;/code&gt;上的，因为我们希望工程师意识到该方法应该销毁基础架构，并且从不禁用它。&lt;code&gt;Destroy()&lt;/code&gt;方法的实现很简单。它使用与前面实现方法中定义的资源映射相同的资源映射，但仅对资源进行反向操作。&lt;/p&gt;
&lt;h3 id=&#34;go中的模式示例&#34;&gt;Go中的模式示例&lt;/h3&gt;
&lt;p&gt;例4-7是Go编程语言中定义的调节器模式的四种方法。&lt;/p&gt;
&lt;p&gt;如果你不了解Go，别担心。该模式可以很容易地用任何语言实现。我们只使用Go，因为它清楚地定义了每种方法的输入和输出类型。请阅读每种方法的注释，因为它定义了每种方法需要做什么以及何时应该使用。&lt;/p&gt;
&lt;p&gt;例4-7. 调节器模式接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 下面的reconciler接口是调节器模式的示例,每当用户打算根据可能随时间变化的状态来更改基础结构时，都应使用它。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Reconciler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// GetActual不接受输入参数。数据结构应包含基础架构的完整表示。有时称为审核。应该使用此方法来实时表示现有的基础架构。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;GetActual&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// GetExpected不接受输入参数，并返回一个填充的数据结构，该数据结构表示运维人员已声明存在的基础结构以及可能的错误。有时将其称为预期或预期状态。应该使用此方法来实时表示运维人员打算使用的基础结构。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;GetExpected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Reconcile有两个参数。actualApi是从GetActual方法返回的填充数据结构。 ExpectedApi是从GetExpected方法返回的填充数据结构。Reconcile将返回填充的数据结构，该数据结构表示新的“实际”状态以及可能的错误。根据定义，此处返回的数据结构应与从GetExpected方法返回的数据结构匹配。此方法负责对基础结构进行更改。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Reconcile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;actualApi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;expectedApi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Destroy有一个参数。actualApi是从GetActual方法返回的填充数据结构。Destroy将返回填充的数据结构，该数据结构表示新的“实际”状态以及可能的错误。根据定义，此处返回的数据结构应与从GetExpected方法返回的数据结构匹配。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Destroy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;actualApi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;审计关系&#34;&gt;审计关系&lt;/h2&gt;
&lt;p&gt;随着时间的推移，基础架构的最后一次审计变得陈旧，增加了我们对基础架构的表示不准确的风险。因此，折衷的办法是运维人员可以调整审计频率以确定基础架构表示的准确性。&lt;/p&gt;
&lt;p&gt;调节是隐式的审计。如果没有任何变化，调节器就什么也不用做，这一步就成为了审计，验证我们对基础架构的表示是否准确。&lt;/p&gt;
&lt;p&gt;此外，如果在我们的基础架构中碰巧发生了一些变化，调节器将检测到这一变化并尝试纠正它。在完成调节后，基础架构的状态将保证准确。因此，隐含地，我们再次审计了基础架构。&lt;/p&gt;
&lt;h2 id=&#34;配置管理中的审计和调节器模式&#34;&gt;配置管理中的审计和调节器模式&lt;/h2&gt;
&lt;p&gt;基础架构工程师可能熟悉来自配置管理工具的调节器模式，这些工具使用类似的方法来改变操作系统。配置管理工具通过一组资源来管理工程师定义的一组清单或配方。&lt;/p&gt;
&lt;p&gt;该工具将对系统采取行动以确保实际状态和所需状态匹配。如果没有更改，则执行简单审计以确保状态匹配。&lt;/p&gt;
&lt;p&gt;配置管理与云原生基础架构应用程序不同的原因是，配置管理传统上是抽象的单节点，并且不会创建或管理基础架构资源。&lt;/p&gt;
&lt;p&gt;一些配置管理工具正在将其在这个领域的使用扩展到一定程度的成功，但它们仍然属于基础架构类的代码范畴，而不是软件提供的基础架构的双向关系。&lt;/p&gt;
&lt;p&gt;轻量级和稳定的调节器实施可以产生强大的效果，并快速协调，从而为运维人员提供准确的基础架构表示的信心。&lt;/p&gt;
&lt;h3 id=&#34;在控制器中使用调节器模式&#34;&gt;在控制器中使用调节器模式&lt;/h3&gt;
&lt;p&gt;编排管理工具（如Kubernetes）为我们提供了一个可以方便地运行应用程序的平台。控制器是为预期状态提供控制回路。Kubernetes建立在这个基础之上。调节器模式可以很容易地审计和协调由Kubernetes控制的对象。&lt;/p&gt;
&lt;p&gt;想象一下在以下步骤中循环将无休止地流经调节器模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;GetExpected()&lt;/code&gt;并从数据存储中读取基础结构的预期状态。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;GetActual()&lt;/code&gt;并从环境中读取以获取基础结构的实际状态。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;Reconcile()&lt;/code&gt;并调和状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以这种方式实施调节器模式的程序将用作控制器。由于很容易看出控制器本身的程序必须有多小巧，因此该方案的优雅显而易见。&lt;/p&gt;
&lt;p&gt;此外，改变基础架构就像改变状态存储一样简单。控制器将在下次调用&lt;code&gt;GetExpected()&lt;/code&gt;时读取更改并触发协调。负责基础架构的运维人员可以放心，稳定可靠的循环在后台安静地运行，在基础架构环境中执行他的意愿。现在，运维人员通过管理应用来管理基础架构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;控制回路的目标搜寻行为非常稳定。Kubernetes已经证明了这一点，我们曾经发现过一些没有被注意到的错误，因为控制回路基本上是稳定的，并且会随着时间的推移而自行修正。&lt;/p&gt;
&lt;p&gt;如果您被边缘（edge）触发，则会冒着损害您的状态的风险，并且永远无法重新创建状态。如果您是水平（level）触发的，并为不正常的组件留出了空间，应予以纠正。 这就是使Kubernetes如此出色地工作的原因。&lt;/p&gt;
&lt;p&gt;——Joe Beda，Heptio公司首席技术官&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;销毁基础架构现在就像通知控制器我们希望销毁基础架构一样简单。这可以通过多种方式完成。一种方法是让控制器遵守禁用的状态文件。这可以通过从开启一个比特位反转来表示。&lt;/p&gt;
&lt;p&gt;另一种方式可能是删除状态的内容。无论运维人员如何选择发送&lt;code&gt;Destroy()&lt;/code&gt;信号，控制器都准备好调用&lt;code&gt;convenienceDestroy()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&#34;本章小结&#34;&gt;本章小结&lt;/h2&gt;
&lt;p&gt;基础架构工程师也是软件工程师，负责构建先进的高度分布式系统，在后台开发。他们必须编写管理他们负责的基础架构的软件。&lt;/p&gt;
&lt;p&gt;虽然这两个学科之间有许多相似之处，但基础架构管理应用程序的工程需要终身学习。诸如引导基础架构之类的难题不断发展，需要工程师不断学习新事物。还需要维护和优化基础架构，这一定会让工程师长期受雇。&lt;/p&gt;
&lt;p&gt;本章为用户提供了强大的模式和基础知识，将不明确的API结构映射为粒度资源。这些资源可以应用到您的本地数据中心、私有云或公有云中。&lt;/p&gt;
&lt;p&gt;了解这些模式的工作原理对于构建可靠的基础架构管理应用程序至关重要。本章阐述的模式旨在为工程师提供构建声明式基础架构管理应用程序的起点和灵感。&lt;/p&gt;
&lt;p&gt;在构建基础架构管理应用程序时，没有正确或错误的答案，只要应用程序遵循Unix哲学：“做一件事并把它做得很好。“&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP 连接管理器介绍</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/http-conneciton-manager/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/service-mesh/http-conneciton-manager/</guid>
      <description>&lt;p&gt;HCM 是一个网络级的过滤器，将原始字节转译成 HTTP 级别的消息和事件（例如，收到的 Header，收到的 Body 数据等）。&lt;/p&gt;
&lt;p&gt;HCM 过滤器还处理标准的 HTTP 功能。它支持访问记录、请求 ID 生成和跟踪、Header 操作、路由表管理和统计等功能。&lt;/p&gt;
&lt;p&gt;从协议的角度来看，HCM 原生支持 HTTP/1.1、WebSockets、HTTP/2 和 HTTP/3（仍在 Alpha 阶段）。&lt;/p&gt;
&lt;p&gt;Envoy 代理被设计成一个 HTTP/2 复用代理，这体现在描述 Envoy 组件的术语中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP/2 术语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 HTTP/2 中，流是已建立的连接中的字节的双向流动。每个流可以携带一个或多个&lt;strong&gt;消息（message）&lt;/strong&gt;。消息是一个完整的&lt;strong&gt;帧（frame）&lt;strong&gt;序列，映射到一个 HTTP 请求或响应消息。最后，帧是 HTTP/2 中最小的通信单位。每个帧都包含一个&lt;/strong&gt;帧头（frame header）&lt;/strong&gt;，它至少可以识别该帧所属的流。帧可以携带有关 HTTP Header、消息有效载荷等信息。&lt;/p&gt;
&lt;p&gt;无论流来自哪个连接（HTTP/1.1、HTTP/2 或 HTTP/3），Envoy 都使用一个叫做 &lt;strong&gt;编解码 API（codec API）&lt;/strong&gt; 的功能，将不同的线程协议翻译成流、请求、响应等协议无关模型。协议无关的模型意味着大多数 Envoy 代码不需要理解每个协议的具体内容。&lt;/p&gt;
&lt;h2 id=&#34;http-过滤器&#34;&gt;HTTP 过滤器&lt;/h2&gt;
&lt;p&gt;在 HCM 中，Envoy 支持一系列的 HTTP 过滤器。与监听器级别的过滤器不同，这些过滤器对 HTTP 级别的消息进行操作，而不知道底层协议（HTTP/1.1、HTTP/2 等）或复用能力。&lt;/p&gt;
&lt;p&gt;有三种类型的 HTTP 过滤器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解码器（Decoder）：当 HCM 对请求流的部分进行解码时调用。&lt;/li&gt;
&lt;li&gt;编码器（Encoder）：当 HCM 对响应流的部分进行编码时调用。&lt;/li&gt;
&lt;li&gt;解码器 / 编码器（Decoder/Encoder）：在两个路径上调用，解码和编码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图解释了 Envoy 如何在请求和响应路径上调用不同的过滤器类型。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-请求响应路径及-http-过滤器&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jimmysong.io/envoy-handbook/images/008i3skNly1gz9kop73v4j31kd0u0djh.jpg&#34; alt=&#34;请求响应路径及 HTTP 过滤器&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      请求响应路径及 HTTP 过滤器
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;像网络过滤器一样，单个的 HTTP 过滤器可以停止或继续执行后续的过滤器，并在单个请求流的范围内相互分享状态。&lt;/p&gt;
&lt;h2 id=&#34;数据共享&#34;&gt;数据共享&lt;/h2&gt;
&lt;p&gt;在高层次上，我们可以把过滤器之间的数据共享分成&lt;strong&gt;静态&lt;/strong&gt;和&lt;strong&gt;动态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;静态包含 Envoy 加载配置时的任何不可变的数据集，它被分成三个部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 元数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Envoy 的配置，如监听器、路由或集群，都包含一个&lt;code&gt;metadata&lt;/code&gt;数据字段，存储键 / 值对。元数据允许我们存储特定过滤器的配置。这些值不能改变，并在所有请求 / 连接中共享。例如，元数据值在集群中使用子集选择器时被使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 类型化的元数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类型化元数据不需要为每个流或请求将元数据转换为类型化的类对象，而是允许过滤器为特定的键注册一个一次性的转换逻辑。来自 xDS 的元数据在配置加载时被转换为类对象，过滤器可以在运行时请求类型化的版本，而不需要每次都转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. HTTP 每路过滤器配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与适用于所有虚拟主机的全局配置相比，我们还可以指定每个虚拟主机或路由的配置。每个路由的配置被嵌入到路由表中，可以在 &lt;code&gt;typed_per_filter_config&lt;/code&gt; 字段下指定。&lt;/p&gt;
&lt;p&gt;另一种分享数据的方式是使用&lt;strong&gt;动态状态&lt;/strong&gt;。动态状态会在每个连接或 HTTP 流中产生，并且它可以被产生它的过滤器改变。名为 &lt;code&gt;StreamInfo&lt;/code&gt; 的对象提供了一种从 map 上存储和检索类型对象的方法。&lt;/p&gt;
&lt;h2 id=&#34;过滤器顺序&#34;&gt;过滤器顺序&lt;/h2&gt;
&lt;p&gt;指定 HTTP 过滤器的顺序很重要。考虑一下下面的 HTTP 过滤器链。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;http_filters&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;filter_1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;filter_2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;filter_3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般来说，链中的最后一个过滤器通常是路由器过滤器。假设所有的过滤器都是解码器 / 编码器过滤器，HCM 在请求路径上调用它们的顺序是&lt;code&gt;filter_1&lt;/code&gt;、&lt;code&gt;filter_2&lt;/code&gt;、&lt;code&gt;filter_3&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在响应路径上，Envoy 只调用编码器过滤器，但顺序相反。由于这三个过滤器都是解码器 / 编码器过滤器，所以在响应路径上的顺序是 &lt;code&gt;filter_3&lt;/code&gt;、&lt;code&gt;filter_2&lt;/code&gt;、&lt;code&gt;filter_1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;内置-http-过滤器&#34;&gt;内置 HTTP 过滤器&lt;/h2&gt;
&lt;p&gt;Envoy 已经内置了几个 HTTP 过滤器，如 CORS、CSRF、健康检查、JWT 认证等。你可以&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/http_filters#config-http-filters&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在这里&lt;/a&gt;找到 HTTP 过滤器的完整列表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 5 章：开发基础架构应用程序</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/developing-infrastructure-applications/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/developing-infrastructure-applications/</guid>
      <description>&lt;p&gt;在构建应用程序以管理基础架构时，我们要将需要公开的 API 与要创建的应用程序等量看待。这些 API 将代表您的基础架构的抽象，而应用程序将使用 API 消费这些这些基础架构。&lt;/p&gt;
&lt;p&gt;务必牢牢掌握两者的重要性，和如何利用它们来创建可扩展的弹性基础架构。&lt;/p&gt;
&lt;p&gt;在本章中，我们将举一个虚构的云原生应用程序和 API 示例，这些应用程序和 API 会经历正常的应用程序周期。如果您想了解更多有关管理云原生应用程序的信息，请参阅第 7 章。&lt;/p&gt;
&lt;h2 id=&#34;设计-api&#34;&gt;设计 API&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的 API 是指处理数据结构中的基础架构表示，而不关心如何暴露或消费这些 API。通常使用 HTTP RESTful 端点来传递数据结构，API 如何实现对本章并不重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着基础架构的不断发展，运行在基础架构之上的应用程序也要随之演变。为这些应用程序的功能将随着时间而改变，因此基础架构是也是隐性地演变。随着基础架构的不断发展，管理它的应用程序也必须发展。&lt;/p&gt;
&lt;p&gt;基础架构的功能、需求和发展将永无止境。如果幸运的话，云供应商的 API 将会保持稳定，不会频繁更改。作为基础架构工程师，我们需要做好准备，以适应这些需求。我们需要准备好发展我们的基础架构和运行其上的应用程序。&lt;/p&gt;
&lt;p&gt;我们必须创建可缩放的应用程序，并准备对其进行扩展。为了做到这一点，我们需要了解在不破坏应用程序现有流程的情况下对应用程序进行大量更改的细微差别。&lt;/p&gt;
&lt;p&gt;管理基础架构的工程应用的好处在于它解放了运维人员的生产力。&lt;/p&gt;
&lt;p&gt;应用程序中使用的抽象现在由工程师来完成。我们可以详尽或抽象的描述 API，这都可以。通过具体和抽象定义的强大组合可以帮助运维人员准确地描述他们需要管理基础架构。&lt;/p&gt;
&lt;h2 id=&#34;添加功能&#34;&gt;添加功能&lt;/h2&gt;
&lt;p&gt;根据功能的性质，向基础架构应用程序添加功能可能非常简单也可能非常复杂。添加功能的目标是能够添加新功能而不会危害现有功能。我们绝不希望引入会以给系统其他组件带来负面影响的功能。此外，我们一直希望确保系统输入在合理的时间内保持有效。&lt;/p&gt;
&lt;p&gt;例 5-1 是本书前面介绍的基础架构 API 演化的具体示例。我们称之为 API v1。&lt;/p&gt;
&lt;p&gt;例 5-1. v1.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;想象一下，我们希望实现一项功能，允许基础架构运维人员为虚拟机定义 DNS 记录。新的 API 看起来略有不同。在例 5-2 中，我们将定义一个名为 version 的顶级指令，告诉应用程序这是 API 的 v2 版本。我们还将添加一个新的块，用于在虚拟机块的上下文中定义 DNS 记录。这是 v1 中不支持的新指令。&lt;/p&gt;
&lt;p&gt;例 5-2. v2.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;dnsRecords&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;ttl&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm.example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这两个对象都是有效的，应用程序应该继续支持它们。应用程序应检测到 v2 对象是否打算使用内置于应用程序中的 DNS 新功能。该应用程序应该足够聪明，以适当地导航到新功能。将资源应用于云时，新的 v2 对象的资源集将与第一个 v1 对象相同，但添加了单个 DNS 资源。&lt;/p&gt;
&lt;p&gt;这引入了一个有趣的问题：应用程序应该如何处理旧的 API 对象？应用程序应仍可以在云中创建资源，且支持无 DNS 的虚拟机。&lt;/p&gt;
&lt;p&gt;随着时间的推移，运维人员可以修改现有虚拟机对象以使用新的 DNS 功能。应用程序自动检测到增量并为新功能创建 DNS 记录。&lt;/p&gt;
&lt;h2 id=&#34;弃用功能&#34;&gt;弃用功能&lt;/h2&gt;
&lt;p&gt;让我们快速转到下一个 API v3。在这种情况下，我们的 API 不断发展，我们在表示 IP 地址方面已陷入僵局。&lt;/p&gt;
&lt;p&gt;在 API v1 中，我们能够通过本地 IP 指令方便地为网络接口声明一个本地 IP 地址。我们现在的任务是为虚拟机提供多种网络接口。需要注意的是，这将与最初的 API v1 冲突。&lt;/p&gt;
&lt;p&gt;让我们来看一下示例 5-3 中新的 v3 版本的 API。&lt;/p&gt;
&lt;p&gt;例 5-3. v3.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;networkInterfaces&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;ip&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.11&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;dnsRecords&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;A&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;ttl&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm.example.com&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用定义多个网络接口所需的新数据结构，我们已弃用本地 IP 指令。但是我们并没有删除定义 IP 地址的概念，我们只是简单地重组了它。这意味着我们可以分两个阶段废弃该指令。首先警告，然后是拒绝。&lt;/p&gt;
&lt;p&gt;在警告阶段，我们的应用程序可能会输出不再支持本地 IP 指令的警告。应用程序可以接受在对象中定义的指令，并将旧 API v2 转换为新 API v3。&lt;/p&gt;
&lt;p&gt;转换将采用为本地 IP 定义的值，并在新网络接口指令中创建与初始值相匹配的单个块。应用程序可以继续处理 API 对象，就好像用户发送了 v3 对象而不是 v2 对象一样。预计用户会注意到该指令已被弃用，并及时更新其表示。&lt;/p&gt;
&lt;p&gt;在拒绝阶段，应用程序将彻底拒绝 v2 API。用户将被迫更新他们的 API 到更新的版本，或者甘愿在基础架构中冒此风险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;弃用是非常危险的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个极其危险的过程，成功将用户引导到新版本可能会非常困难。拒绝输入必须给出很好的理由。&lt;/p&gt;
&lt;p&gt;如果输入信息的会破坏应用程序保障，则应拒绝该信息。否则，最佳实践通常是警告并继续。&lt;/p&gt;
&lt;p&gt;破坏用户的输入很容易让运维人员感到不安和沮丧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基础架构工程师在对 API 进行版本控制时，必须对在何时弃用哪些功能做出最佳判断。此外，工程师需要花时间给出巧妙的解决方案，这些方案可以是警告或转换。在某些情况下，做到悄无声息的 API 转换对不断发展的云原生基础架构来说是一个巨大的胜利。&lt;/p&gt;
&lt;h2 id=&#34;基础架构变异&#34;&gt;基础架构变异&lt;/h2&gt;
&lt;p&gt;基础架构需要随着时间的推移而变化。这是云原生环境的本质。不仅应用程序频繁部署，而且运行基础架构的云供应商也在不断变化。&lt;/p&gt;
&lt;p&gt;基础架构的变化可以有多种形式，比如扩大或缩小基础架构，复制整个环境或消费新资源。&lt;/p&gt;
&lt;p&gt;当运维人员承担变更基础架构的任务时，我们可以看到 API 的真实价值。假设我们想要扩展环境中的虚拟机数量。不需要更改 API 版本，但对基础架构的表示做一些小的调整将很快反映出变化。就这么简单。&lt;/p&gt;
&lt;p&gt;然而，重要的是要记住，在这种情况下，运维可能是一个人，也可能是另一个软件。&lt;/p&gt;
&lt;p&gt;请记住，我们故意将 API 构造成易于被计算机解码。我们可以在 API 的两端使用该软件！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用 Operator 消费和生产 API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Operater—— 构建云原生产品和平台的 CoreOS 公司创造了这个术语，即 Kubernetes 控制器，实现了软件取代人类参与管理特定应用的需求。通过协调预期状态和设定预期状态来实现。&lt;/p&gt;
&lt;p&gt;CoreOS 在他们的博客文章中这样描述 Operator：&lt;/p&gt;
&lt;p&gt;Operator 是特定应用程序的控制器，它代表 Kubernetes 用户扩展 Kubernetes API 以创建、配置和管理复杂有状态应用程序的实例。它建立在基本的 Kubernetes 资源和控制器概念的基础上，但包含一个域或特定于应用程序的知识体系以实现常见任务的自动化。&lt;/p&gt;
&lt;p&gt;该模式规定 Operator 可以通过给定声明性指令集来更改环境。Operator 是工程师应该创建的用于管理其基础架构的云原生应用程序类型的完美示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设想一个简单的情景 —— 自动调节器（autoscaler）。假设我们有一个非常简单的软件，可以检查环境中虚拟机上的平均负载。我们可以定义一个规则，只要平均负载平均值高于 0.7，我们就需要创建更多的虚拟机来均匀地分配我们的负载。&lt;/p&gt;
&lt;p&gt;Operator 的规则会随着负载平均值的增加而不再适用，最终 Operator 需要用另一台虚拟机更新基础架构 API。这样可以扩大我们的基础架构，但同样我们也可以很容易的定义另一个规则当平均负载降至 0.2 以下时缩小虚拟机规模。请注意，Operator 这个术语在这里应该是一个应用程序，而不是一个人。&lt;/p&gt;
&lt;p&gt;这是自动缩放的一个非常原始的例子，但该模式清楚地表明软件现在可以开始扮演人类运维人员的角色。&lt;/p&gt;
&lt;p&gt;有许多工具可以帮助扩展如 Kubernetes、Nomad 和 Mesos 等基础架构上的应用程序负载。这假定应用程序层运行一个编排调度器上，它将为我们管理应用程序负载。&lt;/p&gt;
&lt;p&gt;想象一下，如果多个基础架构管理应用程序使用相同的 API，那么会进一步将基础架构 API 的价值最大化。这是一个非常强大的基础架构演进模式。&lt;/p&gt;
&lt;p&gt;我们来看看相同的 API—— 记住它只有几千字节的数据，并且在两个独立的基础架构管理应用程序运行。图 5-1 显示了一个示例，两个基础架构应用程序从相同的 API 获取数据但将基础架构部署到各自独立的云环境。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-1-一个-api-被部署在两个云中&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-5-1.jpg&#34; alt=&#34;图 5-1. 一个 API 被部署在两个云中&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5-1. 一个 API 被部署在两个云中
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;该模型为基础架构工程师提供了在多个云提供商之间提供通用抽象的强大功能。现在我们可以看到应用程序如何确保 API 在多个地方代表相同的基础架构。如果基础架构 API 负责提供自己的抽象和资源调配，则基础架构不必与单个云提供商的抽象相关联。用户可以在他们选择的云中创建独特的基础架构排列。&lt;/p&gt;
&lt;h2 id=&#34;维护云提供商兼容性&#34;&gt;维护云提供商兼容性&lt;/h2&gt;
&lt;p&gt;虽然保持 API 与云提供商的兼容性将会有很多工作要做，但对于部署工作流程和供应流程时，很少需要改变。请记住，人类比技术更难改变。如果您可以保证人类的环境一致，这将抵消所需的技术开销。&lt;/p&gt;
&lt;p&gt;您还应该权衡多云兼容性的好处。如果它不是您的基础架构的需求，您可以节省大量的工作。考虑云厂商锁定时请参阅附录 B。&lt;/p&gt;
&lt;p&gt;我们也可以在同一个云中运行不同的基础架构管理应用程序。这些应用程序可能会对 API 进行不同的解释，这会导致对于运维人员的意图的定义略有不同。根据运维人员定义的基础架构的意图，在管理应用程序之间进行切换可能只是我们所需要的。图 5-2 显示了两个应用程序正在读取相同的 API 源，但在实现数据时会根据环境和需要而不同。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-2-一个-api-以不同的方式部署在同一个云中&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-5-2.jpg&#34; alt=&#34;图 5-2. 一个 API 以不同的方式部署在同一个云中&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5-2. 一个 API 以不同的方式部署在同一个云中
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;与基础架构 API 相比，基础架构应用的排列组合是无止境的。这为基础架构工程师提供了一个非常灵活和可扩展的解决方案，希望能够以不同的环境和方式掌握基础架构。&lt;/p&gt;
&lt;p&gt;我们为满足基础架构要求而可能构建的各种应用程序现在已成为基础架构本身的代表。这是第 3 章中定义的基础设施即软件的缩影。&lt;/p&gt;
&lt;p&gt;请务必记住，我们构建的应用程序本身就是云原生应用程序。这是一个有趣的故事，因为我们正在构建云原生应用程序来管理云原生基础架构。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 6 章：测试云原生基础架构</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/testing-cloud-native-infrastructure/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/testing-cloud-native-infrastructure/</guid>
      <description>&lt;p&gt;基础架构是用来支撑应用程序的。可信任的软件对于工程成功至关重要。如果每次在终端输入 ls 命令，都会发生随机动作，那么你将永远也不会相信 ls，而是去找另一种方式来列出目录中的文件。&lt;/p&gt;
&lt;p&gt;我们的基础架构必须值得信任。本章旨在建立信任和验证基础架构的意识形态。我们将描述的实践旨在增加对应用程序和基础架构工程的信心。&lt;/p&gt;
&lt;p&gt;软件测试在当今的软件工程领域非常普遍。然而，如何测试基础架构还没有很明确的最佳实践。&lt;/p&gt;
&lt;p&gt;这意味着本书中的所有章节中，这一节应该是最令人兴奋的！在该领域像您这样的工程师有充分的空间发挥出色的影响力。&lt;/p&gt;
&lt;p&gt;软件测试是一种证明软件可以正常工作的有效做法，证明软件在各种特殊情况下软件仍然可以正常运行。因此，如果我们将相同的范例应用于基础架构测试，测试目标如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证明基础架构按预期运行。&lt;/li&gt;
&lt;li&gt;证明基础架构不会失败。&lt;/li&gt;
&lt;li&gt;证明这两种情况在各种边缘情况下都是正确的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;衡量基础架构是否有效需要我们先定义什么叫有效。现在，您应该对使用基础架构和工程代表应用程序的想法感到满意。&lt;/p&gt;
&lt;p&gt;定义基础架构 API 的人应该花时间构思一个可以创建有效基础架构的理智的 API。例如，如果创建了一个定义虚拟机的 API 但里面没有使之可以运行的网络信息，这种做法就很愚蠢。您应该在 API 中创建有用的抽象，然后使用第 3 章和第 4 章中提出的想法来确保 API 创建出正确的基础架构组件。&lt;/p&gt;
&lt;p&gt;我们开始开发一个心智模型，通过定义 API 对基础架构的健全性进行检查。这意味着我们可以翻转逻辑并想象出相反的情况，这将是除了原始心智模型之外的所有东西。&lt;/p&gt;
&lt;p&gt;很值得为基础架构定义基本的完整性测试。测试基础架构的第一步是证明您的基础架构是按预期存在的，并且没有任何东西的违背原意而存在。&lt;/p&gt;
&lt;p&gt;在本章中，我们将探索基础架构测试，这将为新的测试工具奠定基础。&lt;/p&gt;
&lt;h2 id=&#34;我们该测试什么&#34;&gt;我们该测试什么？&lt;/h2&gt;
&lt;p&gt;在开始编写代码之前，我们首先必须确定要测试的内容。&lt;/p&gt;
&lt;p&gt;使用测试驱动开发是测试优先的常见做法。测试是为了证明测试点而编写的，从一开始就隐含失败。软件的开发周期都需要通过测试；也就是说，软件是为了满足测试中定义的每个要求而开发的。这是一个强大的实践，可以帮助软件保持专注，帮助工程师建立对软件的信心。&lt;/p&gt;
&lt;p&gt;这是一个可以用多种方式回答的哲学问题。建立值得信赖的基础架构是必不可少的。例如，如果存在依赖基础架构的业务问题，则应该对其进行测试。更重要的是，许多业务不仅依赖基础架构，还会在出现问题时自行修复。&lt;/p&gt;
&lt;p&gt;确定基础架构需要填补的问题空间代表了将需要编写的第一轮测试。&lt;/p&gt;
&lt;p&gt;远景规划是基础架构测试的另一个重要方面，但应该谨慎。在足够的前瞻性和过度工程化之间有一条看不见的界限。如果有疑问，坚持最少量的测试逻辑。&lt;/p&gt;
&lt;p&gt;在我们完全了解需要的测试之后，就可以考虑实施测试套件。&lt;/p&gt;
&lt;h2 id=&#34;编写可测试代码&#34;&gt;编写可测试代码&lt;/h2&gt;
&lt;p&gt;调节器模式不仅旨在创建整洁的基础架构应用程序，而且还鼓励编写可测试的基础架构代码。&lt;/p&gt;
&lt;p&gt;这意味着，在应用程序的每一个重要步骤中，我们总是会重新创建一个相同类型的新对象，也就是说基础系统的每个主要组件都会使用相同的输入和输出。使用相同的输入和输出可以更轻松地以编程方式测试软件的小型组件。测试将确保您的组件按预期工作。&lt;/p&gt;
&lt;p&gt;然而，在编写基础架构测试代码时，还有许多经验值得借鉴。我们将在看看在一些虚拟情景测试基础架构的具体示例。通过浏览场景，您将学到测试基础架构代码的经验教训。&lt;/p&gt;
&lt;p&gt;我们还会给出工程师一些规则，应在编写可测试基础架构代码时遵守这些规则。&lt;/p&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;p&gt;采用非常基础的基础架构定义，如示例 6-1。&lt;/p&gt;
&lt;p&gt;例 6-1. infrastructure.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;192.168.1.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这些数据的目的显而易见：确保一个名为&lt;code&gt;my-vm&lt;/code&gt;的虚拟机的大小为&lt;code&gt;large&lt;/code&gt;，IP 地址为&lt;code&gt;192.168.1.111&lt;/code&gt;。这些数据也暗示确保一个名为&lt;code&gt;my-subnet&lt;/code&gt;的子网将容纳虚拟机&lt;code&gt;my-vm&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;希望您发现了这个数据的问题。虚拟机的 IP 地址超出了子网的可用 CIDR 范围。&lt;/p&gt;
&lt;p&gt;应用程序在运行此数据时应该会失败，因为虚拟机设置了无效的网络。如果将我们的应用程序构建为盲目地允许部署任何数据，那么我们将创建一个可以联网的基础架构。尽管我们应该编写测试以确保新的虚拟机能够在网络上路由，但是我们可以做一些其他事情来帮助加强我们的应用程序并使测试更加容易。&lt;/p&gt;
&lt;p&gt;在应用程序处理输入之前，我们可以首先尝试验证输入。这在软件工程中是很常见的做法。&lt;/p&gt;
&lt;p&gt;想象一下，如果不是盲目部署这个基础架构，我们首先会尝试验证输入。在运行时，应用程序可以很容易的检测到虚拟机的 IP 地址在虚拟机所连接的子网中无效。这将阻止输入到达基础架构环境。由于知道应用程序将故意拒绝无效的基础架构表示，我们可以编写 happy 和 sad 测试来确保实现此行为。&lt;/p&gt;
&lt;p&gt;Happy 测试可以对条件进行正面处理。换句话说，它是一种向应用程序发送有效 API 对象并确保应用程序接受有效输入的测试。Sad 测试，可以对相反的情况或负面情况进行分析。例 6-1 是一个 sad 测试的例子，它将一个无效的 API 对象发送给应用程序，并确保应用程序拒绝无效输入。&lt;/p&gt;
&lt;p&gt;这种新模式使测试基础架构非常快速，而且通常不用费什么力气。一个工程师就可以开发大量的 happy 和 sad 测试，即使是最奇怪的应用程序输入也是如此。此外，测试集合可以随着时间的推移而增长；在欺骗 API 对象流入环境场景中时，工程师可以快速添加测试以防止其再次发生。&lt;/p&gt;
&lt;p&gt;输入验证是测试最基本的事情之一。通过在我们的应用程序中编写简单的验证来检查理智的值，我们可以开始过滤应用程序的输入。这也给了我们一个很容易定义错误并快速返回错误的途径。&lt;/p&gt;
&lt;p&gt;验证提供信心，而不会让您等待基础架构发生变异。这为面向 API 开发的工程师创建了更快的反馈循环。&lt;/p&gt;
&lt;h3 id=&#34;输入代码库&#34;&gt;输入代码库&lt;/h3&gt;
&lt;p&gt;编写易于测试的代码非常重要。经常出错可能会导致成本上升，因此需要围绕专有输入设计应用程序。专有输入是仅与程序中的一个点相关的输入，获得所需输入的唯一方法是线性执行程序。以这种方式线性编写代码对于人类大脑来说是有意义的，但这也是有效测试的最难的模式之一，特别是当涉及到测试基础架构时。&lt;/p&gt;
&lt;p&gt;专有输入陷入困境的例子如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数 &lt;code&gt;DoSomething ()&lt;/code&gt; 的调用返回 &lt;code&gt;Something {}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Something {}&lt;/code&gt; 传递给函数 &lt;code&gt;NextStep (Something)&lt;/code&gt; 并返回 &lt;code&gt;SomethingElse {}&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SomethingElse {}&lt;/code&gt; 被传递给函数 &lt;code&gt;FinalStep (something else)&lt;/code&gt;，返回 true 或 false。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的问题是，为了测试 &lt;code&gt;FinalStep ()&lt;/code&gt; 函数，我们首先需要遍历步骤 1 和 2。在测试的情况下，这会引入复杂性和更多的失败点；甚至可能不会在测试执行的环境中工作。&lt;/p&gt;
&lt;p&gt;更优雅的解决方案是以这样一种方式构造代码，即可以在程序的其余部分使用相同的数据结构上调用最后的 step ()：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码初始化 &lt;code&gt;GreatSomething {}&lt;/code&gt; 实现了方法 &lt;code&gt;great.DoSomething ()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GreatSomething {}&lt;/code&gt; 实现 &lt;code&gt;NextStep ()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GreatSomething {}&lt;/code&gt; 实现了 &lt;code&gt;something.FinalStep ()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从测试的角度来看，我们可以为我们希望测试的任何步骤填充 &lt;code&gt;GreatSomething {}&lt;/code&gt;，并相应地调用这些方法。这个例子中的方法现在负责处理它们扩展的对象中定义的内存。这与最后一种方法不同，在这种方法中，特殊的内存中的结构被传递到每个函数中。&lt;/p&gt;
&lt;p&gt;这是一种更为优雅的设计，因为测试工程师可以轻松地在整个过程中的任何一步合成内存，而不必担心学习相同数据的一种表示形式。 这是更加模块化的，如果可以迅速发现任何故障，我们可以介入。&lt;/p&gt;
&lt;p&gt;当您开始编写构成应用程序的软件时，请记住，您将需要在传统的运行时间轴上的许多地方跳入代码库。构建代码以使其易于在任何时候输入代码库并在内部进行测试，这是至关重要的。 在这种情况下，您可以成为自己最好的朋友，也可以成为最大的敌人。&lt;/p&gt;
&lt;h2 id=&#34;自我意识&#34;&gt;自我意识&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;告诉我你如何衡量我，我会告诉你我的行为。&lt;/p&gt;
&lt;p&gt;——Eliyahu M. Goldratt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编写代码和测试时注意自己的置信度。自我意识是软件工程中最重要的部分之一，也是最容易被忽视的部分之一。&lt;/p&gt;
&lt;p&gt;测试的最终目标是增加对应用程序的信心。就基础架构领域来说，我们的目标就是增强对基础架构的信心。&lt;/p&gt;
&lt;p&gt;测试基础架构的方法没有对错之分。可以在应用程序中通过代码覆盖率和单元测试来建立信心，但是对于基础架构来说这样做可能会存在误导。&lt;/p&gt;
&lt;p&gt;代码覆盖率是以程序化方式衡量代码可以满足预期的行为。这个度量标准可以用作原始数据点，但我们要知道即使是覆盖率达到 100％的代码库仍然可能会出现极端中断，这一点至关重要。&lt;/p&gt;
&lt;p&gt;如果你以代码覆盖率来衡量测试结果，那么工程师就会编写更容易被测试覆盖的代码，而不是编写更适应该任务的代码。Dan Ariely 在他刊登于哈弗商业评论的文章 “衡量标准决定一切” ：&lt;/p&gt;
&lt;p&gt;人们的行为会根据衡量指标作出相应的调整。衡量指标会促使某个人在该指标上做出优化。你想要得到什么，就要去衡量什么。&lt;/p&gt;
&lt;p&gt;应该衡量的唯一指标是信心，即我们的基础架构可以按预期工作，并且可以证明这一点。&lt;/p&gt;
&lt;p&gt;衡量信心几乎是不可能的。但是有些方法可以从工程师的心理和情绪中抽取有意义的数据集。&lt;/p&gt;
&lt;p&gt;问自己以下几个问题，记录下答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我担心这行不通吗？&lt;/li&gt;
&lt;li&gt;我可以肯定，这将做我认为会做的事吗？&lt;/li&gt;
&lt;li&gt;如果有人更改此文件，会发生什么情况？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从问题中提取数据的最强好的方式是比较以前的经验水平。例如，工程师可以做出如下陈述，团队的其他成员很快就会明白他想要传达的内容：&lt;/p&gt;
&lt;p&gt;比起上个季度，这次代码发布更令人担忧。&lt;/p&gt;
&lt;p&gt;现在，根据团队以前的经验，我们可以开始为我们的信心水平制定一套标准，从 0 开始表示完全没有信心，随着时间的流逝然后增加到非常自信。当我们了解了我们担心应用程序的哪些问题之后，再为了增加信心而制定测试内容就很简单了。&lt;/p&gt;
&lt;h2 id=&#34;测试类型&#34;&gt;测试类型&lt;/h2&gt;
&lt;p&gt;了解测试的类型以及测试方式将有助于工程师增加其对基础架构应用程序的信心。这些测试不需要编写，而且没有正确或错误之分。唯一的问题是我们相信应用程序会做我们想要它做的事情。&lt;/p&gt;
&lt;h3 id=&#34;基础架构断言&#34;&gt;基础架构断言&lt;/h3&gt;
&lt;p&gt;在软件工程中，有一个重要的概念是断言，这是一种强制的方式 —— 完全确定条件是否成立。目前已经有许多成功的框架使用断言来测试软件。断言是一个微小的函数，它将测试条件是否为真。这些功能可以在各种测试场景中使用，以证明概念正在发挥作用和增加我们的信心。&lt;/p&gt;
&lt;p&gt;在本章的其余部分中，我们将提到基础架构断言。您需要对这些断言的内容以及他们希望完成的内容有基本的了解。您还需要对 Go 语言有基本的了解，才能充分认识这些断言是做什么的。&lt;/p&gt;
&lt;p&gt;在基础架构领域需要声明我们的基础架构有效。对于您的项目来说值得练习下使用构建这些断言功能的库。开源社区也可以从这个工具包测试基础架构中受益。&lt;/p&gt;
&lt;p&gt;例 6-2 显示了 Go 语言中的断言模式。假设我们想测试虚拟机是否可以解析公共主机名，然后路由到它们。&lt;/p&gt;
&lt;p&gt;例 6-2. assertNetwork.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;localIp&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;AssertResolvesHostname&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;expectedIp&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to query DNS for a hostname,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//and compare to the expectedIp
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;AssertRouteable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;port&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to verify the virtualMachine can route
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;//to a hostname on a specific port
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Connect&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to connect to the virtual machine to run the assertions
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;eturn&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Logic to close the connection to the virtual machine 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个例子中，我们将两个断言作为&lt;code&gt;VirtualMachine {}&lt;/code&gt; 结构体上的方法来存储。方法签名是我们将在此演示中关注的内容。&lt;/p&gt;
&lt;p&gt;第一种方法 AssertResolvesHostname () 演示了一种将用于检查给定主机名是否解析为预期 IP 地址的方法。第二种方法 AssertRouteable () 演示了一种用于检查给定主机名是否可在特定端口上路由的方法。&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;VirtualMachine {}&lt;/code&gt; 结构体是如何定义成员本地 IP 的。另请注意，&lt;code&gt;VirtualMachine {}&lt;/code&gt; 结构体具有 &lt;code&gt;Connect ()&lt;/code&gt; 函数以及 &lt;code&gt;Close ()&lt;/code&gt; 函数。这是因为断言框架可以在虚拟机的上下文中运行这个断言。测试可以在基础架构环境之外的系统上运行，然后连接到环境中的虚拟机以运行基础架构断言。&lt;/p&gt;
&lt;p&gt;在例 6-3 中，我们演示了工程师该如何在本地系统上编写 Go 测试。&lt;/p&gt;
&lt;p&gt;例 6-3. network_test.go&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;TestVm&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;VirtualMachine&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;localIp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;10.0.0.17&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Connect&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Unable to connect to VM: % v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AssertResolvesHostname&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com should resolve to any IP&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Unable to resolve hostname: % v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AssertRouteable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;s&#34;&gt;&amp;#34;google.com should be routable on port 443&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatalf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Unable to route to hostname: % v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该示例使用 Go 语言中的内置测试标准，这意味着该函数将作为应用程序中 Go 测试的正常运行测试的一部分执行。测试框架将测试名称以&lt;code&gt;_test.go&lt;/code&gt;结尾的所有文件，并使用以&lt;code&gt;TestXxx&lt;/code&gt;开头的签名名称测试所有函数。该框架还将&lt;code&gt;* test.T&lt;/code&gt; 指针传递给以这种方式定义的每个函数。&lt;/p&gt;
&lt;p&gt;这个简单的测试将使用我们之前定义的断言库来完成以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尝试连接到应在 10.0.0.17 上可访问的虚拟机。&lt;/li&gt;
&lt;li&gt;在虚拟机上尝试断言虚拟机可以解析 google.com 并且可返回一些 IP 地址。&lt;/li&gt;
&lt;li&gt;在虚拟机上尝试声明虚拟机可以通过端口 443 路由到 google.com。&lt;/li&gt;
&lt;li&gt;关闭与虚拟机的连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是一个非常强大的程序。它为我们的基础架构按预期工作建立了信心。它还引入了一个优雅的脚手架，供工程师定义测试，而不必担心它们将如何运行。&lt;/p&gt;
&lt;p&gt;开源社区迫切需要这样的基础架构测试框架。基础架构测试的标准化和可靠方法将成为开发者工具箱中的有益补充。&lt;/p&gt;
&lt;h3 id=&#34;集成integration测试&#34;&gt;集成（integration）测试&lt;/h3&gt;
&lt;p&gt;集成测试也被称为端到端（e2e）测试。这些是长期运行的测试。按照预生产的方式来运行系统，这是证明可靠性和增加信心的最有价值的测试。&lt;/p&gt;
&lt;p&gt;编写集成测试套件可能很有趣，也很有意义。在集成测试基础架构管理应用程序的情况下，测试将执行基础架构生命周期的大扫除。&lt;/p&gt;
&lt;p&gt;线性集成测试套件的一个简单例子如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义一个常用的基础架构 API。&lt;/li&gt;
&lt;li&gt;将数据保存到应用程序的数据存储区。&lt;/li&gt;
&lt;li&gt;运行该应用程序并创建基础架构。&lt;/li&gt;
&lt;li&gt;针对基础架构运行一系列断言。&lt;/li&gt;
&lt;li&gt;从应用程序的数据存储中删除 API 数据。&lt;/li&gt;
&lt;li&gt;确保基础架构已成功销毁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在此过程中的任何一步，测试都可能失败，并且测试套件应该清理发生变异的基础架构。这是测试可以按照预期销毁基础架构重要的原因之一。&lt;/p&gt;
&lt;p&gt;测试使我们相信，该应用程序将创建并销毁预期的基础架构，并按预期工作。随着时间的推移，我们可以增加步骤 4 中运行的断言的数量，并继续强化套件。&lt;/p&gt;
&lt;p&gt;集成测试工具可能是测试基础架构最强大的环境。没有集成测试工具，运行像单元测试这样的小测试就没有多大价值。&lt;/p&gt;
&lt;h3 id=&#34;单元unit测试&#34;&gt;单元（unit）测试&lt;/h3&gt;
&lt;p&gt;单元测试是测试系统并单独运行其组件的基本部分。单元测试的责任是小而谨慎。单元测试是软件工程中的常见做法，因此将成为基础架构工程的一部分。&lt;/p&gt;
&lt;p&gt;在编写基础架构测试的情况下，测试系统的一个组件是困难的。基础架构的大多数组件都建立在彼此的基础之上。相应地测试软件通常需要改变基础架构来测试并查看其是否工作。这个过程通常涉及大部分系统。&lt;/p&gt;
&lt;p&gt;但这并不意味着为基础架构管理系统编写单元测试是不可能的。事实上，前面例子中定义的大部分断言在技术上将都是单元测试！单元测试只测试一个小组件，但在大型集成测试系统环境中使用时，它们可能非常有用。&lt;/p&gt;
&lt;p&gt;在测试基础架构时鼓励进行单元测试，但请记住，它们运行的上下文通常需要相当大的开销。这种开销通常以集成测试的形式出现。将单元测试的小而谨慎的检查与更大的整体测试模式相结合，使基础架构工程师对其基础架构按照预期工作具有高度的信心。&lt;/p&gt;
&lt;h3 id=&#34;模拟mock测试&#34;&gt;模拟（Mock）测试&lt;/h3&gt;
&lt;p&gt;在软件工程中，综合系统的常见做法是模拟测试。在模拟测试中，工程师编写或使用旨在欺骗或伪造系统的软件。&lt;/p&gt;
&lt;p&gt;一个简单的例子就是使用一个旨在与 API 通信并以 “mock” 模式运行的 SDK。SDK 不会将任何数据发送到 API，而是合成 SDK 认为 API 在各种情况下应该执行的操作。&lt;/p&gt;
&lt;p&gt;确保模拟软件准确地反映它正在合成的系统的责任在于开发模拟软件的工程师手中。在某些情况下，模拟软件也是由开发其正在模拟的系统的工程师开发的。&lt;/p&gt;
&lt;p&gt;尽管可能有一些模拟工具保持最新并且比其他工具更稳定，但使用模拟系统合成您计划测试的基础架构时存在一个普遍的道理：虚假系统只会给您带来虚假信心。&lt;/p&gt;
&lt;p&gt;现在，这条规则可能看起来很苛刻。但它的目的是鼓励工程师不要轻易走出去，并通过构建真正的集成套件来运行测试的实践。虽然模拟系统功能强大，但将它作为基础架构测试的核心（因此也是您的信心）是非常危险的。&lt;/p&gt;
&lt;p&gt;大多数公有云提供商对其资源实施配额限制。想象一下与一个对资源有严格限制的系统进行交互的测试。模拟系统可能会尽最大努力限制资源，但是如果不在运行时审核实际系统，模拟系统将无法确定您的基础架构是否实际部署。在这种情况下，您的模拟测试会成功。但是，当代码在真实环境中运行时，它会中断。&lt;/p&gt;
&lt;p&gt;这只是许多实例中的一个例子，这些实例证明了为什么变异实际基础架构和发送实际网络数据包比使用模拟系统更可靠。请记住，测试的目标是增强您的基础架构在真实环境中按照预期工作的信心。&lt;/p&gt;
&lt;p&gt;这并不是说所有的模拟测试都不好。了解模拟正在测试的基础架构与为了方便而模拟另一部分系统之间的差异非常重要。&lt;/p&gt;
&lt;p&gt;工程师需要决定什么时候适合使用模拟系统。我们只是告诫工程师不要对这些系统有太大的信心。&lt;/p&gt;
&lt;h3 id=&#34;混沌chaos测试&#34;&gt;混沌（chaos）测试&lt;/h3&gt;
&lt;p&gt;混沌测试可能是本书中介绍的所有测试基础架构的方法中中最令人兴奋。混沌测试证明在基础架构中发生不可预知的事件时不会影响基础架构的稳定性。我们通过故意破坏基础架构并衡量系统如何应对灾难来做此演示。与其他的所有测试一样，我们将以基础架构工程师的身份来应对这个问题。&lt;/p&gt;
&lt;p&gt;我们将编写旨在以意想不到的方式打破生产系统的软件。建立对系统的信心的一部分是理解它们如何以及为什么会破坏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Google 如何建立信心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习如何破解系统的例子可以在谷歌的 DiRT（灾难恢复培训）计划中看到。该计划旨在帮助 Google 的 SRE 熟悉他们所支持的系统。在站点可靠性工程中，他们解释说，DiRT 计划的目的是因为 “长时间与生产脱节可能会导致信心问题，不管是过于自信还是不自信，该计划仅仅是为了发现当事件发生时的认知差距 “。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不幸的是，如果没有系统来衡量影响并从灾难中恢复过来，就不会让工程团队感觉释然。再次，我们将要求运行本章前面定义的基础结构断言。微小的单一责任功能为测量系统随时间的稳定性提供了绝佳的数据点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测量混沌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再来看一下例 6-3 中的 &lt;code&gt;AssertRouteable ()&lt;/code&gt; 函数。想象一下，我们有一个服务，将连接到虚拟机，并尝试保持连接打开。服务每秒都会调用 &lt;code&gt;AssertRouteable ()&lt;/code&gt; 函数并记录结果。来自此服务的数据是虚拟机在其网络上路由的能力的准确表示。只要虚拟机可以路由，数据就会在图形上产生一条直线，如图 6-1 所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-f-6-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-1.jpg&#34; alt=&#34;f-6-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      f-6-1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果在任何时候连接断开或者虚拟机不再能够路由，那么图形数据会发生变化，并且我们会看到图形上的线条发生变化。随着基础架构自行修复，线路开启该图将再次稳定下来，如图 6-2 所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-f-6-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-2.jpg&#34; alt=&#34;f-6-2&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      f-6-2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这里考虑的重要方面是时间。随着时间的推移，测量混乱将伴随着混沌的测量。&lt;/p&gt;
&lt;p&gt;我们可以快速扩展测量。想象一下，名为 &lt;code&gt;AssertRouteable ()&lt;/code&gt; 的服务现在正在虚拟机上调用一组 100 个基础结构断言。另外，假设我们有 100 台虚拟机正在测量。&lt;/p&gt;
&lt;p&gt;这将对我们的基础架构产生大约每秒 1.0×10&lt;sup&gt;4&lt;/sup&gt; 个断言。来自我们的基础架构断言的大量数据使我们能够创建强大的图形表示基础架构。以可查询的格式记录数据也可以进行高级混沌调查。&lt;/p&gt;
&lt;p&gt;随着混沌的测量，拥有可靠的测量工具和服务非常重要。以有意义的方式存储来自服务的数据也很重要，以便稍后可以引用它们。强烈建议将数据存储在日志聚合器或其他容易索引的数据存储中。&lt;/p&gt;
&lt;p&gt;系统的混乱与系统的可靠性成反比。因此，它直接反映了我们正在评估的基础架构的稳定性。这意味着，当事情发生中断或引入变化时，将信息随时间绘制成分析是非常有价值的，以了解是否降低了稳定性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引入混沌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将混沌引入系统的另一种说法：“故意破坏系统”。我们希望总结出我们可能在野外看到的意想不到的基础架构问题组合。如果我们不会故意注入混沌，那么云提供商、互联网或某个系统会为我们做这件事。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Netflix 的猿猴军队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Netflix 推出了它称之为猿猴军队（Simian Army）的系统，导致其混乱。猴子、猿猴以及猿猴家族的其他动物都以不同的方式造成混乱。Netflix 解释了这些工具之一 Chaos Monkey 的工作原理：&lt;/p&gt;
&lt;p&gt;构建 Chaos Monkey 是我们的哲学，它是随机禁用我们的生产实例以确保我们能够在没有任何客户影响的情况下经受这种常见故障的工具。这个名字来自于在数据中心（或云区域）用武器释放野猴以随机击落实例并通过电缆咀嚼的想法 —— 这一切都是在我们不间断的继续为客户提供服务的同时进行。通过在工作日运行 Chaos Monkey，在受到严密监控的环境中，工程师站在一边解决问题，我们仍然可以学习有关系统弱点的教训，并构建自动恢复机制来处理这些问题。所以下一次星期天上午 3 点有一个实例失败的时候，我们甚至不会注意到。&lt;/p&gt;
&lt;p&gt;就云原生基础架构而言，Monkey 是基础架构作为软件和利用协调模式的很好例子。主要区别在于它们旨在以意想不到的方式摧毁基础架构，而不是可预测地创建和管理基础架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，您应该有一个准备好使用的基础架构管理应用程序，或者至少有一个。用于部署，管理和稳定基础架构的基础架构管理应用程序也可用于引入混乱。&lt;/p&gt;
&lt;p&gt;想象一下两个非常相似的部署。&lt;/p&gt;
&lt;p&gt;第一个示例 6-4 代表有效（或 happy）基础架构。&lt;/p&gt;
&lt;p&gt;例 6-4. infrastructure_happy.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;large&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.0.17&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以使在环境中设置的方式来部署此基础架构。这个基础架构应该部署且运行稳定。就像以前一样，随着时间的推移记录您的基础架构测试非常重要；图 6-3 就是一个例子。理想情况下，您运行的测试数量应该随着时间的推移而增加。&lt;/p&gt;
&lt;p&gt;我们决定引入混乱。因此，我们创建了原始基础架构管理应用程序的副本，但这次我们采取了更加险恶的方式部署基础架构。我们利用我们的部署工具的能力来审计基础架构，并对已经存在的基础架构进行更改。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-f-6-3&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-3.jpg&#34; alt=&#34;f-6-3&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      f-6-3
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第二次部署将代表有意故障的基础架构，并仍使用与原始基础架构相同的标识符（名称）。基础架构管理工具将检测现有基础架构并进行更改。在第二个示例（示例 6-5）中，我们将虚拟机大小更改为较小，并且意图将虚拟机的静态 IP 地址 192.168.1.111 分配到 10.0.100.0/24 范围之外。&lt;/p&gt;
&lt;p&gt;我们知道虚拟机上的工作负载不会在小型虚拟机上运行，并且我们知道虚拟机将无法在网络上路由。这是我们将要介绍的混乱情况。&lt;/p&gt;
&lt;p&gt;例 6-5. infrastructure_sad.json&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;virtualMachines&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-vm&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;size&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;small&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;localIp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;192.168.1.111&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;#34;subnets&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;my-subnet&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nt&#34;&gt;&amp;#34;cidr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.100.0/24&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于第二个基础架构管理应用程序默默地对基础架构进行了更改，因此我们可以预料会看到事态发展。我们图中的数据将开始波动，如图 6-4 所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-f-6-4&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-6-4.jpg&#34; alt=&#34;f-6-4&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      f-6-4
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如果虚拟机上的任何应用程序未完全中断，则应该缓慢地失败。虚拟机的内存和 CPU 现在已经过载。该 shell 无法 fork 新进程。负载平均值远高于 20。系统正在接近死锁，我们甚至无法访问虚拟机来查看错误，因为没有任何方式可以路由到冒名顶替者的 IP 地址。&lt;/p&gt;
&lt;p&gt;正如预期的那样，初始系统将检测到底层基础架构中的某些内容发生了变化，并会相应地进行调整。冒名顶替者系统脱机是非常重要的，否则两个系统之间可能会有永无休止的和解，而这两者将会按照指示的方式相互竞争以纠正基础架构。&lt;/p&gt;
&lt;p&gt;这种引入混沌的方法之美在于，我们不需要开发任何额外的工具或花费任何工程时间编写混沌框架。我们以巧妙的方式滥用了原有的基础架构管理工具，引发了一场灾难。&lt;/p&gt;
&lt;p&gt;当然，这可能并不总是一个完美的解决方案。与您的生产基础架构应用程序不同，您的混沌应用程序应该有一定的限制，以确保它们有益。一些常见的限制是能够根据标签或元数据排除某些系统，不能在非工作时间运行混沌测试，并将混沌限制在特定的百分比或系统类型。&lt;/p&gt;
&lt;p&gt;现在引入随机混沌的主要负担在于基础架构工程师随着时间推移而随机化探索的工作流程的能力。当然，基础架构工程师还需要确保从实验中收集的数据以可消化的格式提供。&lt;/p&gt;
&lt;h2 id=&#34;监控基础架构&#34;&gt;监控基础架构&lt;/h2&gt;
&lt;p&gt;除了测试基础架构外，我们不能忘记监控正在运行的系统。测试和熟悉的失败模式可以让您对基础架构充满信心，但要测试系统可能出现的所有故障是不可能的。&lt;/p&gt;
&lt;p&gt;监测可以检测到的，在测试期间未识别的异常并执行正确的操作是非常重要的。通过积极监控站点基础架构还可以增强我们的信心，即当发生的事情认为是不 “正常” 时，我们会收到警报。明确什么时候以及如何提醒人类这些异常是一个很有争议的话题。&lt;/p&gt;
&lt;p&gt;在云原生环境中监控基础架构的实践中涌现出许多优秀的资源。我们不会在这里讨论这些主题，但您应该先阅读 Rob Ewaschuk 的 “监控分布式系统：Google 的 SRE 团队的案例研究”（O’Reilly），并观看 MonitoramaConference 上的视频。两者都可以在线免费观看。&lt;/p&gt;
&lt;p&gt;无论您实施哪种监控解决方案，都要记住用云原生方法来创建您的监控规则。规则应声明并存储为代码。监控规则应与您的应用程序代码放在一起，并以自助服务的方式提供。当测试和遥测可能满足您的大部分需求时，不要过度补偿监控。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;测试可以将强我们对基础架构的信心，我们所支持的应用程序也获得了信心和信任。如果一个测试套件不能提供信心，它的价值应该是有问题的。记住，本章中提出的工具和模式是出发点，旨在激发和吸引在这个领域中工作的工程师。无论测试类型或运行它们的框架如何，最重要的一点是工程师可以开始相信他们的系统。作为工程师，我们通常会通过观察实践证明事情按预期工作的动手演示获得信心。&lt;/p&gt;
&lt;p&gt;而且，在生产中进行实验不仅是可以的，而且是值得鼓励的。您需要确保环境是为了进行这种实验而建立的，并且实施了适当的跟踪，以便不会浪费测试！&lt;/p&gt;
&lt;p&gt;现实测量是基础架构开发和测试的重要组成部分。能够从工程角度和运营角度来封装现实是运用基础架构的重要组成部分，因此可以确信它能够按预期运行。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 7 章：管理云原生应用程序</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/managing-cloud-native-applications/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/managing-cloud-native-applications/</guid>
      <description>&lt;p&gt;云原生应用程序依赖基础架构才能运行，反过来说，云原生基础架构也需要云原生应用程序来维持。&lt;/p&gt;
&lt;p&gt;对于传统基础架构，维护和升级基本上都是由人工完成。可能是在单机上手动运行服务或使用自动化工具定义基础结构和应用程序的快照。&lt;/p&gt;
&lt;p&gt;但是，如果基础架构可以由应用程序管理，同时基础架构又可以管理应用程序，那么基础架构工具就会成为另一种应用程序。工程师对于基础架构的责任可以用调解器模式表示，内置于该基础架构上运行的应用程序中。&lt;/p&gt;
&lt;p&gt;我们花了三章来说明如何构建可以管理基础架构的应用程序。本章将介绍如何在基础架构上运行云原生应用或其它任何应用。&lt;/p&gt;
&lt;p&gt;如前所述，保持基础架构和应用程序的简单非常重要。解决应用程序复杂性最常用的方法就是把应用程序分解成小的，易于理解的组件。通常通过创建单一职责的服务来实现，或者将代码分解为一系列事件触发的函数。&lt;/p&gt;
&lt;p&gt;随着小型、可部署单元的扩容成多份即使是最自动化的基础架构也可能被压垮。管理大量应用程序的唯一方法是让它们承担第 1 章中所述的功能性操作。应用程序需要在可以按规模管理之前变成原生云。&lt;/p&gt;
&lt;p&gt;学习完本章不会帮助您建下一个伟大的应用程序，但您将了解一些基础知识，这块可以让您的应用程序在云原生基础架构是良好运行。&lt;/p&gt;
&lt;h2 id=&#34;应用程序设计&#34;&gt;应用程序设计&lt;/h2&gt;
&lt;p&gt;已经有很多教您如何构建应用程序的书了，本书不打算再讨论。但是，了解应用程序架构如何影响基础架构设计仍然很重要。&lt;/p&gt;
&lt;p&gt;正如我们在第 1 章中讨论的那样，我们假设应用程序设计成云原生的，这样可以从云原生基础架构中获得最大收益。云原生的本质是应用程序由软件而不是人类来管理。&lt;/p&gt;
&lt;p&gt;应用程序的设计和打包方式是分开考虑的。应用程序可以是云原生的，打包为 RPM 或 DEB 文件，可以部署到虚拟机而不是容器。它们可以是单体应用或微服务，可以用 Java 或 Go 编写。&lt;/p&gt;
&lt;p&gt;这些实现细节不影响应用程序被设计成在云上运行。&lt;/p&gt;
&lt;p&gt;假设我们有一个用 Go 编写的应用程序，使用容器打包，运行在 Kubernetes 上，视为微服务运行。&lt;/p&gt;
&lt;p&gt;我们假想的这个应用是 “云原生” 的吗？&lt;/p&gt;
&lt;p&gt;如果应用程序将所有活动日志记录到文件，还硬编码数据库 IP 地址呢？也许它不接受运行时配置并将状态存储在本地磁盘上。如果它不以可预见的方式存在或挂起并等待人工调试呢？&lt;/p&gt;
&lt;p&gt;这个应用所选择的语言和打包方式，可能会让您觉的它是云原生的，但实际上它根本不是。像 Kubernetes 这样的框架可以通过各种功能来管理这个应用，但即使它可以运行，但还是需要人类来维护。&lt;/p&gt;
&lt;p&gt;第 1 章详细介绍了使应用程序在云原生基础架构上运行得更好的一些特点。如果我们具有第 1 章中规定的特点，应用程序还有另一个考虑因素：我们如何有效地管理它们？&lt;/p&gt;
&lt;h2 id=&#34;实施云原生模式&#34;&gt;实施云原生模式&lt;/h2&gt;
&lt;p&gt;诸如弹性伸缩、服务发现、配置、日志、健康检查和相关监控指标等功能都可以以不同方式在应用程序中实现。实现这些功能的常见做法是通过导入实现相关功能的标准语言库。Netflix OSS 和 Twitter 的 Finagle 是在 Java 语言库中实现这些功能的很好的例子。&lt;/p&gt;
&lt;p&gt;应用程序可以导入和使用库，自动获得库中提供许多相关的功能，无需额外的代码。当一个组织内支持的语言很少时，这种模式很有意义。这种模式很容易实现最佳实践。&lt;/p&gt;
&lt;p&gt;当组织开始实施微服务时，它们往往倾向于使用多语言服务。这样可以自由地为不同的服务选择正确的语言，但是很难为每种语言维护库。&lt;/p&gt;
&lt;p&gt;获得该功能的另一种方法是通过所谓的 &amp;ldquo;Sidecar&amp;rdquo; 模式。此模式应用程序本身与实现管理功能的应用程序绑定在一起。通常作为单独的容器来实现，但也可以通过在虚拟机上运行另一个守护进程来实现。&lt;/p&gt;
&lt;p&gt;Sidecar 的例子包括以下内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Envoy 代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为服务增加弹性伸缩和监控指标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过外部服务发现注册服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;订阅配置更改并通知服务进程重新加载&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;健康检查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供用于检查应用程序运行状况的 HTTP 端点 (Endpoints)&lt;/p&gt;
&lt;p&gt;Sidecar 容器还可以用来适配 Polyglot 容器，通过暴露特定于语言的端点与使用库的应用程序进行交互。来自 Netflix 的 Prana 正是为那些不使用标准 Java 库的应用程序而定制的。&lt;/p&gt;
&lt;p&gt;当有团队集中管理特定的 Sidecar 进程时，Sidecar 模式很有意义。如果工程师想要在它们的服务中暴露监控指标，它们可以将其构建到应用程序中，或者一个单独的团队也可以提供处理日志记录输出并公开计算出的监控指标的 Sidecar 应用。&lt;/p&gt;
&lt;p&gt;在这两种情况下，都可以在不修改应用程序的情况下为应用添加功能。在可以使用软件管理应用程序后，我们来看看如何管理应用程序的生命周期。&lt;/p&gt;
&lt;h2 id=&#34;应用程序生命周期&#34;&gt;应用程序生命周期&lt;/h2&gt;
&lt;p&gt;云原生应用程序除了生命周期应该由软件管理以外，其生命周期本身与传统应用程序并没有什么不同。&lt;/p&gt;
&lt;p&gt;本章不打算解释管理应用程序时涉及的所有模式和选项。我们将简要讨论几个阶段，在云原生基础架构之上运行云原生应用，这几个阶段受益程度最高：部署、运行和下线。&lt;/p&gt;
&lt;p&gt;这些主题并不都包含所有选项，但还有很多其他书籍和文章可供参考，这取决于应用程序的架构，语言和所选库。&lt;/p&gt;
&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;
&lt;p&gt;部署是应用程序最依赖基础架构的一个领域。虽然没有什么东西会阻止应用程序自行部署，但基础架构管理还可以管理更多的方面。&lt;/p&gt;
&lt;p&gt;本文不会涉及集成和交付，但是在这个领域的一些做法很明确。应用程序部署不仅仅是获取和运行代码。&lt;/p&gt;
&lt;p&gt;云原生应用程序旨在由软件管理应用生命周期的各个阶段。这包括周期性的健康检查和部署初始化。应尽可能地消除技术、流程和策略中人为造成的瓶颈。&lt;/p&gt;
&lt;p&gt;应用程序的部署首先应该是自动、自助的，如果应用正在活跃开发中，则应该是被频繁触发的。也应该可以被测试、验证可稳定运行。&lt;/p&gt;
&lt;p&gt;新版本和新功能的发布时很少会有一次性替换应用程序的所有实例的情况。新功能在配置标志成 &amp;ldquo;gated&amp;rdquo;，可以在不重启应用的情况下选择性地动态启用新功能。版本升级部分发布，通过测试进行验证，并在所有测试通过时以受控方式发布。&lt;/p&gt;
&lt;p&gt;当启用新功能或部署新版本时，应该存在控制流向或隔离应用流量的机制（请参阅附录 A）。通过缓慢的部署和更快的应用性能反馈循环进行新功能的试用，可以限制中断带来的影响。&lt;/p&gt;
&lt;p&gt;基础架构应负责部署软件的所有细节。工程师可以定义应用程序版本，基础架构要求和依赖关系，并且基础架构将朝着该状态发展，直至满足所有要求或需求更改。&lt;/p&gt;
&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;
&lt;p&gt;运行应用程序应该是应用程序生命周期中最平稳最稳定的阶段。运行软件最重要的两个的方面在第 1 章中讨论：了解应用程序在做什么以及可操作性即可以根据需要更改应用程序。&lt;/p&gt;
&lt;p&gt;我们已经在第 1 章中详细介绍了关于应用报告健康和遥测数据的可观测性，但是当事情不按预期工作时，你会做什么？如果应用程序的遥测数据显示它不符合 SLO，那么如何解决和调试应用程序？&lt;/p&gt;
&lt;p&gt;对于云原生应用程序，你不应该通过 SSH 连接到服务器的形式查看日志。如果你需要 SSH，更应该考虑使用日志或其它的服务替代。&lt;/p&gt;
&lt;p&gt;你仍然需要访问应用程序（API）和日志数据（云日志记录）以及获取在堆栈中的服务，但这值得通过演练来查看是否需要传统工具。当事件中断时，你需要一个调试应用程序和基础架构组件的方法。&lt;/p&gt;
&lt;p&gt;在做系统调试时，你应该首先查看你的基础架构测试，如第 5 章所述。测试应公开所有未正确配置或未提供预期性能的基础架构组件。&lt;/p&gt;
&lt;p&gt;不能说因为你不管理底层基础架构就意味着基础架构不可能出问题。通过测试来验证期望值将确保你的基础架构能够以你期望的方式运行。&lt;/p&gt;
&lt;p&gt;在排除基础架构后，你应该查看应用程序以获取更多信息。应用程序调试的最佳位置是应用性能管理（APM）以及可能通过 OpenTracing 等标准进行的分布式应用程序跟踪。&lt;/p&gt;
&lt;p&gt;OpenTracing 示例、实现和 APM 不在本书的范围之内。总而言之，OpenTracing 允许你在整个应用程序中跟踪调用，以更轻松地识别网络和应用程序通信问题。OpenTracing 的示例可视化可以在图 7-1 中看到。APM 为你的应用程序添加了用于向收集服务报告指标和故障的工具。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-f-7-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-7-1.jpg&#34; alt=&#34;f-7-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      f-7-1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;当测试和跟踪仍然没有暴露出问题时，有时你只需要在应用程序上启用更详细的日志记录。但是，如何在不破坏问题的情况下启用调试？&lt;/p&gt;
&lt;p&gt;运行时配置对于应用程序很重要，但在云原生环境中，无须重启应用程序，配置就应该是动态的。配置选项仍然通过应用程序中的库实现，但标志值应该能够通过集中协调器，应用程序 API 调用，HTTP 协议 Header 或多种方式进行动态更改。&lt;/p&gt;
&lt;p&gt;Netflix 的 Archaius 和 Facebook 的 GateKeeper 是动态配置的两个例子。前 Facebook 工程师经理 Justin Mitchell 在 Quora 的帖子中分享到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GateKeeper 是从代码部署中解耦出来的功能。我们可以在几天或几周内发布新功能，因为我们观察了用户指标、性能并确保服务可以随时扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;允许对应用程序配置进行动态控制，可以实现更多对曝光过度的新功能的控制并更好地测试已部署代码的覆盖范围。可以很容易的发布新代码并不意味着这是适合所有情况的正确解决方案。&lt;/p&gt;
&lt;p&gt;基础架构可以帮助解决此问题，并通过协调何时启用新功能和基于高级网络策略的路由控制来启用更灵活的应用程序。这种模式还允许更细粒度的控制和更好的协调发布或回滚场景。&lt;/p&gt;
&lt;p&gt;在动态的自助服务环境中，部署的应用程序数量将快速增长。你需要确保有一个简单的方法来动态调试应用类似自助服务模型中部署的应用。&lt;/p&gt;
&lt;p&gt;工程师喜欢发布新应用程序一样，反过来很难让它们下线旧应用程序。即使如此，旧应用下线仍然是应用程序生命周期中的关键阶段。&lt;/p&gt;
&lt;h3 id=&#34;下线&#34;&gt;下线&lt;/h3&gt;
&lt;p&gt;部署新的应用程序和服务在快速迭代的环境中很常见。下线应用程序应该像创建应用一样自动化。&lt;/p&gt;
&lt;p&gt;如果新的服务和资源被自动化部署与监控，则它们应该按照相同标准下线。尽快部署新服务而不删除未使用的服务是应对技术债务的最简单方法。&lt;/p&gt;
&lt;p&gt;识别应该下线的服务和资源，这是一个特定的业务。你可以使用应用程序遥测的经验数据来了解某个应用程序是否正在被使用，但是下线应用程序的决定应由该业务决定。&lt;/p&gt;
&lt;p&gt;基础架构组件（例如，VM 实例和负载均衡器端点）应在不需要时被自动清理。自动化组件清理的一个例子是 Netflix 的 Janitor Monkey。该公司在一篇博文中解释道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Janitor Monkey 通过应用一组规则来决定资源是否应该成为候选的清理内容。如果任何规则确定该资源是被清理的候选内容，则 Janitor Monkey 标记该资源并安排清理时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有这些应用阶段的目标是让基础架构和软件来管理原本由人类管理的方面。我们采用协调模式与组件元数据相结合的方式来不断运行，并根据当前上下文对需要采取的高层次操作做出决策。以此来取代由人类编写的临时自动化脚本。&lt;/p&gt;
&lt;p&gt;应用程序的生命周期不是唯一一个需要依赖于基础架构的阶段。还有一些每个阶段都要依赖于基础架构服务的程序。我们将在下一节讨论一些提供给这类应用的支持服务和基础架构 API。&lt;/p&gt;
&lt;h2 id=&#34;对运行于基础架构上的应用的要求&#34;&gt;对运行于基础架构上的应用的要求&lt;/h2&gt;
&lt;p&gt;云原生应用程序对基础架构的期望不仅只是执行二进制文件，它们还需要抽象、隔离与保证应用程序运行和管理。对于应用程序来说，需要提供 hook 和 API 以允许基础架构管理它们。为了实现这种模式，两者就需要有一种共生关系。&lt;/p&gt;
&lt;p&gt;我们在第 1 章中定义了云原生应用程序，并刚刚讨论了一些生命周期的要求。现在让我们看看云原生应用程序对从运行它们的基础架构建设的更多期望：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行与隔离&lt;/li&gt;
&lt;li&gt;资源分配和调度&lt;/li&gt;
&lt;li&gt;环境隔离&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;状态管理&lt;/li&gt;
&lt;li&gt;监控和记录&lt;/li&gt;
&lt;li&gt;监控指标聚合&lt;/li&gt;
&lt;li&gt;调试和跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些期望都应该是服务的默认选项，或者是由自助 API 提供。我们将更详细地解释每个要求，以确保这些期望被明确的定义。&lt;/p&gt;
&lt;h3 id=&#34;应用程序运行和隔离&#34;&gt;应用程序运行和隔离&lt;/h3&gt;
&lt;p&gt;除了有时候需要的解释器，传统应用程序只需要一个内核就可以运行。 云原生应用仍然需要它们，但云原生应用运行时同样也需要与操作系统和其他应用程序隔离。隔离使多个应用能够在同一台服务器上运行并控制它们的依赖和资源。&lt;/p&gt;
&lt;p&gt;应用隔离有时被称为多租户。该术语可用于在同一服务器上运行的多个应用程序以及在共享集群中运行应用程序的多个用户。用户可以运行经过验证的可信代码，也可以运行你不能控制且不信任的代码。&lt;/p&gt;
&lt;p&gt;云原生不意味着需要使用容器。Netflix 率先推出了许多云原生模式，当他们从原来的方式过渡到在公有云上运行时，使用虚拟机作为它们的部署工具，而不是容器。FaaS 服务（例如 AWS Lambda）是用于打包和部署代码的另一种流行的云原生技术。在大多数情况下，它们使用容器进行应用程序隔离，但容器包装对用户是不可见的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是容器？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器有很多不同的实现。Docker 推广了术语 “容器” 来描述一种在隔离的环境中打包和运行应用程序的方式。基本上，容器使用内核原语或硬件功能来隔离单个操作系统上的进程。&lt;/p&gt;
&lt;p&gt;容器隔离级别可能会有所不同，但通常这意味着应用程序使用独立的根文件系统、命名空间以及来自同一服务器上其他进程的资源分配（例如，CPU 和 RAM）运行。容器格式已被许多项目采用，并创建了开放容器计划（OCI），该计划定义了如何打包和运行应用程序容器的标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容器隔离还会给编写应用程序的工程师造成负担。它们现在负责声明所有的软件依赖关系。如果它们没做到这点，应用程序将无法运行，因为必要的库将不可用。&lt;/p&gt;
&lt;p&gt;容器经常被选中来用于云原生应用程序，因为已经出现了更好的用于管理它们流程和编排的工具。虽然容器是实现运行时和资源隔离的最简单方式，但这并不总是（并且也可能不会）如此。&lt;/p&gt;
&lt;h3 id=&#34;资源分配和调度&#34;&gt;资源分配和调度&lt;/h3&gt;
&lt;p&gt;从历史上看，应用程序可以提供最低系统要求的粗略估计，人类有责任确定应用程序在满足什么需求下可以运行。人工调度可能需要很长时间才能准备好应用程序运行的操作系统和依赖项。&lt;/p&gt;
&lt;p&gt;部署可以通过配置管理实现自动化，但在运行应用程序时，仍然需要人员验证资源并标记服务器。云原生基础架构基于依赖隔离，允许应用程序在任何有资源的地方运行。&lt;/p&gt;
&lt;p&gt;通过隔离，只要系统有可用的进程，存储和可访问的依赖，应用程序就可以在任何地方被调度。动态调度通过将决策留给机器更好地消除了人为瓶颈。集群调度程序从所有系统收集资源信息并计算出应用程序的最佳位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人为控制应用程序不能很好的伸缩。当人生病、休假（或至少它们应该），通常会带来瓶颈。随着规模和复杂性的增加，人们也不可能清楚地记住应用程序在哪里运行。&lt;/p&gt;
&lt;p&gt;许多公司试图通过招聘更多人来扩大规模。这加剧了系统的复杂性，因为调度需要在多个人之间进行协调。最终，人为调度将采用电子表格（或类似的解决方案）来保存每个应用程序的运行位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;动态调度并不意味着运维人员无法控制。基于调度器可能没有的知识，运维人员仍然可以覆盖或强制进行调度决策。覆盖和手动资源调度应通过 API 提供，而不是会议请求。&lt;/p&gt;
&lt;p&gt;解决这些问题是 Google 编写名为 Borg 的内部集群调度程序的主要原因之一。在 Borg 的研究报告中，谷歌指出 Borg 提供了三大好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它隐藏了资源管理和失败处理的细节，因此用户可以专注于应用程序开发；&lt;/li&gt;
&lt;li&gt;以非常高的可靠性和可用性运行，并支持相同的应用程序；&lt;/li&gt;
&lt;li&gt;让我们可以有效地在数以万计的机器上运行工作负载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调度程序在任何云原生环境中的角色都非常相似。从根本上说，它需要抽象出许多机器并允许用户而不是服务器请求资源。&lt;/p&gt;
&lt;h3 id=&#34;环境隔离&#34;&gt;环境隔离&lt;/h3&gt;
&lt;p&gt;当应用程序由许多服务组成时，基础架构就需要提供一种方法来定义所有依赖的隔离。传统的方法是通过将复杂的服务器，网络或集群隔离成开发或测试环境来管理依赖关系。基础架构应能够通过应用程序环境在逻辑上分离依赖关系，而不会完全复制集群。&lt;/p&gt;
&lt;p&gt;逻辑分割环境可以更好地利用硬件，减少重复的自动化，并且更容易测试应用程序。在某些情况下，需要单独的测试环境（例如，需要进行底层更改时）。但是，应用程序测试应该在完全复制的基础架构下进行。&lt;/p&gt;
&lt;p&gt;环境可以是传统的永久性开发、测试、预发和生产，也可以是动态分支或基于提交（commit）。它们甚至可以是生产环境的一部分，通过动态配置和实例的选择性路由启用功能。&lt;/p&gt;
&lt;p&gt;环境应有应用程序所需的所有数据，服务和网络资源组成。这包括诸如数据库，文件共享和任何外部服务之类的东西。云原生基础架构可以创建低开销的环境。&lt;/p&gt;
&lt;p&gt;基础架构应该能够提供环境和被使用。应用程序应遵循最佳实践，允许灵活配置以支持环境，并通过服务发现发现支持服务的端点。&lt;/p&gt;
&lt;h3 id=&#34;服务发现&#34;&gt;服务发现&lt;/h3&gt;
&lt;p&gt;应用程序几乎可以肯定依靠一项或多项服务来提供商业利益。基础架构的责任是提供一种服务在每个环境基础上找到彼此的方式。&lt;/p&gt;
&lt;p&gt;某些服务发现需要应用程序进行 API 调用，而其他服务则通过 DNS 或网络代理公开透明地进行。使用什么工具并不重要，但服务使用服务发现很重要。&lt;/p&gt;
&lt;p&gt;尽管服务发现是最古老的网络服务之一（即 ARP 和 DNS），但它经常被忽视不用。在每个实例文本文件或代码中静态定义服务端点是不可扩展的，且不适合云原生环境。端点（Endpoint）注册应该在创建服务时自动发生，并且端点可用或消失。&lt;/p&gt;
&lt;p&gt;云原生应用程序与基础架构一起工作以发现其相关服务。这些包括但不限于 DNS，云元数据服务或独立服务发现工具（即 etcd 和 consul）。&lt;/p&gt;
&lt;h3 id=&#34;状态管理&#34;&gt;状态管理&lt;/h3&gt;
&lt;p&gt;如果有状态管理的话基础架构将能知道应用程序实例需要做什么。这与应用程序生命周期截然不同，因为生命周期适用于应用程序的整个开发过程。状态适用于启动和停止的实例。&lt;/p&gt;
&lt;p&gt;应用程序有责任提供 API 或 hook，以便检查其当前状态。基础架构的责任是监控实例的当前状态并采取相应的行动。&lt;/p&gt;
&lt;p&gt;以下是一些应用程序状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已提交&lt;/li&gt;
&lt;li&gt;预定&lt;/li&gt;
&lt;li&gt;准备好了&lt;/li&gt;
&lt;li&gt;健康&lt;/li&gt;
&lt;li&gt;不健康&lt;/li&gt;
&lt;li&gt;终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些状态和相应行动的简要概述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个应用申请提交运行。&lt;/li&gt;
&lt;li&gt;基础架构检查请求的资源并安排应用程序。应用程序启动时，提供一个准备好 / 未准备好的状态。&lt;/li&gt;
&lt;li&gt;基础架构将等待就绪状态，然后允许使用应用程序资源（例如，将实例添加到负载均衡器）。如果应用程序在指定的时间前未准备就绪，基础结构将终止它并安排一个新的应用程序实例。&lt;/li&gt;
&lt;li&gt;一旦应用程序准备就绪，基础架构将监控活动状态并等待不健康状态，或者直到应用程序设置为不再运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有比上述更多的状态。如果要对状态进行正确的检查和采取行动，则状态需要得到基础架构的支持。Kubernetes 通过事件、探针和 hook 实现应用程序状态管理，但是每个编排平台都应该具有类似的应用程序管理功能。&lt;/p&gt;
&lt;p&gt;当应用程序被提交、调度或扩缩容时，会触发 Kubernetes 事件。探针用于检查应用程序何时准备好提供流量（就绪）并确保应用程序健康（存活）。Hook 用于在进程启动之前或之后需要发生的事件。&lt;/p&gt;
&lt;p&gt;应用程序实例的状态与应用程序生命周期管理同样重要。基础架构在确保实例可用并据此采取行动方面起着关键作用。&lt;/p&gt;
&lt;h3 id=&#34;监控和记录&#34;&gt;监控和记录&lt;/h3&gt;
&lt;p&gt;永远不要让应用程序自己要求监控或被日志记录；它们是基础架构运行的基本条件。更重要的是，如果需要被监控和记录，其配置应该以应用程序资源请求相同的方式声明为代码。如果你拥有部署应用程序的所有自动化功能，但无法动态监控服务，那么云原生基础架构也就不完整。&lt;/p&gt;
&lt;p&gt;状态管理（即进程健康检查）和日志记录处理应用程序的各个实例。日志系统应该能够根据应用程序、环境、标签或任何其他有用的元数据整合日志。&lt;/p&gt;
&lt;p&gt;应用程序应该尽可能没有单点故障，并且应该运行多个实例。如果一个应用程序有 100 个实例正在运行，就算单个实例变得不健康，监控系统也不应触发警报。&lt;/p&gt;
&lt;p&gt;监控从整体上看应用程序，并用于调试和验证所需的状态监控与警报不同，因为应根据应用程序的度量和 SLO 触发警报。&lt;/p&gt;
&lt;h3 id=&#34;指标聚合&#34;&gt;指标聚合&lt;/h3&gt;
&lt;p&gt;要知道应用程序处于健康状态时的行为方式，收集指标。它们还可以提供有关不健康时可能被破坏的信息的洞察，并且就像监控一样，收集的指标应作为代码与应用程序定义的一部分被请求。&lt;/p&gt;
&lt;p&gt;基础架构可以自动收集有关资源利用率的指标，但应用程序有责任呈现服务级别指标。&lt;/p&gt;
&lt;p&gt;监测和日志记录是对应用程序运行时的状况检查，指标可提供所需的遥测数据。没有指标（metric），就无法知道应用程序是否满足服务级别目标以提供商业价值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从日志中提取遥测和健康检查数据可能很诱人，但要小心，因为日志记录需要后处理，并且比应用特定监控指标来说开销更重。&lt;/p&gt;
&lt;p&gt;在收集指标时，你希望尽可能接近实时数据。这需要一个可扩展且简单高效的解决方案。&lt;/p&gt;
&lt;p&gt;应该使用日志进行调试，且应该预计到数据处理的延迟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与日志记录类似，指标通常在实例级别收集，然后汇总在一起以提供完整的服务视图，而不是单个实例的展示。&lt;/p&gt;
&lt;p&gt;一旦应用程序提供收集指标的方法，基础架构的工作就是搜集、整合和存储指标用于分析。收集指标的端点应该可以根据每个应用程序进行配置，但数据格式应该标准化，以便可以在单个系统中查看所有指标。&lt;/p&gt;
&lt;h3 id=&#34;调试和跟踪&#34;&gt;调试和跟踪&lt;/h3&gt;
&lt;p&gt;应用程序在开发过程中很容易调试。集成开发环境（IDE），代码断点以及在调试模式下运行都是工程师在编写代码时可以使用的所有工具。&lt;/p&gt;
&lt;p&gt;对于部署的应用程序来说，自检要困难得多。当应用程序由数十或数百个微服务或独立部署的功能组成时，此问题更为严重。当用多种语言和不同的团队编写服务时，也可能无法将工具内置到应用程序中。&lt;/p&gt;
&lt;p&gt;基础架构需要提供调试整个应用程序的方法，不仅仅是单个服务。调试有时可以通过日志记录系统完成，但是复现错误需要较短的反馈回路。&lt;/p&gt;
&lt;p&gt;如前所述，调试对于动态配置来说是很好用的。当发现问题时，应用程序可以切换到详细日志记录，而无需重新启动，并且流量可以通过应用程序代理有选择地路由到实例。&lt;/p&gt;
&lt;p&gt;如果问题无法通过日志输出解决，那么分布式跟踪提供了一个不同的界面来可视化发生的事情。分布式跟踪系统（如 OpenTracing）可以补充日志以帮助人类调试问题。&lt;/p&gt;
&lt;p&gt;跟踪为调试分布式系统提供了更短的反馈回路。如果它不能构建到应用程序中，则可以通过代理或流量分析由基础架构透明地完成。当你大规模地运行任何协调的应用程序时，基础架构提供了一种调试应用程序的方法。&lt;/p&gt;
&lt;p&gt;尽管在分布式系统中设置跟踪有很多好处和实现细节，但我们不会在此讨论。应用程序跟踪一直非常重要，并且在分布式系统中越来越困难。云原生基础架构需要提供可以以透明方式跨越多个服务的跟踪服务。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;应用程序需求已经改变：带有操作系统和软件包管理器的服务器已经不够用了。应用程序现在需要协调服务和更高级别的抽象。抽象允许资源与服务器分离并根据需求以编程的方式使用。&lt;/p&gt;
&lt;p&gt;本章中提出的要求并不是基础架构可以提供的所有服务，但它们是云原生应用程序所期望的基础。如果基础架构不提供这些服务，那么应用程序将不得不实施它们，否则它们将无法达到现代业务所需的规模和速度。&lt;/p&gt;
&lt;p&gt;基础架构不会自行发展：人们需要改变自己的行为方式，从根本上解决以不同的方式运行应用程序这个问题。幸运的是，有些项目已经在借鉴开创了这些解决方案的公司的经验了。&lt;/p&gt;
&lt;p&gt;应用程序依赖基础架构的功能和服务来支持敏捷开发。基础架构要求应用程序公开端点和集成以自主管理的方式。工程师应尽可能使用现有的工具，并设计出有弹性的简单解决方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 8 章：保护应用程序</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/securing-applications/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/securing-applications/</guid>
      <description>&lt;p&gt;我们讨论过只能使用云原生应用程序来创建基础架构。同时基础架构也负责运行这些应用程序。&lt;/p&gt;
&lt;p&gt;运行由应用程序配置和控制的基础架构可以轻松得扩展。我们通过学习如何通过扩展应用的方式来扩展基础架构。我们还通过学习如何保护应用程序来保护基础架构。&lt;/p&gt;
&lt;p&gt;在动态环境中，无法通过增加人手来管理这样的复杂性，同样也不能靠增加人手来处理策略和安全问题。&lt;/p&gt;
&lt;p&gt;这意味着，就像我们必须创建通过协调器模式强制执行基础架构状态的应用程序一样，我们需要创建实施安全策略的应用程序。在创建应用程序以执行的策略之前，我们需要以机器可解析的格式编写策略。&lt;/p&gt;
&lt;h2 id=&#34;策略即代码&#34;&gt;策略即代码&lt;/h2&gt;
&lt;p&gt;由于策略没有明确定义的技术实现，所以策略难以纳入代码。它更多地关注业务如何实现而不是谁来实现。&lt;/p&gt;
&lt;p&gt;如何实现和谁来实现都会经常变化，但是实现方式变化更频繁且不容易被抽象化。它也是组织特定的，可能需要了解创建基础架构人员的沟通结构的具体细节。&lt;/p&gt;
&lt;p&gt;策略需要应用于应用程序生命周期的多个阶段。正如我们在第 7 章中所讨论的，应用程序通常有三个阶段：部署、运行和退役。&lt;/p&gt;
&lt;p&gt;部署阶段将在应用程序和基础架构变更发布之前先应用策略。这将包括部署规则和一致性测试。运行阶段将包括持续的遵守和执行访问控制和隔离。退役阶段很重要，以确保没有服务落后于未安排或未维护的状态。&lt;/p&gt;
&lt;p&gt;在这些阶段中，您需要将策略分解为明确的，可操作的实现。模糊的策略无法执行。您需要将实现放在代码中，然后创建应用程序或使用现有的应用程序来执行策略规则。&lt;/p&gt;
&lt;p&gt;您应该将策略视为代码。策略更改应视为应用程序更改并在版本控制中进行跟踪。&lt;/p&gt;
&lt;p&gt;控制应用程序部署的相同策略也应该适用于您的新策略部署。您可以使用与部署应用程序相同的工具跟踪和部署的基础架构组件越多，就越容易了解正在运行的内容以及变更如何影响系统。&lt;/p&gt;
&lt;p&gt;将策略作为代码带来的巨大好处是您可以轻松地添加或删除策略并对其进行跟踪，因此记录了谁执行了策略，何时执行了策略以及提交和提交请求的评论。由于该策略以代码形式存在，因此您现在可以为自己的策略编写测试！如果你想验证一个策略是否可以正常工作，你可以使用第 5 章中的测试实践。&lt;/p&gt;
&lt;p&gt;让我们更仔细地看看如何将策略应用到应用程序生命周期。&lt;/p&gt;
&lt;h3 id=&#34;部署-gateway&#34;&gt;部署 Gateway&lt;/h3&gt;
&lt;p&gt;部署 gateway 确保应用程序的部署符合业务规则。这意味着您将需要构建部署流水线，并且不允许从用户机器进行直接生产部署。&lt;/p&gt;
&lt;p&gt;在实施集中化策略之前，您需要集中控制，但是应该从小规模开始，并在实施之前证明解决方案可行。部署流水线的好处远不止于策略执行，而且应该是任何拥有少数开发人员的组织中的标准。&lt;/p&gt;
&lt;p&gt;以下是一些策略示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署只有在所有测试都通过后才能进行。&lt;/li&gt;
&lt;li&gt;新应用程序要求高级开发人员检查更改并对提取请求发表评论。&lt;/li&gt;
&lt;li&gt;生产工件推送只能从部署流水线发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gateway 不应该强制运行状态或应用程序的 API 请求。应用程序应该知道如何配置基础架构组件，并通过合规性和审计将策略应用于这些组件，而不是在应用程序部署期间应用。&lt;/p&gt;
&lt;p&gt;部署 gateway 策略的一个例子是，星期五下午 3 点之后，如果您的组织没有获得经理批准，不允许部署代码。&lt;/p&gt;
&lt;p&gt;这个很容易放入代码中。图 8-1 是代表策略的非常简化的图。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-f-8-1&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f-8-1.jpg&#34; alt=&#34;f-8-1&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      f-8-1
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;您可以看到该策略简单地检查了允许部署部署的一周中的时间和日期。如果是星期五和下午 3 点以后，那么策略会检查管理员确定。&lt;/p&gt;
&lt;p&gt;该策略可以通过经理发送的经过验证的电子邮件，经过验证的 API 调用或各种其他方式来获得 OK 通知。决定首选通信方法的内容以及等待批准的时间长度取决于策略。&lt;/p&gt;
&lt;p&gt;这个简单的例子可以用很多不同的选项进行扩展，但确保该策略不符合人类解析和执行是很重要的。人的解释是不同的，而不明确的策略通常不会得到执行。&lt;/p&gt;
&lt;p&gt;通过确保策略阻止新的部署，可以为解决生产环境的状态节省很多工作。有一系列可以通过软件验证的事件可以帮助您理解系统。版本控制和持续部署流水线可以验证代码；使用策略和流程作为代码可以验证软件的部署方式和时间。&lt;/p&gt;
&lt;p&gt;除了确保通过公司策略部署正确的事情之外，我们还应该轻松地使用模板部署受支持的事物，并通过一致性测试强制执行它们。&lt;/p&gt;
&lt;h3 id=&#34;合规性测试&#34;&gt;合规性测试&lt;/h3&gt;
&lt;p&gt;在任何基础架构中，您都需要提供建议的方式来创建特定类型的应用程序。这些建议成为用户根据需要消费和拼凑在一起的基石。&lt;/p&gt;
&lt;p&gt;这些建议是可堆砌的，但又不能太小。需要在其预期的功能和自助服务方面可以理解。我们已经建议将云原生应用程序打包为容器并通过协调器使用；由您决定什么最适合您的用户以及您想要提供哪些组件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;您可以通过多种方式为用户提供模板化基础架构。&lt;/p&gt;
&lt;p&gt;提供一个模板化的代码，比如 Jsonnet，或者完全模板化的应用程序，例如 Helm 的 chart。&lt;/p&gt;
&lt;p&gt;您还可以通过您的部署流水线提供模板。可以是 Terraform 模块或特定于部署的工具，例如 Spinnaker 模板。&lt;/p&gt;
&lt;p&gt;创建部署模板允许用户成为模板的消费者，随着最佳实践的发展，用户将自动受益。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基础架构模板的最关键的一点是使做正确的事情变得容易，并且很难做错事情。如果您满足客户的需求，那么获得适配器将会容易得多。&lt;/p&gt;
&lt;p&gt;但是，我们需要模板化基础架构的根本原因是可以执行合规性测试。合规性测试的存在是为了确保应用程序和基础架构组件符合组织的标准。&lt;/p&gt;
&lt;p&gt;对不符合标准的基础架构进行测试的一些示例如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不在自动缩放组中的服务或端点&lt;/li&gt;
&lt;li&gt;不在负载均衡器后面的应用程序&lt;/li&gt;
&lt;li&gt;前端层直接与数据库通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些标准是关于基础架构的信息，您可以通过调用云提供商的 API 来找到这些信息。合规性测试应持续运行，并强制执行公司采用的架构标准。&lt;/p&gt;
&lt;p&gt;如果发现基础架构组件或应用程序架构违反了公司提供的标准，则应尽早终止它们。越早可以对模板进行编码，就可以越早检查出不符合标准的应用程序。在应用程序的生命早期解决不受支持的体系结构非常重要，因此可以最大限度地减少对体系结构决策的依赖。&lt;/p&gt;
&lt;p&gt;合规性处理如何构建应用程序和维护可操作性。合规性测试确保应用程序和基础架构安全。&lt;/p&gt;
&lt;h3 id=&#34;一致性测试&#34;&gt;一致性测试&lt;/h3&gt;
&lt;p&gt;合规性测试不会测试架构设计，而是集中于组件的实施，以确保它们遵守定义的策略。放在代码中的最简单的策略是那些有助于安全的策略。围绕组织需求（例如 HIPAA）的策略也应定义为代码并在合规性测试期间进行测试。&lt;/p&gt;
&lt;p&gt;合规策略的一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象存储的用户访问受限，并且不能被公共因特网读取或写入&lt;/li&gt;
&lt;li&gt;API 端点全部使用 HTTPS 并具有有效证书&lt;/li&gt;
&lt;li&gt;虚拟机实例（如果有的话）没有过分宽松的防火墙规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这些策略不会使应用程序免受所有漏洞或错误的影响，但是如果应用程序确实被利用，合规性策略应将影响范围降至最低。&lt;/p&gt;
&lt;p&gt;Netflix 在其博客文章 “The Netflix Simian Army” 中通过其 Security Monkey 解释了其执行合规性测试的目的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Security Monkey 是 Conformity Monkey 的延伸。它会查找安全违规或漏洞（如未正确配置的 AWS 安全组），并终止违规实例。它还确保我们所有的 SSL 和 DRM 证书都是有效的，并且不会延期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将您的策略放入代码并通过观察云提供商 API 继续运行它，可以让您保持更高的安全性，立即捕获不安全的设置，并随时跟踪版本控制系统的策略。根据这些策略不断测试您的基础架构的模型也非常适合调节器模式。&lt;/p&gt;
&lt;p&gt;如果您认为策略是需要应用和实施的配置类型，那么实施它可能会更简单。请务必记住，随着您的基础架构和业务需求的变化，您的合规策略也应该如此。&lt;/p&gt;
&lt;p&gt;部署测试在将应用程序部署到基础架构之前进行监视，合规性和合规性测试都处理正在运行的应用程序。确保您拥有策略的最后一个应用程序生命周期阶段是了解何时以及如何废止应用程序和生命周期组件。&lt;/p&gt;
&lt;h3 id=&#34;活动测试&#34;&gt;活动测试&lt;/h3&gt;
&lt;p&gt;合规性和一致性测试应该删除那些未通过定义策略的应用和基础架构。还应该有一个应用程序清理旧的和未使用的基础架构组件。高级使用模式应基于应用程序遥测数据，但仍有其他基础架构组件很容易被遗忘并需要退役。&lt;/p&gt;
&lt;p&gt;在云环境中，您可以根据需要消费资源，但很容易会忘记需求。如果没有自动清理旧的或未使用的资源，最后您会对账单感到惊讶，或者需要耗费大量人力进行手动审计和清理。&lt;/p&gt;
&lt;p&gt;您应该测试并自动清理的资源的一些示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;旧磁盘快照&lt;/li&gt;
&lt;li&gt;测试环境&lt;/li&gt;
&lt;li&gt;以前的应用程序版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;负责清理的应用程序需要根据默认策略做正确的事情，并为工程师指定的异常提供灵活性。&lt;/p&gt;
&lt;p&gt;正如第 7 章所提到的，Netflix 已经实现了它所称的 “Janitor Monkey”，它的实现完美地描述了这种需要的模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Janitor Monkey 在 “标记、通知和删除” 过程中工作。当 Janitor Monkey 将资源标记为候选清理对象时，它会安排删除资源的时间。删除时间在标记资源的规则中指定。&lt;/p&gt;
&lt;p&gt;每个资源都与一个所有者电子邮件相关联，该电子邮件可以在资源上指定为标签，或者您可以快速扩展 Janitor Monkey 以从您的内部系统获取信息。最简单的方法是使用默认的电子邮件地址，例如您的团队的电子邮件列表中的所有资源。您可以配置若干天，以指定何时让 Janitor Monkey 在计划终止之前向资源所有者发送通知。默认情况下，数字为 3，表示业主将在终止日期前 3 个工作日收到通知。&lt;/p&gt;
&lt;p&gt;在这 3 天期间，资源所有者可以决定资源是否可以删除。如果资源需要保留更长时间，则所有者可以使用简单的 REST 接口将资源标记为未被 Janitor Monkey 清除。所有者总是可以使用另一个 REST 接口来删除该标志，然后 Janitor Monkey 将能够再次管理该资源。&lt;/p&gt;
&lt;p&gt;当 Janitor Monkey 看到标记为清理候选者的资源并且预定的终止时间已经过去时，它将删除资源。如果资源所有者想要提前释放资源以节省成本，则还可以手动删除该资源。当资源状态改变而使资源不是清理候选者时，例如一个分离的 EBS 卷被附加到一个实例，Janitor Monkey 将取消该资源的标记并且不会终止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拥有自动清理基础架构的应用程序可以降低您的复杂性和成本。该测试将协调模式应用到应用程序的最后生命周期阶段。&lt;/p&gt;
&lt;p&gt;还有其他一些基础架构的实践很重要，需要考虑。其中一些实践适用于传统基础架构，但在云原生环境中需要进行不同的处理。&lt;/p&gt;
&lt;p&gt;不断测试基础架构的各个方面有助于您了解自己遵守的策略。当基础架构频繁变更时，很难审计哪些变更可能导致停机或使用历史数据来预测未来趋势。&lt;/p&gt;
&lt;p&gt;如果您希望从账单声明中获取该信息或通过基础架构的当前快照来推断，您会很快发现它们所提供的信息是没用的。为了跟踪变化并预测未来，我们需要有审计工具，可以快速提供我们需要的信息。&lt;/p&gt;
&lt;h2 id=&#34;审计基础架构&#34;&gt;审计基础架构&lt;/h2&gt;
&lt;p&gt;在这个意义上审计云原生基础架构与审核调解器模式中的组件不同，它与第 6 章中讨论的测试框架也不同。相反，当我们谈论审计时，我们指的是对变更的高级概述和基础架构内的组件关系。&lt;/p&gt;
&lt;p&gt;跟踪基础架构中存在的内容以及它与其他组件的关系，为我们了解当前状态提供了重要的背景。当某些事情中断时，第一个问题几乎总是 “什么改变了？” 审计为我们回答了这个问题，并且可以用来告诉我们如果我们应用变更会受到什么影响。&lt;/p&gt;
&lt;p&gt;在传统的基础架构中，配置管理数据库（CMDB）通常是基础架构当前状态的真相来源。但是，CMDB 不会跟踪基础架构或资产关系的历史版本。&lt;/p&gt;
&lt;p&gt;云提供商可以通过库存 API 为您提供 CMDB 替代服务，但它们可能不会激励您显示历史趋势或让您查询您需要进行故障排除的特定详细信息，例如主机名。&lt;/p&gt;
&lt;p&gt;一个好的云审计工具可以让你显示当前基础架构与昨天或上周相比的差异（diff）。它应该能够将云提供商数据与其他来源（例如容器编排器）相结合，以便您可以查询云提供商可能没有的数据的基础架构，理想情况下，它可以自动构建组件关系的拓扑表示。&lt;/p&gt;
&lt;p&gt;如果您的应用程序完全在单个平台上运行（例如 Kubernetes），则收集资源依赖关系的拓扑信息要容易得多。自动可视化关系的另一种方法是统一关系发生的层次。&lt;/p&gt;
&lt;p&gt;对于在云中运行的服务，可以在服务之间的网络通信中识别关系。有很多方法可以识别服务之间的网络流量，但审计的重要考虑是对信息进行历史跟踪。您需要能够轻松识别关系何时发生变化，就像您识别组件之间关系一样容易。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;自动识别服务关系的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跟踪服务之间的网络流量意味着您需要了解用于通信的网络协议的工具。您不能简单地依赖流入或流出服务端点的原始数据包流量。你需要一种方法来利用信息流来建立关系模型。&lt;/p&gt;
&lt;p&gt;检查网络流量和构建依赖关系图的一种流行方式是通过网络代理。&lt;/p&gt;
&lt;p&gt;网络代理的一些实现示例是 linkerd 和 envoy。服务通过这些代理来传输所有流量，这些代理知道正在使用的协议和其他相关服务。如附录 B 所述，代理还允许其他网络弹性模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟踪时间拓扑结构是一个强大的审计工具。结合基础架构的历史，它将确保 “改变了什么？” 问题更容易回答。&lt;/p&gt;
&lt;p&gt;还有一个审计方面涉及在当前基础架构状态下建立信任。应用程序通过所描述的测试工具获得信任，但基础架构的某些方面无法应用相同的测试。&lt;/p&gt;
&lt;p&gt;用可验证的可重现组件构建基础架构可以提供很大的信任。这种做法被称为不可变基础设施。&lt;/p&gt;
&lt;h2 id=&#34;不可变基础设施&#34;&gt;不可变基础设施&lt;/h2&gt;
&lt;p&gt;不可变的基础架构是通过替换而不是修改来创建变更的做法。换句话说，不是运行配置管理来对所有服务器应用更改，而是建立新服务器并丢弃旧服务器。&lt;/p&gt;
&lt;p&gt;云环境很大程度上受益于创建变更的方法，因为部署新 VM 的成本通常非常低，比管理可强制配置并保持实例运行的另一个系统要容易。因为服务器是虚拟的（即用软件定义），所以您可以像构建服务器镜像一样应用与构建应用程序相同的实践。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物理服务器的传统基础架构与系统创建时的云具有完全相反的优化。提供物理服务器需要很长时间，并且在修改现有操作系统方面有很大的好处，而不是替换旧的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不可变基础设施的问题之一是建立信任链，为部署创造黄金镜像。镜像在构建时应该是可验证的（例如，签名密钥或镜像哈希），并且一旦部署就不应改变。&lt;/p&gt;
&lt;p&gt;镜像创建也需要自动化。历史上使用黄金镜像的最大问题之一是它们通常依靠人类在对照检查表十分耗时得创建出来。&lt;/p&gt;
&lt;p&gt;存在工具（例如，Hashicorp 的 Packer）来自动化构建过程，并且没有理由存在旧镜像。自动化还允许旧的清单成为可以审计和版本控制的脚本。了解配置工具何时发生变化以及由谁建立信任的不可变基础设施的另一方面。&lt;/p&gt;
&lt;p&gt;发生变更时，应该经常变更，您需要一种方法来跟踪变更内容和原因。审计将有助于确定发生了什么变化，而不可变的基础架构可以帮助您追踪到 Git 提交或拉取请求。&lt;/p&gt;
&lt;p&gt;追踪历史也大大有助于从失败中恢复过来。如果您有一个已知可用的虚拟机映像，另一个虚拟机镜像不可用，则可以像部署新的破损版本一样快速地部署以前的工作版本。&lt;/p&gt;
&lt;p&gt;不可变基础设施不是云原生基础架构的要求，但环境从这种基础架构管理风格中受益匪浅。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;通过本章介绍的实践，您将能够更轻松地控制在基础架构中运行的内容，并跟踪其运作的方式。将您的策略放在代码中可让您跟踪变更，而且您不用认为来解读策略。&lt;/p&gt;
&lt;p&gt;审计和不可变基础设施为您提供了更好的信息，以确保您的系统安全并帮助您更快地从故障中恢复。&lt;/p&gt;
&lt;p&gt;除了本章前面讨论的合规性测试要求之外，我们不会在本书中讨论安全性，但您应该及时了解您使用的技术和云提供商的安全最佳实践。安全性最重要的方面之一是在整个堆栈中应用 “分层安全”。&lt;/p&gt;
&lt;p&gt;换句话说，仅仅在主机操作系统上运行防病毒守护进程不足以保护您的应用程序。您需要查看您控制的所有基础架构层，并应用适合您需求的安全监控。&lt;/p&gt;
&lt;p&gt;本章中介绍的所有测试都应以第 4 章中介绍的相同协调模式运行。收集信息以了解当前状态，根据一组规则查找更改，然后使这些更改都适合云原生模式。&lt;/p&gt;
&lt;p&gt;如果您可以将您的策略作为代码实施，那么您将超越云的技术优势，并为云原生模式实现商业利益。&lt;/p&gt;
&lt;p&gt;历史和拓扑审计可能看起来并不明显，但随着基础架构的增长以及变化率和应用敏捷性的增加，这些审计将非常重要。将传统方法应用于管理云基础架构不是云原生，本章向您展示了您应该利用的一些好处以及您将面临的一些挑战。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 9 章：实施云原生基础架构</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/implementing-cloud-native-infrasctructure/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/implementing-cloud-native-infrasctructure/</guid>
      <description>&lt;p&gt;如果您认为云原生基础架构是可购买的产品或是从云供应商那购买的服务器，我们很抱歉让您失望了。如果不采用这些做法并改变您建设和维护基础架构的方式，您就不会受益。&lt;/p&gt;
&lt;p&gt;它不仅仅影响服务器、网络和存储。它关乎的是工程师如何管理应用程序，就像接受故障一样。&lt;/p&gt;
&lt;p&gt;围绕云原生实践建立的文化与传统技术和工程组织有很大不同。我们并不是解决组织文化或结构问题的专家，但如果您希望改变组织结构，我们建议您从高绩效组织中实施 DevOps 实践的角度来看待价值观和经验教训。&lt;/p&gt;
&lt;p&gt;一些需要探索的地方是 Netflix 的文化套餐，它促进了自由和责任感，还有亚马逊的双比萨团队，这些团队以低开销推广自治团体。云原生应用程序需要与构建它们的团队具有相同的解耦特征。康威定律很好地描述了这一点：“设计系统的架构受制于产生这些设计的组织的沟通结构。”&lt;/p&gt;
&lt;p&gt;在我们结束本书时，我们希望关注哪些领域是您采用云原生实践时最重要的。我们还将讨论一些预测变化的基础架构模式，以便您知道将来要寻找什么。&lt;/p&gt;
&lt;h2 id=&#34;关注改变的地方&#34;&gt;关注改变的地方&lt;/h2&gt;
&lt;p&gt;如果您拥有现有的基础架构或传统数据中心，则过渡到云原生不会在一夜之间发生。如果您有足够大的基础架构或两个以上的人员管理它，试图强制实施基础架构管理的新方法可能会失败。&lt;/p&gt;
&lt;p&gt;采用这些模式与配置新服务器或购买新软件无关。要开始采用云原生基础架构，最重要的是是首先关注这些领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人&lt;/li&gt;
&lt;li&gt;架构&lt;/li&gt;
&lt;li&gt;混乱&lt;/li&gt;
&lt;li&gt;应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直到您准备好这些区域以使用本书中描述的实践，才能开始更改基础架构。&lt;/p&gt;
&lt;h3 id=&#34;人&#34;&gt;人&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;比竞争对手更快学习的能力可能是唯一的可持续竞争优势。&lt;/p&gt;
&lt;p&gt;——Arie de Geus&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如我们在第 2 章中所讨论的，人是实施任何变革中最难的部分。他们的抵制有很多原因，而那些要求进行变更以帮助其影响的人有责任。&lt;/p&gt;
&lt;p&gt;当需要改变的驱动激励时，变更更容易。主动提高潜力是一个很好的激励因素，但如果没有紧迫感，就很难改变行为。&lt;/p&gt;
&lt;p&gt;人们抗拒改变的原因大多来自恐惧。人们喜欢习惯，因为他们可以控制并避免意外。&lt;/p&gt;
&lt;p&gt;为了使任何技术取得成功的重大转变，您需要与人们合作以最大限度地减少他们的恐惧。给他们一种主人翁感，并解释变化的明确目标。确保突出新旧技术之间的相似之处，特别是在改变后他们将扮演的角色。&lt;/p&gt;
&lt;p&gt;人们了解这种变化并不是因为他们在旧系统或现有系统中的失败，这一点也很重要。他们需要明白，要求已经改变，环境不同，并且希望他们成为变革的一部分，因为你尊重他们所做的并且对他们能做的事有信心。&lt;/p&gt;
&lt;p&gt;他们需要学习新事物，为此，失败是必要的，预期的，并且是进步的标志。&lt;/p&gt;
&lt;p&gt;鼓励学习和实验，并奖励适应数据洞察的人员和系统。让工程师通过诸如 “百分之二十的时间” 之类的自由来探索新的可能性，可以做到这一点。&lt;/p&gt;
&lt;p&gt;如果敏捷系统没有改变，它就没有好处。一个不适应和改进的系统将无法满足正在改变和学习的企业的需求。&lt;/p&gt;
&lt;p&gt;一旦你能够激发人们寻求改变，你应该用信任和自由来赋予他们力量。不断引导他们将自己的目标与业务需求结合起来，并赋予他们应聘的管理职责。&lt;/p&gt;
&lt;p&gt;如果人们已经准备好采用本书中的做法，那么实现它就没有什么限制。关于创建组织变革的更深入的指导，我们推荐阅读 John P. Kotter（哈佛商业评论出版社）的 “领导变革”。&lt;/p&gt;
&lt;p&gt;改变环境文化需要组织的大量努力和支持，以及更改应用程序运行的基础架构。您选择的架构可能会对采用云原生模式的能力产生重大影响。&lt;/p&gt;
&lt;h3 id=&#34;架构&#34;&gt;架构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;弹性、安全性、可伸缩性、可部署性、可测试性是架构问题。&lt;/p&gt;
&lt;p&gt;——Jez Humble&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将应用程序迁移到云原生基础架构时，您需要考虑如何管理和设计应用程序。例如，作为云原生应用程序前身的 12 因子应用程序受益于在平台上运行。它们被设计为最小化手动管理，频繁更改和弹性。许多传统应用程序的架构都是为了抵制自动化，不经常升级和失败。在迁移它之前，您应该考虑应用程序的架构。&lt;/p&gt;
&lt;p&gt;单个应用程序架构是一个问题，但您还需要考虑应用程序如何与基础架构内的其他服务通信。应用程序应已云环境中支持的协议以及通过明确界定的接口进行通信，通过采用微服务保持应用程序范围很小可以帮助定义应用程序间接口和提高应用程序部署速度。但是，采用微服务会暴露出新的问题，如应用程序通信速度较慢以及分布式跟踪和策略控制网络的需求。 如果不能为您的基础架构提供好处，就不要采用微服务。&lt;/p&gt;
&lt;p&gt;虽然您几乎可以适应任何应用程序在容器中运行并使用容器编排器进行部署，但如果首选迁移所有关键业务数据库服务器，您将很快就会后悔。&lt;/p&gt;
&lt;p&gt;首先确定接近具有第 1 章概述的特性的应用程序并获得在云原生环境中运行它们的经验。一旦您围绕简单的应用程序集体获得经验和良好实践，那么您就可以决定接下来要做什么。&lt;/p&gt;
&lt;p&gt;您的服务器和服务也不例外。在将基础架构切换为不可变的之前，您应确保它解决了当前的问题，并意识到新问题。&lt;/p&gt;
&lt;p&gt;可靠系统中最重要的架构考虑是争取简单的解决方案。软件和系统自然会变得复杂，这会造成不稳定。在云中，您可以释放对许多区域的控制，因此在仍然可以控制的区域保持简单性很重要。&lt;/p&gt;
&lt;p&gt;无论您将内部部署基础架构迁移到云中还是创建新的解决方案，都要确保您在第 1 章中进行可用性数学计算，并为混乱情况做好准备。&lt;/p&gt;
&lt;h3 id=&#34;混沌管理&#34;&gt;混沌管理&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;拥抱失败并期待混乱。&lt;/p&gt;
&lt;p&gt;——Netflix 的 Andrew Spyker&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当您构建云原生应用程序和基础架构时，其目标是创建最小可行产品（MVP）和迭代。尝试指定您的客户需要什么或他们将如何使用您的产品可能会有用一段时间，但成功的应用程序将适应而不是预测。&lt;/p&gt;
&lt;p&gt;客户需求改变；应用程序需要随它们改变。您无法计划和构建完整的解决方案，因为在产品准备就绪时，需求已发生变化。&lt;/p&gt;
&lt;p&gt;保持敏捷并在现有技术基础上发展很重要。就像您为应用程序导入库一样，您应该为基础架构使用 IaaS 和 SaaS。你越努力建立自己，你就越能提供价值。&lt;/p&gt;
&lt;p&gt;无论何时释放对某物的控制，都会冒着意想不到的风险。如果因为导入的库已更新而导致应用程序中断，您将会知道这是什么感觉。&lt;/p&gt;
&lt;p&gt;您的应用程序依赖于库所提供的功能，该功能已更改。你是否应该删除库并编写自己的功能以便控制它？答案几乎总是不。相反，您更新应用程序以使用新库，或者将正在运行的较旧版本的库与应用程序捆绑在一起，以暂时避免损坏。&lt;/p&gt;
&lt;p&gt;运行在公有云上的基础架构也是如此。您不再控制硬连线网络，使用什么 RAID 控制器，或者虚拟机的哪个版本的虚拟机管理程序运行。您所拥有的只是可以在底层技术之上提供抽象的 API。&lt;/p&gt;
&lt;p&gt;您无法控制底层技术何时发生变化。如果云提供商弃用所有大型内存实例类型，则您别无选择，只能遵守。您要么适应新的尺寸，要么支付更换提供商的成本（时间和金钱）（请参阅附录 B 关于锁定）。&lt;/p&gt;
&lt;p&gt;最重要的是，您构建的基础架构不再可以从单个关键服务器获得。如果您采用云原生基础架构，无论您是否喜欢，您正在构建一个分布式系统。&lt;/p&gt;
&lt;p&gt;通过简单地避免失败来保持服务可用的旧做法不起作用。目标不再是您可以设计的最大数目的几个 9—— 而是你可以摆脱的最小数量的几个 9。&lt;/p&gt;
&lt;p&gt;站点可靠性工程（Site Reliability Engineering）以这种方式解释它：&lt;/p&gt;
&lt;p&gt;坚持 SLO 将百分之百满足是不现实的和不可取的：这样做可能会降低创新和部署的速度，需要昂贵的，过于保守的解决方案，或两者兼而有之。相反，最好允许一个错误预算 —— 一个可能错过 SLO 的速率，并且每天或每周对其进行跟踪。&lt;/p&gt;
&lt;p&gt;工程的目标不可用；它创造了商业价值。你应该制造弹性系统，但不要以过度工程解决方案为代价来避免混乱。&lt;/p&gt;
&lt;p&gt;测试更改以防止停机的旧方法也不起作用。为大型分布式系统创建测试环境并不重要。当服务经常更新并且部署是自助服务时尤其如此。&lt;/p&gt;
&lt;p&gt;当 Netflix 每天有 4,000 次部署或 Facebook 有 10,000 个同时运行的版本时，对环境进行快照是不可能的。测试环境需要动态分离生产部分。基础架构需要支持这种测试方法，并支持经常测试生产中的新代码所带来的失败。&lt;/p&gt;
&lt;p&gt;你可以测试一些混乱（参见第 5 章），但混沌根据定义是不可预测的。准备您的基础架构和应用程序，以便可预测地对混乱做出反应，而不要试图避免它。&lt;/p&gt;
&lt;h3 id=&#34;应用程序&#34;&gt;应用程序&lt;/h3&gt;
&lt;p&gt;基础架构的目的是运行应用程序。如果您的业务完全基于向其他公司提供基础架构，那么您的成功仍取决于其运行应用程序的能力。&lt;/p&gt;
&lt;p&gt;如果你建立它，他们不能保证来用。您创建的任何抽象需要提高运行应用程序的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;避免 “泄漏抽象”（Leaky Abstraction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象并不完全隐藏抽象的实现细节。泄漏抽象定律指出：“所有非平凡的抽象在一定程度上都是泄漏的。”&lt;/p&gt;
&lt;p&gt;这意味着你进一步抽象某事，隐藏事物的细节就越困难。&lt;/p&gt;
&lt;p&gt;例如，应用程序资源请求通常通过请求 CPU 核心的百分比，内存量和磁盘存储量来抽象化。这些资源的物理分配不直接由应用程序管理（API 不是由它们规定的），但对资源的请求很明显地表明运行应用程序的系统具有可用的这些类型的资源。&lt;/p&gt;
&lt;p&gt;相反，如果抽象是服务器或数据中心（例如，50 台服务器，0.2 个数据中心）的百分比，那么抽象并不具有相同的含义，因为不存在单一大小的服务器或数据中心单元。确保创建的抽象对于将使用它们的应用程序有意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云原生实践的好处是，随着您提高运行应用程序的能力，您还可以提高运行基础架构的能力。如果您遵循第 3-6 章的模式，您将很好地适应使用应用程序不断改进和调整您的基础架构以满足应用程序的需求。&lt;/p&gt;
&lt;p&gt;重点关注构建范围小，易于适应，易于操作和故障发生时具有弹性的应用程序。确保这些应用程序负责所有基础架构管理和更改。如果你这样做，你将创建云原生基础架构。&lt;/p&gt;
&lt;h2 id=&#34;预测未来&#34;&gt;预测未来&lt;/h2&gt;
&lt;p&gt;如果您已经采用了本书中的模式和实践，那么您现在处于未知领域。运行全球最大基础架构的公司已采用了这些做法。无论他们运行基础架构的新模式是否公开披露或仍在发现之中。&lt;/p&gt;
&lt;p&gt;好消息是您的基础架构现在被设计为敏捷和变化。您可以更轻松地适应您遇到的任何新挑战。&lt;/p&gt;
&lt;p&gt;为了展望未来的道路，我们可以不考虑现有的基础架构模式，而是考虑基础架构在哪里获得灵感 —— 软件。几乎所有基础架构采用的模式都来自软件开发模式。&lt;/p&gt;
&lt;p&gt;例如，分布式应用程序。很多年前，当软件暴露于互联网时，在单一代码库下的单个服务器上运行应用程序不会扩展。这包括管理应用程序的性能和流程限制。&lt;/p&gt;
&lt;p&gt;该应用程序需要复制到其他服务器上，然后进行负载均衡以满足需求。当达到限制时，它被分解成更小的组件，创建 API 以通过 HTTP 远程调用功能，而不是通过应用程序库。&lt;/p&gt;
&lt;p&gt;基础架构采取了类似的方法来扩大规模；在大多数领域只适应比软件更慢的速度。像 Kubernetes 这样的现代化基础架构平台将基础架构管理分解成更小的组件。这些组件可以根据其性能瓶颈（CPU、内存和 I/O）独立扩展，并且可以快速迭代。&lt;/p&gt;
&lt;p&gt;有些应用程序没有相同的扩展需求，也不需要适应新的架构。工程师的需要知道何时采用新技术。只有那些了解其堆栈的局限性和瓶颈的人才能决定什么是正确的方向。&lt;/p&gt;
&lt;p&gt;当发现新的限制时，请密切注意新的解决方案应用程序的发展。如果您了解限制是什么以及进行更改的原因，那么您将始终处于基础架构的领先地位。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;本书的目标是帮助您更好地理解什么是云原生基础架构以及您为什么要采用它。虽然我们相信它比传统基础架构有很多优势，但我们不希望您在不理解它的情况下盲目使用任何技术。&lt;/p&gt;
&lt;p&gt;不要期望在不采用其伴随的文化和流程的情况下获得所有好处。只是在公有云中运行基础架构或运行容器编排器不会改变该基础架构如何适应的过程。&lt;/p&gt;
&lt;p&gt;在 AWS 中手动创建少量虚拟机，通过 SSH 连接到每台虚拟机，创建 Kubernetes 集群比改变人们的工作方式更容易。前者不是云原生的。&lt;/p&gt;
&lt;p&gt;请记住，配置基础架构的应用程序不是及时的静态快照；它们应该不断运行并将基础架构推向期望的状态。管理基础架构不是维护主机。您需要为资源创建抽象，用 API 来表示这些抽象，以及使用它们的应用程序。&lt;/p&gt;
&lt;p&gt;目标是满足您的应用程序的需求，并编写与您的业务流程和工作职能相当的软件应用程序。随着流程和功能的频繁变化，软件需要轻松适应。&lt;/p&gt;
&lt;p&gt;掌握它时，您将不断发现在创建新抽象，保持服务弹性以及推动可伸缩性极限方面的挑战。如果您能够找到新的限制和有用的抽象，请回馈给您所属的社区。&lt;/p&gt;
&lt;p&gt;开源并通过研究和社区回馈是这些模式是使得它们从先驱环境中出现。共享使更多的创新和见解得以传播，并使每个人更容易实践和适应。&lt;/p&gt;
&lt;p&gt;创新不仅来自寻找解决方案或打造下一个出色的产品。创新通常来自寻常的提问、交谈和失败。&lt;/p&gt;
&lt;p&gt;请继续做所有这些事情，尤其是失败和分享。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>附录 A：网络弹性模式</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/appendix-a-patterns-for-network-resiilency/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/appendix-a-patterns-for-network-resiilency/</guid>
      <description>&lt;p&gt;在云环境中运行时，应用程序需要具有弹性。网络通信方面特别容易出现故障。添加网络弹性的一种常见模式是创建一个导入到应用程序中的库，该库提供本附录中描述的网络弹性模式。但是，导入的库很难维护以多种语言编写的服务，且当新版本的网络库发布时，会增加应用程序测试和重新部署的负担。&lt;/p&gt;
&lt;p&gt;取代应用程序处理网络弹性逻辑的另一种方式是，可以将代理置于适当的位置，作为应用程序的保护和增强层。代理的优势在于避免应用程序需要额外的复杂代码，尽量减少开发人员的工作量。&lt;/p&gt;
&lt;p&gt;可以在连接层（物理或 SDN），应用程序或透明代理中处理网络弹性逻辑。虽然代理不是传统网络堆栈的一部分，但它们可用于透明地管理应用程序的网络弹性。&lt;/p&gt;
&lt;p&gt;透明代理可以在基础架构中的任何位置运行，但与应用程序的距离越近越有利。代理支持的协议还要尽可能全面，且可以代理的开放系统互连模型（OSI 模型）层。&lt;/p&gt;
&lt;p&gt;通过实施以下模式，代理在基础架构的弹性中扮演着积极的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;负载切分（Load shedding）&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;重试和 deadline&lt;/li&gt;
&lt;li&gt;断路&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代理也可以用来为应用程序添加功能。包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全和认证&lt;/li&gt;
&lt;li&gt;路由（入口和出口）&lt;/li&gt;
&lt;li&gt;洞察和监测&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;
&lt;p&gt;应用程序负载均衡的方式有很多，应始终将负载均衡器放在云原生应用程序之前的原因有：&lt;/p&gt;
&lt;p&gt;DigitalOcean 在 “5 个 DigitalOcean 负载均衡器使用案例” 中给出了一些很好的理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平缩放&lt;/li&gt;
&lt;li&gt;高可用性&lt;/li&gt;
&lt;li&gt;应用程序部署&lt;/li&gt;
&lt;li&gt;动态流量路由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;协调透明代理（例如 Envoy 和 Linkerd）是负载均衡应用程序的一种方式。具有透明代理句柄负载均衡的一些好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对所有端点的请求视图允许更好的负载均衡决策。&lt;/li&gt;
&lt;li&gt;基于软件的负载均衡器可灵活选择正确的方式来平衡负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;透明代理不必盲目地将流量传递给下一个路由器。正如 Bunyan 在其博客文章 “超越循环：负载均衡延迟” 中指出的，他们可以集中协调以对基础架构有更广泛的了解。这使得负载均衡能够从全局优化流量路由，而不是仅为本地优化快速分组切换。&lt;/p&gt;
&lt;p&gt;随着对端点中哪些服务正在发送和接收请求有了更深的了解，代理可以更合理地向发送流量。&lt;/p&gt;
&lt;h2 id=&#34;负载切分&#34;&gt;负载切分&lt;/h2&gt;
&lt;p&gt;“站点可靠性工程” 手册解释了负载切分（Load shedding）与负载均衡不同。尽管负载均衡试图找到正确的后端来发送流量，但是如果应用程序无法接受请求，负载剔除会有意地丢弃流量。&lt;/p&gt;
&lt;p&gt;通过删除负载来保护应用程序实例，可以确保应用程序不会重新启动或被迫进入不利条件。删除请求比等待超时并要求重新启动应用程序要快得多。&lt;/p&gt;
&lt;p&gt;当发生中断或流量过多时，减载可以帮助保护应用程序实例。一切正常时，应用程序应该通过服务发现发现其他相关服务。&lt;/p&gt;
&lt;h2 id=&#34;服务发现&#34;&gt;服务发现&lt;/h2&gt;
&lt;p&gt;服务发现通常由运行服务的编排系统处理。透明代理可以绑定到相同的数据并提供附加功能。&lt;/p&gt;
&lt;p&gt;代理可以通过将多个源绑定在一起（例如，DNS 和键值数据库）并将它们呈现在统一接口中来增强标准服务发现。这允许实现者在不重写所有应用程序代码的情况下改变其后端。如果在应用程序之外处理服务发现，则可以更改服务发现工具而不必重写任何应用程序代码。&lt;/p&gt;
&lt;p&gt;由于代理可以对基础架构中的请求提供更全面的视图，因此可以决定端点何时健康与否。这与其他功能配合使用，例如负载均衡和重试，以将流量路由到最佳端点。&lt;/p&gt;
&lt;p&gt;当允许服务彼此发现时，代理服务器还可以考虑额外的元数据。它们可以实现逻辑，如节点延迟或 “距离”，以确保为请求发现正确的服务。&lt;/p&gt;
&lt;h2 id=&#34;重试和-deadline&#34;&gt;重试和 deadline&lt;/h2&gt;
&lt;p&gt;通常，应用程序会使用内置逻辑来知道如何处理对外部服务失败的请求。这也可以由代理无需额外的应用程序代码来处理。&lt;/p&gt;
&lt;p&gt;代理拦截应用程序的所有入口和出口流量并路由请求。如果传出请求失败，代理可以自动重试，而无需涉及应用程序。如果请求因任何其他原因返回，则代理可以根据其配置中的规则进行适当处理。&lt;/p&gt;
&lt;p&gt;这很好，只要应用程序对延迟有弹性。否则，代理应根据申请截止日期返回失败通知。&lt;/p&gt;
&lt;p&gt;截止日期允许应用程序指定允许请求的时间长度。由于代理可以 “追踪” 到目的地和返回的请求，因此它可以在使用代理的所有应用程序中强制执行最终期限策略。&lt;/p&gt;
&lt;p&gt;当超过 deadline 时，失败将返回给应用程序，并且可以决定适当的操作。选项可能会降级服务，但应用程序也可能选择将错误发回给用户。&lt;/p&gt;
&lt;h2 id=&#34;断路&#34;&gt;断路&lt;/h2&gt;
&lt;p&gt;该模式根据家用的断路器命名。当一切正常时，电路默认为 “关闭” 状态，允许流量流过断路器。当检测到故障时，电路 “打开” 并切断流量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重试模式使应用程序能够重试操作，以期成功。断路器模式阻止应用程序执行可能失败的操作。&lt;/p&gt;
&lt;p&gt;——Alex Homer，云设计模式：云应用程序指令性架构指南&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;断开的电路可以是单个端点或整个服务。打开后，不会发送任何流量，所有发送流量的尝试都将立即返回失败。&lt;/p&gt;
&lt;p&gt;与家用电路不同，即使处于打开状态，代理也可以测试失败的端点。当检测到故障后再次可用时，可将损坏的端点置于 “半开” 状态。此状态将发送少量流量，直到端点被标记为失败或健康。&lt;/p&gt;
&lt;p&gt;这种模式可以使得应用程序快速失败，并且只能发送到健康端点，从而使应用程序更快。通过不断检查端点，网络可以自行修复并智能地路由流量。&lt;/p&gt;
&lt;p&gt;除了这些弹性功能外，代理还可以通过以下方式增强应用程序。&lt;/p&gt;
&lt;h2 id=&#34;tls-和身份验证&#34;&gt;TLS 和身份验证&lt;/h2&gt;
&lt;p&gt;代理可以终止传输层安全性（TLS）或代理支持的任何其他安全性。这使得安全逻辑能够集中管理，而不是在每个应用程序中重新实现。然后可以在整个基础架构中更新安全协议或证书，而无需重新部署应用程序。&lt;/p&gt;
&lt;p&gt;身份验证也是如此。但是，授权仍应由应用程序管理，因为它通常是更细粒度的应用程序特定功能。在应用程序监督它们之前，用户会话 cookie 可以由代理验证。这意味着只有通过认证的流量才会被应用程序看到。&lt;/p&gt;
&lt;p&gt;这不仅可以节省应用程序的时间，还可以防止某些类型的滥用导致的停机。&lt;/p&gt;
&lt;h2 id=&#34;路由入口和出口&#34;&gt;路由（入口和出口）&lt;/h2&gt;
&lt;p&gt;当代理在所有应用程序之前运行时，它们控制流入和流出应用程序的流量。它们还可以管理流入和流出集群的流量。&lt;/p&gt;
&lt;p&gt;正如反向代理可以用于在 N 层体系结构中将流量路由到后端一样，服务代理也可能暴露于集群外部，用来路由到达的请求。这里的代理知道流量的另一个数据点来自何处和目的地。&lt;/p&gt;
&lt;p&gt;具有对所有服务间通信的深入了解的反向代理，可以比传统的反向代理更好地了解路由选择。&lt;/p&gt;
&lt;h2 id=&#34;洞察和监控&#34;&gt;洞察和监控&lt;/h2&gt;
&lt;p&gt;利用所有关于基础架构内流量流的知识，代理系统可以公开关于单个端点和整个集群范围内的流量视图的指标。这些数据点传统上已经在专有网络系统或难以自动化的协议中暴露出来（例如， SNMP）。&lt;/p&gt;
&lt;p&gt;由于代理可以立即知道何时端点无法访问，所以它们也最先了解端点何时不健康。虽然编排系统也可以检查应用程序运行状况，但应用程序可能不知道向编排工具报告不健康的状态。有了对同一服务所有端点的了解后，代理也可以成为监控服务运行状况的最佳位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>附录 B：锁定</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/appendix-b-lock-in/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/appendix-b-lock-in/</guid>
      <description>&lt;p&gt;关于使用云提供商和避免供应商锁定存在很多争议。这种辩论充满了意识心态之争。&lt;/p&gt;
&lt;p&gt;锁定通常是工程师和管理层关心的问题。应该将其与选择编程语言或框架一样作为应用程序的风险来权衡。编程语言和云提供商的选择是锁定的形式，工程师有责任了解风险并评估这些风险是否可以接受。&lt;/p&gt;
&lt;p&gt;当您选择供应商或技术时，请记住以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁定是不可避免的。&lt;/li&gt;
&lt;li&gt;锁定是一种风险，但并不总是很高。&lt;/li&gt;
&lt;li&gt;不要外包思维。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;锁定是不可避免的&#34;&gt;锁定是不可避免的&lt;/h2&gt;
&lt;p&gt;在技术上有两种类型的锁定：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术锁定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个开发技术栈中底层技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;供应商锁定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数情况下，作为项目的一部分而使用的服务和软件（供应商锁定还可能包括硬件和操作系统，但我们只关注服务）&lt;/p&gt;
&lt;h3 id=&#34;技术锁定&#34;&gt;技术锁定&lt;/h3&gt;
&lt;p&gt;开发人员将选择他们熟悉的技术或为正在开发的应用程序提供最大利益的技术。这些技术可以是供应商提供的技术（例如.NET 和 Oracle 数据库）到开源软件（例如 Python 和 PostgreSQL）。&lt;/p&gt;
&lt;p&gt;在此级别提供的锁定通常要求符合 API 或规范，这将影响应用程序的开发。也可以选择一些替代技术，但是这通常有很高的转换成本，因为技术对应用程序的设计有很大影响。&lt;/p&gt;
&lt;h3 id=&#34;供应商锁定&#34;&gt;供应商锁定&lt;/h3&gt;
&lt;p&gt;供应商，如云提供商，是另一种不同形式的锁定。在这种情况下，您正在消费供应商的资源。这可以是基础架构资源（例如，计算和存储），或者是托管软件（例如，Gmail）。&lt;/p&gt;
&lt;p&gt;消费资源的堆栈越高，应该从消耗的资源（例如 Heroku）中获得的价值就越高。高层次资源是从底层资源中抽离出来的，能产品的生产速度更快。&lt;/p&gt;
&lt;h2 id=&#34;锁定是一种风险&#34;&gt;锁定是一种风险&lt;/h2&gt;
&lt;p&gt;技术锁定通常是一次性决定或与供应商达成使用该技术的协议。如果您不再与供应商达成支持协议，则您的软件不会立即中断 —— 只是变得自我支持。&lt;/p&gt;
&lt;p&gt;开源软件可以在一定程度上减少来自技术的锁定，但并不能完全消除。使用开放标准可以进一步减少锁定，但了解开放标准与开放源代码之间的差异很重要。&lt;/p&gt;
&lt;p&gt;仅仅因为别人编写代码并不能使其成为标准。同样，专有系统可以形成非官方标准，允许从它们迁移出去（如 AWS S3）。&lt;/p&gt;
&lt;p&gt;供应商锁定的原因通常不仅仅是技术锁定，而是因为供应商锁定的风险高于技术风险。如果您不向供应商不支付费用，您的申请将停止运行；你不再能够访问你所支付的资源。&lt;/p&gt;
&lt;p&gt;如前所述，供应商服务提供更多价值，因为它们允许产品开发不需要所有较低级别的实现。不要避免托管服务来消除风险；你应该像对待其他任何事情一样权衡服务的风险和回报。&lt;/p&gt;
&lt;p&gt;如果服务提供标准接口，则风险非常低。接口越是自定义，或者产品越独特，切换的风险就越高。&lt;/p&gt;
&lt;h2 id=&#34;不要外包思维&#34;&gt;不要外包思维&lt;/h2&gt;
&lt;p&gt;本书的目标之一就是帮助您自己做出决定。在不了解建议的背景和是否适用于您的情况下，不要盲目听从其他人的意见或报告。&lt;/p&gt;
&lt;p&gt;如果您可以通过使用托管云服务更快地交付产品，则应该选择一个供应商开始使用。虽然衡量风险是好的，但将大把的时间花费在具有类似解决方案的多家供应商的争论上，又自己构建服务并不能节约您的时间。&lt;/p&gt;
&lt;p&gt;如果多个供应商提供类似的服务，请选择最容易采用的服务。开始使用该服务后，限制将很快显现。选择供应商时最重要的因素是选择一个与您具有相同创新步伐的供应商。&lt;/p&gt;
&lt;p&gt;如果供应商的创新速度比您快，那么您将无法利用其最新技术，还可能不得不花大量时间迁移旧技术。如果供应商的创新过于缓慢，那么您将不得不根据供应商提供的内容构建自己的抽象，而且您不会专注于您的业务目标。&lt;/p&gt;
&lt;p&gt;为了保持竞争力，您可能需要消费尚未拥有标准或替代品的资源（例如，新的和实验性的服务）。不要因为它们会使你陷入这项服务而害怕。重视保持竞争力或失去市场份额的风险，您的竞争对手可能会更快地创新。&lt;/p&gt;
&lt;p&gt;了解您无法避免的风险以及您的业务有多大风险。做可以最大化回报和将风险降至最低的决策。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>附录 C Box：案例研究</title>
      <link>https://lib.jimmysong.io/cloud-native-infra/appendix-c-box-case-study/</link>
      <pubDate>Wed, 18 May 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-infra/appendix-c-box-case-study/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;以下内容最初由 CNCF 发布在 Kubernetes.io 上，并且在此获得许可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 2014 年夏天，Box 对沉淀了十年的硬件和软件基础架构的痛苦，这无法与公司的需求保持一致。&lt;/p&gt;
&lt;p&gt;该平台为超过 5000 万用户（包括政府和大型企业如通用电气公司）管理和共享云中的内容，Box 最初是一个使用 PHP 写的具有数百万行的庞大代码，内置裸机数据中心。它已经开始将单体应用分解成微服务。 “随着我们扩展到全球各地，公有云战争正在升温，我们开始专注于如何在许多不同的环境和许多不同的云基础架构提供商之间运行我们的工作负载”，Box 联合创始人和服务架构师 Sam Ghods 说。 “迄今为止，这是一个巨大的挑战，因为所有这些不同的提供商，特别是裸机，都有非常不同的接口和与合作方式。”&lt;/p&gt;
&lt;p&gt;当 Ghods 参加 DockerCon 时，Box 的云原生之旅加速了。该公司已经认识到，它不能再仅仅使用裸机来运行应用程序，正在研究 Docker 容器化，使用 OpenStack 进行虚拟化以及支持公有云。&lt;/p&gt;
&lt;p&gt;在那次会议上，Google 宣布发布 Kubernetes 容器管理系统，Ghods 成功了。 “我们研究了许多不同的选择，但 Kubernetes 确实很出色，特别是因为 Borg 老兵的团队非常强大，可以以基础架构不可知的方式来运行云软件，” 他谈到 Google 内部的容器调度器 Borg。 “事实上，一开始它设计与裸机一样运行，就像我们可以在数据中心内迁移到它一样，然后也使用相同的工具和概念在公有云提供商上运行。”&lt;/p&gt;
&lt;p&gt;另外：Ghods 喜欢 Kubernetes 拥有一套通用的 API 对象，如 pod、服务、副本集和部署，这些对象创建了一个一致的接口来构建工具。 “甚至像 OpenShift 或 Deis 这样的构建在 Kubernetes 之上的 PaaS 层仍然将这些对象视为统一的原则，” 他说。 “我们很高兴能够在整个生态系统中共享这些抽象概念，这会产生比我们在其他潜在解决方案中更多的动力。”&lt;/p&gt;
&lt;p&gt;六个月后 Box 在一个生产数据中心的集群中部署了 Kubernetes。Kubernetes 在 0.11 版本之前仍然是测试版。他们从小版本开始：Ghods 的团队在 Kubernetes 上运行的第一个服务就是 Box API 监视器，确认了 Box 可以运行。 “这只是一个让整个管道运作正常的测试服务，” 他说。接下来是一些处理作业的守护进程，它们 “很好而且安全，因为如果他们遇到任何中断，也不会让来自客户的同步传入请求失败。”&lt;/p&gt;
&lt;p&gt;几个月后，该团队可以发送并要求提供信息的第一个实时服务启动。那时，Ghods 说：“我们对 Kubernetes 集群的稳定性感到满意。我们开始迁移一些服务，然后我们将扩大集群的规模和端口数量，最后每个数据中心的服务器数量大约为 100 台，这些服务器纯粹专用于 Kubernetes。在未来的 12 个月里，这个数字将会增长很多，达到数百甚至数千。“&lt;/p&gt;
&lt;p&gt;在观察开始使用 Kubernetes 进行微服务的团队时，“我们看到正在发布的微服务数量有所增加，”Ghodsnotes 说。 “显然，通过微服务构建软件的方式已被压抑很久，随着灵活性的提高帮助我们的开发人员提高了生产力，并为更好的架构选择做好了准备。”&lt;/p&gt;
&lt;p&gt;Ghods 反映，作为早期采用者，Box 经历了不同的旅程。他说：“我们肯定是在等待某些事情稳定和功能发布，我们在这一步上被锁定，” 他说。 “在早期，我们对 Kubectl 应用等组件做了很多贡献，并等待 Kubernetes 发布，然后我们会升级，贡献更多，并来回多次。整个项目从我们第一次在 Kubernetes 上进行实际部署到 GA 需要大约 18 个月的时间。如果我们今天自己来做一遍同样的事情，可能会少于六个月。“&lt;/p&gt;
&lt;p&gt;无论如何，Box 无需为 Kubernetes 做过多修改。Ghods 说：“我们团队在 Box 中实施 Kubernetes 所做的绝大多数工作一直致力于在我们现有的（往往是遗留下来的）基础架构内的工作，例如将我们的基础操作系统从 RHEL6 升级到 RHEL7 或将其整合纳入到我们的监控基础架构 Nagios。但总体而言，Kubernetes 非常灵活，能够适应我们的许多限制因素，并且它在我们的裸机基础架构上运行非常成功。“&lt;/p&gt;
&lt;p&gt;对于 Box 来说，更大的挑战也许是文化上的挑战。Ghods 说：“Kubernetes 和一般的云本身代表了一个非常大的范式转换，并且它不是非常渐进的，”Ghods 说。 “我们可以这样说，Kubernetes 将会解决所有问题，因为它能够以正确的方式做事，一切都会变得更好。但是要记住，它不像其他许多解决方案那样可靠。你不能说这家或那家公司花了多少时间做这件事，因为还没有那么多。我们的团队必须真正为资源而战，因为我们的项目有一点点的恐惧。“&lt;/p&gt;
&lt;p&gt;从经验中学习，Ghods 为经历类似挑战的公司提供了以下两条建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提前和经常交付。对于 Box 来说，服务发现是一个巨大的问题，团队必须决定是建立一个临时解决方案还是等待 Kubernetes 本身满足 Box 的独特要求。经过多次辩论之后，“我们刚开始专注于提供可行的解决方案，然后处理可能在稍后迁移到更原始的解决方案，”Ghods 说。 “无论多么微不足道，团队的上述目标应始终是为基础架构上的实际生产用例服务。这有助于保持团队本身和组织对项目的看法。“&lt;/li&gt;
&lt;li&gt;保持开放的态度，了解公司必须从开发人员那里抽象出什么和没有抽象出什么。早期，团队在 Dockerfiles 之上构建了一个抽象，以帮助确保所有容器镜像具有正确的安全更新。事实证明这是多余的工作，因为容器镜像是不可变的，您可以在构建后扫描它们以确保它们不包含漏洞。因为通过容器化来管理基础架构是一个不连续的飞跃，所以最好先直接使用本地工具学习其独特的优势和注意事项。抽象只能在实际需要出现之后才能建立。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，影响力非常强大。“在 Kubernetes 之前，”Ghods 说，“我们的基础架构非常陈旧，需要 6 个多月才能部署一个新的微服务。现在，一个新的微服务部署时间不到五天。我们正在努力让它达到不到一天。诚然，这六个月的大部分时间都是由于我们的系统有多么糟糕，但裸机本质上是一个难以支持的平台，除非您有像 Kubernetes 这样的系统来帮助管理它。“&lt;/p&gt;
&lt;p&gt;按 Ghods 的估计，Box 距离完成 90％运行在 Kubernetes 上的目标还有几年的时间。 “到目前为止，我们已经完成了一项稳定的，关键任务的 Kubernetes 部署，它提供了很多价值，” 他说。 “现在我们 10％左右服务器都运行在 Kubernetes 上，我认为明年我们可能会超过一半。我们正在努力实现所有无状态服务使用案例，并计划在此之后将我们的重点转移到有状态服务。“&lt;/p&gt;
&lt;p&gt;事实上，这就是他在整个行业中的设想：Ghods 预测 Kubernetes 有机会成为新的云平台。 Kubernetes 提供了一个涵盖不同云平台的 API，包括裸机，以及 “当我们可以针对单一界面进行编程时，我不认为人们已经看到了可能的全部潜力”，他说。 “与 AWS 改变基础架构一样，您不必再考虑服务器或机柜或网络设备，Kubernetes 使您能够专注于您正在运行的软件，这非常令人兴奋。这是愿景。“&lt;/p&gt;
&lt;p&gt;Ghods 指出了已经在开发或最近发布的作为云平台的项目：集群联邦，Dashboard UI 和 CoreOS 的 etcd operator。 “我真的相信这是我在云基础架构中看到的最激动人心的事情，” 他说，“因为它是一个前所未有的自动化和智能环境，其基础架构对每个基础架构平台都是可移植和不可知的。”&lt;/p&gt;
&lt;p&gt;由于早期决定使用裸机，Box 不得已开始了 Kubernetes 之旅。但是 Ghods 表示，即使公司现在不必对云提供商不可知，Kubernetes 也可能很快成为行业标准，因为越来越多的工具和扩展是围绕 API 构建的。&lt;/p&gt;
&lt;p&gt;“同样的方式，偏离 Linux 是没有意义的，因为它是如此的标准，”Ghods 说，“我认为 Kubernetes 正在走相同的道路。现在还处于早期阶段 —— 文档仍然需要工作，用于编写和发布 YAML 到 Kubernetes 集群的用户体验仍然很艰难。当你处于潮流最前线时，你可能会做出一些牺牲。但底线是，这是行业发展的方向。从现在开始的三到五年，如果您还会以其他方式运行基础架构，那么真的会让人非常震惊。“&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 的历史</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/kubernetes/history/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/kubernetes/history/</guid>
      <description>&lt;p&gt;众所周知，&lt;a href=&#34;http://kubernetes.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 是 Google 于 2014 年 6 月基于其内部使用的 &lt;a href=&#34;https://research.google.com/pubs/pub43438.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg&lt;/a&gt; 系统开源出来的容器编排调度引擎。其实从 2000 年开始，Google 就开始基于容器研发三个容器管理系统，分别是 Borg、Omega 和 Kubernetes。这篇由 Google 工程师 Brendan Burns、Brian Grant、David Oppenheimer、Eric Brewer 和 John Wilkes 几人在 2016 年发表的&lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Borg, Omega, and Kubernetes》&lt;/a&gt;论文里，阐述了 Google 从 Borg 到 Kubernetes 这个旅程中所获得知识和经验教训。&lt;/p&gt;
&lt;h2 id=&#34;borgomega-和-kubernetes&#34;&gt;Borg、Omega 和 Kubernetes&lt;/h2&gt;
&lt;p&gt;Google 从 2000 年初就开始使用容器（Linux 容器）系统，Google 开发出来的第一个统一的容器管理系统在内部称之为 “Borg”，用来管理长时间运行的生产服务和批处理服务。由于 Borg 的规模、功能的广泛性和超高的稳定性，一直到现在 Borg 在 Google 内部依然是主要的容器管理系统。&lt;/p&gt;
&lt;p&gt;Google 的第二套容器管理系统叫做 Omega，作为 Borg 的延伸，它的出现是出于提升 Borg 生态系统软件工程的愿望。Omega 应用到了很多在 Borg 内已经被认证的成功的模式，但是是从头开始来搭建以期更为一致的构架。由于越来越多的应用被开发并运行在 Borg 上，Google 开发了一个广泛的工具和服务的生态系统。它被应用到了很多在 Borg 内已经被认证的成功的模式，但是是从头开始来搭建以期更为一致的构架。这些系统提供了配置和更新 job 的机制，能够预测资源需求，动态地对在运行中的程序推送配置文件、服务发现、负载均衡、自动扩容、机器生命周期管理、额度管理等。许多 Omega 的创新（包括多个调度器）都被收录进了 Borg。&lt;/p&gt;
&lt;p&gt;Google 的第三套容器管理系统就是我们所熟知的 Kubernetes，它是针对在 Google 外部的对 Linux 容器感兴趣的开发者以及 Google 在公有云底层商业增长的考虑而研发的。和 Borg、Omega 完全是谷歌内部系统相比，Kubernetes 是开源的。像 Omega 一样，Kubernetes 在其核心有一个被分享的持久存储，有组件来检测相关 object 的变化。跟 Omega 不同的是，Omega 把存储直接暴露给信任的控制平面的组件，而在 Kubernete 中，提供了完全由特定领域更高层面的版本控制、认证、语义、策略的 REST API 接口，以服务更多的用户。更重要的是，Kubernetes 是由一群底层开发能力更强的开发者开发的，他们主要的设计目标是用更容易的方法去部署和管理复杂的分布式系统，同时仍能从容器提升的效率中受益。&lt;/p&gt;
&lt;p&gt;2014 年 Kubernetes 正式开源，2015 年被作为初创项目贡献给了云原生计算基金会（CNCF），从此开启了 Kubernetes 及云原生化的大潮。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://queue.acm.org/detail.cfm?id=2898444&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg, Omega, and Kubernetes: Lessons learned from three container-management systems over a decade - queue.acm.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dockone.io/article/1153&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Borg、Omega 和 Kubernetes：谷歌十几年来从这三个容器管理系统中得到的经验教训 - dockone.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Sidecar 模式</title>
      <link>https://lib.jimmysong.io/cloud-native-handbook/kubernetes/sidecar-pattern/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0100</pubDate>
      <guid>https://lib.jimmysong.io/cloud-native-handbook/kubernetes/sidecar-pattern/</guid>
      <description>&lt;p&gt;将应用程序的功能划分为单独的进程运行在同一个最小调度单元中（例如 Kubernetes 中的 Pod）可以被视为 &lt;strong&gt;sidecar 模式&lt;/strong&gt;。如下图所示，sidecar 模式允许您在应用程序旁边添加更多功能，而无需额外第三方组件配置或修改应用程序代码。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-sidecar-模式示意图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../../images/sidecar-pattern.jpg&#34; alt=&#34;Sidecar 模式示意图&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Sidecar 模式示意图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;就像连接了 Sidecar 的三轮摩托车一样，在软件架构中， Sidecar 连接到父应用并且为其添加扩展或者增强功能。Sidecar 应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观测性、监控、日志记录、配置、断路器等功能。&lt;/p&gt;
&lt;h2 id=&#34;使用-sidecar-模式的优势&#34;&gt;使用 Sidecar 模式的优势&lt;/h2&gt;
&lt;p&gt;使用 sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 sidecar 副本。在 sidecar 部署方式中，每个应用的容器旁都会部署一个伴生容器，这个容器称之为 sidecar 容器。Sidecar 接管进出应用容器的所有流量。在 Kubernetes 的 Pod 中，在原有的应用容器旁边注入一个 Sidecar 容器，两个容器共享存储、网络等资源，可以广义的将这个包含了 sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。&lt;/p&gt;
&lt;p&gt;因其独特的部署结构，使得 sidecar 模式具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度。&lt;/li&gt;
&lt;li&gt;因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。&lt;/li&gt;
&lt;li&gt;Sidecar 可独立升级，降低应用程序代码和底层平台的耦合度。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>什么是云绑定应用程序？</title>
      <link>https://lib.jimmysong.io/blog/cloud-bound-applications/</link>
      <pubDate>Fri, 10 Mar 2023 12:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/cloud-bound-applications/</guid>
      <description>&lt;p&gt;本文作者 Bilgin Ibryam 是 Diagrid 的技术产品经理，致力于开发人员生产力工具。在此之前，他曾在 Red Hat 担任顾问和架构师，同时也是 Apache 软件基金会的提交者和成员。Bilgin 还与人合著了两本关于 Kubernetes 模式和 Camel 设计模式的书。在业余时间，Bilgin 喜欢通过博客和其他方式写作和分享他的知识。&lt;/p&gt;
&lt;p&gt;译者注：本文介绍了云绑定应用程序的概念，并探讨了在使用云绑定应用程序时需要考虑的几个关键因素。首先，作者解释了云绑定应用程序是指在构建应用程序时使用云提供的服务和资源。作者强调了使用云绑定应用程序可以带来很多好处，例如降低成本和提高可靠性。然而，作者也指出了在使用云绑定应用程序时需要考虑的几个关键因素，包括云供应商锁定、数据隐私和网络连接可靠性等。最后，作者提供了一些建议，帮助企业在使用云绑定应用程序时避免潜在的风险。例如，选择具有高可用性的云服务提供商，并在使用云绑定应用程序时加强数据安全措施。&lt;/p&gt;
&lt;h3 id=&#34;关键要点&#34;&gt;关键要点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;云提供商将重点从基础设施服务转移到开发人员直接使用的应用程序优先服务，从而产生了新的应用程序架构。&lt;/li&gt;
&lt;li&gt;这种架构允许开发人员将集成逻辑和管理责任卸载到云服务，并专注于实现业务逻辑。&lt;/li&gt;
&lt;li&gt;“云绑定”代表了云原生从解决以计算为中心的问题向管理应用集成问题的演进。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放 API 和事实标准将应用程序的内部架构与其外部依赖项分离。&lt;/li&gt;
&lt;li&gt;云绑定应用程序使用开放的 API 和数据格式将应用程序绑定到计算基础设施，并将状态编排、事件驱动的交互和可靠的同步交互等集成责任卸载到云服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.diagrid.io/blog/evolution-of-cloud-computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用程序优先&lt;/a&gt; 云服务的日益普及导致应用程序和云服务的集成比以前更深入。应用程序和云之间的运行时边界正在从虚拟机转移到容器和函数。在这个最终架构中，应用程序是“云绑定”的，通过将更多应用程序逻辑和管理责任卸载到云服务，开发人员可以专注于业务逻辑。&lt;/p&gt;
&lt;p&gt;本文通过使用保持灵活性和可移植性的开放 API 和标准将应用程序绑定到云服务来检查整个软件堆栈的商品化。&lt;/p&gt;
&lt;h2 id=&#34;内部架构演变&#34;&gt;内部架构演变&lt;/h2&gt;
&lt;p&gt;应用程序的内部架构通常由一个团队拥有和控制。根据所选的语言和运行时，包、模块、接口、类和函数等工具和抽象可帮助开发人员控制内部边界。&lt;a href=&#34;https://martinfowler.com/bliki/DomainDrivenDesign.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;领域驱动设计&lt;/a&gt;(DDD) 帮助开发人员设计领域模型，这些模型作为抽象来封装复杂的业务逻辑并调解业务现实与代码之间的差距。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://alistair.cockburn.us/hexagonal-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hexagonal&lt;/a&gt;，&lt;a href=&#34;https://jeffreypalermo.com/2013/08/onion-architecture-part-4-after-four-years/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Onion&lt;/a&gt; 和 &lt;a href=&#34;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clean&lt;/a&gt; 架构可以[补充](&lt;a href=&#34;https://herbertograca.com/2017/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://herbertograca.com/2017/&lt;/a&gt; 11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/) DDD 并安排具有不同边界和外部化基础设施依赖性的应用程序代码。尽管这些方法在开始时是创新的并且在今天仍然适用，但它们最初是为三层 Java 应用程序开发的，该应用程序由部署在共享应用程序运行时中的 JSP、Servlet 和 EJB 组成。当时的主要焦点是将应用程序逻辑与 UI 和数据库分离，并启用隔离测试。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1内部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1：内部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/images/f1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_feec8cd588a45db492687584396bcfe3.webp 400w,
               /blog/cloud-bound-applications/images/f1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_40c92b682d23732ab6339f1b8bf4c808.webp 760w,
               /blog/cloud-bound-applications/images/f1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/images/f1_hue4b81ea9d779f4b30e717f1931f2f2cc_42288_feec8cd588a45db492687584396bcfe3.webp&#34;
               width=&#34;760&#34;
               height=&#34;619&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1：内部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从那时起，微服务和&lt;a href=&#34;https://12factor.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;十二因素&lt;/a&gt; 应用程序等新挑战和概念不断涌现，并影响了我们设计应用程序的方式。微服务的核心是将应用程序逻辑分离到由单个团队拥有的可独立部署的单元中。十二因素应用程序方法旨在创建在动态云环境中运行和扩展的分布式、无状态应用程序。所有这些架构都引入了原则和最佳实践，这些原则和最佳实践塑造了我们构建应用程序内部架构的方式以及我们管理它的方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2应用程序架构演进时间表&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2：应用程序架构演进时间表&#34; srcset=&#34;
               /blog/cloud-bound-applications/images/f2_hu40b71820fd7baf24807d72301013b030_29518_d89e688973927ac5fd7998866b3b0562.webp 400w,
               /blog/cloud-bound-applications/images/f2_hu40b71820fd7baf24807d72301013b030_29518_c16fd89fd6a30c64f22bd56567ae8e1b.webp 760w,
               /blog/cloud-bound-applications/images/f2_hu40b71820fd7baf24807d72301013b030_29518_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/images/f2_hu40b71820fd7baf24807d72301013b030_29518_d89e688973927ac5fd7998866b3b0562.webp&#34;
               width=&#34;760&#34;
               height=&#34;278&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2：应用程序架构演进时间表
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;后来在应用程序架构演变时间表中，容器的主流采用和 Kubernetes 的引入彻底改变了应用程序的打包和编排方式。AWS Lambda 引入了高度可扩展的函数即服务 (FaaS) 的概念，将应用程序粒度的概念提升到一个新的水平，并将完整的基础设施管理责任卸载给云提供商。其他技术趋势，例如服务网格和&lt;a href=&#34;https://www.infoq.com/articles/multi-runtime-microservice-architecture/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;多运行时微服务架构&lt;/a&gt;，也已经出现并将非功能方面商品化，例如网络和分布式开发原语，分别将它们提取到 sidecar 中。受微服务的启发，数据网格架构旨在将应用程序的分析数据架构分解为更小、独立的数据域，每个域都有自己的产品和团队。这些以及最近的趋势，例如应用程序优先的云服务，正在开始重塑应用程序的外部架构，我在本文中将其统称为“云绑定应用程序”。&lt;/p&gt;
&lt;h2 id=&#34;外部架构演化&#34;&gt;外部架构演化&lt;/h2&gt;
&lt;p&gt;外部架构是应用程序与其他团队和组织拥有的其他应用程序和基础设施相交的地方，通常以专用的本地中间件、存储系统或云服务的形式出现。应用程序连接到外部系统并卸载其部分职责的方式形成了外部架构。为了从基础架构中受益，应用程序需要绑定到该基础架构并强制执行清晰的边界以保持其敏捷性。一个应用程序的内部架构和实现应该能够在不改变另一个应用程序的情况下进行更改，外部依赖关系（例如云服务）可以在不改变内部结构的情况下进行交换。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3外部应用架构&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3：外部应用架构&#34; srcset=&#34;
               /blog/cloud-bound-applications/images/f3_huf37fbf5460b713081b06bb34dc5f650c_50572_98f5fc9d59945d51fb14f17906cc87a0.webp 400w,
               /blog/cloud-bound-applications/images/f3_huf37fbf5460b713081b06bb34dc5f650c_50572_83cafdcf3f20c64c2852615623833d8e.webp 760w,
               /blog/cloud-bound-applications/images/f3_huf37fbf5460b713081b06bb34dc5f650c_50572_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/images/f3_huf37fbf5460b713081b06bb34dc5f650c_50572_98f5fc9d59945d51fb14f17906cc87a0.webp&#34;
               width=&#34;622&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3：外部应用架构
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从广义上讲，我们可以将应用程序与其周围环境绑定的方式分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算绑定是在计算平台（例如 Kubernetes、容器服务，甚至是 AWS Lambda 等无服务器函数）上运行应用程序所需的所有绑定、配置、API 和合约。大多数情况下，这些绑定对内部架构是透明的，并且由运营团队而非开发人员配置和使用。容器抽象是当今应用程序计算绑定最广泛的“API”。&lt;/li&gt;
&lt;li&gt;集成绑定是对应用程序所依赖的外部依赖项的所有其他绑定的总称。云服务还使用这些绑定与应用程序交互，通常是通过定义明确的 HTTP “API”或专门的消息传递和存储访问协议，例如 AWS S3、Apache Kafka、Redis API 等。集成绑定不像运行时绑定那样透明。开发人员需要围绕它们实现额外的逻辑，例如重试、TTL、延迟、死信队列 (DLQ) 等，并将它们绑定到应用程序的业务逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用程序在云上运行并通过使用这些绑定来使用其他服务。让我们更详细地了解这些绑定背后的内容。&lt;/p&gt;
&lt;h2 id=&#34;计算绑定&#34;&gt;计算绑定&lt;/h2&gt;
&lt;p&gt;对于运营团队来说，理想情况下，每个应用程序都是一个需要在计算平台上运行的黑盒单元。计算绑定用于管理 Kubernetes、AWS Lambda 和其他服务等平台上应用程序的生命周期。这些绑定以应用程序和应用程序运行平台之间的配置和 API 交互集合的形式形式化和定义。这些交互中的大部分对应用程序是透明的，只有少数 API 需要开发人员实现，例如健康端点和指标 API。这是目前CNCF对“云原生”&lt;a href=&#34;https://github.com/cncf/toc/blob/main/DEFINITION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;定义&lt;/a&gt;和范围的扩展，只要开发者实现云原生应用，他们可以在云计算平台上绑定运行。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4应用程序和平台计算绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4：应用程序和平台计算绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/images/f4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_82927a1b374a2db16c1d5c07cf38e2a5.webp 400w,
               /blog/cloud-bound-applications/images/f4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_84d775a565adf364067a746b2e6a439a.webp 760w,
               /blog/cloud-bound-applications/images/f4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/images/f4_hu1b40fa2145481e5f4874d3ce5345bc21_55792_82927a1b374a2db16c1d5c07cf38e2a5.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4：应用程序和平台计算绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;要在云平台上可靠地运行，应用程序必须在从规范到最佳实践的多个层面上与之绑定。这是通过一组行业标准规范（例如容器 API、指标 API）实现的，例如基于 Prometheus、健康端点或云提供商规范（例如 AWS Lambda 或 AWS ECS 规范）。此外，通过云原生最佳技术和共享知识，例如健康检查、部署策略和放置策略。让我们看看当今使用的常见计算绑定。&lt;/p&gt;
&lt;h3 id=&#34;资源需求&#34;&gt;资源需求&lt;/h3&gt;
&lt;p&gt;包括微服务和函数在内的应用程序需要 CPU、内存和存储等资源。这些资源的定义因所使用的平台而异。例如，在 Kubernetes 上，CPU 和内存是通过&lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;请求和限制&lt;/a&gt; 定义的，而在 AWS Lambda 上，用户&lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;指定&lt;/a&gt;运行时分配的内存量，以及对应的CPU分配。存储在这些平台上的处理方式也不同，Kubernetes 使用临时存储和卷，而 Lambda 提供临时暂存资源和基于 Amazon EFS 挂载的持久存储。&lt;/p&gt;
&lt;h3 id=&#34;生命周期钩子&#34;&gt;生命周期钩子&lt;/h3&gt;
&lt;p&gt;由平台管理的应用程序通常需要了解重要的生命周期事件。例如，在 Kubernetes 上，init 容器等概念和 PostStart 和 PreStop 等钩子允许应用程序对这些事件做出反应。同样，Lambda 的 &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/runtimes-extensions-api.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;extensions&lt;/a&gt; API 允许应用程序拦截 Init、Invoke 和 Shutdown 阶段。处理生命周期事件的其他选项包括包装器脚本或特定于语言的运行时修改选项，例如 JVM 的关闭钩子。这些机制形成了平台和应用程序之间的契约，使其能够响应和管理自己的生命周期。&lt;/p&gt;
&lt;h3 id=&#34;健康检查&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;运行状况探测是平台监控应用程序运行状况并在必要时采取纠正措施（例如重新启动应用程序）的一种方式。由于请求的生命周期较短，Lambda 函数没有健康探测，而容器化应用程序和编排器（如 Kubernetes、AWS EKS 和 GCP Cloud Run）确实在其定义中包含 &lt;a href=&#34;https://cloud.google.com/run/docs/configuring/healthchecks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;健康探测 &lt;/a&gt; 。这使平台能够确保应用程序平稳运行，并在应用程序运行不平稳时采取措施。&lt;/p&gt;
&lt;h3 id=&#34;部署和放置策略&#34;&gt;部署和放置策略&lt;/h3&gt;
&lt;p&gt;一旦知道所需的资源，计算平台就可以开始管理应用程序的生命周期。要以不损害业务逻辑完整性的方式执行此操作，平台必须了解扩展约束。有些应用程序被设计为单例。例如，它们需要维护已处理事件的顺序并且不能扩展到多个实例。其他有状态应用程序可能是仲裁驱动的，并且需要特定数量的最小实例连续运行才能正常运行。还有一些函数，例如无状态函数，可能有利于快速扩展以解决不断增加的负载峰值问题。一旦建立了应用程序的缩放指南，平台就会控制应用程序实例的启动和终止。&lt;/p&gt;
&lt;p&gt;计算还提供滚动、蓝绿、金丝雀、一次等多种部署策略，来控制服务更新的顺序。除了部署顺序之外，这些平台还允许用户指定放置首选项。例如，Kubernetes 提供标签、污点和容忍度、亲和力和反亲和力等选项，而 Lambda 允许用户在区域和&lt;a href=&#34;https://aws.amazon.com/lambda/edge/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;边缘放置&lt;/a&gt; 类型之间进行选择。这些首选项可确保部署应用程序并满足合规性和性能要求。&lt;/p&gt;
&lt;h3 id=&#34;网络流量&#34;&gt;网络流量&lt;/h3&gt;
&lt;p&gt;计算平台还负责将低级网络流量引导至服务实例。这是因为它负责部署排序、放置和自动缩放，这些都会影响流量如何定向到服务实例。健康检查也可以在流量管理中发挥作用，例如 GCP Cloud Run 和 Kubernetes 中的&lt;a href=&#34;https://cloud.google.com/run/docs/configuring/healthchecks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;准备情况检查&lt;/a&gt;。通过处理这些任务，计算平台有助于确保流量高效且有效地路由到适当的服务实例。&lt;/p&gt;
&lt;h3 id=&#34;监控和报告&#34;&gt;监控和报告&lt;/h3&gt;
&lt;p&gt;任何用于分布式应用程序的计算平台都必须以日志、指标和跟踪的形式提供深入的应用程序洞察力。目前该领域几乎没有被广泛接受的事实标准：日志最好以结构化格式使用，例如 JSON 或其他行业特定标准。计算平台通常收集日志或为专门的日志提取和分析服务提供扩展点以访问日志。这可以是 Kubernetes 上的 DaemonSet，用于监控的 Lambda 合作伙伴扩展，或 Vercel 边缘功能日志 Drainer。计算平台必须支持指标和追踪数据的收集和分析，以全面了解分布式应用程序的性能和行为。有几种行业标准格式和工具可用于处理此数据 &lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry (OTEL) for Tracking &lt;/a&gt; 计算平台可以提供内置工具来收集和分析这些数据，或者为专门服务提供扩展点来访问数据。无论代码粒度（微服务或函数）或位置（边缘或非边缘）如何，计算平台都必须允许捕获日志、指标和追踪数据，并导出到其他同类最佳的云服务。例如 &lt;a href=&#34;http://honeycomb.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Honeycomb&lt;/a&gt;、&lt;a href=&#34;https://www.datadoghq.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DataDog&lt;/a&gt;、&lt;a href=&#34;https://sysdig.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grafana&lt;/a&gt; 等。&lt;/p&gt;
&lt;h3 id=&#34;计算绑定趋势&#34;&gt;计算绑定趋势&lt;/h3&gt;
&lt;p&gt;计算绑定与语言和应用程序运行时无关，主要由运营团队用于在运行时管理应用程序，而不是开发人员实现它们。&lt;/p&gt;
&lt;p&gt;虽然应用程序的大小和复杂性可能因整体和功能而异，但它们通常打包在具有健康检查端点、实施的生命周期挂钩和公开指标的容器中。了解这些计算绑定将帮助你有效地使用任何基于容器的计算平台，无论是本地 Kubernetes 集群、托管容器服务（例如 AWS ECS、Google Cloud Run、Azure Container App），还是基于函数的运行时（例如作为 AWS Lambda、GCP 函数或边缘运行时，例如 Vercel &lt;a href=&#34;https://vercel.com/docs/concepts/functions/edge-functions&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;边缘函数&lt;/a&gt;、CloudFlare &lt;a href=&#34;https://workers.cloudflare.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;worker&lt;/a&gt; 或 Netlify edge &lt;a href=&#34;https://docs.netlify.com/edge-functions/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;functions&lt;/a&gt; 等。使用开放的事实上的标准 API 不仅可以帮助你创建可移植的应用程序，还可以通过使用可跨云供应商和服务提供商移植的操作实践和工具来限制供应商锁定。&lt;/p&gt;
&lt;h2 id=&#34;集成绑定&#34;&gt;集成绑定&lt;/h2&gt;
&lt;p&gt;另一方面，集成绑定旨在供开发人员而不是运营团队使用。它们以常见的分布式系统实现领域为中心，例如服务调用、事件驱动交互、任务调度和有状态工作流编排。它们通过基于云的类似中间件的服务帮助将应用程序与专用存储系统和外部系统连接起来，在本文中统称为集成云。与容器提供计算抽象的方式相同，集成云服务提供与语言无关的集成抽象作为服务。这些原语独立于用例、应用程序实现、运行时和计算环境。例如&lt;a href=&#34;https://learn.microsoft.com/en-us/azure/architecture/patterns/retry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;重试模式&lt;/a&gt;、&lt;a href=&#34;https://www.enterpriseintegrationpatterns.com/DeadLetterChannel.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DLQ模式&lt;/a&gt;、 &lt;a href=&#34;https://microservices.io/patterns/data/saga.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Saga 模式&lt;/a&gt;、服务发现和&lt;a href=&#34;https://martinfowler.com/bliki/CircuitBreaker.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;断路器&lt;/a&gt; 模式都可以集成为服务使用。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5应用程序和平台集成绑定&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5：应用程序和平台集成绑定&#34; srcset=&#34;
               /blog/cloud-bound-applications/images/f5_hufb20aa7c61dad71a4c335dca460c4126_61270_f8e0535135278d40dd69e50f2ec7e44c.webp 400w,
               /blog/cloud-bound-applications/images/f5_hufb20aa7c61dad71a4c335dca460c4126_61270_1ef486d5434f07eeaaa7d34c78ff219a.webp 760w,
               /blog/cloud-bound-applications/images/f5_hufb20aa7c61dad71a4c335dca460c4126_61270_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/images/f5_hufb20aa7c61dad71a4c335dca460c4126_61270_f8e0535135278d40dd69e50f2ec7e44c.webp&#34;
               width=&#34;760&#34;
               height=&#34;616&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5：应用程序和平台集成绑定
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;今天不存在将所有主要模式公开为独立功能的纯集成云。早期的云服务正在提供其中一些集成原语作为存储系统（如 Kafka、Redis 等）的功能，但这些功能很少单独使用或与其他功能结合使用。这里值得注意的例外是 AWS EventBridge 和 Azure Event Grid 等服务，你可以将它们与来自同一提供商的多个云服务一起使用，但不能直接与其他提供商一起使用。这是一个快速发展的领域，有一些很好的例子和一些尚未填补的空白，但我相信它们会在未来出现。应用程序必须绑定到集成的云服务并卸载其中的一些开发人员职责才能运行。以下是集成云服务的主要类型和绑定方面。&lt;/p&gt;
&lt;h3 id=&#34;集成要求&#34;&gt;集成要求&lt;/h3&gt;
&lt;p&gt;与应用程序可以请求资源并向计算平台表达部署和放置偏好的方式相同，应用程序也可以请求和激活特定的集成绑定。这些绑定可以通过以声明方式传递给平台的配置来激活，或者在运行时通过编程交互来激活。例如，应用程序可以使用声明式和编程式&lt;a href=&#34;https://docs.dapr.io/developing-applications/building-blocks/pubsub/subscription-methods/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;订阅&lt;/a&gt; pub/sub 主题。AWS Lambda 函数事件源可以通过配置以声明方式订阅，也可以通过客户端库或 SDK 请求集成平台注册或注销特定绑定以编程方式订阅。应用程序可以订阅 cron 作业触发器、激活外部系统的连接器、进行配置更改等等，所有这些都在集成云上运行。&lt;/p&gt;
&lt;h3 id=&#34;工作流程编排&#34;&gt;工作流程编排&lt;/h3&gt;
&lt;p&gt;持久服务编排逻辑是一种非常普遍的必需品，也是作为服务进行外部化和消费的主要候选者。因此，工作流编排是当今最著名的集成绑定类型之一。该服务的常见用途包括为服务和业务流程编排实施 Saga 模式、使用 AWS Step Functions、Google Stateful Functions、Azure Durable Functions 进行函数编排、使用 Google Workflow 进行任务分配等等。当使用这样的绑定时，部分应用程序编排状态和逻辑被卸载到另一个服务中。虽然应用程序服务具有内部状态和管理该状态的逻辑，但其他部分是外部的，可能在其他一些云服务中。这代表了当今应用程序作为一个独立的单元进行设计和操作的方式的转变。未来的应用程序不仅&lt;a href=&#34;https://queue.acm.org/detail.cfm?id=3415014&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据是外部的&lt;/a&gt;，而且集成也将是外部的。随着越来越多地采用集成云，更多的集成数据和逻辑将开始存在于外部。&lt;/p&gt;
&lt;h3 id=&#34;时间触发器&#34;&gt;时间触发器&lt;/h3&gt;
&lt;p&gt;时间绑定表示编排绑定的时间限制专业化。它只有一个目标，即根据给定的策略在特定时间触发各种服务。此类别中的示例包括 AWS EventBridge Scheduler、Google Cloud Scheduler、Upstash Qstack 服务等。&lt;/p&gt;
&lt;h3 id=&#34;事件驱动和消息服务&#34;&gt;事件驱动和消息服务&lt;/h3&gt;
&lt;p&gt;这些绑定充当事件存储来卸载请求和解耦应用程序，但它们越来越不限于存储和扩展以提供消息处理模式。它们在事件存储之上提供开发者原语，例如死信队列、重试、延迟传递和消息处理模式，例如过滤、聚合、重新排序、基于内容的路由、窃听等。这种绑定的例子有 Confluent Cloud kSQL、AWS EventBridge、Decodable Data Pipeline 等。&lt;/p&gt;
&lt;h3 id=&#34;外部连接器&#34;&gt;外部连接器&lt;/h3&gt;
&lt;p&gt;这些绑定有助于连接到外部系统。它们还执行数据规范化、错误处理、协议转换和数据转换。示例包括 Knative 源导入器、AWS EventBridge 连接器、Confluent Cloud &lt;a href=&#34;https://www.confluent.io/product/confluent-connectors&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;连接器&lt;/a&gt;、可解码的 Kafka 连接器、AWS Lambda 源和目标。&lt;/p&gt;
&lt;h3 id=&#34;健康检查-1&#34;&gt;健康检查&lt;/h3&gt;
&lt;p&gt;健康检查对于计算连接至关重要，失败的健康检查通常会导致应用程序重启。集成绑定也需要健康检查，但目的不同：集成健康检查不会影响应用程序的运行时，但它会告诉集成云应用程序是否能够处理集成驱动的交互。失败的集成状态检查会停止集成绑定，直到应用程序返回正常状态并且集成绑定恢复。通常，你可以使用相同的应用程序端点进行计算和集成绑定测试。一个很好的例子是 Dapr 应用程序 &lt;a href=&#34;https://docs.dapr.io/developing-applications/building-blocks/observability/app-health/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;健康检查&lt;/a&gt;，它可以暂时阻止消费者和连接器。将数据插入不健康的应用程序。&lt;/p&gt;
&lt;h3 id=&#34;其他绑定&#34;&gt;其他绑定&lt;/h3&gt;
&lt;p&gt;还有更多的绑定，属于集成绑定的范畴。例如，Kubernetes &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/downward-api/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Downward&lt;/a&gt; API 和 Lambda &lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;环境变量&lt;/a&gt; 等为应用程序提供内省数据，它为应用程序自省和元数据注入提供了一种简单的机制。配置和秘密绑定，其中秘密不仅在启动时注入到应用程序中，而且任何配置更新都通过 sidecars 推送到应用程序，例如 Hashicorp Vault Sidecar [Injector](&lt;a href=&#34;https://developer.hashicorp.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://developer.hashicorp.com/&lt;/a&gt; vault /docs/platform/k8s/injector) 或者 Dapr 的 &lt;a href=&#34;https://docs.dapr.io/developing-applications/building-blocks/configuration/configuration-api-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Configuration&lt;/a&gt; API, Kubernetes 的 &lt;a href=&#34;https://servicebinding.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Service Binding 设置&lt;/a&gt; 规范。和不太常见的模式，例如分布式&lt;a href=&#34;https://docs.dapr.io/developing-applications/building-blocks/distributed-lock/distributed-lock-api-overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;锁&lt;/a&gt;，这也是一个集成绑定提供对共享资源的互斥访问。&lt;/p&gt;
&lt;h3 id=&#34;集成绑定趋势&#34;&gt;集成绑定趋势&lt;/h3&gt;
&lt;p&gt;容器正在成为最流行和广泛使用的可移植格式，用于打包和运行应用程序，无论它们是长期运行的微服务还是短期功能。另一方面，集成绑定可以分为不同的问题域，例如事件驱动的交互、有状态的编排和状态访问，并且在底层存储和使用模式方面有所不同。例如，Apache Kafka 是 &lt;a href=&#34;https://www.kai-waehner.de/blog/2021/05/09/kafka-api-de-facto-standard-event-streaming-like-amazon-s3-object-storage/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;事实上的标准&lt;/a&gt;、用于文档访问的 AWS S3 API、用于键值缓存的 Redis、用于关系数据访问的 PostgreSQL 等等。使它们成为标准的是围绕它们构建的库、工具和服务的不断增长的生态系统，为成熟度、稳定性和未来的向后兼容性提供了很大程度的保证。但这些 API 本质上仅限于存储访问，并且通常需要开发人员解决应用程序代码中的分布式系统挑战。与堆栈上层软件的商品化一致，集成绑定作为服务提供。越来越多的无服务器云服务提供了额外的集成功能，除了数据访问之外，应用程序代码还可以绑定这些功能。&lt;/p&gt;
&lt;p&gt;在此模型中，云绑定应用程序通常在无服务器计算基础设施上运行，遵循云原生原语。它与其他无服务器云服务绑定，用于服务编排、事件处理或同步交互，如下所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6云绑定应用程序生态系统&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6：云绑定应用程序生态系统&#34; srcset=&#34;
               /blog/cloud-bound-applications/images/f6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_ab119bcb8a8f7654223b711c08dc5f1a.webp 400w,
               /blog/cloud-bound-applications/images/f6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_fd93c2e8696946321b4c2cbef64a8341.webp 760w,
               /blog/cloud-bound-applications/images/f6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/cloud-bound-applications/images/f6_hu76b96fdb2a4bf0da0f289f018df2de45_74762_ab119bcb8a8f7654223b711c08dc5f1a.webp&#34;
               width=&#34;760&#34;
               height=&#34;638&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6：云绑定应用程序生态系统
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CNCF 的 &lt;a href=&#34;https://dapr.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dapr&lt;/a&gt; 是一个将大部分集成绑定和开发人员关注点整合到一个开源 API 中的项目。它提供同步服务调用、有状态服务编排、异步事件驱动交互和特定技术连接器作为 API。类似于容器和 Kubernetes 如何充当计算抽象，Dapr 充当外部服务的抽象。Dapr 还提供了独立于底层云服务且往往必须在应用层实现的集成能力，例如弹性策略、死信队列、[延迟交付](&lt;a href=&#34;https://github.com/dapr/dapr/issues/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/dapr/dapr/issues/&lt;/a&gt; 2675)、跟踪、细粒度授权等。Dapr 被设计为多语言并在应用程序外部运行，从而可以轻松交换外部依赖项而无需更改应用程序的内部架构，如 Hexagon Architecture 中所述。虽然 Dapr 主要由实施应用程序的开发人员使用，但一旦引入，Dapr 就会增强分布式应用程序的可靠性和可见性，为运营和架构师团队提供 &lt;a href=&#34;https://www.diagrid.io/blog/dapr-as-a-10x-platform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;整体利益&lt;/a&gt;。要了解有关此主题的更多信息，请在今年晚些时候亲自或以虚拟方式参加 QConLondon，我将在那里&lt;a href=&#34;https://qconlondon.com/presentation/mar2023/commoditization-software-stack-how-application-first-cloud-services-are&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;讨论&lt;/a&gt; “应用程序优先的云服务如何改变游戏规则”。&lt;/p&gt;
&lt;h2 id=&#34;后云原生应用&#34;&gt;后云原生应用&lt;/h2&gt;
&lt;p&gt;云绑定应用代表了云原生的进步，从只解决计算问题到管理应用层需求。应用程序堆栈中的云服务从基础设施扩展到应用程序优先服务，加速了这一趋势。我们可以在以开发人员为中心的云服务的爆炸式增长中观察到这种转变，包括状态协调、事件驱动的应用程序基础架构、同步交互、基于云的开发和测试环境以及无服务运行时。这种向应用程序优先的云服务的转变正在产生一种新的应用程序架构，越来越多的应用程序逻辑在云服务中运行。应用程序与第三方云服务的这种混合允许开发人员分担更多责任，但是，它可能会限制不断变化的业务需求所需的灵活性和敏捷性。为了保持应用程序的内部和外部架构独立，应用程序和云服务需要在开发时通过清晰的边界解耦，并在运行时使用定义良好的开放 API 和格式进行深度绑定。正如容器和 Kubernetes 为计算提供了开放的 API，我们需要为应用程序集成抽象提供开放的 API。这将使操作实践和工具以及开发模式、功能和实践的可移植性和重用成为可能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生网络功能（CNF）应该让每个容器聚焦一个关注点</title>
      <link>https://lib.jimmysong.io/blog/cloud-native-network-functions-concern/</link>
      <pubDate>Thu, 02 Mar 2023 11:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/cloud-native-network-functions-concern/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;译者注：这篇文章介绍了如何编写云原生网络功能（CNF），即在电信领域的网络应用，它们与大多数云原生企业应用有不同的非功能性需求。CNF 需要满足高性能、高可靠性、高安全性和低延迟等指标。文章提出了一个基本的设计原则：每个容器只负责一个关注点，即一个单一的网络功能或子功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;本文主旨&#34;&gt;本文主旨&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Docker 和 Kubernetes 文档都提倡将一个应用程序或每个容器“一个问题”打包的概念。 这也可以作为每个应用程序和容器运行“一种进程类型”的指南。&lt;/li&gt;
&lt;li&gt;基于电信的云原生网络功能 (CNF) 具有低延迟、高吞吐量和弹性等特定要求，这激发了多关注点/多进程类型的容器化方法。&lt;/li&gt;
&lt;li&gt;使用多种进程类型实现的高性能电信应用程序应该探索使用 unix 域套接字而不是 TCP 或 HTTP 进行通信，因为这可以加快容器之间的通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://vmblog.com/archive/2022/01/04/the-zeitgeist-of-cloud-native-microservices.aspx#.Y73WvezMJhE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务的详细和简明定义&lt;/a&gt; 很有价值。 厚微服务可以是任何利用康威定律并按产品团队边界部署代码的东西。 精益微服务是那些遵循粗粒度代码部署的服务，通常在容器中，具有单一的关注点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.infoq.com/articles/cloud-native-network-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Network Functions&lt;/a&gt;（CNFs）是电信领域的网络应用，非功能性需求不同于大多数云原生企业应用。 CNF 通常是 &lt;a href=&#34;https://www.cncf.io/blog/2022/09/12/top-11-things-you-didnt-know-about-cloud-native-statefulness/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有状态的&lt;/a&gt; 同时需要 &lt;a href=&#34;https://www.cncf.io/blog/2022/09/26/top-9-overlooked-questions-when-designing-your-stateful-cloud-native-network-application/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;低延迟、高吞吐量和弹性&lt;/a&gt;。任何减少或禁止这些要求的架构要么不适合电信发展，要么在其实施中需要特殊例外。 这就是瘦微服务模型的挑战，它促进了容器和 CNF 的“一个关点，一个进程”的设计。&lt;/p&gt;
&lt;h2 id=&#34;每个容器聚焦于一个关注点&#34;&gt;每个容器聚焦于一个关注点&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google 云文档、&lt;/a&gt;&lt;a href=&#34;https://docs.docker.com/config/containers/multi-service_container/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docker 文档&lt;/a&gt; 和 &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 文档&lt;/a&gt; 都提倡每个容器一个应用程序或一个关注点的概念。 谷歌云文档使用术语“应用程序”，而 docker 文档使用术语“关注点”并将关注点进一步描述为一组父/子进程，它们是应用程序的一个方面。 nginx 实现就是一个很好的例子，它将在启动时创建一组子工作进程。 理解单一关注规则的另一种方法是说容器中应该只存在一种进程类型（例如一组 nginx 工作进程）。&lt;/p&gt;
&lt;p&gt;为什么存在这条规则？ 虽然最初认为这条规则背后的基本原理是降低单个模块、组件、对象等的复杂性，但这条规则背后的真正驱动力是尊重代码的变化率，这个概念借鉴了传统建筑概念和生物学。 工件的部署速度应与其更改频率一致。 云原生的方式是通过尽最大努力解耦代码来做到这一点。 对性能优化的需求通常会助长对解耦的抵制，我们将在后面介绍。&lt;/p&gt;
&lt;p&gt;电信等行业有独立发展的历史。 换句话说，在电信行业内，代码、代码库和代码部署都是在一个大型组织内开发的。 即使多个子组织共同开发一个大型项目（例如商业级交换机），此类库、项目和最终产品的部署也是集中部署并锁定步骤。 鉴于这段历史，即使前面提到的微服务的厚定义存在问题，网络功能更难遵守微服务的薄定义和单一关注点规则也就不足为奇了。&lt;/p&gt;
&lt;h2 id=&#34;每个进程一个关注点的七大好处&#34;&gt;每个进程一个关注点的七大好处&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/monodot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tom Donohue&lt;/a&gt; 说明了此处重述的&lt;a href=&#34;https://www.tutorialworks.com/containers-single-or-multiple-processes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;单一关注原则&lt;/a&gt; 的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;隔离&lt;/strong&gt;：进程在使用容器命名空间系统时，不会相互干扰。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：与许多类型相比，扩展一个进程或一类进程更容易。 这可能是出于复杂性的原因（一种进程类型比许多进程类型更难扩展）或因为变化率不同（一个进程需要根据与其他进程不同的条件增长）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可测试性&lt;/strong&gt;：当假定一个进程独立运行时，它可以独立于其他进程进行测试。 这使开发人员可以通过消除额外的变量来更轻松地定位问题的根本原因。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可部署性&lt;/strong&gt;：当进程的二进制文件和依赖项部署在容器中时，部署的变化率相对于二进制文件和容器是粗粒度的，但相对于其他进程及其依赖项是细粒度的。 这允许部署根据依赖树中发生更改的位置和时间进行调整，而不是同步重新部署所有内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可组合性&lt;/strong&gt;：进程中只有一个关注点，因此每个容器的进程类型更容易推理，因为它更容易以数字方式共享和口头交流其内容。 这使得它更容易在其他项目中重用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遥测&lt;/strong&gt;：从一个问题或进程类型推断日志消息比与其他问题交错的日志消息更容易。 在将所有日志消息打印到 &lt;a href=&#34;https://en.wikipedia.org/wiki/Standard_streams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标准输出&lt;/a&gt; 的容器中尤其如此，例如 12 因素云原生应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编排&lt;/strong&gt;：如果容器中有多个进程类型，则必须在容器内管理次要关注点的生命周期，这实际上意味着在父进程类型中创建编排器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开源云原生运动对电信行业的影响是供应商之间协作的爆炸式增长。 与在一个组织的保护伞下开发紧密耦合的软件相反，对更多协作和互操作性的呼吁已经促使来自不同组织的多个项目重新审视单一关注点原则的好处。&lt;/p&gt;
&lt;h2 id=&#34;云原生进程最佳实践&#34;&gt;云原生进程最佳实践&lt;/h2&gt;
&lt;h3 id=&#34;独立于流程顺序&#34;&gt;独立于流程顺序&lt;/h3&gt;
&lt;p&gt;将多个进程类型放在同一个容器中的论据之一是&lt;a href=&#34;https://medium.com/@kelseyhightower/12-fractured-apps-1080c73d481c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;需要更多地控制问题的启动顺序&lt;/a&gt;。 例如需要数据库的传统应用程序。 如果数据库不可用，应用程序和 Web 服务器可能无法正常启动，因此有人可能会在启动应用程序之前手动启动 docker 文件中的数据库。 虽然这确实有效，但这样做会失去关注点松散耦合的七个好处。 更好的方法是使您的关注点和流程类型尽可能独立于顺序。&lt;/p&gt;
&lt;h3 id=&#34;你的进程将被终止&#34;&gt;你的进程将被终止&lt;/h3&gt;
&lt;p&gt;Kubernetes 有一个 &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pod 优先级&lt;/a&gt; 的设置，如果不满足一组条件时，允许用户&lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;抢占或终止&lt;/a&gt; pod。 这意味着 pod 需要响应来自这些调度策略的正常关闭请求，否则它们将面临数据损坏和其他错误。 这些正常关闭请求以 &lt;a href=&#34;https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SIGTERM 请求&lt;/a&gt; 的形式出现，通常在 SIGKILL 请求发出前 30 秒终止强制过程。 当运行多个进程时，所有子进程都需要能够处理正常关闭信号。 正如我们稍后将看到的，处理进程的正常关闭可能会导致一些微妙的问题，这些问题在处理多个进程时会变得更糟。&lt;/p&gt;
&lt;p&gt;在电信中，流程顺序独立性和抢占通常由与其管理的流程紧密耦合的编排器处理。 有了像 Kubernetes 这样的与应用程序无关的编排器，这些自定义和紧密耦合的编排器时代即将结束，如&lt;a href=&#34;https://kubernetes.io/docs/reference/scheduling/config/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;声明式调度配置&lt;/a&gt;。电信云原生方法可能应该类似于Erlang社区对进程的 &amp;ldquo;&lt;a href=&#34;https://erlang.org/download/armstrong_thesis_2003.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;让它失败&lt;/a&gt;&amp;ldquo;方法，其中调用进程对它所调用的进程更加稳健。&lt;/p&gt;
&lt;h3 id=&#34;多进程和应用程序生命周期&#34;&gt;多进程和应用程序生命周期&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-containers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud&lt;/a&gt; 建议您为每个容器打包一个“应用程序”。 在更技术层面上，单个应用程序被定义为具有可能的许多子进程的单个父进程。 这一基本原理的主要部分是利用应用程序生命周期中不同的变化率。 生命周期是什么意思？ 生命周期是应用程序的开始、执行和终止。 任何具有不同启动、执行或终止原因的进程都应该与其他进程分开（即不紧密耦合）。 当我们理清这些问题时，我们可以将它们表示为单独的健康检查、策略和部署配置。 然后我们可以声明性地表达这些关注点，在源代码控制中跟踪它们，并在语义上对它们进行版本控制。 这使我们能够避免步调一致地升级，导致将不同的应用生命周期锁定在一起。&lt;/p&gt;
&lt;p&gt;管理容器中多个应用程序或进程类型的生命周期的问题源于它们都有&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-container#package_a_single_app_per_container&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同的状态&lt;/a&gt;。 例如，如果您有一个父进程启动 Apache，然后还启动 Redis，则父进程需要知道如何以及何时启动、监视和终止 Apache 和 Redis。 对于您无法控制的代码或二进制文件，此问题甚至更加困难，因为您无法控制这些应用程序如何表达其健康状况。 这就是为什么表达程序健康状况的最佳位置，尤其是您无法控制的进程，是在暴露给容器管理系统或编排器（例如 Kubernetes）的配置中，它旨在适应生命周期而不是临时的 bash 脚本。&lt;/p&gt;
&lt;h3 id=&#34;多进程加剧云原生信号和僵尸问题&#34;&gt;多进程加剧云原生信号和僵尸问题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不处理所谓的PID 1&lt;/a&gt; 容器中的进程充满了极度隐蔽、难以察觉的问题。 当涉及多个进程时，这些问题会加剧。 正确处理 PID 1 的两个主要问题是&lt;a href=&#34;https://cloud.google.com/architecture/best-practices-for-building-containers#signal-handling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;处理终止信号和僵尸&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;sigterm&#34;&gt;SIGTERM&lt;/h3&gt;
&lt;p&gt;所有应用程序和进程都必须知道两种类型的关机：正常关机和立即关机。 假设一个有状态应用程序希望打开一个重要文件、写入数据并关闭文件而不被中断。 在这种情况下，由于 K8s 的抢占功能，应用程序最终会破坏文件。处理此类问题的一种方法是正常关闭。 这就是 SIGTERM 信号的作用。 它告诉应用程序它将被关闭并开始正常运行以避免损坏或其他错误。 在编排系统中，所有进程都应设计为在需要时处理正常关闭。 但是启动其他进程的进程呢？ 为了处理子进程的正常终止，父进程需要向所有子进程传递 SIGTERM 信号，让它们也正常关闭。 这就是 PID 1 处理不当的问题所在。 除非明确告知，否则像 bash 这样的简单脚本不会将 SIGTERM 信号传递给它们启动的进程。 如果您不通过 SIGTERM，将产生非常难以检测的错误。&lt;/p&gt;
&lt;h3 id=&#34;一个隐蔽的-sigterm-错误示例&#34;&gt;一个隐蔽的 SIGTERM 错误示例&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://about.gitlab.com/blog/2022/05/17/how-we-removed-all-502-errors-by-caring-about-pid-1-in-kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gitlab 记录&lt;/a&gt;他们遇到了一个问题，即页面上会出现 502 错误，但在一定时间后神秘地自行修复。 问题是因为前面提到的正常终止信号 (SIGTERM) 没有被发送到在页面服务资源被删除后打开连接的子进程。 众所周知，这个问题很难追踪。&lt;/p&gt;
&lt;h3 id=&#34;僵尸进程&#34;&gt;僵尸进程&lt;/h3&gt;
&lt;p&gt;容器中的&lt;a href=&#34;https://en.m.wikipedia.org/wiki/Process_identifier&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PID 1进程&lt;/a&gt;也会在子进程终止后清理它们。 这看起来很简单，但默认情况下 PID 1 bash 脚本无法正确清理。 不清理或收割子进程意味着什么？ 这些不干净的进程，也称为僵尸进程，填满了所谓的进程表。 它们最终会阻止您启动新进程，从而阻止您的整个节点运行。&lt;/p&gt;
&lt;h3 id=&#34;一个合适的初始化系统来处理僵尸和信号&#34;&gt;一个合适的初始化系统来处理僵尸和信号&lt;/h3&gt;
&lt;p&gt;限制僵尸进程影响的一种方法是拥有一个&lt;a href=&#34;https://ahmet.im/blog/minimal-init-process-for-containers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;适当的初始化系统&lt;/a&gt;。 如果您正在考虑使用您无法控制的代码（例如 Postgres 数据库）运行 PID 1 进程，则尤其如此。 这个进程可能会启动其他进程，然后忘记收割它们。 使用适当的 init 系统，任何终止的子进程最终都会被 init 系统回收。&lt;/p&gt;
&lt;p&gt;您可以在容器内运行适当的初始化系统和复杂的监督程序。 监督程序有时候被认为是矫枉过正，因为它们占用了太多资源，而且有时过于复杂。 复杂监管程序有 supervisord、monit 和 runit。 适当的 init 系统比复杂的监管程序小，因此适用于容器。 合适的容器初始化系统有 tini、dumb-init 和 s6-overlay。&lt;/p&gt;
&lt;h2 id=&#34;性能和云原生电信进程&#34;&gt;性能和云原生电信进程&lt;/h2&gt;
&lt;p&gt;在容器中运行多个进程的主要动机之一是对性能的渴望。 在单独的容器中而不是在同一个容器中运行进程（假设进程间通信是相同的）似乎会降低性能。 这种&lt;a href=&#34;https://pythonspeed.com/articles/docker-performance-overhead/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;性能下降可归因于&lt;/a&gt; 容器系统中内置的隔离和安全措施。 也可以通过在特权模式下运行容器来删除它，但这会降低安全性。&lt;/p&gt;
&lt;p&gt;人们对将进程分离到多个容器中存在一种误解，那就是所有通信的性能都会受到影响，因为它必须通过 TCP 或更糟糕的 HTTP 进行。 这不太对。 通过&lt;a href=&#34;https://dev.to/douglassakey/a-simple-example-of-using-unix-domain-socket-in-kubernetes-1fga&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 unix 域套接字进行通信&lt;/a&gt;。 这可以在 Kubernetes 中通过使用在 pod 内的所有容器之间共享的卷挂载来配置。&lt;/p&gt;
&lt;p&gt;在电信环境中，数据平面的核心关注点是性能，因此使用线程、共享内存和进程间通信来提高性能。 当这些问题密切相关时，它会因为复杂性而增加。 在不同容器之间但在同一个 pod 中实现的进程间通信应该有所帮助。 电信控制平面通常需要较低的性能，因此可以设计为遗留应用程序&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;为了获得云原生生态系统的最大互操作性和可升级性优势，电信行业需要遵守容器和部署的单一焦点规则。 能够做到这一点的供应商将比不能做到这一点的供应商更具竞争优势。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;要了解更多云原生原理，请加入 CNCF 的云原生&lt;a href=&#34;https://github.com/cncf/cnf-wg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;网络功能工作组&lt;/a&gt;。有关 CNCF 的 CNF 认证计划的信息，该计划&lt;a href=&#34;https://www.cncf.io/certification/cnf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;验证您网络功能中的云原生最佳实践&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;特别感谢 Denver Williams 对本文的技术审阅。&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>云原生网络功能（CNF） 介绍</title>
      <link>https://lib.jimmysong.io/blog/cloud-native-network-functions/</link>
      <pubDate>Tue, 23 Aug 2022 11:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/cloud-native-network-functions/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://infoq.com/articles/cloud-native-network-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Network Functions Are Here&lt;/a&gt;，译者 &lt;a href=&#34;https://jimmysong.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jimmy Song&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;云原生网络不是另一种方式的 SDN，它以一种完全不同的方式来看待网络。&lt;/li&gt;
&lt;li&gt;虽然SDN似乎是把物理网络和机器做了虚拟化，但「云原生网络功能」（Cloud-native Network Functions，下文简称 CNF）不仅仅是容器化的网络和虚拟机，它还将网络功能分割成服务，这是 CNF 与 SDN 的一个主要区别。&lt;/li&gt;
&lt;li&gt;CNF是OSI网络模型中的网络功能（越底层实现起来就越困难），这些功能是根据云原生实践实现的。&lt;/li&gt;
&lt;li&gt;虽然SDN数据平面（这里指的是转发数据包）位于硬件ASIC上，或在传统内核网络转发的虚拟化盒子里，但CNF探索用户平面转发或更新的eBPF数据路径转发。&lt;/li&gt;
&lt;li&gt;在云原生数据中心中，偏向于三层的解决方案，但CNF的一大驱动力是电信服务提供商，他们经常下降到二层的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在三类云资源（计算、存储和网络）中，网络似乎最难满足云原生的非功能性需求。例如，计算弹性可以通过虚拟机、容器和编排器合理分配，并通过CI/CD管道进行管理。网络弹性似乎在实施中有所欠缺。在这篇文章中，我们展示了云原生网络功能将网络应用引入云原生世界的一种尝试。究竟什么是CNF，为什么它们很重要？&lt;/p&gt;
&lt;h2 id=&#34;sdn重生我们以前没有试过吗&#34;&gt;SDN重生？我们以前没有试过吗？&lt;/h2&gt;
&lt;p&gt;不论是在过去还是现在，软件定义网络（SDN）都试图实现网络配置的自动化。CNF 不是另一种 SDN，而是以一种完全不同的方式来看待网络。从某种意义上说，CNF与SDN一样，都是基于软件而非硬件的解决方案。但云原生网络有一套全新的非功能要求，与SDN不同。云原生的非功能要求优先考虑弹性，并推而广之，自动化也比SDN多得多。这一要求的实现倚重于声明性配置。换句话说，云原生配置应该更喜欢说&amp;quot;想做什么&amp;quot;，而不是&amp;quot;想怎么做&amp;quot;。例如，声明式配置对网络的影响之一是禁止硬编码的IP地址。声明式配置允许整个系统自我修复，因为它使人们更容易读懂和回应系统应该是什么样子。然后可以使系统不断地自我修正。云原生系统的其他非功能要求是弹性和可用性，但用扩展冗余而不是扩展技术实现。云原生系统试图通过更高的可服务性和冗余度使子组件具有更高的可用性来解决可靠性问题。例如，在云原生系统中，如果一个顶级组件带有多个冗余的子组件，其中有几个组件是可用的，但有几个组件出现故障，这比一个紧密耦合但&amp;quot;高度可靠 &amp;quot;的组件更可靠。&lt;/p&gt;
&lt;h2 id=&#34;超越虚拟化的网络盒子&#34;&gt;超越虚拟化的网络盒子&lt;/h2&gt;
&lt;p&gt;在某种意义上，&amp;quot;网络功能&amp;quot;并没有被解耦。虚拟网络功能（VNF）开始是网络硬件的虚拟化。VNF有一个硬件与虚拟化硬件的一对一对应关系，小到网卡、特定应用集成电路（ASIC），大到整个交换机。虽然SDN似乎采取物理网络机器并将其虚拟化，但CNF不仅仅是容器化的网络虚拟机。CNF是关于进一步解耦网络功能的。CNF根据敏捷产品团队的发布周期，将网络功能分组为具有类似变化率的组件，这就摆脱了大公司的大型发布周期。由产品团队发布的软件[^4] 可以被认为是微服务的&amp;quot;厚&amp;quot;定义。微服务的 &amp;ldquo;薄&amp;rdquo; 定义是指作为容器内的单一进程类型交付的软件。通过跟踪开发软件的产品团队，我们发现厚微服务在实践中往往看起来薄微服务很像。&lt;/p&gt;
&lt;p&gt;为了管理微服务，出现了编排器。编排器负责微服务的调度、启动、停止和监控（&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;生命周期&lt;/a&gt;）。有许多编排器，其中Kubernetes（K8s）是最受欢迎的，但也有特定领域的编排器，如电信领域的编排器。云原生生态系统的早期承诺之一是使编排器K8s不被&amp;quot;碎片化&amp;quot;。由CNCF维护的官方&lt;a href=&#34;https://www.cncf.io/certification/software-conformance/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;K8s认证&lt;/a&gt;，确保K8s的任何分叉版本都能支持社区规定的API和最佳实践。&lt;/p&gt;
&lt;h2 id=&#34;究竟什么是云原生网络功能&#34;&gt;究竟什么是云原生网络功能？&lt;/h2&gt;
&lt;p&gt;云原生网络功能（CNF）位于 OSI 模型的第六层，它出现在了&lt;a href=&#34;https://github.com/cncf/trailmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;云原生足迹图&lt;/a&gt;中。CNF在堆栈中的位置越低，良好的云原生实现就越困难。这可能是因为网络需要与编排器和底层主机集成，同时保留其云原生属性。这也可能是因为将以前的网络功能（如转发平面的功能）从共享内存/线程模型中分离出来，形成一个无共享的进程模型，如果不仔细操作，会降低性能。&lt;/p&gt;
&lt;p&gt;为了理解网络功能解耦的影响，了解一下网络层背后的原因是有帮助的。OSI层的发展使网络创新得以发生，同时保持堆栈上下各层之间的互操作性。在网络层，IP协议最终成为一个大赢家。在数据链路层，ARP出现了。多个供应商在每一层的协议层面进行迭代，创造新的协议和协议的新实现。CNF 有机会作为库内的协议、微服务内的协议，甚至作为网络应用内的一组微服务来实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://networkservicemesh.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Network Service Mesh&lt;/a&gt;项目的Ed Warnicke曾经说过，对于网络服务来说，&amp;quot;&lt;a href=&#34;https://www.youtube.com/watch?v=OyI2ZuwIc_Q&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据包就是有效载荷&lt;/a&gt;&amp;quot;。这意味着网络应用或服务实际上是对网络数据包或帧进行操作（转换、路由或分析）。以下是OSI模型各层的网络功能的一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第七层：CoreDNS&lt;/li&gt;
&lt;li&gt;第六层：NFF数据包检查器&lt;/li&gt;
&lt;li&gt;第五层：Rsocket&lt;/li&gt;
&lt;li&gt;第四层和第三层：Envoy/Network Service Mesh/各种CNI插件&lt;/li&gt;
&lt;li&gt;第二层：基于VPP的VSwitch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于云原生网络应用，或跨越多层的高阶CNF，例如 &lt;a href=&#34;https://www.matrixx.com/5g-bss-technology/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MATRIXX软件&lt;/a&gt;公司的&lt;a href=&#34;https://github.com/cncf/cnf-wg/tree/main/use-case/0003-UC-stateful-cnf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;5G融合计费系统&lt;/a&gt;和&lt;a href=&#34;https://cdnf.io/cnf_list/bgp/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PANTHEON.tech&lt;/a&gt;公司的&lt;a href=&#34;https://github.com/cncf/cnf-wg/tree/main/use-case/0002-UC-bgp-enterprise&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BGP服务器&lt;/a&gt;使用案例。&lt;/p&gt;
&lt;p&gt;云原生足迹图在一定程度上描述了云原生应用程序的成熟度。当我们深入研究云原生道路上的每一步时，事情就会变得更加复杂，比如网络、策略和安全。这就是说，在帮助你实现云原生的工具中存在着云原生的反射性。当把它应用于CNF时，我们最终不得不像其他云原生应用一样实现网络功能。这方面的总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步从粗粒度的部署开始，通常以容器形式实现。&lt;/li&gt;
&lt;li&gt;第二步是让服务或应用程序在CI/CD管道中以无状态和声明式的配置进行部署。&lt;/li&gt;
&lt;li&gt;第三步是支持部署在同质化节点上的编排器（如K8s），该编排器管理服务的生命周期。&lt;/li&gt;
&lt;li&gt;第四步确保网络功能有遥测功能，这包括度量（如开放度量兼容的Prometheus）、追踪（兼容OpenTracing的Jaeger）和事件流兼容的日志（如Fluentd）。&lt;/li&gt;
&lt;li&gt;云原生成熟度的第五步，服务发现，允许网络服务被集群内部甚至外部的其他消费者发现。&lt;/li&gt;
&lt;li&gt;为了促进声明性配置，第六步概述了策略的重要性，特别是网络和安全政策，通过服务适用和支持。&lt;/li&gt;
&lt;li&gt;第七步是分布式存储，适用于使用有状态工作负载的地方，以确保与云原生环境兼容。&lt;/li&gt;
&lt;li&gt;云原生信息传递、注册表、运行时和软件分发是云原生成熟度的其他阶段，使&lt;a href=&#34;https://github.com/cncf/trailmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;应用程序的旅程&lt;/a&gt;更加完善。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cnf数据平面&#34;&gt;CNF数据平面&lt;/h2&gt;
&lt;p&gt;有了CNF，数据平面（也被称为转发平面）与传统硬件的距离更远。由于云原生原则重视扩展而不是扩大，这意味着拥有更多的同质化商用节点比拥有更少的异质化和专业化节点更受欢迎。正因为如此，出现了一种分解运动，用商用服务器来代替专门的网络交换机的特定应用集成回路（ASIC）。这样做的一个好处是，出现了支持更敏捷的变化速度的数据平面。虽然SDN数据平面（这里我们说的是字面意义上的转发数据包）停留在硬件ASIC上或传统内核网络转发的虚拟化盒子里，但CNF已经开始探索用户数据平面（如&lt;a href=&#34;https://s3-docs.fd.io/vpp/22.10/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VPP&lt;/a&gt;）、eXpress Data Path（XDP）的扩展伯克利包过滤器（eBPF）和SmartNIC转发等技术。&lt;/p&gt;
&lt;h2 id=&#34;三层网络升华&#34;&gt;三层网络升华&lt;/h2&gt;
&lt;p&gt;在云原生数据中心中，有一个&lt;a href=&#34;http://docs.projectcalico.org/v3.5/usage/troubleshooting/faq#i-heard-calico-is-suggesting-layer-2-i-thought-you-were-layer-3-whats-happening&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;偏向于三层的解决方案&lt;/a&gt;。能够声明性地指定和自动配置三层网络，这是发展Kubernetes网络模型的决定性因素。这些新的云原生网络依靠IP地址来连接集群的节点和应用，而不是第二层的MAC和VLAN。然而，这主要是编排器及其应用程序的网络故事。数据中心有多个移动部件，在这个故事中的变化率不同。这三层可以说是在编排器下面（有SONIC等网络操作系统，Terraform等配置工具），在编排器（如Kubernetes）本身，以及在编排器上面但在容器（如CNF）内。编排器下面的网络基础设施结构，如数据中心的架顶交换机（可能是分解的），继续拥有第二层配置。电信领域是采用CNF的主要驱动力，也继续有无法避免的第二层用例，如多协议标签交换（MPLS）。第二层结构的故事仍在用新的交换软件实现来书写，如&lt;a href=&#34;https://sonic-net.github.io/SONiC/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SONiC&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;网络的配置、部署和自动化是难以实现弹性的一些原因，而弹性是云原生环境的主要优势。这可能是转移到超级服务器（如亚马逊）的决定性因素，即使是在需要更多定制部署的时候。这与电信领域特别相关，因为他们有定制的网络协议，他们可能想为企业客户提供支持（如MPLS）。CNF通过基于变化率的网络功能解耦来解决这些部署问题，一直到粗粒度的镜像和进程（如容器）级别。这就避免了网络容易出现的传统的锁步式部署问题。&lt;/p&gt;
&lt;p&gt;CNF是网络功能，也就是传统上认为位于OSI堆栈上的功能，遵循云原生实践来实现，它与云原生生态系统耦合。网络，尤其是电信网络，对非功能的要求由来已久，比如说弹性。电信服务提供商以911电话为例，将其作为一个要求极度弹性和可用性的关键任务系统。即便如此，云原生生态系统的非功能属性也得到了服务提供商的关注。这些属性，如可用性（云原生型）、易于部署和弹性，促使电信服务提供商对电信设备供应商（包括物理和软件）施加压力，使其更加云原生。这就要求这些新的网络组件遵循云原生基础设施的最佳实践，以便成为云原生生态系统中的成熟解决方案。这并不容易，因为要把传统上紧密耦合的、对性能有严格要求的组件（如网络数据线）解耦，是非常困难的。&lt;/p&gt;
&lt;p&gt;CNF空间中的数据平面是一项正在进行的工作，有许多解决方案。仅仅是数据平面的概念就使对CNF的理解变得复杂，因为CNF不仅仅是一个物理盒子的虚拟化表示。在一个微不足道的层面上，云原生数据中心的网络可以通过集中于默认的内核网络和第三层IPv4/IPv6网络来避免这种复杂化。这对于电信公司的用例或网络结构的实施通常是不可行的。这些问题是网络软件解耦的自然发展的一部分，所以没有办法避免。如果CNF做得好，就会带来以前没有意识到的可部署性、弹性、易配置性和弹性的新水平。&lt;/p&gt;
&lt;p&gt;要了解更多关于云原生网络功能的信息，请加入CNCF的云原生网络功能&lt;a href=&#34;https://github.com/cncf/cnf-wg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;工作小组&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
