<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>可观测性 | 云原生资料库</title>
    <link>https://lib.jimmysong.io/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
      <atom:link href="https://lib.jimmysong.io/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <description>可观测性</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Tue, 10 Oct 2023 10:00:00 +0800</lastBuildDate>
    <image>
      <url>https://lib.jimmysong.io/media/sharing.png</url>
      <title>可观测性</title>
      <link>https://lib.jimmysong.io/category/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/</link>
    </image>
    
    <item>
      <title>前言</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/foreword/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/foreword/</guid>
      <description>&lt;p&gt;软件开发的模式又一次改变了。开源软件和公有云供应商已经从根本上改变了我们构建和部署软件的方式。有了开源软件，我们的应用不再需要从头开始编码。而通过使用公有云供应商，我们不再需要配置服务器或连接网络设备。所有这些都意味着，你可以在短短几天甚至几小时内从头开始构建和部署一个应用程序。&lt;/p&gt;
&lt;p&gt;但是，仅仅因为部署新的应用程序很容易，并不意味着操作和维护它们也变得更容易。随着应用程序变得更加复杂，更加异质，最重要的是，更加分布式，看清大局，以及准确地指出问题发生的地方，变得更加困难。&lt;/p&gt;
&lt;p&gt;但有些事情并没有改变：作为开发者和运维，我们仍然需要能够从用户的角度理解应用程序的性能，我们仍然需要对用户的事务有一个端到端的看法。我们也仍然需要衡量和说明在处理这些事务的过程中资源是如何被消耗的。也就是说，我们仍然需要可观测性。&lt;/p&gt;
&lt;p&gt;但是，尽管对可观测性的需求没有改变，我们实施可观测性解决方案的方式必须改变。本报告详细介绍了关于可观测性的传统思维方式对现代应用的不足：继续将可观测性作为一系列工具（尤其是作为 &amp;ldquo;三大支柱&amp;rdquo;）来实施，几乎不可能以可靠的方式运行现代应用。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 通过提供一种综合的方法来收集有关应用程序行为和性能的数据，包括指标、日志和跟踪，来解决这些挑战。正如本报告所解释的，OpenTelemetry 是一种生成和收集这些数据的新方法，这种方法是为使用开源组件构建的云原生应用而设计的。&lt;/p&gt;
&lt;p&gt;事实上，OpenTelemetry 是专门为这些开源组件设计的。与供应商特定的仪表不同，OpenTelemetry 可以直接嵌入到开放源代码中。这意味着开源库的作者可以利用他们的专业知识来添加高质量的仪表，而不需要在他们的项目中增加任何解决方案或供应商特定的代码。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 对应用程序所有者也有好处。在过去，遥测的产生方式与它的评估、存储和分析方式相联系。这意味着，选择使用哪种可观测性解决方案必须在开发过程的早期完成，并且在之后很难改变。OpenTelemetry（就像它的前身 OpenTracing 和 OpenCensus 一样）将你的应用程序产生遥测的方式与遥测的分析方式相分离。&lt;/p&gt;
&lt;p&gt;因此，当我们采用新技术时，我们往往没有考虑到该技术将如何被使用，特别是它将如何被不同角色的人使用。本报告描述了 OpenTelemetry 如何满足库作者、应用程序拥有者、运维和响应者的需求，以及它如何使这些角色中的每个人都能独立工作 —— 即自动做出关键决定并进行有效协作。&lt;/p&gt;
&lt;p&gt;也许最重要的是，OpenTelemetry 为应用程序所有者和操作者提供了灵活性，使他们能够选择最适合其应用程序和组织需求的可观测性解决方案，包括需要多种工具的情况。它还包括这些需求随时间变化的情况，以及需要新的工具来满足这些需求的情况，因为随着技术的成熟和组织的发展，可能会出现这种情况。&lt;/p&gt;
&lt;p&gt;虽然用户不需要致力于可观测性解决方案，但他们确实需要投资于生成遥测数据的一致方式。本报告展示了 OpenTelemetry 是如何被设计成范围狭窄、可扩展，而且最重要的是稳定的：如果你被要求进行这种投资，这正是你所期望的。&lt;/p&gt;
&lt;p&gt;与以往任何时候相比，可观测性都不能成为事后的想法。没有一个有效的可观测性解决方案的风险，也就是说，无法了解你的应用程序中正在发生的事情的风险是非常高的，而对可观测性采取错误的方法的成本会造成你的组织多年来一直在偿还的债务。无论是长时间停机，还是开发团队被无休止的供应商迁移所困扰，你的组织的成功都取决于像 OpenTelemetry 这样的集成和开放的方法。&lt;/p&gt;
&lt;p&gt;本报告提供了关于在你的组织中采用和管理 OpenTelemetry 的实用建议。它将使你开始走向成功的可观测性实践的道路，并释放出云原生和开源技术的许多真正的好处：你不仅能够快速建立和部署应用程序，而且能够可靠和自信地运行它们。&lt;/p&gt;
&lt;p&gt;—— Daniel “Spoons” Spoonhower Lightstep&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 1 章：可观测性的历史</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/history/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/history/</guid>
      <description>&lt;p&gt;可观测性行业正处在巨变中。&lt;/p&gt;
&lt;p&gt;传统上，我们观察系统时使用的是一套筒仓式的、独立的工具，其中大部分包含结构不良（或完全非结构化）的数据。这些独立的工具也是垂直整合的。工具、协议和数据格式都属于一个特定的后端或服务，不能互换。这意味着更换或采用新的工具需要耗费时间来更换整个工具链，而不仅仅是更换后端。&lt;/p&gt;
&lt;p&gt;这种孤立的技术格局通常被称为可观测性的 &amp;ldquo;三大支柱&amp;rdquo;：日志、度量和（几乎没有）追踪（见图 1-1）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录构成事务的各个事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;度量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录构成一个事务的事件的集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;追踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测量操作的延迟和识别事务中的性能瓶颈，或者类似的东西。传统上，许多组织并不使用分布式追踪，许多开发人员也不熟悉它。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-1可观测性的-ldquo三大支柱rdquo&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-1.png&#34; alt=&#34;图 1-1：可观测性的 &amp;amp;ldquo;三大支柱&amp;amp;rdquo;。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1-1：可观测性的 &amp;amp;ldquo;三大支柱&amp;amp;rdquo;。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们用这种方法工作了很久，以致于我们不常质疑它。但正如我们将看到的，&amp;ldquo;三大支柱&amp;rdquo; 并不是一种正确的结构化的可观测性方法。事实上，这个术语只是描述了某些技术碰巧被实现的方式，它掩盖了关于如何实际使用我们的工具的几个基本事实。&lt;/p&gt;
&lt;h2 id=&#34;什么是事务和资源&#34;&gt;什么是事务和资源？&lt;/h2&gt;
&lt;p&gt;在我们深入探讨不同可观测性范式的利弊之前，重要的是要定义我们所观察的是什么。我们最感兴趣的分布式系统是基于互联网的服务。这些系统可以被分解成两个基本组成部分：&lt;strong&gt;事务&lt;/strong&gt;和&lt;strong&gt;资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事务（transaction）&lt;/strong&gt; 代表了分布式系统需要执行的所有动作，以便服务能够做一些有用的事情。加载一个网页，购买一个装满物品的购物车，订购一个共享汽车：这些都是事务的例子。重要的是要理解，事务&lt;strong&gt;不仅仅是&lt;/strong&gt;数据库事务。对每个服务的每个请求都是事务的一部分。&lt;/p&gt;
&lt;p&gt;例如，一个事务可能从一个浏览器客户端向一个网络代理发出 HTTP 请求开始。代理首先向认证系统发出请求以验证用户，然后将请求转发给前端应用服务器。应用服务器向各种数据库和后端系统发出若干请求。例如，一个消息系统：Kafka 或 AMQP，被用来排队等待异步处理的额外工作。所有这些工作都必须正确完成，以便向急切等待的用户提供结果。如果任何部分失败或耗时过长，其结果就是糟糕的体验，所以我们需要全面理解事务。&lt;/p&gt;
&lt;p&gt;一路下来，所有这些事务都在消耗&lt;strong&gt;资源（resource）&lt;/strong&gt;。网络服务只能处理这么多的并发请求，然后它们的性能就会下降并开始失效。这些服务可以扩大规模，但它们与可能调用锁的数据库互动，造成瓶颈。数据库读取记录的请求可能会阻碍更新该记录的请求，反之亦然。此外，所有这些资源都是要花钱的，在每个月的月底，你的基础设施供应商会给你发账单。你消耗的越多，你的账单就越长。&lt;/p&gt;
&lt;p&gt;如何解决某个问题或提高服务质量？要么是开发人员修改事务，要么是运维人员修改可用资源。就这样了。这就是它的全部内容。当然，魔鬼就在细节中。&lt;/p&gt;
&lt;p&gt;第四章将详细介绍可观测性工具表示事务和资源的理想方式。但是，让我们回到描述迄今为止我们一直在做的非理想的方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不是所有事情都是事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请注意，除了跨事务之外，还有其他的计算模型。例如，桌面和移动应用程序通常是基于&lt;strong&gt;反应器（reactor）&lt;/strong&gt; 模型，用户在很长一段时间内连续互动。照片编辑和视频游戏就是很好的例子，这些应用有很长的用户会话，很难描述为离散的事务。在这些情况下，基于事件的可观测性工具，如&lt;strong&gt;真实用户监控&lt;/strong&gt;（RUM），可以增强分布式追踪，以更好地描述这些长期运行的用户会话。&lt;/p&gt;
&lt;p&gt;也就是说，几乎所有基于互联网的服务都是建立在事务模式上的。由于这些是我们关注的服务，观察事务是我们在本书中描述的内容。附录 B 中对 RUM 进行了更详细的描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;可观测性的三大支柱&#34;&gt;可观测性的三大支柱&lt;/h2&gt;
&lt;p&gt;考虑到事务和资源，让我们来看看三大支柱模式。将这种关注点的分离标记为 &amp;ldquo;三大支柱&amp;rdquo;，听起来是有意的，甚至是明智的。支柱听起来很严肃，就像古代雅典的帕特农神庙。但这种安排实际上是一个意外。计算机的可观测性由多个孤立的、垂直整合的工具链组成，其真正的原因只是一个平庸的故事。&lt;/p&gt;
&lt;p&gt;这里有一个例子。假设有一个人想了解他们的程序正在执行的事务。所以他建立了一个日志工具：一个用于记录包含时间戳的消息的接口，一个用于将这些消息发送到某个地方的协议，以及一个用于存储和检索这些消息的数据系统。这足够简单。&lt;/p&gt;
&lt;p&gt;另一个人想监测在任何特定时刻使用的所有资源；他想捕捉指标。那么，他不会为此使用日志系统，对吗？他想追踪一个数值是如何随时间变化的，并跨越一组有限的维度。很明显，一大堆非结构化的日志信息与这个问题没有什么关系。因此，一个新的、完全独立的系统被创造出来，解决了生成、传输和存储度量的具体问题。&lt;/p&gt;
&lt;p&gt;另一个人想要识别性能瓶颈。同样，日志系统的非结构化性质使它变得无关紧要。识别性能瓶颈，比如一连串可以并行运行的操作，需要我们知道事务中每个操作的持续时间以及这些操作是如何联系在一起的。因此，我们建立了一个完全独立的追踪系统。由于新的追踪系统并不打算取代现有的日志系统，所以追踪系统被大量抽样，以限制在生产中运行第三个可观测系统的成本。&lt;/p&gt;
&lt;p&gt;这种零敲碎打的可观测性方法是人类工程的一个完全自然和可理解的过程。然而，它有其局限性，不幸的是，这些局限性往往与我们在现实世界中使用（和管理）这些系统的方式相悖。&lt;/p&gt;
&lt;h2 id=&#34;实际上我们如何观察系统&#34;&gt;实际上我们如何观察系统？&lt;/h2&gt;
&lt;p&gt;让我们来看看运维人员在调查问题时所经历的实际的、不加修饰的过程。&lt;/p&gt;
&lt;p&gt;调查包括两个步骤：注意到有事情发生，然后确定是什么原因导致了它的发生。&lt;/p&gt;
&lt;p&gt;当我们执行这些任务时，我们使用可观测性工具。但是，重要的是，我们并不是孤立地使用每一个工具。我们把它们全部放在一起使用。而在整个过程中，这些工具的孤立性给操作者带来了巨大的认知负担。&lt;/p&gt;
&lt;p&gt;通常情况下，当有人注意到一个重要的指标&lt;strong&gt;变得歪七扭八时&lt;/strong&gt;，调查就开始了。在这种情况下，&amp;ldquo;毛刺&amp;rdquo; 是一个重要的术语，因为运维人员在这一点上所掌握的唯一信息是仪表盘上一条小线的形状，以及他们自己对该线的形状是否看起来 &amp;ldquo;正确&amp;rdquo; 的内部评估（图 1-2）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-2传统上寻找不同数据集之间的关联性是一种可怕的经历&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-2.png&#34; alt=&#34;图 1-2：传统上，寻找不同数据集之间的关联性是一种可怕的经历。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1-2：传统上，寻找不同数据集之间的关联性是一种可怕的经历。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在确定了线的形状开始看起来 &amp;ldquo;不对劲&amp;rdquo; 的那一点后，运维人员将眯起眼睛，试图找到仪表板上同时出现 &amp;ldquo;毛刺&amp;rdquo; 的其他线。然而，由于这些指标是完全相互独立的，运维人员必须在他们的大脑中进行比较，而不需要计算机的帮助。&lt;/p&gt;
&lt;p&gt;不用说，盯着图表，希望找到一个有用的关联，需要时间和脑力，更不用说会导致眼睛疲劳。&lt;/p&gt;
&lt;p&gt;就个人而言，我会用一把尺子或一张纸，只看什么东西排成一排。在 &amp;ldquo;现代&amp;rdquo; 仪表盘中，标尺现在是作为用户界面的一部分而绘制的线。但这只是一个粗略的解决方案。识别相关性的真正工作仍然必须发生在操作者的头脑中，同样没有计算机的帮助。&lt;/p&gt;
&lt;p&gt;在对问题有了初步的、粗略的猜测后，运维人员通常开始调查他们认为可能与问题有关的事务（日志）和资源（机器、进程、配置文件）（图 1-3）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-3找到与异常情况相关的日志也是一种可怕的经历&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-3.png&#34; alt=&#34;图 1-3：找到与异常情况相关的日志也是一种可怕的经历。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1-3：找到与异常情况相关的日志也是一种可怕的经历。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这里，计算机也没有真正的帮助。日志存储在一个完全独立的系统中，不能与任何指标仪表板自动关联。配置文件和其他服务的具体信息通常&lt;strong&gt;不在任何系统&lt;/strong&gt;中，运维人员必须通过 SSH 或其他方式访问运行中的机器来查看它们。&lt;/p&gt;
&lt;p&gt;因此，运维人员再次被留下寻找相关性的工作，这次是在指标和相关日志之间。识别这些日志可能很困难；通常必须查阅源代码才能了解可能存在的日志。&lt;/p&gt;
&lt;p&gt;当找到一个（可能是，希望是）相关的日志，下一步通常是确定导致这个日志产生的事件链。这意味着要找到同一事务中的其他日志。&lt;/p&gt;
&lt;p&gt;缺乏关联性给操作者带来了巨大的负担。非结构化和半结构化的日志系统没有自动索引和按事务过滤日志的机制。尽管这是迄今为止运维人员最常见的日志工作流程，但他们不得不执行一系列特别的查询和过滤，将可用的日志筛选成一个子集，希望能代表事务的近似情况。为了成功，他们必须依靠应用程序开发人员来添加各种请求 ID 和记录，以便日后找到并拼接起来。&lt;/p&gt;
&lt;p&gt;在一个小系统中，这种重建事务的过程是乏味的，但却是可能的。但是一旦系统发展到包括许多横向扩展的服务，重建事务所需的时间就开始严重限制了调查的范围。图 1-4 显示了一个涉及许多服务的复杂事务。你将如何收集所有的日志？&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-4在传统的日志记录中找到构成一个特定事务的确切日志需要花费大量的精力如果系统变得足够大这几乎成为不可能&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-4.png&#34; alt=&#34;图 1-4：在传统的日志记录中，找到构成一个特定事务的确切日志需要花费大量的精力。如果系统变得足够大，这几乎成为不可能。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1-4：在传统的日志记录中，找到构成一个特定事务的确切日志需要花费大量的精力。如果系统变得足够大，这几乎成为不可能。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式追踪&lt;/strong&gt;是一个好的答案。它实际上拥有自动重建一个事务所需的所有 ID 和索引工具。不幸的是，追踪系统经常被看作是用于进行延迟分析的利基工具。因此，发送给它们的日志数据相对较少。而且，由于它们专注于延迟分析，追踪系统经常被大量采样，使得它们与这类调查无关。&lt;/p&gt;
&lt;h2 id=&#34;不是三根柱子而是一股绳子&#34;&gt;不是三根柱子，而是一股绳子&lt;/h2&gt;
&lt;p&gt;不用说，这是一个无奈之举。上述工作流程确实代表了一种可怕的状态。但是，由于我们已经在这种技术体制下生活了这么久，我们往往没有认识到，与它可以做到的相比，它实际上是多么低效。&lt;/p&gt;
&lt;p&gt;今天，为了了解系统是如何变化的，运维人员必须首先收集大量的数据。然后，他们必须根据仪表盘显示和日志扫描等视觉反馈，用他们的头脑来识别这些数据的相关性。这是一种紧张的脑力劳动。如果一个计算机程序能够自动扫描和关联这些数据，那么这些脑力劳动就是不必要的。如果运维人员能够专注于调查他们的系统是&lt;strong&gt;如何&lt;/strong&gt;变化的，而不需要首先确定&lt;strong&gt;什么&lt;/strong&gt;在变化，那么他们将节省大量宝贵的时间。&lt;/p&gt;
&lt;p&gt;在编写一个能够准确执行这种变化分析的计算机程序之前，所有这些数据点都需要被连接起来。日志需要被连接在一起，以便识别事务。衡量标准需要与日志联系在一起，这样产生的统计数据就可以与它们所测量的事务联系起来。每个数据点都需要与底层系统资源 —— 软件、基础设施和配置细节相关联，以便所有事件都能与整个系统的拓扑结构相关联。&lt;/p&gt;
&lt;p&gt;最终的结果是一个单一的、可遍历的图，包含了描述分布式系统状态所需的所有数据，这种类型的数据结构将给分析工具一个完整的系统视图。与其说是不相连的数据的 &amp;ldquo;三根支柱&amp;rdquo;，不如说是相互连接的数据的一股绳子。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 因此诞生。如图 1-5 所示，OpenTelemetry 是一个新的遥测系统，它以一种综合的方式生成追踪、日志和指标。所有这些连接的数据点以相同的协议一起传输，然后可以输入计算机程序，以确定整个数据集的相关性。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-5opentelemetry-将所有这些孤立的信息作为一个单一的高度结构化的数据流连接起来&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f1-5.png&#34; alt=&#34;图 1-5：OpenTelemetry 将所有这些孤立的信息，作为一个单一的、高度结构化的数据流连接起来。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1-5：OpenTelemetry 将所有这些孤立的信息，作为一个单一的、高度结构化的数据流连接起来。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这种统一的数据是什么样子的？在下一章，我们将把这三个支柱放在一边，从头开始建立一个新的模型。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 2 章：结构化数据的价值</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/the-value-of-structured-data/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/the-value-of-structured-data/</guid>
      <description>&lt;p&gt;眯着眼睛看图表并不是寻找相关性的最佳方式。目前在运维人员头脑中进行的大量工作实际上是可以自动化的。这使运维人员可以在识别问题、提出假设和验证根本原因之间迅速行动。&lt;/p&gt;
&lt;p&gt;为了建立更好的工具，我们需要更好的数据。遥测必须具备以下两个要求以支持高质量的自动分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的数据点都必须用适当的索引连接在一个图上。&lt;/li&gt;
&lt;li&gt;所有代表常见操作的数据点必须有明确的键和值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这一章中，我们将从一个基本的构件开始浏览现代遥测数据模型：属性。&lt;/p&gt;
&lt;h2 id=&#34;属性定义键和值&#34;&gt;属性：定义键和值&lt;/h2&gt;
&lt;p&gt;最基本的数据结构是&lt;strong&gt;属性（attribute）&lt;/strong&gt;，定义为一个键和一个值。OpenTelemetry 的每个数据结构都包含一个属性列表。分布式系统的每个组件（HTTP 请求、SQL 客户端、无服务器函数、Kubernetes Pod）在 OpenTelemetry 规范中都被定义为一组特定的属性。这些定义被称为 OpenTelemetry &lt;strong&gt;语义约定&lt;/strong&gt;。表 2-1 显示了 HTTP 约定的部分列表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;http.method&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;HTTP 请求类型&lt;/td&gt;
&lt;td&gt;GET; POST; HEAD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http.target&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;在 HTTP 请求行中传递的完整的请求目标或等价物&lt;/td&gt;
&lt;td&gt;/path/12314/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http.host&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;HTTP &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc7230#section-5.4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;host header&lt;/a&gt; 的值。当标头为空或不存在时，这个属性应该是相同的。&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.example.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.example.org&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http.scheme&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;识别所使用协议的 URI 方案&lt;/td&gt;
&lt;td&gt;http; https&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;http.status_code&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;HTTP 请求状态码&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表 2-1：HTTP 规范的部分列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了这样一个标准模式，分析工具就可以对它们所监测的系统进行详细的表述，同时进行细微的分析，而在使用定义不明确或不一致的数据时，是不可能做到的。&lt;/p&gt;
&lt;h2 id=&#34;事件一切的基础&#34;&gt;事件：一切的基础&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 中最基本的对象是&lt;strong&gt;事件（event）&lt;/strong&gt;。事件只是一个时间戳和一组属性。使用一组属性而不是简单的消息 / 报文，可以使分析工具正确地索引事件，并使它们可以被搜索到。&lt;/p&gt;
&lt;p&gt;有些属性对事件来说是独一无二的。时间戳、消息和异常细节都是特定事件的属性的例子。&lt;/p&gt;
&lt;p&gt;然而，大多数属性对单个事件来说&lt;strong&gt;并不&lt;/strong&gt;独特。相反，它们是一组事件所共有的。例如，&lt;code&gt;http.target&lt;/code&gt; 属性与作为 HTTP 请求的一部分而记录的每个事件有关。如果在每个事件上反复记录这些属性，效率会很低。相反，我们把这些属性拉出到围绕事件的封装中，在那里它们可以被写入一次。我们把这些封装称为&lt;strong&gt;上下文（context）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有两种类型的上下文：静态和动态（如图 2-1 所示）。&lt;strong&gt;静态上下文&lt;/strong&gt;定义了一个事件发生的物理位置。在 OpenTelemetry 中，这些静态属性被称为&lt;strong&gt;资源&lt;/strong&gt;。一旦程序启动，这些资源属性的值通常不会改变。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-1虽然事件有一些特定的事件属性但大多数属性属于事件发生的上下文之一&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f2-1.png&#34; alt=&#34;图 2-1：虽然事件有一些特定的事件属性，但大多数属性属于事件发生的上下文之一。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2-1：虽然事件有一些特定的事件属性，但大多数属性属于事件发生的上下文之一。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态上下文&lt;/strong&gt;定义了事件所参与的活动操作。这个操作层面的上下文被称为&lt;strong&gt;跨度（span）&lt;/strong&gt;。每次操作执行时，这些属性的值都会改变。&lt;/p&gt;
&lt;p&gt;不是所有的事件都有两种类型的上下文。只有资源的自由浮动事件，如程序启动时发出的事件，被称为&lt;strong&gt;日志（log）&lt;/strong&gt;。作为分布式事务的一部分而发生的事件被称为&lt;strong&gt;跨度事件（span event）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;资源观察服务和机器&#34;&gt;资源：观察服务和机器&lt;/h2&gt;
&lt;p&gt;资源（静态上下文）描述了一个程序正在消费的物理和虚拟信息结构。服务、容器、部署和区域都是资源。图 2-2 显示了一个典型的购物车结账事务中所涉及的资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-2一个事务被视为一组资源&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f2-2.png&#34; alt=&#34;图 2-2：一个事务，被视为一组资源。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2-2：一个事务，被视为一组资源。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;系统运行中的大多数问题都源于资源争夺，许多并发的事务试图在同一时间利用相同的资源。通过将事件放在它们所使用的资源的上下文中，就有可能自动检测出许多类型的资源争夺。&lt;/p&gt;
&lt;p&gt;像事件一样，资源可以被定义为一组属性。表 2-2 显示了一个服务资源的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表 2-2：服务资源的例子&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;service.name&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;服务的逻辑名称&lt;/td&gt;
&lt;td&gt;shopping cart&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;service.instance.id&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;服务实例的 ID&lt;/td&gt;
&lt;td&gt;627cc493- f310-47de-96bd-71410b7dec09&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;service.version&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;服务 API 或者实现的版本号&lt;/td&gt;
&lt;td&gt;2.0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了识别机器所需的基本信息，配置设置也可以作为资源被记录下来。要访问一台正在运行的机器来了解它是如何配置的，这个负担太让人害怕了。相反，在配置文件中发现的任何重要信息也应该表示为一种资源。&lt;/p&gt;
&lt;h2 id=&#34;跨度观察事务&#34;&gt;跨度：观察事务&lt;/h2&gt;
&lt;p&gt;跨度（动态上下文）描述计算机操作。跨度有一个操作名称，一个开始时间，一个持续时间，以及一组属性。&lt;/p&gt;
&lt;p&gt;标准操作是使用语义约定来描述的，比如上面描述的 HTTP 约定。但也有一些特定的应用属性，如 &lt;code&gt;ProjectID&lt;/code&gt; 和 &lt;code&gt;AccountID&lt;/code&gt;，可以由应用开发者添加。&lt;/p&gt;
&lt;p&gt;跨度也是我们描述因果关系的方式。为了正确记录整个事务，我们需要知道哪些操作是由其他哪些操作触发的。为了做到这一点，我们需要给跨度增加三个属性：&lt;code&gt;TraceID&lt;/code&gt;、&lt;code&gt;SpanID&lt;/code&gt; 和 &lt;code&gt;ParentID&lt;/code&gt;，如表 2-3 所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表 2-3：跨度的三个额外属性&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;traceid&lt;/td&gt;
&lt;td&gt;16 字节数组&lt;/td&gt;
&lt;td&gt;识别整个事务&lt;/td&gt;
&lt;td&gt;4bf92f3577b34da6a3ce929d0e0e4736&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spanid&lt;/td&gt;
&lt;td&gt;8 字节数组&lt;/td&gt;
&lt;td&gt;识别当前操作&lt;/td&gt;
&lt;td&gt;00f067aa0ba902b7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;parentid&lt;/td&gt;
&lt;td&gt;8 字节数组&lt;/td&gt;
&lt;td&gt;识别父操作&lt;/td&gt;
&lt;td&gt;53ce929d0e0e4736&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这三个属性是 OpenTelemetry 的基础。通过添加这些属性，我们所有的事件现在可以被组织成一个图，代表它们的因果关系。这个图现在可以以各种方式进行索引，我们稍后会讨论这个问题。&lt;/p&gt;
&lt;h2 id=&#34;追踪看似日志胜过日志&#34;&gt;追踪：看似日志，胜过日志&lt;/h2&gt;
&lt;p&gt;我们现在已经从简单的事件变成了组织成与资源相关的操作图的事件。这种类型的图被称为&lt;strong&gt;追踪（trace）&lt;/strong&gt;。图 2-3 显示了一种常见的可视化追踪方式，重点是识别操作的延迟。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-3当日志被组织成一个图形时它们就变成了追踪&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f2-3.png&#34; alt=&#34;图 2-3：当日志被组织成一个图形时，它们就变成了追踪。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2-3：当日志被组织成一个图形时，它们就变成了追踪。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;从本质上讲，追踪只是用更好的索引来记录日志。当你把适当的上下文添加到适当的结构化的日志中时，可以得到追踪的定义。&lt;/p&gt;
&lt;p&gt;想想你花了多少时间和精力通过搜索和过滤来收集这些日志；那是收集数据的时间，而不是分析数据的时间。而且，你要翻阅的日志越多，执行并发事务数量不断增加的机器堆积，就越难收集到真正相关的那一小部分日志。&lt;/p&gt;
&lt;p&gt;然而，如果你有一个 TraceID，收集这些日志只是一个简单的查询。通过 TraceID 索引，你的存储工具可以自动为你做这项工作；找到一个日志，你就有了该事务中的所有日志，不需要额外的工作。&lt;/p&gt;
&lt;p&gt;既然如此，为什么你还会要那些没有 &amp;ldquo;追踪&amp;quot;ID 的 &amp;ldquo;日志&amp;rdquo;？我们已经习惯了传统的日志管理迫使我们做大量的工作来连接这些点。但这些工作实际上是不必要的；它是我们数据中缺乏结构的副产品。&lt;/p&gt;
&lt;p&gt;分布式追踪不仅仅是一个测量延迟的工具；它是一个定义上下文和因果关系的数据结构。它是把所有东西联系在一起的胶水。正如我们将看到的，这种胶水包括最后一个支柱 —— 指标。&lt;/p&gt;
&lt;h2 id=&#34;指标观察事件的总体情况&#34;&gt;指标：观察事件的总体情况&lt;/h2&gt;
&lt;p&gt;现在我们已经确定了什么是事件，让我们来谈谈事件的聚合。在一个活跃的系统中，同样的事件会不断发生，我们以聚合的方式查看它们的属性来寻找模式。属性的值可能出现得太频繁，或者不够频繁，在这种情况下，我们要计算这些值出现的频率。或者该值可能超过某个阈值，在这种情况下，我们想衡量该值是如何随时间变化的。或者我们可能想以直方图的形式来观察数值的分布。&lt;/p&gt;
&lt;p&gt;这些聚合事件被称为&lt;strong&gt;度量&lt;/strong&gt;。就像普通的事件一样，度量有一组属性和一组语义上的便利条件来描述普通概念。表 2-4 显示了一些系统内存的例子属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表 2-4：系统内存的属性&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;值类型&lt;/th&gt;
&lt;th&gt;属性值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;system.memory.usage&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;used, free, cached, other&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;system.memory.utilization&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;used, free, cached, other&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;与事件相关的指标统一的系统&#34;&gt;与事件相关的指标：统一的系统&lt;/h2&gt;
&lt;p&gt;传统上，我们认为指标是与日志完全分开的。但实际上它们是紧密相连的。例如，假设一个 API 有一个衡量每分钟错误数量的指标。那是一个统计数字。然而，每一个错误都是由一个特定的事务行为产生的，使用特定的资源。这些细节在我们每次递增该计数器时都会出现，我们想知道这些细节。&lt;/p&gt;
&lt;p&gt;当运维人员被提醒发现错误突然激增时，他们会想到的第一个问题自然是：&amp;ldquo;是什么导致了这个激增？&amp;rdquo; 看一下例子的追踪可以回答这个问题。在失败的事务中较早发生的事件（或未能发生的事件）可能是错误的来源。&lt;/p&gt;
&lt;p&gt;在 OpenTelemetry 中，当指标事件在跨度的范围内发生时，这些追踪的样本会自动与指标相关联，作为&lt;strong&gt;追踪的范例（trace examplar）&lt;/strong&gt;。这意味着不需要猜测或寻找日志。OpenTelemetry 明确地将追踪和度量联系在一起。一个建立在 OpenTelemetry 上的分析工具可以让你从仪表盘上直接看到追踪，只需一次点击。如果有一个模式 —— 例如，一个特定的属性值与导致一个特定错误的追踪密切相关 —— 这个模式可以被自动识别。&lt;/p&gt;
&lt;h2 id=&#34;自动分析和编织&#34;&gt;自动分析和编织&lt;/h2&gt;
&lt;p&gt;事件、资源、跨度、指标和追踪：这些都被 OpenTelemetry 连接在一个图中，并且它们都被发送到同一个数据库，作为一个整体进行分析。这就是下一代的可观测性工具。&lt;/p&gt;
&lt;p&gt;现代可观测性将建立在使用结构的数据上，这些结构允许分析工具在所有类型的事件和总量之间进行关联，这些关联将对我们如何实践可观测性产生深远影响。&lt;/p&gt;
&lt;p&gt;向全面观察我们的系统过渡将有许多好处。但我相信，这些新工具提供的主要省时功能将是各种形式的&lt;strong&gt;自动关联检测&lt;/strong&gt;。在寻找根本原因时，注意到相关关系可以产生大量的洞察力。如图 2-4 所示，相关性往往是产生根本原因假设的关键因素，然后可以进一步调查。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-4可能提供关键洞察力指向根本原因的关联实例&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f2-4.png&#34; alt=&#34;图 2-4：可能提供关键洞察力、指向根本原因的关联实例。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2-4：可能提供关键洞察力、指向根本原因的关联实例。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;平均表现是什么样子的？异常值是什么样子的？哪些趋势在一起变化，它们的共同点是什么？相关性可能发生在许多地方：跨度中的属性之间、追踪中的跨度之间、追踪和资源之间、指标内部，以及所有这些地方都有。当所有这些数据被连接到一个图中时，这些相关性就可以被发现了。&lt;/p&gt;
&lt;p&gt;这就是为什么统一的数据编织是如此关键。任何自动匹配的分析的价值完全取决于被分析的数据的结构和质量。机器遍历数据的图表；它们不会进行逻辑的飞跃。准确的统计分析需要一个有意设计的遥测系统来支持它。&lt;/p&gt;
&lt;h2 id=&#34;重点自动分析为您节省时间&#34;&gt;重点：自动分析为您节省时间&lt;/h2&gt;
&lt;p&gt;为什么我们关心相关性分析的自动化？因为时间和复杂性对我们不利。随着系统规模的扩大，它们最终变得太复杂了，任何操作者都无法完全掌握系统的情况，而且在建立一个假设时，永远没有足够的时间来调查每一个可能的联系。&lt;/p&gt;
&lt;p&gt;问题是，选择调查什么需要直觉，而直觉往往需要对组成分布式系统的每个组件有深刻的了解。随着企业系统的增长和工程人员的相应增加，任何一个工程师对每个系统深入了解的部分自然会缩减到整个系统的一小部分。直觉并不能很好地扩展。&lt;/p&gt;
&lt;p&gt;直觉也极易被误导；问题经常出现在意想不到的地方。根据定义，可以预见的问题几乎不会经常发生。剩下的就是所有未曾预料到的问题了，这些问题已经超出了我们的直觉。&lt;/p&gt;
&lt;p&gt;这就是自动关联检测的作用。有了正确的数据，机器可以更有效地检测出相关的关联。这使得运维人员能够快速行动，反复测试各种假设，直到他们知道足够的信息来制定解决方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 3 章：自动分析的局限性</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/the-limitations-of-automated-analysis/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/the-limitations-of-automated-analysis/</guid>
      <description>&lt;p&gt;自动化开始听起来很神奇，但我们要面对现实：计算机分析不能每天告诉你系统有什么问题或为你修复它。它只能为你节省时间。&lt;/p&gt;
&lt;p&gt;至此，我想停止夸赞，我必须承认自动化的一些局限性。我这样做是因为围绕结合人工智能和可观测性会有相当多的炒作。这种炒作导致了惊人的论断，大意是：&amp;ldquo;人工智能异常检测和根源分析可以完全诊断问题！&amp;rdquo; 和 &amp;ldquo;人工智能操作将完全管理你的系统！&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;谨防炒作&#34;&gt;谨防炒作&lt;/h2&gt;
&lt;p&gt;为了摆脱此类炒作，我想明确的是，这类梦幻般的营销主张&lt;strong&gt;并不是&lt;/strong&gt;我所宣称的现代可观测性将提供的。事实上，我预测许多与人工智能问题解决有关的主张大多是夸大其词。&lt;/p&gt;
&lt;p&gt;为什么人工智能不能解决我们的问题？一般来说，机器无法识别软件中的 &amp;ldquo;问题&amp;rdquo;，因为定义什么是 &amp;ldquo;问题&amp;rdquo; 需要一种主观的分析方式。而我们所讨论的那种现实世界的人工智能不能以任何程度的准确性进行主观决策。机器将始终缺乏足够的背景。&lt;/p&gt;
&lt;p&gt;例如，我们说该版本降低了性能，这里面也隐含了一个期望，就是这个版本包含了每个用户都期望的新功能。对于这个版本，性能退步是一个特征，而不是一个错误。&lt;/p&gt;
&lt;p&gt;虽然它们可能看起来像类似的活动，但在&lt;strong&gt;确定相关关系&lt;/strong&gt;和&lt;strong&gt;确定根本原因&lt;/strong&gt;之间存在着巨大的鸿沟。当你有正确的数据结构时，相关性是一种&lt;strong&gt;客观的分析&lt;/strong&gt; —— 你只需要计算数字。哪些相关关系是相关的，并表明真正问题的来源，总是需要&lt;strong&gt;主观的分析&lt;/strong&gt;，对数据的解释。所有这些相关关系意味着什么？正如杰弗里・李波斯基（Jeffrey Lebowski）所说：&amp;ldquo;嗯，你知道，这只是你的观点，伙计。&amp;rdquo;&lt;/p&gt;
&lt;h2 id=&#34;神奇的-aiops&#34;&gt;神奇的 AIOps&lt;/h2&gt;
&lt;p&gt;在调查一个系统时，有两种类型的分析起作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客观的分析，基于事实的、可衡量的、可观测的。&lt;/li&gt;
&lt;li&gt;主观分析，基于解释、观点和判断的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种二分法 —— 客观与主观，与可计算性理论中一个重要的问题有关，即 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Halting_problem&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;停机问题（halting problem）&lt;/a&gt;&lt;/strong&gt;。停机问题的定义是，在给定任意计算机程序及其输入的描述的情况下，是否可以编写一个计算机程序来确定任意程序是否会结束运行或永远继续运行。简而言之，在 1936 年，艾伦・图灵（Alan Turning）证明了解决停机问题的一般算法是不存在的，这个证明的延伸可以应用于计算机软件中许多形式的识别 &amp;ldquo;问题&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;阿兰・图灵的意思是，我们没有办法拥有神奇的 AIOps（IT 运维的人工智能）。寻找那些承诺将繁琐的客观分析自动化的工具 —— 计算数字是机器的强项！但要小心那些声称能找到问题根源并自动修复的工具。它们很可能会让你失望。&lt;/p&gt;
&lt;p&gt;这就是为什么我们可以确定相关关系，但不能确定因果关系：想象一下，有一台机器可以确定任意计算机程序中的问题行为是什么，并确定该行为的根本原因。如果我们真的造出了这样一台机器，那就是开香槟的时候了，因为这意味着我们终于解决了停机问题！但是，目前还没有迹象表明，机器可以解决这个问题。然而，没有迹象表明机器学习已经超越了艾伦・图灵的统一计算模型；你可以相信，这不会发生。&lt;/p&gt;
&lt;p&gt;做出正确的决定和修复的工作还是要靠你自己。&lt;/p&gt;
&lt;h2 id=&#34;时间是最宝贵的资源&#34;&gt;时间是最宝贵的资源&lt;/h2&gt;
&lt;p&gt;然而，我们不需要神奇的 AIOps 来看到我们工作流程的巨大改善。识别相关性，同时获取相关信息，以便你能有效地浏览这些信息，这是计算机&lt;strong&gt;绝对可以&lt;/strong&gt;做到的事情！这将为你节省时间。大量的时间。这么多的时间，它将从根本上改变你调查系统的方式。&lt;/p&gt;
&lt;p&gt;减少浪费的时间是实践现代可观测性的核心。即使是在简单的系统中，通过分析数字来识别相关性也是很困难的，而在大规模的系统中，这几乎是不可能的。通过将认知负担转移到机器上，运维人员能够有效地管理那些已经超出人类头脑所能容纳的系统。&lt;/p&gt;
&lt;p&gt;但是，我们分析遥测方式的这种转变并不是可观测性世界中即将发生的唯一重大变化。我们需要的大部分遥测数据来自于我们没有编写的软件：我们所依赖的开源库、数据库和管理服务。这些系统在传统上一直在为产生遥测数据而奋斗。我们可以获得哪些数据，以及这些数据来自哪里，也将发生根本性的变化。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 4 章：支持开源和原生监测</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/supporting-open-source-and-native-instrumentation/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/supporting-open-source-and-native-instrumentation/</guid>
      <description>&lt;p&gt;到目前为止，我们已经从数据的角度讨论了现代可观测性。但是，现代可观测性还有另一个方面，从长远来看，它可能被证明同样重要：如何对待产生数据的仪表（instrumention）。&lt;/p&gt;
&lt;p&gt;大多数软件系统都是用现成的部件构建的：网络框架、数据库、HTTP 客户端、代理服务器、编程语言。在大多数组织中，很少有这种软件基础设施是在内部编写的。相反，这些组件是在许多组织中共享的。最常见的是，这些共享组件是以开放源码（OSS）库的形式出现的，并具有许可权。&lt;/p&gt;
&lt;p&gt;由于这些开放源码软件库几乎囊括了一般系统中的所有关键功能，因此获得这些库的高质量说明对大多数可观测性系统来说至关重要。&lt;/p&gt;
&lt;p&gt;传统上，仪表是 &amp;ldquo;单独出售&amp;rdquo; 的。这意味着，软件库不包括产生追踪、日志或度量的仪表。相反，特定解决方案的仪表是在事后添加的，作为部署可观测系统的一部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;什么是特定解决方案仪表？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在本章中，术语 &amp;ldquo;&lt;strong&gt;特定解决方案仪表&lt;/strong&gt;&amp;rdquo; 是指任何旨在与特定的可观测系统一起工作的仪表，使用的是作为该特定系统的数据存储系统的产物而开发的客户端。在这些系统中，客户端和存储系统常常深深地融合在一起。因此，如果一个应用要从一个观测系统切换到另一个观测系统，通常需要进行全面的重新布设。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对解决方案的仪表是 &amp;ldquo;三大支柱&amp;rdquo; 中固有的垂直整合的遗留问题。每个后端都摄取特定类型的专有数据；因此，这些后端的创建者也必须提供产生这些数据的仪表。&lt;/p&gt;
&lt;p&gt;这种工具化的方法给参与软件开发的每个人都带来了麻烦：供应商、用户和开放源码库的作者。&lt;/p&gt;
&lt;h2 id=&#34;可观测性被淹没在特定解决方案的仪表中&#34;&gt;可观测性被淹没在特定解决方案的仪表中&lt;/h2&gt;
&lt;p&gt;从可观测性系统的角度来看，仪表化代表了巨大的开销。&lt;/p&gt;
&lt;p&gt;在过去，互联网应用是相当同质化的，可以围绕一个特定的网络框架来建立可观测性系统。Java Spring、Ruby on Rails 或 .NET。但随着时间的推移，软件的多样性已经爆炸性增长。现在为每一个流行的网络框架和数据库客户端维护仪表是一项巨大的负担。&lt;/p&gt;
&lt;p&gt;这导致的重复劳动难以估量。传统上，供应商将他们在仪表上的投资作为销售点和把关的一种形式。但是，日益增长的软件开发速度已经开始使这种做法无法维持了。对于一个合理规模的仪表设备团队来说，覆盖面实在是太大了，无法跟上。&lt;/p&gt;
&lt;p&gt;这种负担对于新的、新颖的观测系统，特别是开放源码软件的观测项目来说尤其严峻。如果一个新的系统在编写了大量的仪表之前无法在生产中部署，而一个开放源码软件项目在广泛部署之前也无法吸引开发者的兴趣，那么科学进步就会陷入僵局。这对于基于追踪的系统来说尤其如此，它需要端到端的仪表来提供最大的价值。&lt;/p&gt;
&lt;h2 id=&#34;应用程序被锁定在特定解决方案的仪表中&#34;&gt;应用程序被锁定在特定解决方案的仪表中&lt;/h2&gt;
&lt;p&gt;从应用开发者的角度来看，特定解决方案的仪表代表了一种有害的锁定形式。&lt;/p&gt;
&lt;p&gt;可观测性是一个交叉性的问题。要彻底追踪、记录或度量一个大型的应用程序，意味着成千上万的仪表 API 调用将遍布整个代码库。改变可观测性系统需要把所有这些工具去掉，用新系统提供的不同工具来代替。&lt;/p&gt;
&lt;p&gt;替换仪表是一项重大的前期投资，即使只是为了尝试一个新的系统。更糟的是，大多数系统都太大了以致于在所有服务中同时更换所有仪表是不可行的。大多数系统需要逐步推出新的仪表设备，但这样的上线可能很难设计。&lt;/p&gt;
&lt;p&gt;被特定解决方案的仪表所 &amp;ldquo;困住&amp;rdquo; 是非常令人沮丧的。在可观测性供应商开始努力提供自己的仪表的同时，用户也开始拒绝采用这种仪表。由于了解到重新安装仪表的工作量，许多用户强烈希望他们正在考虑的任何新的观测系统能与他们目前使用的仪表一起工作。&lt;/p&gt;
&lt;p&gt;为了支持这一要求，许多可观测性系统试图与其他几个系统提供的仪表一起工作。但这种拼凑的方式降低了每个系统所摄取的数据的质量。从许多来源摄取数据意味着对输入的数据不再有明确的定义，当预期的数据不均衡且定义模糊时，分析工具就很难完成它们的工作。&lt;/p&gt;
&lt;h2 id=&#34;针对开源软件的特定解决方案的仪表基本上是不可能的&#34;&gt;针对开源软件的特定解决方案的仪表基本上是不可能的&lt;/h2&gt;
&lt;p&gt;从一个开放源码库作者的角度来看，特定解决方案的仪表化是一个悲剧。&lt;/p&gt;
&lt;p&gt;来自开放源码软件库的遥测数据对于操作建立在它们之上的应用程序来说至关重要。最了解哪些数据对操作至关重要的人，以及操作者应该如何利用这些数据来补救问题的人，就是实际编写软件的开源库的开发者。&lt;/p&gt;
&lt;p&gt;但是，库的作者却陷入了困境。正如我们将看到的，没有任何一个特定解决方案的仪表化 API，无论写得多么好，都无法作为开放源码库可以接受的选择。&lt;/p&gt;
&lt;h2 id=&#34;如何挑选一个日志库&#34;&gt;如何挑选一个日志库？&lt;/h2&gt;
&lt;p&gt;假设你正在编写世界上最伟大的开源网络框架。在生产过程中，很多事情都会出错，你自然希望把错误、调试和性能信息传达给你的用户。你使用哪个日志库？&lt;/p&gt;
&lt;p&gt;有很多体面的日志库。事实上，有很多，无论你选择哪个库，你都会有很多用户希望你选择一个不同的库。如果你的 Web 框架选择了一个日志库，而数据库客户端库选择了另一个，怎么办？如果这两个都不是用户想要使用的呢？如果他们选择了同一个库的不兼容的版本呢？&lt;/p&gt;
&lt;p&gt;没有一个完美的方法可以将多个特定解决方案的日志库组合成一个连贯的系统。虽然日志足够简单，不同解决方案的大杂烩可能是可行的，但对于特定解决方案的指标和追踪来说，情况并非如此。&lt;/p&gt;
&lt;p&gt;因此，开放源码软件库通常没有内置的日志、度量或追踪功能。取而代之的是，库提供了 &amp;ldquo;可观测性钩子&amp;rdquo;，这需要用户编写和维护一堆适配器，将使用的库连接到他们的可观测性系统上。&lt;/p&gt;
&lt;p&gt;作者们有大量的知识，他们想通信关于他们的系统应该如何运行的知识，但他们没有明确的方法去做。如果你问任何写过大量开源软件的人，他们会告诉你。这种情况是痛苦的！而且是不幸的！一些库的作者&lt;strong&gt;确实&lt;/strong&gt;试图选择一个日志库，但却发现他们无意中为一些用户造成了版本冲突，同时迫使其他用户编写日志适配器来捕捉使用其&lt;strong&gt;实际&lt;/strong&gt;日志库的数据。&lt;/p&gt;
&lt;p&gt;但是对于大多数库来说，可观测性只是一个事后的想法。虽然库的作者经常编写大量的测试套件，但他们很少花时间去考虑运行时的可观测性。考虑到库有大量的测试工具，但可观测性工具为零，这种结果并不令人惊讶。&lt;/p&gt;
&lt;p&gt;正如我们在接下来的几章中所看到的，现代可观测性的设计是为了使在可观测性管道中发挥作用的每个人的代理权最大化。但受益最大的是库的作者；对于特定解决方案的仪表，他们目前根本没有选择。&lt;/p&gt;
&lt;h2 id=&#34;分解问题&#34;&gt;分解问题&lt;/h2&gt;
&lt;p&gt;我们可以通过设计一个可观测性系统来解决上面列出的所有问题，以明确地解决每个人的需求。在本章的其余部分，我们将把现代观测系统的设计分解为基本要求。这些要求将为第五章中描述的 OpenTelemetry 的结构提供动力。&lt;/p&gt;
&lt;h2 id=&#34;要求独立的仪表遥测和分析&#34;&gt;要求：独立的仪表、遥测和分析&lt;/h2&gt;
&lt;p&gt;归根结底，计算机系统实际上就是人类系统。像可观测性这样的跨领域问题，几乎与每一个软件组件都有互动。同时，传输和处理遥测数据可能是一个大批量的活动，以至于一个大规模的观测系统会产生自己的操作问题。这意味着，许多不同的人，以不同的身份，需要与观测系统的不同方面交互。为了很好地服务于他们，这个系统必须确保每个参与其中的人都有他们所需要的代理权，以便快速和独立地执行任务。提供代理权是设计一个有效的观测系统的基本要求。&lt;/p&gt;
&lt;p&gt;让我们首先确定与运行中的软件系统有关的每个角色的责任：库的作者、应用程序的所有者、操作者和响应者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;库的作者了解他们软件的情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于封装了关键功能的软件库，如网络和请求管理，库的作者也必须管理追踪系统的各个方面：注入、提取和上下文传播。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序拥有者组织软件并管理依赖关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序所有者选择构成其应用程序的组件，并确保它们编译成一个连贯的、有功能的系统。应用程序所有者还编写应用程序级别的工具，它必须与库作者提供的指令（和上下文传播）进行正确的交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运维人员管理遥测的生产和传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运维管理从应用到响应者的可观测性数据的传输。他们必须能够选择数据的格式以及数据的发送地点。当数据在产生时，他们必须操作传输系统：管理缓冲、处理和传送数据所需的所有资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应者消费遥测数据并产生有用的见解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要做到这一点，应对者必须了解数据结构及其内在意义（结构和意义将在第三章中详细描述）。当新的和改进的分析工具出现时，反应者还需要将其添加到他们的工具箱中。&lt;/p&gt;
&lt;p&gt;这些角色代表不同的决策点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;库的作者只能通过发布其代码的新版本来进行修改。&lt;/li&gt;
&lt;li&gt;应用程序所有者只能通过部署其可执行文件的新版本来进行更改。&lt;/li&gt;
&lt;li&gt;运维人员只能通过管理可执行文件的拓扑结构和配置来进行改变。&lt;/li&gt;
&lt;li&gt;响应者只能根据他们收到的数据做出改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的三大支柱方法扰乱了所有这些角色。垂直整合的一个副作用是，几乎所有的数据变化都需要进行代码修改。几乎任何对可观测性系统的非微不足道的改变都需要应用程序所有者进行代码修改。要求其他人进行你所关心的改变，这样会有很大的阻力，并可能导致压力、冲突和不作为。&lt;/p&gt;
&lt;p&gt;显然，一个设计良好的可观测性系统应该侧重于允许每个人尽可能多的代理和直接控制，它应该避免将开发者变成意外的看门人。&lt;/p&gt;
&lt;h2 id=&#34;要求零依赖性&#34;&gt;要求：零依赖性&lt;/h2&gt;
&lt;p&gt;应用程序是由依赖关系（网络框架、数据库客户端），加上依赖关系的依赖关系（OpenTelemetry 或其他仪表库），加上它们的依赖关系的依赖关系的依赖关系（无论这些仪表库依赖什么）组成。这些都被称为反式的依赖关系。&lt;/p&gt;
&lt;p&gt;如果任何两个依赖关系之间有冲突，应用程序就无法运行。例如，两个库可能分别需要一个不同的（不兼容的）底层网络库的版本，如 gRPC。这可能会导致一些不好的情况。例如，一个新版本的库可能包括一个需要的安全补丁，但也包括一个升级的依赖关系，这就产生了依赖关系冲突。&lt;/p&gt;
&lt;p&gt;诸如此类的过渡性依赖冲突给应用程序所有者带来了很大的麻烦，因为这些冲突无法独立解决。相反，应用程序所有者必须联系库的作者，要求他们提供一个解决方案，这最终需要时间（假设库的作者回应了这个请求）。&lt;/p&gt;
&lt;p&gt;为了使现代可观测性发挥作用，库必须能够嵌入仪表，而不必担心当他们的库被用于组成应用程序时而导致问题。因此，可观测性系统必须提供不包含可能无意中引发横向依赖冲突的依赖性的仪表。&lt;/p&gt;
&lt;h2 id=&#34;要求严格的后向兼容和长期支持&#34;&gt;要求：严格的后向兼容和长期支持&lt;/h2&gt;
&lt;p&gt;当一个仪表化的 API 破坏了向后的兼容性，坏事就会发生。一个精心设计的应用程序最终可能会有成千上万的仪表调用站点。由于 API 的改变而不得不更新数以千计的调用站点是一个相当大的工作量。&lt;/p&gt;
&lt;p&gt;这就产生了一种特别糟糕的依赖性冲突，即一个库中的仪表化不再与另一个库中的仪表化兼容。&lt;/p&gt;
&lt;p&gt;因此，仪表化 API 必须在很长的时间范围内具有严格的向后兼容能力。理想的情况是，仪表化 API 一旦变得稳定，就永远不会破坏向后兼容。新的、实验性的 API 功能的开发方式必须保证它们的存在不会在包含稳定仪表的库之间产生冲突。&lt;/p&gt;
&lt;h2 id=&#34;分离关注点是良好设计的基础&#34;&gt;分离关注点是良好设计的基础&lt;/h2&gt;
&lt;p&gt;在下一章中，我们将深入研究 OpenTelemetry 的架构，看看它是如何满足上面提出的要求的。但在这之前，我想说的是一个重要的问题。&lt;/p&gt;
&lt;p&gt;如果你分析这些需求，你可能会注意到一些奇特的现象：它们中几乎没有任何专门针对可观测性的内容。相反，重点是尽量减少依赖性，保持向后的兼容性，并确保不同的用户可以在没有无谓干扰的情况下发挥作用。&lt;/p&gt;
&lt;p&gt;每一个要求都指出了关注点分离是一个关键的设计特征。但是这些特性并不是 OpenTelemetry 所独有的。任何寻求广泛采用的软件库都会很好地包括它们。在这个意义上，OpenTelemetry 的设计也可以作为设计一般的开源软件的指南。下次当你开始一个新的开放源码软件项目时，请预先考虑这些要求，相应地设计你的库及你的用户会感谢你的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 5 章：OpenTelemetry 架构概述</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/architectural-overview/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/architectural-overview/</guid>
      <description>&lt;p&gt;第 2 章描述了实现自动分析所需的数据模型，第 4 章描述了支持原生 开源仪表的额外要求，并赋予各角色（应用程序所有者、运维和响应者）自主权。这就是我们对现代可观测性的概念模型。&lt;/p&gt;
&lt;p&gt;在本报告的其余部分，我们描述了这个新模型的一个事实实现，即 OpenTelemetry。这一章描述了构成 OpenTelemetry 遥测管道的所有组件。后面的章节将描述稳定性保证、建议的设置以及 OpenTelemetry 现实中的部署策略。有关该项目的更多细节可以在附录中找到。&lt;/p&gt;
&lt;h2 id=&#34;信号&#34;&gt;信号&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 规范被组织成不同类型的遥测，我们称之为&lt;strong&gt;信号（signal）&lt;/strong&gt;。主要的信号是追踪。日志和度量是其他例子。信号是 OpenTelemetry 中最基本的设计单位。&lt;/p&gt;
&lt;p&gt;每一个额外的信号首先是独立开发的，然后与追踪和其他相关信号整合。这种分离允许开发新的、实验性的信号，而不影响已经变得稳定的信号的兼容性保证。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 是一个&lt;strong&gt;跨领域的关注点（cross-cutting concern）&lt;/strong&gt;，它在事务通过每个库和服务时追踪其执行。为了达到这个目的，所有的信号都建立在低级别的上下文传播系统之上，该系统为信号提供了一个地方来存储它们需要与当前正在执行的代码相关联的任何事务级数据。因为上下文传播系统与追踪系统是完全分开的，其他跨领域的问题也可以利用它。图 5-1 说明了这个分层结构。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-1所有-opentelemetry-信号都建立在一个共享的上下文传播系统之上其他的非可观测性的交叉关注也可以使用上下文传播机制来通过分布式系统传输他们的数据&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-1.png&#34; alt=&#34;图 5-1：所有 OpenTelemetry 信号都建立在一个共享的上下文传播系统之上。其他的，非可观测性的交叉关注也可以使用上下文传播机制来通过分布式系统传输他们的数据。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5-1：所有 OpenTelemetry 信号都建立在一个共享的上下文传播系统之上。其他的，非可观测性的交叉关注也可以使用上下文传播机制来通过分布式系统传输他们的数据。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;上下文context&#34;&gt;上下文（Context）&lt;/h2&gt;
&lt;p&gt;上下文对象是一个与执行上下文相关联的键值存储，例如线程或循环程序。如何实现这一点取决于语言，但 OpenTelemetry 在每种语言中都提供一个上下文对象。&lt;/p&gt;
&lt;p&gt;信号在上下文对象中存储它们的数据。因为 OpenTelemetry 的 API 调用总是可以访问整个上下文对象，所以信号有可能成为集成的，并在上下文共享数据，而不需要改变 API。例如，如果追踪和度量信号都被启用，记录一个度量可以自动创建一个追踪范例。日志也是如此：如果有的话，日志会自动绑定到当前的追踪。&lt;/p&gt;
&lt;h2 id=&#34;传播器propagator&#34;&gt;传播器（Propagator）&lt;/h2&gt;
&lt;p&gt;为了使分布式追踪发挥作用，追踪上下文必须被参与事务的每个服务所共享。传播器通过序列化和反序列化上下文对象来实现这一点，允许信号在网络工作请求中追踪其事务。&lt;/p&gt;
&lt;h2 id=&#34;追踪tracing&#34;&gt;追踪（Tracing）&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 追踪系统是基于 OpenTracing 和 OpenCensus。这两个系统，以及流行的 Zipkin 和 Jaeger 项目，都是基于谷歌开发的 Dapper 追踪系统。OpenTelemetry 试图与所有这些基于 Dapper 的系统兼容。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 追踪包括一个叫做 &lt;strong&gt;链接（link）&lt;/strong&gt; 的概念，它允许单独的追踪被组合成一个更大的图。这被用来连接事务和后台处理，以及观察大型异步系统，如 Kafka 和 AMQP。&lt;/p&gt;
&lt;h2 id=&#34;指标metric&#34;&gt;指标（Metric）&lt;/h2&gt;
&lt;p&gt;度量指标（metric）是一个很大的话题，包含各种各样的方法和实现。OpenTelemetry 度量信号被设计成与 Prometheus 和 StatsD 完全兼容。&lt;/p&gt;
&lt;p&gt;指标包括追踪样本，自动将指标与产生它们的追踪样本联系起来。手工将指标和追踪联系起来往往是一项繁琐且容易出错的任务，自动执行这项任务将为运维人员节省大量的时间。&lt;/p&gt;
&lt;h2 id=&#34;日志log&#34;&gt;日志（Log）&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 结合了高度结构化的日志 API 和高速日志处理系统。现有的日志 API 可以连接到 OpenTelemetry，避免了对应用程序的重新测量。&lt;/p&gt;
&lt;p&gt;每当它出现的时候，日志就会自动附加到当前的追踪中。这使得事务日志很容易找到，并允许自动分析，以找到同一追踪中的日志之间的准确关联。&lt;/p&gt;
&lt;h2 id=&#34;baggage&#34;&gt;Baggage&lt;/h2&gt;
&lt;p&gt;OpenTelemetry Baggage 是一个简单但通用的键值系统。一旦数据被添加为 Baggage（包袱）它就可以被所有下游服务访问。这允许有用的信息，如账户和项目 ID，在事务的后期变得可用，而不需要从数据库中重新获取它们。例如，一个使用项目 ID 作为索引的前端服务可以将其作为 Baggage 添加，允许后端服务也通过项目 ID 对其跨度和指标进行索引。&lt;/p&gt;
&lt;p&gt;你可以将 Baggage 看做是一种&lt;strong&gt;分布式文本的&lt;/strong&gt;形式。直接放入上下文对象的项目只能在当前服务中访问。与追踪上下文一样，作为 Baggage 添加的项目被作为 header 注入网络请求，允许下游服务提取它们。&lt;/p&gt;
&lt;p&gt;与上下文对象一样，Baggage 本身不是一个可观测性工具。它更像是一个通用的数据存储和传输系统。除了可观测性之外，其他跨领域的工具，例如，功能标记、A/B 测试和认证，可以使用 Baggage 来存储他们需要追踪当前事务的任何状态。&lt;/p&gt;
&lt;p&gt;然而，Baggage 是有代价的。因为每增加一个项目都必须被编码为一个头，每增加一个项目都会增加事务中每一个后续网络请求的大小。这就是为什么我们称它为 Baggage。我建议，Baggage 要少用，作为交叉关注的一部分。Baggage 不应该被用作明确定义的服务 API 的 &amp;ldquo;方便&amp;rdquo; 替代品，以明确地向下游应用程序发送参数。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-客户端架构&#34;&gt;OpenTelemetry 客户端架构&lt;/h2&gt;
&lt;p&gt;应用程序通过安装一系列的软件库来检测 OpenTelemetry：API、SDK（软件开发工具包）、SDK 插件和库检测。这套库被称为 OpenTelemetry 客户端。图 5-2 显示了这些组件之间的关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-2opentelemetry-客户端架构为了帮助管理依赖性opentelemetry-将实现与仪表使用的-api-分开&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-2.png&#34; alt=&#34;图 5-2：OpenTelemetry 客户端架构。为了帮助管理依赖性，OpenTelemetry 将实现与仪表使用的 API 分开。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5-2：OpenTelemetry 客户端架构。为了帮助管理依赖性，OpenTelemetry 将实现与仪表使用的 API 分开。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在许多语言中，OpenTelemetry 提供安装程序，这有助于自动安装和设置 OpenTelemetry 客户端。然而，可用的自动化程度取决于语言。在 Java 中，OpenTelemetry 提供了一个 Java 代理，它通过动态地注入所有必要的组件来实现安装的完全自动化。在 Go 中，OpenTelemetry 包必须通过编写代码来安装和初始化，就像任何其他 Go 包一样。Python、Ruby 和 NodeJS 介于两者之间，提供不同程度的自动化。&lt;/p&gt;
&lt;p&gt;在学习 OpenTelemetry 时，了解在你使用的语言中如何设置是很重要的。特别是，一定要学习如何安装仪表，因为不同的语言有很大的不同。&lt;/p&gt;
&lt;p&gt;请查看&lt;a href=&#34;https://opentelemetry.io/docs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;客户端文档&lt;/a&gt;，了解更多的入门细节。&lt;/p&gt;
&lt;h2 id=&#34;客户端架构仪表-api&#34;&gt;客户端架构：仪表 API&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;OpenTelemetry API&lt;/strong&gt; 是指用于编写仪表的一组组件。该 API 被设计成可以直接嵌入到开放源码软件库以及应用程序中。这是 OpenTelemetry 的唯一部分，共享库和应用逻辑应该直接依赖它。&lt;/p&gt;
&lt;h2 id=&#34;提供者provider&#34;&gt;提供者（Provider）&lt;/h2&gt;
&lt;p&gt;API 与任何实现完全分开。当一个应用程序启动时，可以通过为每个信号注册一个提供者来加载一个实现。提供者成为所有 API 调用的接收者。&lt;/p&gt;
&lt;p&gt;当没有加载提供者时，API 默认为无操作提供者。这使得 OpenTelemetry 仪表化可以安全地包含在共享库中。如果应用程序不使用 OpenTelemetry，API 调用就会变成 no-ops，不会产生任何开销。&lt;/p&gt;
&lt;p&gt;对于生产使用，我们建议使用官方的 OpenTelemetry 提供商，我们称之为 &lt;strong&gt;OpenTelemetry SDK&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么有多个实现方案？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;API 和实现的分离有很多好处。但是，如果用户被迫总是安装官方的 OpenTelemetry SDK，这又有什么意义？是否有必要安装另一个实现？SDK 已经具有很强的扩展性。&lt;/p&gt;
&lt;p&gt;我们相信是有的。虽然我们希望 OpenTelemetry 仪表是通用的，但建立一个对所有用例都理想的单一实现是不可能的。尽管我们相信 OpenTelemetry SDK 很好，但也应该有一个选择，那就是使用另一种实现。实现的灵活性是提供通用仪表 API 的一个关键特征。&lt;/p&gt;
&lt;p&gt;首先，这种分离保证了 OpenTelemetry 不会产生无法克服的依赖冲突。我们总是可以选择加载一个包括不同依赖链的实现。&lt;/p&gt;
&lt;p&gt;另一个原因是性能。OpenTelemetry SDK 是一个可扩展的、通用的框架。虽然 SDK 的设计是为了尽可能地提高性能，但扩展性和性能总是要权衡一下的。例如，通过外来函数接口创建与 OpenTelemetry C++ SDK 的绑定，有可能成为 Ruby、Python 和 Node.js 等动态脚本语言的一个非常有效的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有一些流媒体架构显示了有希望的性能提升。在许多这样的优化解决方案中，编写插件和生命周期钩子的能力将受到严重限制；支持这些类型的功能所需的数据结构在这些优化解决方案中是不存在的。归根结底，没有 &amp;ldquo;完美的实现&amp;rdquo;；只有权衡。&lt;/p&gt;
&lt;p&gt;API/SDK 的分离是一个关键的设计选择，该项目大量使用了这一点。例如，除了 SDK 之外，每一种语言都有一个 no-op 的实现，它是默认安装的。还有一个 Fake/Mock 实现，我们用它来测试。而且，还有可能实现更多创造性的实现。例如，为分布式系统建立开发者工具，如一个实时调试器，它可以跨越网络边界工作。&lt;/p&gt;
&lt;h2 id=&#34;客户端架构sdk&#34;&gt;客户端架构：SDK&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 项目为 OpenTelemetry API 提供了一个官方实现，我们称之为 OpenTelemetry SDK。该 SDK 通过提供一个插件框架来实现 OpenTelemetry API。下面将介绍追踪 SDK；类似的架构也适用于度量和日志。&lt;/p&gt;
&lt;p&gt;基本数据结构是一个无锁的 SpanData 对象。当用户开始一个跨度时，SpanData 对象被创建，当用户添加属性和事件时，它被自动建立起来。一旦一个跨度结束，SpanData 对象将不再被更新，可以安全地传递给后台线程。&lt;/p&gt;
&lt;p&gt;SDK 的插件架构被组织成一个流水线。对于追踪来说，该管道由一连串的 SpanProcessors 组成。每个处理器对 SpanData 对象进行两次同步访问：一次是在跨度开始时，另一次是在跨度结束后。采样器、日志附加器和数据清洗器是 SpanProcessors 的例子。链中的最后一个处理器通常是一个 BatchSpanProcessor，它管理着一个已完成的跨度的缓冲区。输出器可以连接到 BatchSpanProcessor，通过网络将成批的跨度传递到遥测管道中的下一个服务，通常将它们发送到收集器或直接发送到追踪后端。一旦跨度被导出，管道就完成了，SpanData 对象也被释放。&lt;/p&gt;
&lt;h2 id=&#34;采样器sampler&#34;&gt;采样器（Sampler）&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 提供了几种常见的采样算法，包括前期采样和基于优先级的采样。采样可以帮助控制成本，但它是有代价的：你将会错过数据。在启用任何种类的采样算法之前，重要的是要检查你计划使用的分析工具支持哪些类型的采用。意外的采样可能会破坏某些形式的分析。一些工具需要他们自己的采样插件。例如，AWS X-Ray 使用它自己的采样算法，它可以作为 AWS 特定的采样插件使用。&lt;/p&gt;
&lt;h2 id=&#34;导出器exporter&#34;&gt;导出器（Exporter）&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 为 OTLP（OpenTelemetry Protocol）、Jaeger、Zipkin、Prometheus 和 StatsD 提供导出器。由第三方维护的其他导出器可以在每种语言的 OpenTelemetry-Contrib 资源库中找到。使用 &lt;a href=&#34;https://opentelemetry.io/registry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 注册表&lt;/a&gt;来了解目前有哪些插件可用。&lt;/p&gt;
&lt;h2 id=&#34;客户端架构库仪表化&#34;&gt;客户端架构：库仪表化&lt;/h2&gt;
&lt;p&gt;为了正常工作，OpenTelemetry 需要端到端的工具。这不是可有可无的：如果关键的库不包括仪表，上下文传播将被破坏。&lt;/p&gt;
&lt;p&gt;一般来说，必须检测的库包括 HTTP 客户端、HTTP 服务器、应用框架、消息传递 / 队列系统和数据库客户端。这些库经常在上下文传播中起作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 客户端必须创建一个&lt;strong&gt;客户端 span&lt;/strong&gt; 来记录请求。客户端还必须使用一个传播器，将当前的上下文作为一组 HTTP 头信息注入到请求中。&lt;/li&gt;
&lt;li&gt;HTTP 服务器（应用框架）必须使用一个传播器来从 HTTP 头信息中提取上下文。提取的上下文被用来创建一个&lt;strong&gt;服务器跨度&lt;/strong&gt;，该跨度被设置为当前活动的跨度，它封装了所有的应用程序代码。&lt;/li&gt;
&lt;li&gt;同样，消息 / 队列系统中的发送者必须使用传播器将上下文注入消息中，这样就可以通过在接收者身上提取上下文来继续追踪。&lt;/li&gt;
&lt;li&gt;数据库客户必须创建一个&lt;strong&gt;数据库跨度&lt;/strong&gt;来记录数据基础事务。一旦数据库服务器也使用 OpenTelemetry 工具，数据库客户端也必须将上下文注入数据库请求中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一要求是我们希望看到开放源码软件库能带有本地仪表的主要原因之一。同时，仪表插件是由 OpenTelemetry 项目或第三方提供的 &lt;strong&gt;contrib 包。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;收集器collector&#34;&gt;收集器（Collector）&lt;/h2&gt;
&lt;p&gt;除了上述的客户端外，OpenTelemetry 还提供了一个独立的服务，称为收集器。收集器是一个灵活、可配置的遥测处理系统。其基本结构如图 5-3 所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-3收集器有一个可配置的处理管道可以导入和导出许多常见格式的数据&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f5-3.png&#34; alt=&#34;图 5-3：收集器有一个可配置的处理管道，可以导入和导出许多常见格式的数据。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5-3：收集器有一个可配置的处理管道，可以导入和导出许多常见格式的数据。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;收集器管道可以提供以下服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置，如路由和数据导出格式。OpenTelemetry 客户端可用的几乎所有配置选项都可以在收集器中进行管理。&lt;/li&gt;
&lt;li&gt;数据处理，如刷新、格式转换和向多个目的地发送。&lt;/li&gt;
&lt;li&gt;缓冲，帮助管理网络。&lt;/li&gt;
&lt;li&gt;机器级环境的资源检测。可以发现主机、Kubernetes 和云提供商的细节，并将其附加到收集器收到的所有数据上。&lt;/li&gt;
&lt;li&gt;收集主机指标，如 RAM、CPU 和存储容量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运维人员可以使用收集器来管理与可观测系统相关的所有部署细节，而不需要与应用程序本身进行交互。由于大多数配置选项是特定于部署的，而且是由运维而不是应用程序开发人员管理的，因此，将遥测配置从应用程序转移到收集器，可以干净地分离关注点。&lt;/p&gt;
&lt;p&gt;如果所有的路由和数据处理任务都转移到收集器上，OpenTelemetry SDK 就可以以更简单的配置运行。默认情况下，SDK 将发送未处理的 OTLP 数据到一个预定的本地端口，在那里它可以由本地收集器接收。&lt;/p&gt;
&lt;h2 id=&#34;收集器架构接收器receiver&#34;&gt;收集器架构：接收器（Receiver）&lt;/h2&gt;
&lt;p&gt;收集器可以被配置为从各种来源接收各种格式的遥测数据。目前，收集器支持超过四十种不同类型的接收器！一旦接收到，所有这些数据都会被转换为 OTLP。OpenTelemetry 同时支持基于推和拉的接收器。&lt;/p&gt;
&lt;h2 id=&#34;收集器架构处理器processor&#34;&gt;收集器架构：处理器（Processor）&lt;/h2&gt;
&lt;p&gt;一旦接收器将遥测数据转换为 OTLP，就会有各种处理器可用。处理器可以被配置为执行各种任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清洗数据以删除敏感数据，如 PII（个人身份信息）。&lt;/li&gt;
&lt;li&gt;数据规范化，例如将数据源的旧版本转换为与当前后台使用的仪表盘和查询相匹配的版本。&lt;/li&gt;
&lt;li&gt;根据某些属性将数据路由到特定的后端。例如，将与欧盟用户有关的数据存储在欧盟境内托管的存储系统上。&lt;/li&gt;
&lt;li&gt;基于尾部的采样，以帮助确保错误和异常值更有可能被捕获，同时对嘈杂和无趣的信息进行速率限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;收集器架构导出器exporter&#34;&gt;收集器架构：导出器（Exporter）&lt;/h2&gt;
&lt;p&gt;一旦遥测数据被处理，它可以被输出到各种后端。在未来，我们希望越来越多的后端能够原生支持 OTLP。同时，OTLP 可以被转换为目前流行的系统所支持的许多格式。请查看 &lt;a href=&#34;https://opentelemetry.io/vendors/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 供应商页面&lt;/a&gt;，找到目前支持 OpenTelemetry 的商业供应商列表。&lt;/p&gt;
&lt;p&gt;除了将遥测数据转换为单一格式外，还可以安装多个导出器。遥测数据可以按类型分开，并发送到不同的后端。例如，将追踪数据发送到 Jaeger，将度量数据发送到 Prometheus。&lt;/p&gt;
&lt;p&gt;重复的遥测数据也可以被同步发送到多个后端。这使得运维人员可以从一个后端无缝切换到另一个后端，而不会有任何服务上的损失。它还允许特殊的分析工具与通用的观测平台一起接收数据。&lt;/p&gt;
&lt;h2 id=&#34;收集器架构管道pipeline&#34;&gt;收集器架构：管道（Pipeline）&lt;/h2&gt;
&lt;p&gt;收集器允许接收器、处理器和导出器组合成复杂的管道（pipeline），可以同时运行。管道是通过 YAML 配置文件设计和管理的。&lt;/p&gt;
&lt;p&gt;这种配置语言是非常强大的。通过在每台机器上部署一个本地收集器，并将它们连接到配置为执行专门处理任务的几层收集器部署上，收集器可以用来开发一个大规模的、强大的遥测系统。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 6 章：稳定和长期支持</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/stability-and-long-term-support/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/stability-and-long-term-support/</guid>
      <description>&lt;p&gt;OpenTelemetry 被设计成允许长期稳定性和不确定性并存的局面。在 OpenTelemetry 中，稳定性保证是在每个信号的基础上提供的。与其看版本号，不如检查你想使用的信号的稳定性等级。&lt;/p&gt;
&lt;h2 id=&#34;信号生命周期&#34;&gt;信号生命周期&lt;/h2&gt;
&lt;p&gt;图 6-1 显示了新信号是如何被添加到 OpenTelemetry 的。&lt;strong&gt;实验性&lt;/strong&gt;信号仍在开发中。它们可能在任何时候改变并破坏兼容性。实验性信号的开发是以规范提案的形式开始的，它是与一组原型一起开发的。一旦实验性信号准备好在生产中使用，信号的特性就会被冻结，新信号的测试版就会以多种语言创建。测试版可能不是完整的功能，它们可能会有一些突破性的变化，但它们被认为是为早期采用者的产品反馈做好准备。一旦一个信号被认为可以被宣布为&lt;strong&gt;稳定&lt;/strong&gt;版本，就会发布一个候选版本。如果候选版本能够在一段时间内保持稳定，没有问题，那么该信号的规范和测试版都被宣布为稳定。&lt;/p&gt;
&lt;p&gt;一旦一个信号变得稳定，它就属于 OpenTelemetry 的长期支持保障范围。OpenTelemetry 非常重视向后兼容和无缝升级。详情见以下章节。&lt;/p&gt;
&lt;p&gt;如果 OpenTelemetry 信号的某个组件需要退役，该组件将被标记为&lt;strong&gt;废弃的&lt;/strong&gt;。被废弃的组件不再获得新的功能，但它们仍然被 OpenTelemetry 的长期支持保证所覆盖。如果可能的话，该组件将永远不会被删除，并将继续发挥作用。如果一个组件必须被删除，将提前宣布删除日期。&lt;/p&gt;
&lt;p&gt;实验性的功能总是与稳定性的功能保持在不同的包中，稳定的功能永远不能引用实验性的功能。这确保了新的开发不会影响现有特性的稳定性。只要库只依赖于稳定的特性，它们就不会经历破坏性的 API 变化。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6-1opentelemetry-中的每个主要功能都被赋予了一个稳定性等级并遵循相同的生命周期&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f6-1.png&#34; alt=&#34;图 6-1：OpenTelemetry 中的每个主要功能都被赋予了一个稳定性等级，并遵循相同的生命周期。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6-1：OpenTelemetry 中的每个主要功能都被赋予了一个稳定性等级，并遵循相同的生命周期。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;api-的稳定性&#34;&gt;API 的稳定性&lt;/h2&gt;
&lt;p&gt;OpenTelemetry API 预计将被数以千计的库所依赖，有数以百万计的调用站点。因此，API 的稳定部分决不能破坏向后的兼容性。应用程序的所有者和库的开发者不应该为了升级到一个新版本的 API 而重新测量他们的应用程序。&lt;/p&gt;
&lt;p&gt;如果一个 OpenTelemetry API 被废弃（这不太可能），被废弃的 API 仍将保持稳定并发挥功能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原生工具是稳定的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;携带原生 OpenTelemetry 仪表的 OSS 库应该只使用稳定的 API，因为实验性功能的改变可能会造成依赖性冲突。&lt;/p&gt;
&lt;p&gt;也就是说，我们鼓励进行测试。如果一个库愿意为实验性的 OpenTelemetry 功能提供支持，这是一个给项目提供反馈和参与新功能设计的好方法。然而，我们建议将与实验性 OpenTelemetry 功能的集成作为可选的插件提供，终端用户必须单独安装才能启用。&lt;/p&gt;
&lt;p&gt;一旦功能变得稳定，就没有必要把它们作为一个单独的插件。事实上，最好是将 OpenTelemetry 原生集成，因为用户可能会忘记安装插件。这样一来，如果应用程序所有者安装了 OpenTelemetry SDK，他们就会自动开始接收来自每个库的数据。如果没有安装 SDK，API 的调用就没有意义了。原生仪表是我们希望 OpenTelemetry 能够简化应用程序所有者的观察能力的一种方式 —— 它已经存在于每一个库中，只要它需要，就可以随时使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;sdk-和收集器的稳定性&#34;&gt;SDK 和收集器的稳定性&lt;/h2&gt;
&lt;p&gt;SDK 的稳定性集中在两个方面：插件接口和资源使用。SDK 可能偶尔会废止一个插件接口。为了确保应用程序的所有者能够干净利落地进行升级，必须在废弃的接口被删除之前添加一个替代接口，而使用废弃接口的流行插件必须被迁移到新的接口上。通过以这种方式安全地迁移插件生态系统，可以避免应用程序所有者陷入这样的境地：他们想要升级，但却被一个无法使用的插件所阻挡。在废弃和移除一个插件接口之间必须有至少 6 个月的时间，而且废弃的接口只有在维护它们会造成性能问题时才会被移除。否则，我们将无限期地保留这些被废弃的接口。&lt;/p&gt;
&lt;p&gt;说到性能，OpenTelemetry SDK 的稳定部分必须避免性能倒退，以确保 SDK 的较新版本在升级时不会引起资源争夺。很明显，启用新版本中增加的功能可能需要额外的资源。但是，简单地升级 SDK 不应该导致性能退步。&lt;/p&gt;
&lt;p&gt;与 SDK 一样，收集器试图避免性能退步，并为收集器插件生态系统提供一个渐进的升级路径。&lt;/p&gt;
&lt;h2 id=&#34;升级-opentelemetry-客户端&#34;&gt;升级 OpenTelemetry 客户端&lt;/h2&gt;
&lt;p&gt;在运行 OpenTelemetry 时，我们希望用户能保持最新的 SDK 版本。有两个事件可能会迫使用户升级 SDK：一个库将其仪表升级到新版本的 API，或者 OpenTelemetry 发布一个重要的安全补丁。&lt;/p&gt;
&lt;p&gt;上面列出的稳定性保证确保了这种升级路径始终是可行的。只要一个应用程序只依赖于稳定的信号，升级应该只涉及依赖性的提升。教程不需要重写，插件也不会突然变得不受支持。&lt;/p&gt;
&lt;p&gt;OpenTelemetry 致力于向后兼容的一个很好的例子是它对其前身 OpenTracing 的支持。OpenTelemetry 追踪信号与 OpenTracing API 完全兼容，OpenTelemetry 和 OpenTracing API 调用可以混合到同一个应用程序中。OpenTracing 用户可以升级到 OpenTelemetry 而不需要重写现有的仪表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 7 章：建议的设置和遥测管道</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/suggested-setups-and-telemetry-pipelines/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/suggested-setups-and-telemetry-pipelines/</guid>
      <description>&lt;p&gt;现在我们了解了组成 OpenTelemetry 的各个构件，我们应该如何将它们组合成一个强大的生产管道？&lt;/p&gt;
&lt;p&gt;答案取决于你的出发点是什么。OpenTelemetry 是模块化的，设计成可以在各种不同的规模下工作。你只需要使用相关的部分。这就是说，我们已经创建了一个建议的路线图供你遵循。&lt;/p&gt;
&lt;h2 id=&#34;安装-opentelemetry-客户端&#34;&gt;安装 OpenTelemetry 客户端&lt;/h2&gt;
&lt;p&gt;可以单独使用 OpenTelemetry 客户端而不部署收集器。这种基本设置通常是绿地部署的充分起点，无论是测试还是初始生产。OpenTelemetry SDK 可以被配置为直接向大多数可观测性服务传输遥测数据。&lt;/p&gt;
&lt;h2 id=&#34;挑选一个导出器&#34;&gt;挑选一个导出器&lt;/h2&gt;
&lt;p&gt;默认情况下，OpenTelemetry 使用 OTLP 导出数据。该 SDK 提供了几种常见格式的导出器。Zipkin、Prometheus、StatsD 等。如果你使用的可观测性后端没有原生支持 OTLP，那么这些其他格式中的一种很可能会被支持。安装正确的导出器并将数据直接发送到你的后端系统。&lt;/p&gt;
&lt;h2 id=&#34;安装库仪表&#34;&gt;安装库仪表&lt;/h2&gt;
&lt;p&gt;除了 SDK，OpenTelemetry 仪表必须安装在所有 HTTP 客户端、Web 框架、数据库和应用程序的消息队列中。如果这些库中有一个缺少仪表，上下文传播就会中断，导致不完整的追踪和混乱的数据。&lt;/p&gt;
&lt;p&gt;在某些语言中，如 Java，仪表可以自动安装，这就更容易了。请确保了解 OpenTelemetry 如何在你使用的编程语言中管理仪表，并仔细检查仪表是否正确安装在你的应用程序中。&lt;/p&gt;
&lt;h2 id=&#34;选择传播器&#34;&gt;选择传播器&lt;/h2&gt;
&lt;p&gt;仔细检查你的系统需要哪些传播器也很重要。默认情况下，OpenTelemetry 使用 W3C 的追踪上下文和 Baggage 传播器。然而，如果你的应用程序需要与使用不同的追踪传播器的服务进行通信，如 Zipkin 的 B3 或 AWS 的 X-Amzn，那么改变 &lt;code&gt;OTEL_PROPAGATORS&lt;/code&gt; 配置以包括这个额外的传播器。&lt;/p&gt;
&lt;p&gt;如果 OpenTelemetry 最终要取代这些其他的追踪系统，我建议同时运行 trace-context 和额外的追踪传播器。这将使你在部署中逐步取代旧系统时，能够无缝地过渡到 W3C 标准。&lt;/p&gt;
&lt;h2 id=&#34;部署本地收集器&#34;&gt;部署本地收集器&lt;/h2&gt;
&lt;p&gt;虽然有些系统有可能只使用客户端，但通过在你的应用程序所运行的机器上添加一个本地收集器，可以改善你的操作体验。&lt;/p&gt;
&lt;p&gt;运行一个本地收集器有许多好处，如图 7-1 所示。收集器可以生成机器指标（CPU、RAM 等），这是遥测的一个重要部分。收集器还可以完成任何需要的数据处理任务，如从追踪和日志数据中清除 PII。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-1一个本地收集器c从本地应用程序a接收遥测数据同时收集主机指标h收集器将合并的遥测数据输出到管道的下一个阶段&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f7-1.png&#34; alt=&#34;图 7-1：一个本地收集器（C）从本地应用程序（A）接收遥测数据，同时收集主机指标（H）。收集器将合并的遥测数据输出到管道的下一个阶段。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7-1：一个本地收集器（C）从本地应用程序（A）接收遥测数据，同时收集主机指标（H）。收集器将合并的遥测数据输出到管道的下一个阶段。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;运行收集器后就可以将大多数遥测配置从你的应用程序中移出。遥测配置通常是特定的部署，而不是特定的应用。SDK 可以简单地设置为使用默认配置，总是将 OTLP 数据导出到预定义的本地端口。通过管理本地收集器，运维可以在不需要与应用程序开发人员协调或重新启动应用程序的情况下进行配置更改。在通过复杂的 CI/CD（持续集成 / 持续交付）管道移动应用程序时，这尤其有帮助，因为在不同的暂存和负载测试环境中，遥测需要不同的处理方式。&lt;/p&gt;
&lt;p&gt;快速发送遥测数据到本地收集器，可以作为一个缓冲器来处理负载，并确保在应用程序崩溃时，缓冲的遥测数据不会丢失。&lt;/p&gt;
&lt;h2 id=&#34;部署收集器处理器池&#34;&gt;部署收集器处理器池&lt;/h2&gt;
&lt;p&gt;如果你的本地收集器开始执行大量的缓冲和数据处理，它就会从你的应用程序中窃取资源。这可以通过部署一个只运行收集器的机器池来解决，这些机器位于负载均衡器后面，如图 7-2 所示。现在可以根据数据吞吐量来管理收集器池的大小。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-2应用程序a可以通过使用路由器或负载均衡器向收集器c池发送遥测信息&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f7-2.png&#34; alt=&#34;图 7-2：应用程序（A）可以通过使用路由器或负载均衡器向收集器（C）池发送遥测信息。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7-2：应用程序（A）可以通过使用路由器或负载均衡器向收集器（C）池发送遥测信息。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;本地收集器现在可以关闭其处理器以释放资源。它们继续收集机器级遥测数据，作为来自本地应用程序的 OTLP 的转发机制。&lt;/p&gt;
&lt;h2 id=&#34;添加额外的处理池&#34;&gt;添加额外的处理池&lt;/h2&gt;
&lt;p&gt;有时，单个收集器池是不够的。一些任务可能需要以不同的速度扩展。将收集器池分割成一个更专门的池的管道，可能允许更有效和可管理的扩展策略，因为每个专门的收集器池的工作负载变得更可预测。&lt;/p&gt;
&lt;p&gt;一旦你达到了这个规模，就没有什么部署的问题了。大规模系统的专门需求往往是独特的，这些需求将驱动你的可观测性管道的拓扑结构。利用收集器提供的灵活性，根据你的需求来定制每一件事情。我建议对每个收集器配置的资源消耗进行基准测试，并使用这些信息来创建弹性的、自动扩展的收集器池。&lt;/p&gt;
&lt;h2 id=&#34;用收集器管理现有的遥测数据&#34;&gt;用收集器管理现有的遥测数据&lt;/h2&gt;
&lt;p&gt;上面描述的路线图适用于上线 OpenTelemetry。但你应该如何处理现有的遥测？大多数运行中的系统已经有了某种形式的指标、日志和（可能有）追踪。而大型的、长期运行的系统往往最终会有多个遥测解决方案的补丁。不同的组件可能是在不同的时代建立的，有些组件可能是从外部继承的，比如收购。从可观测性的角度来看，这可能会导致混乱的局面。&lt;/p&gt;
&lt;p&gt;即使在这样复杂的遗留情况下，仍然有可能过渡到 OpenTelemetry，而不需要停机或一次重写所有的服务。秘诀是首先部署一个收集器，作为一个透明的代理。&lt;/p&gt;
&lt;p&gt;在收集器中，为接收你的系统目前产生的每一种类型的遥测设置接收器，并与以完全相同的格式发送遥测的导出器相连。一个 StatsD 接收器连接到一个 StatsD 导出器，一个 Zipkin 接收器连接到一个 Zipkin 导出器，以此类推。这种透明的代理可以逐步推出，而不会造成干扰。一旦所有的远程测量都由这些收集器来调解，就可以引入额外的处理。甚至在你把你的仪表切换到 OpenTelemetry 之前，你可能会发现这些收集器是管理和组织你当前拼凑的遥测系统的一个有用的方法。图 7-3 显示了一个收集器处理来自各种来源的数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-3收集器可以帮助管理复杂的拼凑的可观测性系统这些系统以各种格式向各种存储系统发送数据&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f7-3.png&#34; alt=&#34;图 7-3：收集器可以帮助管理复杂的、拼凑的可观测性系统，这些系统以各种格式向各种存储系统发送数据。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7-3：收集器可以帮助管理复杂的、拼凑的可观测性系统，这些系统以各种格式向各种存储系统发送数据。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了开始将服务切换到 OpenTelemetry，可以在收集器上添加一个 OTLP 接收器，与现有的导出器相连。随着服务转向使用 OpenTelemetry 客户端，它们将 OTLP 发送到收集器，收集器将把 OTLP 翻译成这些系统以前产生的相同数据。这使得 OpenTelemetry 可以由不同的应用团队逐步上线，而不会出现中断。&lt;/p&gt;
&lt;h2 id=&#34;转移供应商&#34;&gt;转移供应商&lt;/h2&gt;
&lt;p&gt;一旦所有的遥测流量都通过收集器发送，切换到一个新的可观测性后端就变得很容易了：只需在收集器中添加一个导出器，将数据发送到你想尝试的新系统，并将遥测数据同时发送到旧系统和新系统。通过向两个系统发送数据，你创造了一个重叠的覆盖范围。如果你喜欢新系统，你可以在一段时间后让旧系统退役，以避免在可视性方面产生差距。图 7-4 说明了这个过程。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-4使用收集器在可观测性后端之间迁移而不中断服务&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;../images/f7-4.png&#34; alt=&#34;图 7-4：使用收集器在可观测性后端之间迁移而不中断服务。&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7-4：使用收集器在可观测性后端之间迁移而不中断服务。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;也可以使用 OpenTelemetry 在多个供应商之间进行测验。你可以同时向多个系统发送遥测信息，并直接比较系统，看哪一个最适合你的需要。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第 8 章：如何在组织中推广 OpenTelemetry</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/roll-out/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/roll-out/</guid>
      <description>&lt;p&gt;上线一个新的遥测系统可能是一项复杂的工作。它需要整个工程组织的支持，不能一蹴而就。不要低估这可能会产生的问题！&lt;/p&gt;
&lt;p&gt;在大型组织中，通常有许多服务团队负责系统的不同部分。通常情况下，每个团队都需要付出一定的努力来使他们所管理的服务得到充分的工具化。而这些团队都有自己积压的工作，他们当然希望能够优先处理这些工作。&lt;/p&gt;
&lt;p&gt;不幸的是，可观测性计划在开始提供价值和证明其价值之前就会耗尽人的耐心。但通过仔细的计划和协调，这种情况是可以避免的。&lt;/p&gt;
&lt;h2 id=&#34;主要目标&#34;&gt;主要目标&lt;/h2&gt;
&lt;p&gt;在推广 OpenTelemetry 时，重要的是要记住，任何基于分布式追踪的可观测性系统都需要对参与事务的每个服务进行检测，以提供最大价值。如果只有部分服务被检测到，那么追踪就会被分割成小的、不相连的部分。&lt;/p&gt;
&lt;p&gt;这种散乱的仪表的结果是不可取的。这种情况——不一致的仪表和断裂的追踪是你想要避免的主要事情。如果追踪是断开的，运维人员仍然需要在他们的头脑中把所有的东西拼凑起来，以获得他们系统的情况。更糟糕的是，自动分析工具可以使用的数据非常有限。与人类运维人员不同，他们可以运用直觉，跳出框框来思考问题，而分析工具却只能使用他们得到的数据。由于数据有限，他们提供有用的见解的机会也将是有限的。&lt;/p&gt;
&lt;p&gt;为了避免这个陷阱，集中精力对一个工作流程进行检测，在进入下一个工作流程之前对其进行完整的追踪。大多数工作流程并不涉及大系统的每一个部分，所以这种方法将最大限度地减少分析开始和价值实现之前所需的工作量。&lt;/p&gt;
&lt;h2 id=&#34;选择一个高价值的目标&#34;&gt;选择一个高价值的目标&lt;/h2&gt;
&lt;p&gt;谈到实现价值，在开始进行仪表测量工作时，重要的是要有一个有吸引力的目标！这一点很重要。&lt;/p&gt;
&lt;p&gt;最有可能的是，有一个特别的问题促使人们去部署 OpenTelemetry。如果是这样的话，就把重点放在解决该问题所需的最小的推广上。否则，想一想那些众所周知的问题，解决它们就值得公布了。&lt;/p&gt;
&lt;p&gt;目前有哪些痛苦的、长期的问题在困扰着运维？减少系统延迟在哪里可以直接转化为商业价值？当人们问 &amp;ldquo;为什么这么慢？&amp;rdquo; 时，他们说的是系统的哪一部分？在选择第一个工作流程时，请以这些信息为指导。&lt;/p&gt;
&lt;p&gt;识别一个有吸引力的目标有两个好处。首先，它可以更有利于说服众人，因为有一个具体的理由来做这项工作。这使得它更容易说服有关团队优先考虑增加指导，并以协调的方式进行。&lt;/p&gt;
&lt;p&gt;第二，速战速决给你的新的可观测性系统一个闪亮的机会。第一次通过分布式追踪的视角来分析一个软件系统时，几乎总是会产生有用的见解。证明可观测性的价值可以引起很多人的兴趣，并有助于降低采用时任何挥之不去的障碍。&lt;/p&gt;
&lt;p&gt;如果直接进入生产是困难的，&amp;ldquo;生产支持&amp;rdquo; 系统也是一个好的开始。可以对 CI/CD 系统进行检测，以帮助了解构建和部署的性能。在这里，整个组织都会感受到性能的大幅提升，并可以为将 OpenTelemetry 转移到生产中提供良好的理由。&lt;/p&gt;
&lt;h2 id=&#34;集中遥测管理&#34;&gt;集中遥测管理&lt;/h2&gt;
&lt;p&gt;展开和管理遥测系统从集中化中获益良多。在一些组织中，会有一个平台或信息结构团队可以接触到每一项服务。像这样的团队是集中管理遥测的一个好地方，这可以提供巨大的帮助。遥测管道最好被认为是它自己的系统；允许一个团队操作整个遥测管道，往往比要求许多团队各自拥有系统的一部分要好。&lt;/p&gt;
&lt;p&gt;在软件层面，将 OpenTelemetry 设置与已经广泛部署的代码管理工具——例如共享的启动脚本和应用框架整合起来，减少了每个团队需要管理的代码量。这有助于确保服务与最新的版本和配置保持同步，并使采用更加容易。&lt;/p&gt;
&lt;p&gt;另一个关键工具是一个集中的知识库。OpenTelemetry 有文档，但它是通用的。创建特定于在你的组织内部署、管理和使用 OpenTelemetry 的文档。大多数工程师都是第一次接触 OpenTelemetry 和分布式追踪，这对他们的帮助怎么强调都不为过。&lt;/p&gt;
&lt;h2 id=&#34;先广度后深度&#34;&gt;先广度后深度&lt;/h2&gt;
&lt;p&gt;还有一个关于合理分配精力的说明。当对一个工作流程进行端对端检测时，通常只需安装 OpenTelemetry 附带的仪表，加上你的组织所使用的任何内部或自创框架的仪表即可。没有必要深入检测应用程序代码，至少在开始时没有必要。OpenTelemetry 附带的标准跨度和指标足以让你识别大多数问题；必要时可以有选择地增加更深层次的检测。在添加这种细节之前，请确保你已经建立并运行了端到端的追踪。&lt;/p&gt;
&lt;p&gt;这就是说，有一个快速的方法可以为你的追踪增加很多细节，那就是把任何现有的日志转换成追踪事件。这可以通过创建一个简单的日志附加器来实现，它可以抓取当前的跨度，并将日志作为一个事件附加到它上面。现在，当你查找追踪时，你所有的应用日志都可以得到，这比在传统的日志工具中寻找它们要容易得多。OpenTelemetry 确实为一些常见的日志系统提供了日志附加程序，但它们也很容易编写。&lt;/p&gt;
&lt;h2 id=&#34;与管理层合作&#34;&gt;与管理层合作&lt;/h2&gt;
&lt;p&gt;如果你是一个工程师在读这篇文章，我有一个补充说明。推广一个新的遥测系统可能需要组织很多人。幸运的是，有些人已经在做这种组织工作了 —— 经理们！这就是我们的工作。&lt;/p&gt;
&lt;p&gt;但是，如果你想启动其中的一个项目，说服工程或项目经理来帮助你是很好的第一步。他们将对如何完成项目有宝贵的见解，并能在你可能不参加的会议上推销该项目。有时候，组织人比组织代码更难，所以不要害怕寻求帮助！&lt;/p&gt;
&lt;h2 id=&#34;加入社区&#34;&gt;加入社区&lt;/h2&gt;
&lt;p&gt;最后，在个人和组织层面上，考虑加入 OpenTelemetry 社区！维护者和项目负责人都很友好，非常平易近人。社区是一个很好的获取援助和专业知识的资源的地方；我们总是很乐意帮助新的用户得到指导。还有一种汗水文化：如果有你想看到的 OpenTelemetry 功能，加入一个工作组并提供帮助是使它们得到优先考虑的一个好办法。&lt;/p&gt;
&lt;p&gt;至少，一定要给我们反馈。我们从用户那里听到的越多，我们就越能专注于最重要的问题。我们的目标是建立一个推动下一代可观测性的标准。没有你，我们做不到，我们的大门永远是敞开的。&lt;/p&gt;
&lt;h2 id=&#34;谢谢你的阅读&#34;&gt;谢谢你的阅读&lt;/h2&gt;
&lt;p&gt;我希望你喜欢这份关于 OpenTelemetry 的可观测性的未来的报告。如果你有任何问题、评论、反馈或基于你所读的内容的灵感，请随时在 Twitter 上与我联系，我是 @tedsuo。&lt;/p&gt;
&lt;p&gt;要想获得 OpenTelemetry 的帮助，请加入云原生计算基金会（CNCF）Slack 上的 #OpenTelemetry 频道。我希望能在那里见到你！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>附录 A：OpenTelemetry 项目组织</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/organization/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/organization/</guid>
      <description>&lt;p&gt;OpenTelemetry 是一个大型项目。OpenTelemetry 项目的工作被划分为&lt;strong&gt;特殊兴趣小组&lt;/strong&gt;（SIG）。虽然所有的项目决策最终都是通过 GitHub issue 和 pull request 做出的，但 SIG 成员经常通过 CNCF 的官方 Slack 保持联系，而且大多数 SIG 每周都会在 Zoom 上会面一次。&lt;/p&gt;
&lt;p&gt;任何人都可以加入一个 SIG。要想了解更多关于当前 SIG、项目成员和项目章程的细节，请查看 GitHub 上的 &lt;a href=&#34;https://github.com/open-telemetry/community&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 社区档案库&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;规范&#34;&gt;规范&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 是一个规范驱动的项目。OpenTelemetry 技术委员会负责维护该规范，并通过管理规范的 backlog 来指导项目的发展。&lt;/p&gt;
&lt;p&gt;小的改动可以以 GitHub issue 的方式提出，随后的 pull request 直接提交给规范。但是，对规范的重大修改是通过名为 OpenTelemetry Enhancement Proposals（OTEPs）的征求意见程序进行的。&lt;/p&gt;
&lt;p&gt;任何人都可以提交 OTEP。OTEP 由技术委员会指定的具体审批人进行审查，这些审批人根据其专业领域进行分组。OTEP 至少需要四个方面的批准才能被接受。在进行任何批准之前，通常需要详细的设计，以及至少两种语言的原型。我们希望 OTEP 的作者能够认真对待其他社区成员的要求和关注。我们的目标是确保 OpenTelemetry 适合尽可能多的受众的需求。&lt;/p&gt;
&lt;p&gt;一旦被接受，将根据 OTEP 起草规范变更。由于大多数问题已经在 OTEP 过程中得到了解决，因此规范变更只需要两次批准。&lt;/p&gt;
&lt;h2 id=&#34;项目治理&#34;&gt;项目治理&lt;/h2&gt;
&lt;p&gt;管理 OpenTelemetry 项目如何运作的规则和组织结构由 OpenTelemetry 治理委员会定义和维护，其成员经选举产生，任期两年。&lt;/p&gt;
&lt;p&gt;治理成员应以个人身份参与，而不是公司代表。但是，为同一雇主工作的委员会成员的数量有一个上限。如果因为委员会成员换了工作而超过了这个上限，委员会成员必须辞职，直到雇主代表的人数降到这个上限以下。&lt;/p&gt;
&lt;h2 id=&#34;发行版&#34;&gt;发行版&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 有一个基于插件的架构，因为有些观察能力系统需要一套插件和配置才能正常运行。&lt;/p&gt;
&lt;p&gt;发行版（&lt;strong&gt;distros&lt;/strong&gt;）被定义为广泛使用的 OpenTelemetry 插件的集合，加上一组脚本或辅助功能，可能使 OpenTelemetry 与特定的后端连接更简单，或在特定环境中运行 OpenTelemetry。&lt;/p&gt;
&lt;p&gt;需要澄清的是，如果一个可观测性系统声称它与 OpenTelemetry 兼容，那么它应该总是可以使用 OpenTelemetry 而不需要使用某个特定的发行版。如果一个项目没有经过规范过程就扩展了 OpenTelemetry 的核心功能，或者包括任何导致它与上游 OpenTelemetry 仓库不兼容的变化，那么这个项目就是一个分叉，而不是一个发行版。&lt;/p&gt;
&lt;h2 id=&#34;注册表&#34;&gt;注册表&lt;/h2&gt;
&lt;p&gt;为了便于发现目前有哪些语言、插件和说明，OpenTelemetry 提供了一个注册表。任何人都可以向 &lt;a href=&#34;https://opentelemetry.io/registry/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 注册表&lt;/a&gt;提交插件；在 OpenTelemetry 的 GitHub 组织内托管插件不是必须的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>附录 B：OpenTelemetry 项目路线图</title>
      <link>https://lib.jimmysong.io/opentelemetry-obervability/roadmap/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/opentelemetry-obervability/roadmap/</guid>
      <description>&lt;p&gt;路线图很快就会过时。有关最新的路线图，请参见 &lt;a href=&#34;https://opentelemetry.io/status/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 状态&lt;/a&gt;页面。也就是说，以下是截至目前 OpenTelemetry 的状态。&lt;/p&gt;
&lt;h2 id=&#34;核心组件&#34;&gt;核心组件&lt;/h2&gt;
&lt;p&gt;目前，OpenTelemetry 追踪信号已被宣布为稳定的，并且在许多语言中都有稳定的实现。&lt;/p&gt;
&lt;p&gt;度量信号刚刚被宣布稳定，测试版的实施将在 2022 年第一季度广泛使用。&lt;/p&gt;
&lt;p&gt;日志信号预计将在 2022 年第一季度宣布稳定，测试版实现预计将在 2022 年第二季度广泛使用。2021 年，Stanza 项目被捐赠给 OpenTelemetry，为 OpenTelemetry 收集器增加了高效的日志处理能力。&lt;/p&gt;
&lt;p&gt;用于 HTTP/RPC、数据库和消息系统的语义公约预计将在 2022 年第一季度宣布稳定。&lt;/p&gt;
&lt;h2 id=&#34;未来&#34;&gt;未来&lt;/h2&gt;
&lt;p&gt;完成上述路线图就完成了对 OpenTelemetry 核心功能的稳定性要求。这是一个巨大的里程碑，因为它打开了进一步采用 OpenTelemetry 的大门，包括与数据库、管理服务和 OSS 库的原生集成。这些集成工作大部分已经以原型和测试版支持的形式在进行。随着 OpenTelemetry 的稳定性在 2022 年上半年完成，我预计在 2022 年下半年将出现支持 OpenTelemetry 的宣言，使 2022 年成为 &amp;ldquo;OpenTelemetry 之年&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;但我们并没有就此止步。下一步是什么？&lt;/p&gt;
&lt;h2 id=&#34;ebpf&#34;&gt;eBPF&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Extended Berkeley Packet Filter&lt;/strong&gt;（eBPF）是一种在 Windows、Linux 和其他类似 Unix 的操作系统上提供底层网络访问的机制。利用 eBPF 将给 OpenTelemetry 提供一种极其有效的网络监控形式，不需要任何开发人员的工具。&lt;/p&gt;
&lt;p&gt;2021 年，Flowmill 项目被捐赠给了 OpenTelemetry。Flowmill 是一个基于 eBPF 的可观测性解决方案，专门设计用于观测分布式系统。Flowmill 的开发者与 Pixie 项目的开发者一起，正在努力为 OpenTelemetry Collector 增加 eBPF 支持。Pixie 是专门为 Kubernetes 设计的基于 eBPF 的观测工具，是 CNCF 旗下 OpenTelemetry 的一个姊妹项目。我们还在一起研究如何将底层（第 2 层）eBPF 数据与高层（第 7 层）分布式追踪数据进一步关联起来，这在业界尚属首次。&lt;/p&gt;
&lt;h2 id=&#34;rum&#34;&gt;RUM&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;真实用户监控&lt;/strong&gt;（RUM）是一种可观测性工具，用于描述用户在长期运行的用户会话中如何与移动、网络和桌面客户端进行交互。RUM 与分布式追踪不同，因为图形用户界面（GUI）往往是基于反应器的系统，与数据库和网络服务器等基于事务的系统有根本的架构差异。长话短说：你不能把一个用户会话建模为一个追踪，然后就收工了。&lt;/p&gt;
&lt;p&gt;Client Instrumentation SIG 目前正在开发一个新的 RUM 设计，它将扩展并与 OpenTelemetry 现有的分布式追踪、指标和日志信号完全整合。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-控制平面&#34;&gt;OpenTelemetry 控制平面&lt;/h2&gt;
&lt;p&gt;目前，OpenTelemetry 收集器和 SDK 是作为独立的单元来管理的，必须重新启动才能改变它们的配置。目前，Agent Management SIG 正在开发一个控制平面，它可以报告这些组件的当前状态，并允许实时改变配置。它将允许运维人员或自动服务动态地控制整个遥测管道的处理。&lt;/p&gt;
&lt;p&gt;动态配置将允许对采样、日志水平和其他形式的资源管理进行细粒度、反应灵敏的控制，从而减少成本。最终，这个控制平面可以实现更先进的基于尾部的采样形式，即需要在整个部署中协调的采样技术。&lt;/p&gt;
&lt;h2 id=&#34;列式编码的-otlp&#34;&gt;列式编码的 OTLP&lt;/h2&gt;
&lt;p&gt;目前的 OpenTelemetry 协议是对 OpenTelemetry 数据模型的一种有效而直接的编码。跨度、度量和日志被编码为跨度、度量和日志。这可以被认为是一个&lt;strong&gt;基于行的模型&lt;/strong&gt;，每个跨度、度量和日志都被编码为元素列表中的一个离散元素。基于列的模型则将每个元素编码为一个单一的表格，其中所有元素共享相同的列，用于重叠的概念，如时间戳和属性。&lt;/p&gt;
&lt;p&gt;这种列式表示法有望优化数据批次的创建、大小和处理。这种方法的主要好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更好的数据压缩率（一组相似的数据）。&lt;/li&gt;
&lt;li&gt;更快的数据处理（更好的数据定位意味着更好地使用 CPU 缓存线）。&lt;/li&gt;
&lt;li&gt;更快的序列化和反序列化（更少的对象需要处理）。&lt;/li&gt;
&lt;li&gt;更快的批量创建（更少的内存分配）。&lt;/li&gt;
&lt;li&gt;更好的 I/O 效率（传输的数据更少）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方法的好处与批次的大小成比例地增加。使用现有的 &amp;ldquo;面向行&amp;rdquo; 的表示方法很适合小批量的情况。因此，列式编码将&lt;strong&gt;扩展&lt;/strong&gt;当前的协议。目前提出的实施方案是基于 Apache Arrow，这是一种成熟的列式内存格式。&lt;/p&gt;
&lt;p&gt;这种优化的重点是允许高容量的数据源，如 CDN 和大型多租户系统，像常规服务一样参与可观测性。列式编码也将减少跨网络边界的遥测出口的成本。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么 Prometheus 查询很难？</title>
      <link>https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/</link>
      <pubDate>Tue, 10 Oct 2023 10:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://fiberplane.com/blog/why-are-prometheus-queries-hard&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fiberplane.com/blog/why-are-prometheus-queries-hard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Prometheus 是一个强大的开源可观测性工具。但是许多人，包括我自己，都很难理解其查询语言。在这篇文章中，我将从头开始建立一个基本的查询，并使用每个步骤来解释 PromQL 中一些较难理解的方面。希望这能更直观地展示 Prometheus 的工作原理，帮助你编写查询并理解数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于&lt;a href=&#34;https://autometrics.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Autometrics&lt;/a&gt;项目的一个快速介绍：它是一个开源微型框架，使你可以轻松地为代码添加最有用的指标，并为你编写 Prometheus 查询。无需手动编写查询，即可在生产环境中识别和调试问题！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;用简单的查询回答问题&#34;&gt;用“简单”的查询回答问题&lt;/h2&gt;
&lt;p&gt;假设我们正在运行一个 HTTP API，并且我们想了解用户遇到错误的频率。这似乎是一个简单的问题，对吧？&lt;/p&gt;
&lt;p&gt;为了从 Prometheus 中获取这个答案，我们需要进行类似以下的查询，其中已经涉及了很多内容：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum by (status) (rate(http_requests_total[5m]))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了理解为什么这个查询有效，以及为什么我们需要这个查询，我们需要深入了解 Prometheus 如何存储数据以及一些关键的 PromQL 功能。在接下来的几节中，我们将逐步构建这个查询，同时花时间理解每个部分的作用以及为什么它是必要的。&lt;/p&gt;
&lt;h2 id=&#34;计数器主要是递增的&#34;&gt;计数器主要是递增的&lt;/h2&gt;
&lt;p&gt;Prometheus 最重要且最令人困惑的一个方面是，它跟踪的大多数值都是递增的。Prometheus 不会存储每个小时间段发生的事件数量。相反，它跟踪的是随着时间累积的总数。这既是 Prometheus 效率的来源，也是在编写查询时造成困惑的主要原因之一。&lt;/p&gt;
&lt;p&gt;当你在应用程序中创建一个计数器时，它将使用内存中存储的一个简单数字来跟踪事件发生的总次数。Prometheus 每隔几秒钟抓取这些数据并存储它所观察到的总数。如果你想要计算在特定时间段内事件发生的次数，你需要编写一个查询，从 Prometheus 实际存储的累积总数中提取这些信息（我们将在下面详细介绍）。&lt;/p&gt;
&lt;p&gt;为了说明这一点和后续的内容，有一个有关 Prometheus 内部数据的心智模型是很有用的。下面是一个简化的图片，显示了一个跟踪服务的 HTTP 请求总数的计数器。请注意，每个计数器的值在不同的时间段内要么增加，要么保持不变。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_42be651e62d0366c37dc4ba030f75d4d.webp 400w,
               /blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_be5f95248e820ce08ca39b2562c1c5c5.webp 760w,
               /blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/1_huf043d28e52d76f54617a7ba3cb26ae3e_112856_42be651e62d0366c37dc4ba030f75d4d.webp&#34;
               width=&#34;760&#34;
               height=&#34;264&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;每个时间点上，我们看到的是自开始以来到该时间点的 HTTP 请求的&lt;em&gt;总数&lt;/em&gt;，而不是自上次观察以来的请求数量。&lt;/p&gt;
&lt;p&gt;为什么我们说计数器“主要”是递增的，而不是总是递增的？因为有重新启动和崩溃的情况。如果你的服务由于任何原因重新启动，它在内存中存储的计数器值将被重置为零，并重新开始计数。PromQL 具有处理计数器重置的特殊函数，因此你的派生统计数据是正确的。&lt;/p&gt;
&lt;p&gt;现在我们知道计数器主要是递增的，我们可以开始查询数据并利用它。&lt;/p&gt;
&lt;h2 id=&#34;即时向量和范围向量&#34;&gt;即时向量和范围向量&lt;/h2&gt;
&lt;p&gt;PromQL 有两种主要类型的数据：即时向量和范围向量 - 这两个术语让我的眼睛立刻变得模糊。&lt;/p&gt;
&lt;p&gt;下面是即时向量和范围向量之间的区别的示例。即时向量以橙色显示，是一个时间点上的值的快照。范围向量以蓝色显示，每个系列的每个时间点都有一个值。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_3c8ae426f8d58a57041244cd65434a63.webp 400w,
               /blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_6cf61867895d5ad0d8eea7a6d7f75fa5.webp 760w,
               /blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/2_hu4febf0279dbbc0aa5f55140ce699a828_148402_3c8ae426f8d58a57041244cd65434a63.webp&#34;
               width=&#34;760&#34;
               height=&#34;291&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为什么我们有两种类型的向量呢？如果要绘制图形，你需要一个即时向量，因为图形每个时间点只能显示一个值。然而，你很少想绘制随时间累积的事件总数。相反，你经常希望绘制随时间变化的事件速率，为此需要将统计函数应用于一系列数据，以计算每个时间点要显示的值。这就是范围向量的用途。&lt;/p&gt;
&lt;p&gt;让我们看一下如何开始构建一个查询，这也展示了查询中微小差异如何改变我们是在使用即时向量还是范围向量。&lt;/p&gt;
&lt;p&gt;如果我们将以下查询发送到 Prometheus，我们将获得以下即时向量。请注意，它只是上面表格中的最后一列数据。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http_requests_total
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_9b190f3cdc88ee540c93fa9d7ecbaaae.webp 400w,
               /blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_7d903ee81ea8c72e54590f190b0bced3.webp 760w,
               /blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/3_hu6e253b7687f059d1721aa606804eee54_71414_9b190f3cdc88ee540c93fa9d7ecbaaae.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此查询返回一个范围向量，显示每个系列的最后 5 分钟数据：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http_requests_total[5m]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_311a3f1b182fe78e60894b4824bc3513.webp 400w,
               /blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_e5c25a4f6b70a972452d3e4433e7dece.webp 760w,
               /blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/4_hu454bde1e9be2503834e3b32542f9979f_83728_311a3f1b182fe78e60894b4824bc3513.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些数据有什么用？这就引出了我们的下一个主题。&lt;/p&gt;
&lt;h2 id=&#34;为什么通常需要使用rate&#34;&gt;为什么通常需要使用&lt;code&gt;rate&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;我们之前提到，计数器会跟踪随时间累积的总数，但我们经常希望看到显示特定时间点上发生了多少事件的图形。这就是速率的用途。&lt;/p&gt;
&lt;p&gt;速率函数显示在一定时间范围内计算出的每秒平均事件数量。&lt;code&gt;一定时间范围&lt;/code&gt;就是范围向量的用途。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rate(http_requests_total[5m])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_953b1af5f57749b5f08f6f5532de1333.webp 400w,
               /blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_887a84c5b9bc1994a2fd6a19b176ce3f.webp 760w,
               /blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/5_huff48bf47c86c87c7ff01452797d30457_79928_953b1af5f57749b5f08f6f5532de1333.webp&#34;
               width=&#34;760&#34;
               height=&#34;408&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;这些数字看起来突然变得更加复杂，但第一个值只是表示在 5 分钟窗口内发生了一个事件：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_7317dd346eaa5f23a1ce65459122932c.webp 400w,
               /blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_c1a5a445cb8b5f84e609e27a68b1362f.webp 760w,
               /blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/6_hu198abe4e23d3d67954191585cabfde4b_30154_7317dd346eaa5f23a1ce65459122932c.webp&#34;
               width=&#34;760&#34;
               height=&#34;63&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;现在，如果我们将此查询绘制成图表而不是查看表格视图，图表上的每个点将是给定时间点每秒发生的请求数。这更接近我们实际关心的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rate&lt;/code&gt;函数还处理计数器重置。因此，如果你的服务崩溃，Prometheus 观察到计数器从 1000 变为 5，它将使用在这些抓取之间发生了 5 个事件的事实来计算速率。&lt;/p&gt;
&lt;h2 id=&#34;标签集和通常需要使用sum-by&#34;&gt;标签集和通常需要使用&lt;code&gt;sum by&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在继续构建我们的查询之前，重要的是花一点时间了解 Prometheus 标签。Prometheus 为每个唯一的标签值组合存储一个单独的时间序列。&lt;/p&gt;
&lt;p&gt;在我们的示例表中，我们有带有&lt;code&gt;path&lt;/code&gt;和&lt;code&gt;status&lt;/code&gt;标签的计数器&lt;code&gt;http_requests_total&lt;/code&gt;。对于每个&lt;code&gt;path&lt;/code&gt;和&lt;code&gt;status&lt;/code&gt;的组合，我们为每个时间戳存储一个计数器值。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_9ecc3da701c5f479524df74c951df26b.webp 400w,
               /blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_97ad599d75df916c8ba94bd767f399e0.webp 760w,
               /blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/7_huff140567d1675e9bb8ae4de74917817e_61794_9ecc3da701c5f479524df74c951df26b.webp&#34;
               width=&#34;760&#34;
               height=&#34;652&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;（这也是为什么人们经常谈论“标签基数问题”或&lt;a href=&#34;https://blog.cloudflare.com/how-cloudflare-runs-prometheus-at-scale/#metrics-cardinality&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“基数爆炸”&lt;/a&gt;。你对给定标签的每个新值都需要存储一个新的时间序列。如果存储的标签变化太大，例如用户 ID，你将创建过多的时间序列并导致 Prometheus 数据库膨胀。）&lt;/p&gt;
&lt;p&gt;在查询数据时，我们通常关心其中一些标签维度，而不关心其他标签。在 PromQL 中，&lt;code&gt;sum by (label1, label2，…)&lt;/code&gt;按你指定的标签对时间序列进行分组，并使用&lt;code&gt;sum&lt;/code&gt;函数将系列合并在一起（类似于 SQL 中的&lt;code&gt;GROUP BY&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;回到我们的示例表，我们只有两个标签：&lt;code&gt;path&lt;/code&gt;和&lt;code&gt;status&lt;/code&gt;。如果我们想查看每个&lt;code&gt;path&lt;/code&gt;的每秒请求数，而忽略&lt;code&gt;status&lt;/code&gt;，我们将使用以下查询：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum by (path) (rate(http_requests_total[5m]))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在实际的 Prometheus 部署中，我们通常有更多的标签。例如，Prometheus 会自动添加作业（job）和实例（instance）标签来标识它正在抓取的每个唯一目标。然而，我们可能不关心针对服务的每个实例单独查看指标，因此我们需要使用我们关心的标签进行求和，让 Prometheus 对其余部分进行求和。&lt;/p&gt;
&lt;p&gt;最后，这使我们回到了最初的查询。如果我们想查看返回不同 HTTP 状态代码的请求数，而与路径无关，我们可以使用此查询，并会看到以下结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sum by (status) (rate(http_requests_total[5m]))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_1f866cfab36e8d493da45d279314b379.webp 400w,
               /blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_c012d176bfc2c3239200e96b001257b5.webp 760w,
               /blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/why-are-prometheus-queries-hard/8_hu3408895e88969762328e60a39820c92c_42226_1f866cfab36e8d493da45d279314b379.webp&#34;
               width=&#34;760&#34;
               height=&#34;288&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sum by (labels) (rate(metric[5m]))&lt;/code&gt;这种构造方式非常有用，值得记住。&lt;/p&gt;
&lt;p&gt;不幸的是，除了与 PromQL 相关的特定问题之外，还有许多重要问题需要注意。&lt;/p&gt;
&lt;h2 id=&#34;我是否在查看正确的数据&#34;&gt;我是否在查看正确的数据？&lt;/h2&gt;
&lt;p&gt;工程师经常遇到的另外两个挑战与查询语言本身无关。&lt;/p&gt;
&lt;p&gt;首先，应该使用哪些指标来回答特定的问题？组织可能有数千个指标，如果没有经验，很难知道有哪些可用，并且哪些可能有助于调查特定类型的问题。预先构建的仪表板和查询可能会在一定程度上帮助，但许多组织也面临一个问题，即有太多的仪表板，人们不知道该看哪个。&lt;/p&gt;
&lt;p&gt;第二个甚至更为严重的问题是，你编写的查询是否显示了你认为它显示的内容。你可能会花费很多时间编写查询，并最终得到正确的语法。但它是否在统计上是正确的？从根本上说，Prometheus 不知道。这些时间序列只是一堆附带字符串标签的数字。Prometheus 不知道不同指标的含义，因此无法帮助你编写好的查询或告诉你所查看的图形是否回答了你的实际问题。这尤其危险，因为错误的查询可能会让你在调试事故时陷入无用的路径，或者可能会建议一种实际上无法解决问题的修复方法。&lt;/p&gt;
&lt;h2 id=&#34;结论promql-查询很难&#34;&gt;结论：PromQL 查询很难&lt;/h2&gt;
&lt;p&gt;编写好的查询需要对系统的了解，对查询语言语法的理解，甚至还需要一些统计知识。在本文中，我们只是浅尝辄止！所有这些都很难掌握，绝对不是你希望在服务崩溃并且用户在抱怨时学习的内容。在任何查询语言中编写查询都很困难，PromQL 也不例外。&lt;/p&gt;
&lt;h2 id=&#34;autometrics-为你编写-promql&#34;&gt;Autometrics 为你编写 PromQL&lt;/h2&gt;
&lt;p&gt;在 Fiberplane 为 DevOps 和站点可靠性工程师制作协作笔记本时，我们一直听到工程师说“查询很难”。这就是我们创建开源项目 Autometrics 的动机。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://autometrics.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Autometrics&lt;/a&gt;基于现有的 Prometheus 和 OpenTelemetry 客户端库，并使你的代码中的函数使用最有用的指标（请求速率、错误率和延迟）非常简单。它&lt;a href=&#34;https://fiberplane.com/blog/the-case-for-function-level-metrics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;标准化这些指标&lt;/a&gt;，然后根据函数详细信息为你构建强大的 PromQL 查询。这改进了对代码的仪表化体验，并极大地简化了在生产环境中识别和调试问题的过程。&lt;/p&gt;
&lt;p&gt;如果你正在使用 Prometheus，但不喜欢手动编写查询，请尝试将其添加到你的项目之一！它现在可用于 Rust、Go、Python、TypeScript 和 C#。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何利用 OpenTelemetry 监控和优化 Kubernetes 的性能</title>
      <link>https://lib.jimmysong.io/blog/how-opentelemetry-works-with-kubernetes/</link>
      <pubDate>Tue, 09 May 2023 16:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/how-opentelemetry-works-with-kubernetes/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要：本文译自 &lt;a href=&#34;https://thenewstack.io/how-opentelemetry-works-with-kubernetes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How OpenTelemetry Works with Kubernetes&lt;/a&gt;。本文介绍了如何将 OpenTelemetry 与 Kubernetes 配合使用。OpenTelemetry 可以作为 Prometheus 的替代品，也可以将数据导出到各种后端，包括 Prometheus。OpenTelemetry Operator 负责部署和管理 OpenTelemetry Collector，该组件是收集、处理和导出遥测数据的中央组件。OpenTelemetry 日志提供了一种标准化的方式来收集、处理和分析分布式系统中的日志。此外，本文还介绍了 OpenTelemetry 的下一步计划，包括 Web 服务器的自动化仪器化、OpenTelemetry Profile 和 Open Agent Management Protocol。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OpenTelemetry 的主要目标是提供一种标准的方式，使开发人员和最终用户能够从他们的应用程序和系统中创建、收集和导出遥测数据，并促进不同可观察性工具和平台之间的互操作性。&lt;/p&gt;
&lt;p&gt;OTEL 支持多种编程语言，包括 &lt;a href=&#34;https://thenewstack.io/getting-started-with-opentelemetry-for-java/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Java&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/an-introduction-to-python-a-language-for-the-ages/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/opentelemetry-in-go-its-all-about-context/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;/a&gt;、&lt;a href=&#34;https://thenewstack.io/why-were-sticking-with-ruby-on-rails-at-gitlab/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ruby&lt;/a&gt; 等，因此可以从不同类型的应用程序和系统中收集遥测数据，是一种多用途的解决方案。&lt;/p&gt;
&lt;p&gt;一旦 OpenTelemetry 组件收集到遥测数据，就可以将其导出到各种后端，如软件即服务解决方案、平台或存储系统，提供存储和查询功能。OpenTelemetry 提供与各种后端的集成，包括 &lt;a href=&#34;https://prometheus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Prometheus&lt;/a&gt;、Jaeger、&lt;a href=&#34;https://zipkin.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Zipkin&lt;/a&gt; 等，使导出遥测数据到不同系统变得更加容易。&lt;/p&gt;
&lt;p&gt;在 Kubernetes 中使用 OTEL 并不困难。实际上，安装 &lt;a href=&#34;https://thenewstack.io/kubernetes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes&lt;/a&gt; 的 OTEL Operator 是一个简单的过程，在本文中，您将学习如何执行此操作。&lt;/p&gt;
&lt;p&gt;通过此 Operator，您可以轻松地管理 Kubernetes 集群中的 OpenTelemetry 组件，并将其配置为导出遥测数据到您选择的后端。这简化了监视 Kubernetes 集群的过程，并使您能够对应用程序的健康和性能做出明智的决策。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的基本组件&#34;&gt;OpenTelemetry 的基本组件&lt;/h2&gt;
&lt;p&gt;前四个组件用于仪器开发人员或可观察性公司创建可观察性产品。&lt;/p&gt;
&lt;h3 id=&#34;规范&#34;&gt;规范&lt;/h3&gt;
&lt;p&gt;规范提供了定义这些组件的行为和功能的标准化方式，确保在不同的 OpenTelemetry 实现之间保持一致性和兼容性。例如，规范定义了跟踪和指标数据的格式和语义，确保它们可以被系统中的其他组件正确解释。&lt;/p&gt;
&lt;h3 id=&#34;api&#34;&gt;API&lt;/h3&gt;
&lt;p&gt;OpenTelemetry API 为开发人员提供了一种标准的方式来使用跟踪、指标和其他遥测数据对其应用程序进行仪器化。该 API 是语言不可知的，并允许在不同的编程语言和框架之间进行一致的仪器化。&lt;/p&gt;
&lt;p&gt;API 为开发人员提供了一种标准的方式来使用跟踪和指标对其应用程序进行仪器化。&lt;/p&gt;
&lt;h3 id=&#34;sdk&#34;&gt;SDK&lt;/h3&gt;
&lt;p&gt;OpenTelemetry SDK 提供了 OpenTelemetry API 的语言特定实现。SDK 通过提供用于收集和导出遥测数据的库和实用程序，使开发人员更轻松地对其应用程序进行仪器化。&lt;/p&gt;
&lt;h3 id=&#34;数据模型---otlp&#34;&gt;数据模型 - OTLP&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 数据模型提供了一种用于遥测数据的标准化格式，称为 OTLP（OpenTelemetry 协议）。OTLP 是一种供应商中立的格式，使将遥测数据导出到不同的后端和分析工具变得更加容易。&lt;/p&gt;
&lt;p&gt;最后两个组件，OpenTelemetry 自动仪器化和收集器，适用于希望从其应用程序收集和导出遥测数据到不同后端的开发人员，而无需编写自己的仪器化代码。&lt;/p&gt;
&lt;h3 id=&#34;自动仪器化&#34;&gt;自动仪器化&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 包括一个自动仪器化代理，可以注入具有跟踪和指标的应用程序，而无需任何手动仪器化代码。这使得可以向现有应用程序添加可观察性，而无需进行重大代码更改。&lt;/p&gt;
&lt;p&gt;自动仪器化组件可以下载并安装为库或代理，具体取决于使用的编程语言或框架。自动仪器化库会自动将应用程序代码注入 OpenTelemetry API 调用，以捕获和导出遥测数据。&lt;/p&gt;
&lt;h3 id=&#34;收集器&#34;&gt;收集器&lt;/h3&gt;
&lt;p&gt;收集器组件负责从不同来源（如应用程序、服务器和基础架构组件）收集遥测数据，并将其导出到各种后端。&lt;/p&gt;
&lt;p&gt;收集器可以下载并配置以从不同来源收集数据，并可以执行聚合、采样和其他操作，以在导出到不同后端之前对遥测数据执行处理，具体取决于特定用例。&lt;/p&gt;
&lt;h2 id=&#34;telemetry-数据是如何创建的&#34;&gt;Telemetry 数据是如何创建的&lt;/h2&gt;
&lt;p&gt;我们以一个包含三个工作负载的电子商务应用程序为例——前端、驱动程序和客户端——它们通过 HTTP 相互通信。我们想要收集遥测数据以监视这些应用程序的性能和健康状况。&lt;/p&gt;
&lt;p&gt;为此，我们使用 OpenTelemetry API 为每个应用程序实现仪表化：&lt;code&gt;logger.log()&lt;/code&gt;、&lt;code&gt;meter.record()&lt;/code&gt; 和 &lt;code&gt;tracer.span().start()&lt;/code&gt;。这些 API 允许我们创建遥测信号，例如日志、度量和跟踪。&lt;/p&gt;
&lt;p&gt;创建这些信号后，它们被发送或者由 OpenTelemetry 收集器收集，后者充当集中式数据中心。&lt;/p&gt;
&lt;p&gt;收集器负责处理这些信号，其中包括批处理、重新标记、PII 过滤、数据丢弃和聚合等任务，以确保数据准确和有意义。一旦收集器对数据满意，它就将遥测信号发送到平台进行存储和分析。&lt;/p&gt;
&lt;p&gt;收集器可以配置为将这些处理后的信号发送到各种平台，例如 Prometheus、&lt;a href=&#34;https://github.com/grafana/loki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Loki&lt;/a&gt;、Jaeger 或供应商，例如 &lt;a href=&#34;https://www.dynatrace.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynatrace&lt;/a&gt;、New Relic 等。&lt;/p&gt;
&lt;p&gt;例如，收集器可以将日志发送到类似 Loki 的日志聚合平台、将指标发送到类似 Prometheus 的监控平台、将跟踪发送到类似 Jaeger 的分布式跟踪平台。平台中存储的遥测数据可以用于深入了解系统的行为和性能，并识别需要解决的任何问题。&lt;/p&gt;
&lt;h2 id=&#34;定义-kubernetes-operator-的行为&#34;&gt;定义 Kubernetes Operator 的行为&lt;/h2&gt;
&lt;p&gt;您可以将 OpenTelemetry Operator 部署到 Kubernetes 集群中，并使其自动为应用程序仪表化和收集遥测数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/docs/k8s-operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Kubernetes Operator&lt;/a&gt; 提供了两个自定义资源定义（CRD），用于定义 Operator 的行为。这两个 CRD 共同允许您为应用程序定义 OpenTelemetry Operator 的完整行为。&lt;/p&gt;
&lt;p&gt;这两个 CRD 是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;otelinst&lt;/code&gt;&lt;/strong&gt; ：此 CRD 用于定义应用程序的仪表化。它指定要使用 OpenTelemetry API 的哪些组件、要收集哪些数据以及如何将该数据导出到后端。&lt;/p&gt;
&lt;p&gt;使用 otelinst CRD，您可以指定要仪表化的应用程序的名称、语言和运行时环境、跟踪的采样率以及要使用的导出器类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;otelcol&lt;/code&gt;&lt;/strong&gt;：此 CRD 用于定义 OpenTelemetry 收集器的行为。它指定收集器的配置，包括接收器（遥测数据源）、处理器（用于过滤和转换数据）和导出器（用于将数据发送到后端）。&lt;/p&gt;
&lt;p&gt;使用 otelcol CRD，您可以指定要用于通信的协议，例如 Google 远程过程调用（gRPC）或 HTTP，要使用哪些接收器和导出器，以及任何其他配置选项。&lt;/p&gt;
&lt;h2 id=&#34;安装-opentelemetry-kubernetes-operator&#34;&gt;安装 OpenTelemetry Kubernetes Operator&lt;/h2&gt;
&lt;p&gt;OpenTelemetry Kubernetes Operator 可以使用各种方法安装，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operator 生命周期管理器 (OLM)。这是&lt;a href=&#34;https://olm.operatorframework.io/docs/tasks/install-operator-with-olm/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;推荐的方法&lt;/a&gt;，因为它提供了方便的安装、升级和管理 Operator 的方法。&lt;/li&gt;
&lt;li&gt;Helm charts。Helm 是 Kubernetes 的软件包管理器，提供了一种在 Kubernetes 上部署和管理应用程序的简单方法。OpenTelemetry operator 的 Helm charts &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-helm-charts/tree/main/charts/opentelemetry-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可用&lt;/a&gt;，可用于部署 Operator。&lt;/li&gt;
&lt;li&gt;Kubernetes 清单。Operator 也可以使用 Kubernetes 清单进行安装，后者提供了一种声明性的方式来管理 Kubernetes 资源。Operator 清单可以根据特定要求进行定制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要收集遥测数据，我们需要使用创建遥测信号的代码仪表化我们的应用程序。有不同的方法来为遥测数据仪表化应用程序。&lt;/p&gt;
&lt;h3 id=&#34;显式手动方法&#34;&gt;显式/手动方法&lt;/h3&gt;
&lt;p&gt;在此方法中，开发人员明确向其应用程序添加仪表化代码，以创建日志、度量和跟踪等遥测信号。这种方法使开发人员对遥测数据更具控制力，但可能耗时且容易出错。&lt;/p&gt;
&lt;h3 id=&#34;直接集成在运行时&#34;&gt;直接集成在运行时&lt;/h3&gt;
&lt;p&gt;某些运行时，例如 &lt;a href=&#34;https://quarkus.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quarkus&lt;/a&gt; 和 &lt;a href=&#34;https://www.wildfly.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WildFly&lt;/a&gt; 框架，直接与 OpenTelemetry 集成。这意味着开发人员无需向其应用程序添加仪表化代码，运行时会自动为他们生成遥测数据。这种方法可能更易于使用，要求更少的维护工作，但比显式/手动方法灵活性可能较差。&lt;/p&gt;
&lt;p&gt;直接集成在运行时的主要缺点是，仪表化仅限于支持的框架。如果应用程序使用不受支持的框架，则可能无法有效捕获遥测数据或需要额外的自定义仪表化。&lt;/p&gt;
&lt;p&gt;如果所选运行时或框架仅与特定的可观察性供应商兼容，则此方法还可能导致供应商锁定。&lt;/p&gt;
&lt;p&gt;因此，此方法可能不适用于所有应用程序或组织，特别是如果他们需要在选择可观察性堆栈或需要仪器化各种框架和库时具有灵活性。&lt;/p&gt;
&lt;h3 id=&#34;自动仪表化代理方法&#34;&gt;自动仪表化/代理方法&lt;/h3&gt;
&lt;p&gt;在此方法中，向应用程序运行时添加 OpenTelemetry 代理或自动仪表化库。代理/库自动为应用程序代码创建仪表化并生成遥测数据，而无需开发人员添加仪表化代码。&lt;/p&gt;
&lt;p&gt;这种方法可能是最易于使用的，需要最少的维护工作，但可能不太灵活，并且可能无法捕获所有相关的遥测数据。&lt;/p&gt;
&lt;p&gt;虽然自动仪表化/代理方法具有许多优点，但主要缺点之一是它可能消耗更多的内存和 CPU 周期，因为它支持广泛的框架并为应用程序中几乎所有 API 进行仪表化。这种附加开销可能会影响应用程序的性能，尤其是如果应用程序已经消耗了资源。&lt;/p&gt;
&lt;p&gt;此外，此方法可能无法捕获所有必要的遥测数据，或可能会导致错误的正面或负面结果。例如，它可能无法捕获某些边缘情况，或者可能捕获过多的数据，使查找相关信息变得困难。&lt;/p&gt;
&lt;p&gt;但是，尽管存在这些缺点，自动仪表化/代理方法仍然强烈推荐给刚开始使用观察性的组织，因为它提供了一种快速且简单的方法来快速收集遥测数据。&lt;/p&gt;
&lt;h2 id=&#34;传送遥测数据的收集和导出&#34;&gt;传送遥测数据的收集和导出&lt;/h2&gt;
&lt;p&gt;收集器负责接收来自仪器代码的遥测数据，处理并将其导出到平台进行存储和分析。收集器可以配置各种组件，例如接收器、处理器和导出器，以满足特定需求。&lt;/p&gt;
&lt;p&gt;接收器负责从各种来源（例如代理、导出器或网络）接受数据，而处理器则可以转换、过滤或增强数据。最后，导出器将数据发送到存储或分析平台，例如 Prometheus 或 Jaeger。&lt;/p&gt;
&lt;p&gt;收集器有两个版本，Core 和 Contrib。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Core&lt;/a&gt; 是官方版本，包含稳定和经过充分测试的组件，而 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-contrib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Contrib&lt;/a&gt; 是社区驱动版本，包含额外的实验性&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol-contrib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;组件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;您还可以通过选择所需的组件并根据您的要求进行配置来构建自己的收集器。收集器用 Go 编写，这使得它易于部署和维护。&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry 网站上的文档&lt;/a&gt;提供了详细的指南，介绍如何设置、配置和使用收集器。&lt;/p&gt;
&lt;p&gt;在某些情况下，OpenTelemetry 可以作为 Prometheus 的替代品，特别是在边缘设备上资源有限的情况下。Prometheus 更加专注于监控和警报，而 OpenTelemetry 则专为可观察性而设计，并提供超出指标以外的功能，包括跟踪和日志记录。&lt;/p&gt;
&lt;p&gt;此外，OpenTelemetry 可以用于将数据导出到各种后端，包括 Prometheus，因此如果您愿意，仍然可以使用 Prometheus 进行监控和警报。OpenTelemetry 的灵活性和可扩展性使您可以将可观察性解决方案定制为符合您的特定需求和资源限制。&lt;/p&gt;
&lt;p&gt;OpenTelemetry Operator 负责部署和管理 OpenTelemetry Collector，该组件是收集、处理和导出遥测数据的中央组件。它不部署其他边车，例如 Envoy，但可以与它们一起工作以收集额外的遥测数据。&lt;/p&gt;
&lt;p&gt;OpenTelemetry Collector 可以以不同的模式部署，例如边车、daemonset、deployment 或 statefulset，具体取决于特定用例和要求。&lt;/p&gt;
&lt;p&gt;但是，如果目标是从群集中的节点收集日志，则将收集器部署为 daemonset 可以是一个不错的选择，因为它确保在每个节点上运行一个收集器实例，从而实现高效且可靠的日志收集。&lt;/p&gt;
&lt;h3 id=&#34;otel-收集器配置&#34;&gt;OTEL 收集器配置&lt;/h3&gt;
&lt;p&gt;以下是使用 otelcol 自定义资源定义部署 OpenTelemetry 收集器的 Kubernetes 清单文件示例：&lt;/p&gt;
&lt;p&gt;在此示例中，我们定义了一个名为 &lt;code&gt;otel-collector&lt;/code&gt; 的收集器，它使用 OTLP 接收器接收跟踪数据，使用 Prometheus 导出器将指标导出到 Prometheus 服务器，并使用两个处理器（&lt;code&gt;batch&lt;/code&gt; 和 &lt;code&gt;queued_retry&lt;/code&gt;）处理数据。config 字段指定收集器的配置，其格式为 YAML。&lt;/p&gt;
&lt;p&gt;使用 OpenTelemetry 收集跟踪、指标和日志在几个方面都很重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;增加可观察性。&lt;/strong&gt; 通过收集和关联跟踪、指标和日志，您可以更好地了解应用程序和系统的性能。增强的可观察性使您能够在影响用户之前快速识别和解决问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;改进故障排除。&lt;/strong&gt; OpenTelemetry 提供了一种收集遥测数据的标准化方式，这使得在整个堆栈中进行故障排除变得更加容易。通过在单个位置访问所有相关遥测数据，您可以快速找到问题的根本原因。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的性能优化。&lt;/strong&gt; 有了详细的遥测数据，您可以做出有关如何优化应用程序和系统以实现更好的性能和可靠性的明智决策。例如，通过分析指标，您可以确定系统中未利用或过度利用的区域，并相应地调整资源分配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨平台兼容性。&lt;/strong&gt; OpenTelemetry 设计用于跨多种编程语言、框架和平台工作，这使得从堆栈的不同部分收集遥测数据变得更加容易。这种互操作性对于使用多种技术并需要在整个堆栈中标准化可观察性实践的组织非常重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opentelemetry-日志&#34;&gt;OpenTelemetry 日志&lt;/h3&gt;
&lt;p&gt;OpenTelemetry 日志提供了一种标准化的方式来收集、处理和分析分布式系统中的日志。通过使用 OpenTelemetry 收集日志，开发人员可以避免日志分布在多个系统和不同格式的问题，从而难以分析和排除问题。&lt;/p&gt;
&lt;p&gt;使用 OpenTelemetry 日志，开发人员可以从多个来源收集日志，包括传统的日志库，然后使用通用格式和 API 处理和分析它们。这允许更好地与可观察性堆栈的其他部分（例如指标和跟踪）集成，并提供更完整的系统行为视图。&lt;/p&gt;
&lt;p&gt;此外，OpenTelemetry 日志提供了一种将日志与其他上下文信息（例如有关请求、用户或环境的元数据）进行丰富的方法，这些信息可以用于使日志分析更有意义和有效。&lt;/p&gt;
&lt;h2 id=&#34;opentelemetry-的下一步是什么&#34;&gt;OpenTelemetry 的下一步是什么？&lt;/h2&gt;
&lt;h3 id=&#34;web-服务器的自动化仪器化&#34;&gt;Web 服务器的自动化仪器化&lt;/h3&gt;
&lt;p&gt;OTEL &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-cpp-contrib/tree/main/instrumentation/otel-webserver-module#otel-webserver-module&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;webserver&lt;/a&gt; 模块包括 Apache 和 &lt;a href=&#34;https://www.nginx.com/?utm_content=inline-mention&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nginx&lt;/a&gt; 仪器化。Apache 模块负责在运行时将仪器化注入到 Apache 服务器中，以跟踪传入请求到服务器。它捕获参与传入请求的许多模块的响应时间，包括 mod_proxy。这使得可以捕获每个模块的分层时间消耗。&lt;/p&gt;
&lt;p&gt;类似地，Nginx web 服务器模块也可以通过在运行时将仪器化注入到 Nginx 服务器中来跟踪传入请求到服务器。它捕获涉及请求处理的各个模块的响应时间。&lt;/p&gt;
&lt;h3 id=&#34;opentelemetry-profile&#34;&gt;OpenTelemetry Profile&lt;/h3&gt;
&lt;p&gt;此 &lt;a href=&#34;https://github.com/open-telemetry/oteps/blob/main/text/profiles/0212-profiling-vision.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;文档&lt;/a&gt; 概述了 OpenTelemetry 项目中的分析支持的长期愿景。该计划是 OpenTelemetry 社区成员之间的讨论和协作的结果，代表了各种行业和专业知识的多元化。&lt;/p&gt;
&lt;p&gt;该文档旨在指导 OpenTelemetry 中的分析支持开发，但并非要求清单。预计随着学习和反馈的增加，该愿景将随时间演化和完善。&lt;/p&gt;
&lt;h3 id=&#34;open-agent-management-protocol&#34;&gt;Open Agent Management Protocol&lt;/h3&gt;
&lt;p&gt;Open Agent Management Protocol (OpAMP) 是一种网络协议，可实现对大型数据收集代理群集的远程管理。它允许代理报告其状态并从服务器接收配置，并从服务器接收代理安装包更新。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/open-telemetry/opamp-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpAMP&lt;/a&gt; 是供应商无关的，因此服务器可以远程监视和管理实现 OpAMP 的不同供应商的代理群集，包括来自不同供应商的混合代理群集。&lt;/p&gt;
&lt;p&gt;它支持代理的远程配置、状态报告、代理自身的遥测报告、可下载特定于代理的软件包的管理、安全自动更新功能和连接凭据管理。此功能允许管理大型混合代理群集的单个窗口视图。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>以图形重构 Kubernetes 可观测性</title>
      <link>https://lib.jimmysong.io/blog/reframing-kubernetes-observability-with-a-graph/</link>
      <pubDate>Sat, 06 May 2023 06:27:22 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/reframing-kubernetes-observability-with-a-graph/</guid>
      <description>&lt;p&gt;本文译自 &lt;a href=&#34;https://thenewstack.io/reframing-kubernetes-observability-with-a-graph/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reframing Kubernetes Observability with a Graph&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;摘要：本文介绍了将 DevOps 和 Kubernetes 视为图形的方法，以提高效率和弹性。通过将 Kubernetes 部署中的不同组件建模为图中的节点，组织可以更好地了解不同组件的交互方式以及一个区域的更改如何影响整个系统。这可以帮助组织采取更为主动、战略性的 DevOps 方法，而不仅仅是在问题出现时做出反应。&lt;/p&gt;
&lt;p&gt;Kubernetes 可以跨多个主机部署应用程序，同时让团队将它们作为单个逻辑单元进行管理。它抽象了底层基础架构，并提供了一个用于与集群交互的统一 API，以及用于简化工作流程的自动化。它是现代开发实践的完美系统。&lt;/p&gt;
&lt;p&gt;但在这些以云为先的生态系统中确保效率和弹性并不容易。微服务架构使得无法跟上正在不断发生的所有软件和基础架构变化。这个问题只会因分裂的监视和可观测工具以及团队和个人之间的隔离信息而变得更加严重。&lt;/p&gt;
&lt;p&gt;为了跟上，组织必须以一种新的方式考虑 DevOps 和 Kubernetes - 作为一个图形。&lt;/p&gt;
&lt;h2 id=&#34;将-devops-视为图形&#34;&gt;将 DevOps 视为图形&lt;/h2&gt;
&lt;p&gt;DevOps 通常专注于自动化和集成，而不考虑底层工具和流程之间的关系和依赖关系。另一方面，将 &lt;a href=&#34;https://thenewstack.io/devops-as-a-graph-for-real-time-troubleshooting/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DevOps 视为图形&lt;/a&gt; 更加注重这些连接，以提供更好的上下文，从而导致更有效的操作。传统的 DevOps 方法通常依赖于线性、顺序工作流，而将 DevOps 视为图形有助于组织采用更全面、基于系统的方法。&lt;/p&gt;
&lt;p&gt;通过将 DevOps 流水线的不同组件建模为图中的节点，组织可以更好地了解不同组件的交互方式以及一个区域的更改如何影响整个系统。这可以帮助组织采取更为主动、战略性的 DevOps 方法，而不仅仅是在问题出现时做出反应。&lt;/p&gt;
&lt;p&gt;以这种方式考虑 DevOps 需要从以工具为中心的方法转向更为系统化的方法，需要思维方式和实践方法上的转变。&lt;/p&gt;
&lt;p&gt;这并不容易，但最终使团队和组织更加数据驱动和主动。&lt;/p&gt;
&lt;h2 id=&#34;图形和-kubernetes&#34;&gt;图形和 Kubernetes&lt;/h2&gt;
&lt;p&gt;在基于 Kubernetes 的 DevOps 流水线中，可以使用基于图形的方法对许多组件进行建模和分析。例如，Kubernetes 集群中不同容器、服务和 Pod 之间的关系可以表示为图中的节点，它们之间的交互可以表示为边。通过分析这个图，组织可以获得有关其基于 Kubernetes 的 DevOps 流水线性能的见解，包括识别瓶颈、故障排除和优化工作流程。&lt;/p&gt;
&lt;p&gt;更具体地说，应用于 Kubernetes 部署的图形方法允许：&lt;/p&gt;
&lt;h3 id=&#34;知识捕获和保留&#34;&gt;知识捕获和保留&lt;/h3&gt;
&lt;p&gt;通过将 Kubernetes 部署中的不同组件可视化为图形，组织可以更好地了解不同组件的交互方式，以及一个区域的更改如何影响其他区域。例如，它可以显示特定服务是否被其他组件广泛依赖。或者在处理像 Amazon 关系型数据库服务 (RDS) 或 DynamoDB 这样的外部资源时，组织可以注意到哪个 Pod 依赖于哪个数据库，以获得清晰的依赖关系和风险。&lt;/p&gt;
&lt;p&gt;以下是实际实现的方法：&lt;/p&gt;
&lt;p&gt;在 DevOps 可观测性平台中，我们为 Kubernetes/Amazon Elastic Kubernetes Service (EKS) 设置了一个场景。场景提供了 Kubernetes 架构的拓扑视图。在这种情况下，我们创建了一个简单的 Kubernetes 基础设施图，它可以自动发现和可视化所有 Kubernetes 依赖项，以帮助跟踪更改。依赖关系图包括来自群集和服务到 Pod、容器和进程的资源。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_40d50b4f7acd52b20d96cfc351d47962.webp 400w,
               /blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_fa9456b2c88229f8671c519d82343377.webp 760w,
               /blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/reframing-kubernetes-observability-with-a-graph/1_hud4fd5d2f2c8ff51a72f1cfeb695c169e_110356_40d50b4f7acd52b20d96cfc351d47962.webp&#34;
               width=&#34;760&#34;
               height=&#34;400&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;场景可以包括度量指标，允许用户学习 Pod、节点和命名空间之间的关系以及与它们相关的指标。如果所选实体有任何关联的指标，那么它们将出现在上下文菜单中的指标选项卡下。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_b188cad8e6008c1d32a0059332f5147a.webp 400w,
               /blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_b2874328a7aa02098ba224db6aab0ca4.webp 760w,
               /blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/reframing-kubernetes-observability-with-a-graph/2_hu74f26c63bbb1f1a138aa8b4a266f2b77_13001_b188cad8e6008c1d32a0059332f5147a.webp&#34;
               width=&#34;478&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;单击列出的任何指标将生成一个图表窗口。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_f6d34faf5e73a9a77ad1faf5ac66e858.webp 400w,
               /blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_6fbc696620a96ded0c4d858a1d2184b1.webp 760w,
               /blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/reframing-kubernetes-observability-with-a-graph/3_huc18582dc0df7975eb6c705f10792d8e8_37095_f6d34faf5e73a9a77ad1faf5ac66e858.webp&#34;
               width=&#34;760&#34;
               height=&#34;509&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;然后，您可以将图表添加到仪表板中，以帮助确定问题并建立问题的根本原因。&lt;/p&gt;
&lt;h3 id=&#34;优化和故障排除&#34;&gt;优化和故障排除&lt;/h3&gt;
&lt;p&gt;通过分析 Kubernetes 部署的图形，组织还可以识别瓶颈并优化工作流程的流程。如果基于图形的分析显示特定的 Pod 经常导致超时或错误，组织可以调查原因并采取措施予以纠正。更好的是，团队可以看到与异常行为相关的相关更改的时间轴，并实时揭示根本原因。曾经故障排除需要太长时间，因为团队未能意识到其环境中所有持续变化，现在他们可以在共享的、上下文驱动的空间中连接因果关系。&lt;/p&gt;
&lt;h3 id=&#34;资源分配&#34;&gt;资源分配&lt;/h3&gt;
&lt;p&gt;优化资源分配也变得更简单。通过分析组件和需求之间的关系，组织可以识别优化资源使用和降低成本的机会。例如，基于图形的分析可能显示特定的 Pod 进行了过度配置，需要缩减规模，而如果没有它，可能很难确定部署的哪个离散方面是问题。&lt;/p&gt;
&lt;h2 id=&#34;更好的-devops&#34;&gt;更好的 DevOps&lt;/h2&gt;
&lt;p&gt;最终，将 DevOps 视为图形具有不可否认的好处。通过关系和工作流程映射，它提供了对复杂系统更好、更细粒度的了解。它提高了离散组件的可视化，以便快速识别和解决整个环境中的问题。&lt;/p&gt;
&lt;p&gt;决策可以通过从图中揭示的模式和关系获得数据驱动的洞见来得到加强。简单地说，这是增加效率并持续改进 DevOps 过程的最佳方法，即使在处理 Kubernetes 和其他以云为先的技术的复杂性时也是如此。&lt;/p&gt;
&lt;p&gt;要达到这种运营效率水平，DevOps 团队需要使用提供统一的或易于连接的更改时间轴的依赖图的工具。团队必须全面查看部署中所有不同的组件，同时能够注意到它们所有的关系和依赖关系。&lt;/p&gt;
&lt;p&gt;由于云为先的体系结构（如 Kubernetes）存在的知识差距和复杂性问题，这不能通过手动或逐案例完成。只有现代的变更智能工具，可以在生成实时、准确的拓扑视图的同时，通过相关指标添加上下文，才能有效地实现这一点。&lt;/p&gt;
&lt;p&gt;想象一下团队通过不必手动构建、维护和管理图形，就能节省多少时间和头痛。幸运的是，您不必想象太久。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何降低可观测性带来的认知负荷</title>
      <link>https://lib.jimmysong.io/blog/reducing-the-cognitive-load-associated-with-observability/</link>
      <pubDate>Thu, 13 Apr 2023 17:32:17 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/reducing-the-cognitive-load-associated-with-observability/</guid>
      <description>&lt;p&gt;本文译自：&lt;a href=&#34;https://thenewstack.io/reducing-the-cognitive-load-associated-with-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reducing the Cognitive Load Associated with Observability - The New Stack&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：本文讨论了降低可观测性对认知负荷的影响。在处理大量数据时，我们需要过滤和转换数据点以生成适当的信号，并依赖警报系统来进行人类干预。游戏日是测试响应能力的好机会。在团队中培养协作文化对每个人的福祉至关重要。通过实施这些策略，软件工程团队可以确保他们具备使用和有效理解可观测性信号所需的知识和技能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;你能想象在没有现代可观测工具的情况下开发或操作分布式系统吗？我们知道可观测性是一项关键的实践，可以让我们提高系统的可靠性，减少服务停机时间，可视化使用模式，提供性能见解并促进问题解决。&lt;/p&gt;
&lt;p&gt;随着过去十年微服务架构和全球“shift left”的意图的广泛采用，工程师的角色——从开发人员和运维人员到 DevOps、站点可靠性工程和平台工程——发生了巨大变化。许多人被赋予更多的责任，并增加了工作量。&lt;/p&gt;
&lt;div class=&#34;alert-note-title&#34;&gt;
    &lt;p&gt;什么是 Shift left？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
    &lt;p&gt;&amp;ldquo;Shift left&amp;rdquo; 是一种软件开发术语，它指的是在开发生命周期的早期阶段引入测试和安全性措施，以便更早地发现和修复潜在问题，从而减少开发成本和增强产品质量。&lt;/p&gt;
&lt;p&gt;传统的软件开发过程中，测试和安全性通常是在开发周期的后期才被考虑，这意味着潜在的问题可能已经存在于系统中并且需要更多时间和成本来修复。而“Shift left”意味着在开发过程的早期引入这些步骤，以便更快地发现并解决潜在的问题。&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;作为软件工程组织，我们的工作是构建满足特定业务需求的高质量系统。为了实现这一目标，我们已经对我们的应用程序进行了仪器化，设置了分布式跟踪以及集中式日志收集，并不断监视延迟、错误率和吞吐量，并在此之上设置了警报。现在呢？我们可以依赖我们组织中的一个英雄专家来处理警报，诊断系统故障并防止停机。或者我们可以将这种知识传播给所有工程师并分享工作负载。&lt;/p&gt;
&lt;p&gt;要求每个人都能熟练掌握现有的工具和理解生成的大量数据不可避免地会导致焦虑、沮丧和疲劳。我们能否以某种方式降低与可观测性相关的认知负荷？&lt;/p&gt;
&lt;h2 id=&#34;理解可观测性数据&#34;&gt;理解可观测性数据&lt;/h2&gt;
&lt;p&gt;可观测性有一些硬技能。工程师需要接受训练以解密基本数据类型。希望工具能在这项任务中协助人类。难怪我们看到了大量的供应商工具涌现，旨在提供最佳的解释和可视化分布式跟踪、指标和日志体验。这是一项复杂的任务！分布式跟踪只是一大块链接时间戳和元数据；指标可以是测量仪、计数器或直方图；日志语句可以根据受众和使用者而是结构化或非结构化的。即使是最常见的日志语句在没有受过培训的人的眼中也可能看起来很陌生。只要问问 Java 开发人员如何解开 Python 堆栈跟踪！&lt;/p&gt;
&lt;p&gt;然后我们面临“太多数据”的问题。我们依赖工具来在大海捞针并过滤噪声，并使其清晰明了，即在任何时候，收集但未在任何可视化中公开或由任何警报使用的信号都是删除的候选信号。&lt;/p&gt;
&lt;h3 id=&#34;信号在大海中找到触发事件的针头&#34;&gt;信号：在大海中找到触发事件的针头&lt;/h3&gt;
&lt;p&gt;需要过滤和转换数据点才能生成适当的信号。没有人想每天 24x7 小时盯着仪表板或日志，因此我们依赖警报系统。当警报触发时，它旨在进行人类干预，这意味着将原始信号转换为带有上下文数据的可操作事件：警报的重要性、环境、描述、注释、链接等。必须提供足够的信息来引起对问题的关注，但不要提供太多的信息以避免被淹没在噪音中。&lt;/p&gt;
&lt;p&gt;页面警报需要人工响应。否则，工程师如何证明他们已经中断了他们的流程？&lt;/p&gt;
&lt;p&gt;当警报触发时，分析开始了。虽然我们热切地希望通过人工智能的出现实现异常检测和自动化分析，从而完全消除人为因素，但我们可以使用一些技巧来帮助我们的大脑快速识别问题所在。&lt;/p&gt;
&lt;h3 id=&#34;可视化不要低估平台---人类交互的价值&#34;&gt;可视化：不要低估平台 - 人类交互的价值&lt;/h3&gt;
&lt;p&gt;需要警报信号触发的阈值。在可视化方面，调查和检测异常的人员也需要考虑这些阈值。这个数据值是否过低或者出乎意料地高呢？&lt;/p&gt;
&lt;p&gt;在这个非常普遍的图表中，图表标题、轴标签和描述被故意删除了。我们缺乏上下文，但我们的大脑可以立即发现异常。导致图表的警报应该始终包含一个视觉指示器。它们对于突出趋势和异常模式是至关重要的，即使对于未受过训练的人。&lt;/p&gt;
&lt;h2 id=&#34;积极学习避免英雄文化训练你的团队&#34;&gt;积极学习：避免英雄文化；训练你的团队&lt;/h2&gt;
&lt;p&gt;在出问题时，你的团队中的谁是事实上的第一响应者和可观测性专家，当事情变得不好时会挺身而出呢？也许是你。要求他退缩，尽管越来越渴望恢复服务的正常运行时间并挽救局面。问问自己这些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最坏的情况是什么？&lt;/li&gt;
&lt;li&gt;是否会有其他人挺身而出？&lt;/li&gt;
&lt;li&gt;这对团队中其他人来说是个学习机会吗？&lt;/li&gt;
&lt;li&gt;这是一个教学机会吗？在这种情况下，跟随经验丰富的团队成员的阴影工作是否可行？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让其他人变得擅长工作。调整期望并给自己和团队调查的空间是减轻压力和应对紧急情况的关键。在控制的无压力环境中实时响应真实事件和生产系统中的数据是最终的训练。这就是为什么我们有 Game Days。&lt;/p&gt;
&lt;h3 id=&#34;game-days&#34;&gt;Game Days&lt;/h3&gt;
&lt;p&gt;游戏日是消防演习。我们需要接受故障和故障将发生的事实。游戏日的目标是通过提前练习我们的响应能力来减少实际事件的压力。我们希望在危机时能够快速自信地行动，并建立一些直觉和反应能力，这些能力在凌晨 4 点非常有用。练习使人完美！&lt;/p&gt;
&lt;p&gt;首先选择一个游戏大师和必要的同谋。通常，这些是域或系统的主题专家。他们需要仔细选择在游戏日活动期间将接受测试的系统和场景。以下情况非常普遍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重播以前的事件场景。这会测试事件响应过程是否得到改进，人们是否知道要关注哪些可观测性信号并了解如何相关数据点。这也是测试后期学习和纠正行动后系统更具弹性的好机会。&lt;/li&gt;
&lt;li&gt;确保一个新的系统或服务在进入生产之前具有正确的监控、警报和度量衡。这会测试您是否准备好操作系统，以及人们是否知道如何发现可观测性数据并知道如何响应警报。&lt;/li&gt;
&lt;li&gt;校准安全、优雅降级、高可用系统等方面的过度自信偏见。这会测试您是否实际了解系统的故障模式，以及工程师是否有能力诊断未知问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后要求游戏大师提出一组假设并预测演习的预期收益。评估演习对业务的影响（爆炸半径），并确定如果/需要采取的步骤以将其最小化（例如，通过将演习限制在时间框中，如果发生意外情况则中止它等）。&lt;/p&gt;
&lt;p&gt;然后开始游戏！故意破坏并引入一些混乱。我们希望人们在处理事件时依靠理性、专注和深思熟虑的认知功能。压力和恐惧会影响认知功能和决策能力。&lt;/p&gt;
&lt;p&gt;观察人类互动在这个解决问题的练习中如何发挥作用。这个练习是否促进了协作文化？团队成员是否互相支持？&lt;/p&gt;
&lt;h2 id=&#34;协作文化不再保留数据&#34;&gt;协作文化：不再保留数据&lt;/h2&gt;
&lt;p&gt;在团队中培养协作文化对每个人的福祉至关重要。分享数据、见解和问题将从团队成员中获得更多的参与、好奇心和信任。信息应该被共享，应避免保密。这些是简单的原则，但很少有组织符合这个标准，当从事事故学习时。透明的后期检查可以推动有意义的变革，我们应该庆祝失败！指责和指责的文化只会加速焦虑和意外的恶性循环。&lt;/p&gt;
&lt;p&gt;每个事件响应过程都应包括事后检查。有效的无指责事后检查将确保团队成员有权提出对过程、工具或系统的更改。这项活动通过纠正措施和质量改进使人们有能力做出改变。后期检查还应受益于组织中可能没有直接涉及领先事件的其他成员，因为书面记录应该广泛共享并作为学习材料。&lt;/p&gt;
&lt;h2 id=&#34;在值班时&#34;&gt;在值班时&lt;/h2&gt;
&lt;p&gt;工程师有能力理解可观测性数据。在团队的每个成员都积极学习如何应对游戏日事故的情况下，分享整个工程组织的值班任务非常重要，而不是只由少数精选人员负责。这也有助于减轻可能随时到来的重负和压力。当值班时，不应让任何一名工程师独自面对。角色和升级路径需要明确定义和理解。从第一响应者（911 调度员）到事故指挥官（专业人士）和升级经理（通常是负责沟通的工程经理），都不应要求他们成为英雄，而应要求他们协调和组装最适合解决问题的团队。&lt;/p&gt;
&lt;p&gt;在值班时，检查清单可以被称为“运行簿”或其他名称。这些清单可以作为认知援助，卸载完成复杂教学任务的思维过程。游戏日是测试这些清单的完美场所。&lt;/p&gt;
&lt;p&gt;因为我们已经通过消除信号噪声来确保减少虚假警报，并且每个人都了解自己在值班轮换中的角色，所以警报疲劳应该成为过去式。&lt;/p&gt;
&lt;h2 id=&#34;人仍然是分布式系统的核心&#34;&gt;人仍然是分布式系统的核心&lt;/h2&gt;
&lt;p&gt;通过实施这些策略，软件工程团队可以确保他们具备使用和有效理解可观测性信号所需的知识和技能。充分利用收集的数据对于提高分布式系统的整体性能和可靠性至关重要。教学和学习将使人因素超越单个个体。虽然我们仍然必须依靠人类大脑来诊断和解决问题，但让我们确保我们可以可持续地这样做。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 eBPF 准确定位服务网格的关键性能问题</title>
      <link>https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</link>
      <pubDate>Tue, 05 Jul 2022 17:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/</guid>
      <description>&lt;h2 id=&#34;background&#34;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;Apache SkyWalking 观察部署在服务网格中的服务的度量、日志、追踪和事件。在进行故障排除时，SkyWalking 错误分析是一个宝贵的工具，可以帮助确定错误发生的位置。然而，确定性能问题更加困难：利用预先存在的观察数据往往不可能找到性能问题的根本原因。为此，动态调试和故障排除在进行服务性能剖析时就必不可少。在这篇文章中，我们将讨论如何使用 eBPF 技术来改进 SkyWalking 中的剖析功能，并用于分析服务网格中的性能影响。&lt;/p&gt;
&lt;h2 id=&#34;trace-profiling-in-skywalking&#34;&gt;SkyWalking 中的追踪剖析&lt;/h2&gt;
&lt;p&gt;自 SkyWalking 7.0.0 以来，Trace Profiling 通过定期对线程堆栈进行采样，让开发者知道运行哪行代码花费更多时间，从而帮助开发者发现性能问题。然而，Trace Profiling 不适合以下情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程模型&lt;/strong&gt;：Trace Profiling 对于剖析在单线程中执行的代码最有用。它对严重依赖异步执行模式的中间件不太有用。例如，Go 中的 Goroutines 或 Kotlin Coroutines。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语言&lt;/strong&gt;：目前，Trace Profiling 只支持 Java 和 Python，因为在 Go 和 Node.js 等一些语言的运行时中不容易获得线程栈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Agent 绑定&lt;/strong&gt;：Trace Profiling 需要安装 Agent，根据语言的不同，这可能很麻烦（例如，PHP 必须依赖其 C 内核；Rust 和 C/C++ 需要的仪器需要手动安装）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联性&lt;/strong&gt;：由于追踪剖析只与单个请求相关，所以当无法确认哪个请求产生问题时则变得难已处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期短的服务&lt;/strong&gt;：由于（至少）两个原因，Trace Profiling 不支持短声明周期的服务：
&lt;ul&gt;
&lt;li&gt;在启动阶段，很难区分系统性能和类代码操作。&lt;/li&gt;
&lt;li&gt;Trace Profiling 与一个端点相连，以识别性能影响，但没有端点来匹配这些短生命周期的服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，有一些技术比 Trace Profiling 更实用。&lt;/p&gt;
&lt;h2 id=&#34;introduce-ebpf&#34;&gt;eBPF 简介&lt;/h2&gt;
&lt;p&gt;我们发现，eBPF —— 一种可以在操作系统内核中运行沙盒程序的技术，从而安全有效地扩展内核的功能，而不需要修改内核或加载内核模块，可以帮助我们填补 Trace Profiling 留下的空白。eBPF 技术正在流行，因为它打破了传统上的用户和内核空间之间的障碍。现在我们可以将程序作为字节码注入到内核中运行，而不需要定制和重新编译内核。可观测可以很好地利用这一点。&lt;/p&gt;
&lt;p&gt;在下图中，我们可以看到，当系统执行 &lt;code&gt;execve&lt;/code&gt; 系统调用时，eBPF 程序被触发，通过使用函数调用获得当前进程的运行时信息。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-ebpf-程序调用流程图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;eBPF 程序调用流程图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_501ba58999de3fea0b73da4d1a5134c6.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/eBPF-hook-points_hu045d3eb9c20514286c2b99759556b302_48258_31dd29f7e8dc45b4aa8c3e9978c15fd3.webp&#34;
               width=&#34;760&#34;
               height=&#34;578&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      eBPF 程序调用流程图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;使用 eBPF 技术，可以将 SkyWalking 的剖析能力范围扩大到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局性能剖析&lt;/strong&gt;：在 eBPF 之前，数据收集被限制在代理可以观察的范围内。由于 eBPF 程序在内核中运行，它们可以观察到所有的线程。当你不确定某个性能问题是否是由一个特定的请求引起的，这一点特别有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据内容&lt;/strong&gt;：eBPF 可以转储用户和内核空间的线程栈，所以如果性能问题发生在内核空间就更容易被发现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理绑定&lt;/strong&gt;：所有现代 Linux 内核都支持 eBPF，所以不需要安装任何东西。这意味着它是一个免编排与代理的模型。这减少了由内置软件引起的摩擦，这些软件可能没有安装正确的代理，如服务网格中的 Envoy。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采样类型&lt;/strong&gt;：与追踪剖析不同，eBPF 是事件驱动的，因此，不受间隔轮询的限制。例如，eBPF 可以触发事件，并根据传输大小的阈值收集更多的数据。这可以让系统在极端负载下分流和优先收集数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ebpf-limitations&#34;&gt;eBPF 的局限性&lt;/h3&gt;
&lt;p&gt;虽然 eBPF 为发掘性能瓶颈提供了显著的优势，但没有任何技术是完美的。eBPF 有一些限制，如下所述（幸运的是，由于 SkyWalking 不依赖 eBPF，其影响是有限的）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linux 版本要求&lt;/strong&gt;：eBPF 程序需要的 Linux 内核版本要 4.4 以上，更新的内核版本可以提供更多的数据收集。BCC 记录了 &lt;a href=&#34;https://github.com/iovisor/bcc/blob/13b5563c11f7722a61a17c6ca0a1a387d2fa7788/docs/kernel-versions.md#main-features&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;不同 Linux 内核版本所支持的功能&lt;/a&gt;，不同版本之间的差异在于 eBPF 收集的数据集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要特权权限&lt;/strong&gt;：所有打算将 eBPF 程序加载到 Linux 内核的进程必须在特权模式下运行。因此，代码中的错误或其他问题可能对安全有很大的影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对动态语言的支持较弱&lt;/strong&gt;：eBPF 对基于 JIT 的动态语言，如 Java，支持较弱。这也取决于你想收集什么数据。对于 Profiling，eBPF 不支持解析程序的字符表（symbol），这就是为什么大多数基于 eBPF 的剖析技术只支持静态语言如 C、C++、Go 和 Rust。然而，字符表映射有时可以通过语言所提供的工具来解决。例如，在 Java 中，可以使用 &lt;a href=&#34;https://github.com/jvm-profiling-tools/perf-map-agent#architecture&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;perf-map-agent&lt;/a&gt; 来生成字符表映射。然而，动态语言不支持附加（&lt;code&gt;uprobe&lt;/code&gt;）功能，而这种功能可以让我们通过符号追踪执行事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;introducing-skywalking-rover&#34;&gt;SkyWalking Rover 简介&lt;/h3&gt;
&lt;p&gt;SkyWalking Rover 是 SkyWalking 生态系统中引入的 eBPF 剖析功能。下图显示了 SkyWalking Rover 的整体架构。SkyWalking Rover 目前支持 Kubernetes 环境，必须部署在 Kubernetes 集群内。与 SkyWalking 后端服务器建立连接后，它将当前机器上的进程信息保存到 SkyWalking。当用户通过用户界面创建 eBPF 剖析任务时，SkyWalking Rover 会接收任务并在相关的基于 C、C++、Golang 和 Rust 语言的程序中执行。&lt;/p&gt;
&lt;p&gt;除了需要具有 eBPF 功能的内核外，部署 SkyWalking Rover 没有其他先决条件。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-skywalking-rover-架构图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;SkyWalking Rover 架构图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_77630572196fa0d44044c36d67f6e3d2.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/skywalking-rover_hu96ce0a1793ef4084b7c6baa2f4d21194_31590_6edef539501f91527785125de04f77d1.webp&#34;
               width=&#34;760&#34;
               height=&#34;259&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      SkyWalking Rover 架构图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;cpu-profiling-with-rover&#34;&gt;使用 Rover 进行 CPU 剖析&lt;/h3&gt;
&lt;p&gt;CPU 剖析是显示服务性能的最直观方式。受 &lt;a href=&#34;https://www.brendangregg.com/offcpuanalysis.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Brendan Gregg 的博客文章&lt;/a&gt; 的启发，我们将 CPU 剖析分为两种类型，并在 Rover 中加以实施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 剖析&lt;/strong&gt;：线程在 CPU 上的运行时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;off-CPU 剖析&lt;/strong&gt;：线程在 I/O、锁、定时器、分页 / 交换等方面被阻塞时的等待时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;profiling-envoy-with-ebpf&#34;&gt;用 eBPF 对 Envoy 进行剖析&lt;/h2&gt;
&lt;p&gt;Envoy 是一个流行的代理，在 Istio 服务网格中被用作为数据平面。在 Kubernetes 集群中，Istio 将 Envoy 作为 sidecar 注入到每个服务的 pod 中，在那里透明地拦截和处理传入和传出的流量。作为数据平面，Envoy 的任何性能问题都会影响到网格中的所有服务流量。在这种情况下，使用 eBPF 剖析来分析生产中由服务网格引起的问题是比较有力的。&lt;/p&gt;
&lt;h3 id=&#34;demo-environment&#34;&gt;演示环境&lt;/h3&gt;
&lt;p&gt;如果你想看到详细过程，我们已经建立了一个演示环境，在那里我们部署了一个 Nginx 服务进行压力测试。流量被 Envoy 拦截并转发到 Nginx。安装整个环境的命令可以在 &lt;a href=&#34;https://github.com/mrproliu/skywalking-rover-profiling-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt; 上获取。&lt;/p&gt;
&lt;h2 id=&#34;on-cpu-profiling&#34;&gt;CPU 剖析&lt;/h2&gt;
&lt;p&gt;当服务的 CPU 使用率很高时，CPU 剖析适用于分析线程堆栈。如果堆栈被转储的次数较多，意味着线程堆栈占据了更多的 CPU 资源。&lt;/p&gt;
&lt;p&gt;在使用演示配置文件安装 Istio 时，我们发现有两个地方的性能可以优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Zipkin 追踪&lt;/strong&gt;：不同的 Zipkin 采样百分比对 QPS 有直接影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问日志格式&lt;/strong&gt;：减少 Envoy 访问日志的字段可以提高 QPS。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zipkin-追踪&#34;&gt;Zipkin 追踪&lt;/h3&gt;
&lt;h3 id=&#34;zipkin-100-采样&#34;&gt;Zipkin 100% 采样&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，Envoy 使用 100% 采样作为默认的追踪策略。这对性能有什么影响？&lt;/p&gt;
&lt;p&gt;如下图所示，使用 CPU 剖析，我们发现它大约需要 &lt;strong&gt;16%&lt;/strong&gt; 的 CPU 开销。在固定消耗 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 的情况下，其 QPS 可以达到 &lt;strong&gt;5.7K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-zipkin-100-采样-cpu-剖析的火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Zipkin 100% 采样 CPU 剖析的火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_b68a53a9b8fc1f02dbfc560074a62481.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-sampling-100_huf238a1b5794ab6185477371703bb7cbb_258667_5c5bdd04bcd413ed5927348c85330886.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Zipkin 100% 采样 CPU 剖析的火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;禁用-zipkin-追踪&#34;&gt;禁用 Zipkin 追踪&lt;/h3&gt;
&lt;p&gt;此时，我们发现，如果没有必要，可以降低 Zipkin 采样比例，甚至可以禁用追踪。根据 &lt;a href=&#34;https://istio.io/latest/docs/reference/config/istio.mesh.v1alpha1/#Tracing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Istio 文档&lt;/a&gt;，我们可以在安装 Istio 时使用以下命令禁用追踪。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.enableTracing=false&amp;#39;&lt;/span&gt; &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set &lt;span class=&#34;s1&#34;&gt;&amp;#39;meshConfig.defaultConfig.tracing.sampling=0.0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用追踪后，我们再次进行 CPU 剖析。根据下图，我们发现 Zipkin 已经从火焰图中消失了。在与前面的例子相同的 &lt;strong&gt;2 个 CPU&lt;/strong&gt; 消耗下，QPS 达到 &lt;strong&gt;9K&lt;/strong&gt;，几乎增加了 &lt;strong&gt;60%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用-zipkin-追踪的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用 Zipkin 追踪的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_4120d0c8954a6454493ed53dde25e284.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/zipkin-disable-tracing_hu1f0ecaf355e785aa0e2514c9e5fd63b4_235208_6ce84d92564a56b7ebc933d9646c9347.webp&#34;
               width=&#34;760&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用 Zipkin 追踪的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;tracing-with-throughput&#34;&gt;追踪吞吐量&lt;/h3&gt;
&lt;p&gt;在 CPU 使用率相同的情况下，我们发现，当追踪功能被禁用时，Envoy 的性能会大大提升。当然，这需要我们在 Zipkin 收集的样本数量和 Envoy 的预期性能（QPS）之间做出权衡。&lt;/p&gt;
&lt;p&gt;下表说明了在相同的 CPU 使用率下，不同的 Zipkin 采样比例对 QPS 的影响。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Zipkin 采样比例&lt;/th&gt;
&lt;th&gt;QPS&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100% &lt;strong&gt;（默认）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;5.7K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 16%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1%&lt;/td&gt;
&lt;td&gt;8.1K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;禁用&lt;/td&gt;
&lt;td&gt;9.2K&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Zipkin 占用 0%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;access-log-format&#34;&gt;访问日志格式&lt;/h2&gt;
&lt;h3 id=&#34;default-log-format&#34;&gt;默认访问日志格式&lt;/h3&gt;
&lt;p&gt;在默认的演示配置文件中，默认的访问日志格式包含大量的数据。下面的火焰图显示了在解析数据时涉及的各种功能，如请求头、响应头和流媒体主体。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-默认访问日志格式的-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;默认访问日志格式的 CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_ca470e83e66ecbe17169087ebaace536.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/log-format-default_hu7d2fdb57bd91148e550aa40a981eaed2_174188_0f5231040d3cb686febbbade6d4f490a.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      默认访问日志格式的 CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;simplifying-access-log-format&#34;&gt;简化访问日志格式&lt;/h3&gt;
&lt;p&gt;通常情况下，我们不需要访问日志中的所有信息，所以我们通常可以简化它来获得我们需要的信息。下面的命令简化了访问日志的格式，只显示基本信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo &lt;span class=&#34;se&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;se&#34;&gt;&lt;/span&gt;   --set meshConfig.accessLogFormat&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;[% START_TIME%] \&amp;#34;% REQ (:METHOD)% % REQ (X-ENVOY-ORIGINAL-PATH?:PATH)% % PROTOCOL%\&amp;#34;% RESPONSE_CODE%\n&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;简化访问日志格式后，我们发现 QPS 从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。当再次执行 CPU 剖析时，日志格式化的 CPU 使用率从 &lt;strong&gt;2.4%&lt;/strong&gt; 下降到 &lt;strong&gt;0.7%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简化日志格式帮助我们提高了性能。&lt;/p&gt;
&lt;h2 id=&#34;off-cpu-剖析&#34;&gt;Off-CPU 剖析&lt;/h2&gt;
&lt;p&gt;Off-CPU 剖析适用于由非高 CPU 使用率引起的性能问题。例如，当一个服务中有太多的线程时，使用 off-CPU 剖析可以揭示出哪些线程花费了更多的时间进行上下文切换。&lt;/p&gt;
&lt;p&gt;我们提供两个维度的数据汇总。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;切换次数&lt;/strong&gt;：一个线程切换上下文的次数。当线程返回到 CPU 时，它完成了一次上下文切换。开关次数较多的线程栈会花费更多时间进行上下文切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切换持续时间&lt;/strong&gt;：一个线程切换上下文所需的时间。切换持续时间较长的线程栈在 off-CPU 花费的时间较多。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;write-access-log&#34;&gt;写入访问日志&lt;/h3&gt;
&lt;h4 id=&#34;enable-write&#34;&gt;启用写入&lt;/h4&gt;
&lt;p&gt;使用与之前 CPU 测试相同的环境和设置，我们进行了 off-CPU 剖析。如下图所示，我们发现访问日志的写入占总上下文切换的 &lt;strong&gt;28%&lt;/strong&gt; 左右。下图中的 &lt;code&gt;__write&lt;/code&gt; 也表明这是 Linux 内核中的方法。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-启用写入的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;启用写入的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_fea2e2c0d03b286f15392cc50602ab21.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-enable_hubdf9a606cdf61d4031d0e2209c45ffff_117338_4f90812f80bcc003b7376d5607177654.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      启用写入的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h4 id=&#34;禁用写入&#34;&gt;禁用写入&lt;/h4&gt;
&lt;p&gt;SkyWalking 实现了 Envoy 的访问日志服务（ALS）功能，允许我们使用 gRPC 协议将访问日志发送到 SkyWalking 可观察性分析平台（OAP）。即使禁用访问日志，我们仍然可以使用 ALS 来捕获 / 汇总日志。我们使用以下命令禁用了对访问日志的写入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;istioctl install -y --set &lt;span class=&#34;nv&#34;&gt;profile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;demo --set meshConfig.accessLogFile&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;禁用访问日志功能后，我们进行了 off-CPU 剖析。如下图所示，文件写入条目已经消失了。Envoy 的吞吐量也从 &lt;strong&gt;5.7K&lt;/strong&gt; 增加到 &lt;strong&gt;5.9K&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-禁用访问日志功能后的-off-cpu-剖析火焰图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;禁用访问日志功能后的 off-CPU 剖析火焰图&#34; srcset=&#34;
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp 400w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_64a520f1998a1b10dd8b102cdaefebbb.webp 760w,
               /blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/pinpoint-service-mesh-critical-performance-impact-by-using-ebpf/access-log-write-disable_hu5e4e6d524a292897da8cca3705844d39_104099_5d9c5dc3f590028c1b5386c0232bffb5.webp&#34;
               width=&#34;760&#34;
               height=&#34;385&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      禁用访问日志功能后的 off-CPU 剖析火焰图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我们研究了 Apache SkyWalking 的 Trace Profiling 可以给我们带来的启示，以及使用 eBPF 剖析可以实现的更多功能。所有这些功能都在 &lt;a href=&#34;https://github.com/apache/skywalking-rover&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;skywalking-rover&lt;/a&gt; 中实现。除了 CPU 和 off-CPU 剖析之外，你还会发现以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连续剖析&lt;/strong&gt;，帮助你自动剖析，无需人工干预。例如，当 Rover 检测到 CPU 超过一个可配置的阈值时，它会自动执行 CPU 剖析任务。&lt;/li&gt;
&lt;li&gt;更多的剖析类型，以丰富使用场景，如网络和内存剖析。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>一键开启 Kubernetes 可观测性——如何自动生成和存储 OpenTelemetry 追踪</title>
      <link>https://lib.jimmysong.io/blog/generate-and-store-opentelemetry-traces-automatically/</link>
      <pubDate>Mon, 30 May 2022 11:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/generate-and-store-opentelemetry-traces-automatically/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 追踪包含了理解分布式系统和排除故障的信息宝库 —— 但你的服务必须首先被指标化，以发射 OpenTelemetry 追踪来实现这一价值。然后，这些追踪信息需要被发送到一个可观察的后端，使你能够获得关于这些数据的任意问题的答案。可观测性是一个分析问题。&lt;/p&gt;
&lt;p&gt;本周早些时候，我们部分解决了这个问题，宣布&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 Promscale 中普遍提供 OpenTelemetry 追踪支持&lt;/a&gt;，将由 SQL 驱动的可观测性带给所有开发者。随着对分析语言 ——SQL 的全面支持，我们解决了分析的问题。但我们仍然需要解决第一部分的问题：测量。&lt;/p&gt;
&lt;p&gt;为了让你的服务发出追踪数据，你必须手动添加 OpenTelemetry 测量工具到代码中。而且你必须针对所有服务和你使用的所有框架来做，否则你将无法看到每个请求的执行情况。你还需要部署 OpenTelemetry 收集器来接收所有新的追踪，处理它们，批处理它们，并最终将它们发送到你的可观测性后端。这需要花费大量的时间和精力。&lt;/p&gt;
&lt;p&gt;如果你不需要做所有这些手工工作，并且可以在几分钟内而不是几小时甚至几天内启动和运行呢？如果你还能建立一个完整的可观测性技术栈并自动连接所有的组件呢？如果我告诉你，你可以用一个命令完成所有这些工作呢？&lt;/p&gt;
&lt;p&gt;我不是疯子。我只是一个 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tobs&lt;/a&gt; 用户😎。&lt;/p&gt;
&lt;p&gt;Tobs 是 Kubernetes 的可观测性技术栈，是一个可以用来&lt;a href=&#34;https://www.timescale.com/blog/introducing-tobs-deploy-a-full-observability-suite-for-kubernetes-in-two-minutes/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在几分钟内在 Kubernetes 集群中部署一个完整的可观测性技术栈&lt;/a&gt;的工具。该栈包括 OpenTelemetry Operator、OpenTelemetry Collector、Promscale 和 Grafana。它还部署了其他几个工具，如 Prometheus，以收集 Kubernetes 集群的指标，并将其发送到 Promscale。&lt;a href=&#34;https://github.com/timescale/tobs/releases/tag/0.10.1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在我们的最新版本中&lt;/a&gt;，tobs 包括支持通过 OpenTelemetry Operator 用 OpenTelemetry 追踪自动检测你的 Python、Java 和 Node.js 服务。&lt;/p&gt;
&lt;p&gt;是的，你没看错：自动！你不需要改变服务中的任何一行代码，就可以让它们被检测出来。锦上添花的是什么？你可以通过执行 helm 命令来部署一切。&lt;/p&gt;
&lt;p&gt;有了 tobs，你可以安装你的可观测性技术栈，只需几步就能搞定你的 OpenTelemetry 指标化的第一层。告别繁琐的配置工作，因为你的框架会自己检测。&lt;/p&gt;
&lt;p&gt;如果你想了解如何做到这一点，请继续阅读本博文。首先，我们将解释一切是如何运作的，剖析 OpenTelemetry Operator 在内部的真正作用。接下来，我们将通过一个例子演示如何将其直接付诸实践。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将通过 tobs 在我们的 Kubernetes 集群中安装一个完整的可观测性技术栈。&lt;/li&gt;
&lt;li&gt;我们将部署一个云原生 Python 应用程序。&lt;/li&gt;
&lt;li&gt;我们将检查我们的应用程序是如何被 OpenTelemetry 追踪器自动检测到的，这要归功于 tobs 和 OpenTelemetry Operator 所做的魔术🪄。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;opentelemetry-operator&#34;&gt;OpenTelemetry Operator&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://opentelemetry.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry&lt;/a&gt; 是一个开源的框架，可以捕获、转换和路由所有类型的信号（追踪、日志和指标）。在大多数情况下，你会使用 &lt;a href=&#34;https://open-telemetry.github.io/opentelemetry-js/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry SDK&lt;/a&gt; 来在你的应用程序代码中生成这些信号。但是，在某些情况下，OpenTelemetry 可以自动检测你的代码 —— 也就是说，当你的应用框架被支持，并且你使用的语言是 OpenTelemetry 可以注入代码的。在这种情况下，你的系统将开始产生遥测，而不需要手动工作。&lt;/p&gt;
&lt;p&gt;要了解 OpenTelemetry 是如何做到这一点的，我们首先需要熟悉 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Operator&lt;/a&gt;。OpenTelemetry Operator 是一个实现 &lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/operator/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes Operator 模式&lt;/a&gt;的应用程序，与 Kubernetes 集群中的两个 CustomResourceDefinitions（CRD）互动。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图示说明-opentelemetry-operator-如何与-kubernetes-互动&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图示说明 OpenTelemetry Operator 如何与 Kubernetes 互动&#34; srcset=&#34;
               /blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_89510390ea80e6b60d8a5067819ad3e1.webp 400w,
               /blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_67c2a525aead983718379ac249f37412.webp 760w,
               /blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/generate-and-store-opentelemetry-traces-automatically/otel-operator-kubernetes_hu9eaea35c1c3da37ce10befac350865f4_54425_89510390ea80e6b60d8a5067819ad3e1.webp&#34;
               width=&#34;760&#34;
               height=&#34;481&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图示说明 OpenTelemetry Operator 如何与 Kubernetes 互动
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 CustomResourceDefinitions（CRD&lt;/a&gt;）实例的变化，Operator 为我们管理以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建和删除 OpenTelemetry Collector 实例&lt;/li&gt;
&lt;li&gt;将 OpenTelemetry 自动测量所需的库和二进制文件直接注入到你的 pod 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们更详细地解读这两项任务。&lt;/p&gt;
&lt;h2 id=&#34;管理-opentelemetry-collector&#34;&gt;管理 OpenTelemetry Collector&lt;/h2&gt;
&lt;p&gt;OpenTelemetry Operator 的首要任务是部署 &lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Collector&lt;/a&gt; 实例。这些实例将被用来把信号从源头（你的工作负载和 Kubernetes 本身）路由到它们的目标（支持 OpenTelemetry 协议的存储系统或集群外的另一个采集器）。&lt;/p&gt;
&lt;p&gt;采集器可以以三种不同的方式部署：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为 Kubernetes Deployment：这是默认选项，它允许采集器根据需要在节点之间移动，支持向上和向下扩展。&lt;/li&gt;
&lt;li&gt;作为 Kubernetes Daemonset：这个选项将在每个节点上部署一个采集器，当你想确保你的信号在没有任何网络开销的情况下被处理时，它可能很有用。&lt;/li&gt;
&lt;li&gt;作为一个 Sidecar：被注入到任何新的注释的 pod 中（使用 &lt;code&gt;sidecar.opentelemetry.io/inject: true&lt;/code&gt;）。当采集器需要一个 pod 的特定配置时，这可能是很好的（例如，也许它需要一些专门的转换）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你愿意，你可以混合和匹配这些收集器模式。例如，你可以设置一个 sidecar，为部署中的 pod 做一些转换，然后将它们发送到一个全局收集器，与你的其他工作负载共享。&lt;/p&gt;
&lt;p&gt;定义这些收集器实例的配置在收集器 CRD（&lt;code&gt;opentelemetrycollectors.opentelemetry.io&lt;/code&gt;）中进行建模。允许多个实例来实现更复杂的模式。部署类型是通过 &lt;code&gt;mode&lt;/code&gt; 设置来选择的，伴随着一个原始的配置字符串，它被逐字传递给控制器，并作为配置加载。下面是使用 Deployment 模式创建 Operator 的 CRD 的例子。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opentelemetry.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;OpenTelemetryCollector&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tobs-tobs-opentelemetry&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;Spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;config&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    receivers:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      jaeger:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        protocols:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          grpc:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          thrift_http:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      otlp:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        protocols:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          grpc:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          http:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    exporters:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      logging:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      otlp:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        endpoint: &amp;#34;tobs-promscale-connector.default.svc:9202&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        compression: none
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        tls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          insecure: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      prometheusremotewrite:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        endpoint: &amp;#34;tobs-promscale-connector.default.svc:9201/write&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        tls:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          insecure: true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    processors:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      batch:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;    service:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;      pipelines:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        traces:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          receivers: [jaeger, otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          exporters: [logging, otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          processors: [batch]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;        metrics:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          receivers: [otlp]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          processors: [batch]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;sd&#34;&gt;          exporters: [prometheusremotewrite]    &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正如我们在后面的例子中看到的，当你使用 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tobs&lt;/a&gt; 时，你不需要担心所有这些配置细节。tobs 的好处之一是它会为你安装一个采集器，它将直接把数据发送到本地的 Promscale 实例。&lt;/p&gt;
&lt;h2 id=&#34;在-kubernetes-中添加-opentelemetry-自动监测系统&#34;&gt;在 Kubernetes 中添加 OpenTelemetry 自动监测系统&lt;/h2&gt;
&lt;p&gt;Operator 的第二个关注点是将 OpenTelemetry 自动测量所需的库和二进制文件注入到 pod 中。要做到这一点，这些 pod 需要容纳 Java、Python 或 Node.js 应用程序（OpenTelemetry 将来会支持更多语言）。&lt;/p&gt;
&lt;p&gt;用于部署这些 pod 的 Kubernetes 清单文件必须包括一个注释，以指示 OpenTelemetry Operator 对其进行检测。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instrumentation.opentelemetry.io/inject-&amp;lt;language&amp;gt;: &amp;#34;true&amp;#34;   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;language&lt;/code&gt; 可以是 &lt;code&gt;python&lt;/code&gt;、&lt;code&gt;java&lt;/code&gt; 或 &lt;code&gt;nodejs&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当注解的 pod 启动时，会创建一个 &lt;code&gt;init&lt;/code&gt; 容器，注入所需的代码并改变 pod 运行代码的方式，使用正确的 OpenTelemetry 自动探测方法。实际上，这意味着在使用 Kubernetes 时，不需要修改任何代码就可以获得自动监测的好处。该配置还定义了 OpenTelemetry Collector 端点，这些追踪将被发送到该端点，传播的信息类型，以及我们用来采样追踪的方法（如果有的话）(关于 &lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator/blob/main/docs/api.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CRD 的全部细节，请看文档&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;为 Python、Java 和 Node.js 应用程序提供自动测量的自定义资源的例子是这样的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;opentelemetry.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Instrumentation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;tobs-auto-instrumentation&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exporter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;endpoint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http://tobs-opentelemetry-collector.default.svc:4318 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;propagators&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;tracecontext&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;baggage&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;b3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sampler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;argument&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;0.25&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;parentbased_traceidratio&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再一次，如果你使用 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/tobs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tobs&lt;/a&gt;，你将不需要自己创建这些自定义资源。Tobs 将确保集群被自动配置成对任何有注释的 pod 进行检测，而不需要你做任何操作。你所需要做的就是在你想收集追踪的 pod 中添加以下注释之一。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;instrumentation.opentelemetry.io/inject-java: &amp;#34;true&amp;#34;
instrumentation.opentelemetry.io/inject-nodejs: &amp;#34;true&amp;#34;
instrumentation.opentelemetry.io/inject-python:&amp;#34;true&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们通过一个例子看看这在实践中是如何运作的。&lt;/p&gt;
&lt;h2 id=&#34;使用-opentelemetry-operator-和-tobs&#34;&gt;使用 OpenTelemetry Operator 和 Tobs&lt;/h2&gt;
&lt;p&gt;在本节中，我们将使用我们的&lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;微服务演示应用程序&lt;/a&gt;，它由一个过度工程化的密码生成器应用程序组成。&lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;在 repo 中&lt;/a&gt;，你可以找到一个已测量的版本和一个未测量的版本，这就是我们在这个例子中要使用的版本。&lt;/p&gt;
&lt;p&gt;要运行这个，你首先需要一个 Kubernetes 集群，安装了 cert-manager，配置了通过 &lt;code&gt;kubectl&lt;/code&gt;（至少需要 1.21.0 版本）的访问，并安装了 &lt;a href=&#34;https://helm.sh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helm&lt;/a&gt;。为了部署和运行所有不同的组件，你将需要在你的 Kubernetes 集群中提供大约 4 核 CPU 和 8GB 的内存。&lt;/p&gt;
&lt;p&gt;如果你的集群中没有 cert-manager，你将需要使用这个命令来安装它。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -f 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;准备好后，让我们使用 Timescale Helm Chart 来安装 tobs。在命令提示符下运行以下命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm repo add timescale https://charts.timescale.com/ --force-update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;helm install --wait --timeout 10m tobs timescale/tobs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Tobs 需要几分钟的时间来安装，但最终，你会看到类似这样的输出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#helm install --wait tobs timescale/tobs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAME: tobs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LAST DEPLOYED: Thu May &lt;span class=&#34;m&#34;&gt;19&lt;/span&gt; 11:22:19 &lt;span class=&#34;m&#34;&gt;2022&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NAMESPACE: default
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;STATUS: deployed
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;REVISION: &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;NOTES:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;###############################################################################&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;👋🏽 Welcome to tobs, The Observability Stack &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; Kubernetes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;✨ Auto-configured and deployed:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🔥 Kube-Prometheus
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🐯 TimescaleDB
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🤝 Promscale
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🧐 PromLens
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;📈 Grafana
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🚀 OpenTelemetry
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;🎯 Jaeger
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;###################################&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;👉 故障排除提示：如果你得到这个错误信息 &lt;code&gt;INSTALLATION FAILED: rate:Wait(n=1) would exceed context deadline&lt;/code&gt;，这很可能表明你的集群中没有足够的可用资源。&lt;/p&gt;
&lt;p&gt;一旦 tobs 的安装完成，检查你的 Kubernetes 集群，确认所有的组件都已正确部署。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get podes --all-namespaces &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep &lt;span class=&#34;s2&#34;&gt;&amp;#34;tobs-&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;👉故障排除提示：如果某些 pod 处于待定或错误状态，你可以使用 &lt;code&gt;kubectl describe pod &amp;lt;pod-name&amp;gt;&lt;/code&gt; 或 &lt;code&gt;kubectl logs &amp;lt;pod-name&amp;gt;&lt;/code&gt; 来了解可能存在的问题。&lt;/p&gt;
&lt;p&gt;现在，我们可以从 &lt;a href=&#34;https://github.com/timescale/opentelemetry-demo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenTelemetry Demo GitHub repo&lt;/a&gt; 中导入未测量的 Kubernetes 微服务。&lt;/p&gt;
&lt;p&gt;如果你回顾一下 &lt;code&gt;uninstrumented&lt;/code&gt; 文件夹中的代码，你会发现它没有提到 OpenTelemetry。例如，看一下 &lt;code&gt;load&lt;/code&gt; 微服务的 Python 文件（这个服务通过发出密码请求来驱动其他服务的流量）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过将这些微服务导入安装了 tobs 的集群中，它们将自动获得 OpenTelemetry 追踪的测量工具。&lt;/p&gt;
&lt;p&gt;要调出演示应用程序，请运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl apply -k &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://github.com/timescale/opentelemetry-demo/yaml/app&amp;#39;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当这个过程结束，应用程序被部署时，它将已经被 OpenTelemetry 追踪器所记录。追踪现在正在生成并自动发送到 Promscale。&lt;/p&gt;
&lt;p&gt;这种魔法是如何发生的？&lt;/p&gt;
&lt;p&gt;这里有一个总结性的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 pod 都被注解为 &lt;code&gt;instrumentation.opentelemetry.io/inject-python: &amp;quot;true&amp;quot;&lt;/code&gt;，所以当它们启动时，会被 OpenTelemetry Operator 注意到。&lt;/li&gt;
&lt;li&gt;接下来，使用一个突变的 webhook 添加一个 init 容器，注入 Python 库和启用测量工具所需的代码。&lt;/li&gt;
&lt;li&gt;然后，追踪数据被发送到 Instrumentation CRD 中注明的 OpenTelemetry Collector。&lt;/li&gt;
&lt;li&gt;OpenTelemetry Collector 将数据发送到 Promscale（和 TimescaleDB），从那里可以直接用 SQL 查询或用 Grafana 等工具进行可视化访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们看看我们直接从 Grafana（tobs 也自动安装在我们的集群中）自动生成的追踪。&lt;/p&gt;
&lt;p&gt;要获得 Grafana 实例的管理用户的密码，请运行以下命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl get secret tobs-grafana -o &lt;span class=&#34;nv&#34;&gt;jsonpath&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;{.data.admin-password}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; base64 -d 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kubectl port-forward svc/tobs-grafana 3000:80
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，导航到 http://localhost:3000/d/vBhEewLnk，使用你刚刚找回的密码，以管理员用户身份登录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Promscale 应用性能监控（APM）仪表盘&lt;/a&gt;将显示出来，向你展示关于演示应用的洞察力。Tobs 直接导入这套开箱即用、可用于生产的仪表盘，我们在 Grafana 中使用 SQL 查询对追踪数据进行构建，在这种情况下，它是由演示微服务自动生成的。下图显示了其中一个仪表盘 ——“服务详情”。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-用演示应用程序的追踪数据填充的-服务细节仪表盘&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;用演示应用程序的追踪数据填充的 &amp;lt;a href=&amp;#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;服务细节仪表盘&amp;lt;/a&amp;gt;&#34; srcset=&#34;
               /blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_e987cee28e5586d3309d943b90593978.webp 400w,
               /blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_38fa9f225f71344d9cc7cadc07a0349a.webp 760w,
               /blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/generate-and-store-opentelemetry-traces-automatically/service-overview_hu7b2370ea432b5684d50aba5f5c723790_152700_e987cee28e5586d3309d943b90593978.webp&#34;
               width=&#34;760&#34;
               height=&#34;390&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      用演示应用程序的追踪数据填充的 &amp;lt;a href=&amp;#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;服务细节仪表盘&amp;lt;/a&amp;gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于这些预建仪表盘的更多信息，请&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;查看这篇博文&lt;/a&gt;（导航到“集成到 Grafana 的现代 APM 体验”一节）。&lt;/p&gt;
&lt;p&gt;我们已经得到了所有这些信息，而在任何 Python 服务中都没有测量工具代码。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;OpenTelemetry 追踪从未像现在这样方便。&lt;a href=&#34;https://opentelemetry.io/docs/collector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如果你的微服务是用 OpenTelemetry Operator 目前支持的语言之一编写的&lt;/a&gt;，你可以立即开始收集和存储追踪数据，只需要很少的手动工作。你只需采取以下两个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/timescale/tobs/blob/master/chart/README.md#install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通过 Helm 在你的 Kubernetes 集群中安装 tobs&lt;/a&gt;(请注意，你必须使用 Helm 来安装 tobs，才能使这个最新版本发挥作用，而不是使用 CLI)。&lt;/li&gt;
&lt;li&gt;在部署之前，给你想收集追踪数据的微服务 pods 添加&lt;a href=&#34;https://github.com/open-telemetry/opentelemetry-operator#opentelemetry-auto-instrumentation-injection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;注解&lt;/a&gt;（例如 &lt;code&gt;instrumentation.opentelemetry.io/inject-python: &amp;quot;true&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你的微服务将自动被 OpenTelemetry 追踪器检测，你的追踪器将自动存储在 Promscale 中，Promscale 是建立在 PostgreSQL 和 TimescaleDB 上的统一的指标和追踪器的可观测性后端。&lt;/p&gt;
&lt;p&gt;通过 &lt;a href=&#34;https://docs.timescale.com/promscale/latest/visualize-data/apm-experience/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Promscale 预先建立的 APM 仪表盘&lt;/a&gt;，你将立即了解到你的系统性能如何，并且你将能够&lt;a href=&#34;https://www.timescale.com/blog/observability-powered-by-sql-understand-your-systems-like-never-before-with-opentelemetry-traces-and-postgresql/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用 SQL 查询你的追踪&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>混沌工程和视觉隐喻的可观测性</title>
      <link>https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/</link>
      <pubDate>Tue, 24 May 2022 10:00:00 +0800</pubDate>
      <guid>https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/</guid>
      <description>&lt;h2 id=&#34;主要收获&#34;&gt;主要收获&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于现代软件系统来说，可观测性不是关于数学方程。它是关于人类如何与复杂的系统互动并试图理解它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混沌工程利用了可观测性，因为它可以检测到系统稳定状态的偏差。混沌工程借助可观测性可以发现和克服系统的弱点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可观测性依赖于系统所发出的信号，这些信号提供了关于系统行为的原始数据。然而，可观测性不仅受限于这些信号的质量，还受限于这些信号的可视化和解释的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑到混沌工程、可观测性和可视化涉及到人类自我的解释，仪表盘的设计者可能会对这些解释产生偏差，这是一个事实。在这个意义上，视觉隐喻并不能保证我们以正确的方式解释这些数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于视觉隐喻的仪表盘可以提供比经典的可视化更有用的数据。然而，这两种策略都很容易产生偏差；例如，在一项研究中，大多数参与者都注意到，由于显示了糟糕的柱状图和线状图，没有在图中显示出重要的分界点，因此整体结果是有偏差的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自从 Netflix、Slack 和 Linkedin 等领先的技术公司采用混沌工程来抵御生产中的意外中断后，这门学科在近来已经成为主流。在这条道路上，可观测性发挥了关键作用，为工程师们带来了数据和监控的力量，他们现在有了了解自己系统的策略，确定当某些东西发生故障时它们将如何表现，并增加复原力和可靠性。&lt;/p&gt;
&lt;p&gt;混沌工程和可观测性是两个密切相关的学科。根据 Russ Miles 的说法，&amp;quot;可观测性原则将系统变成了可检查和可调试的案发现场，而混沌工程鼓励并利用可观测性，因为它试图帮助预先发现并克服系统的弱点 &amp;quot;。混沌工程鼓励并要求可观测性，因为要自信地执行混沌实验，可观测性必须检测系统何时正常，以及在执行方法实验时如何偏离该稳定状态。见图 1 中的说明。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-1-混沌工程和可观测性&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 1. 混沌工程和可观测性&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_5d7fb018e0e824d2448996f75ff4f637.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_b2bb9661845b41200cb05c69a2d66c51.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f1_huf280a69d36e74c95041d917268dd5fcf_36322_5d7fb018e0e824d2448996f75ff4f637.webp&#34;
               width=&#34;760&#34;
               height=&#34;399&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 1. 混沌工程和可观测性
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;学术界和科技界都做出了巨大的努力，为实践混沌工程和可观测性提供了工具。然而，指标的可视化和视觉策略的适当选择仍然是有限的。本文引入了一个新的角色：视觉隐喻。具体来说，它提供了混沌工程和可观测性的概念基础，介绍了市场上可用的可视化技术的现状，并展示了树状图、仪表图、地理图和城市隐喻是如何丰富观察混沌的视觉策略的。&lt;/p&gt;
&lt;h2 id=&#34;混沌工程和可观测性的基础&#34;&gt;混沌工程和可观测性的基础&lt;/h2&gt;
&lt;p&gt;关于混沌工程：混沌、弹性和可靠性是关键的概念，而关于可观测性，当人类想要观察他们的系统时，监控、度量和仪表盘是至关重要的。因此，在深入研究混沌工程和可观测性之间的关系之前，明确这些定义很重要。&lt;/p&gt;
&lt;p&gt;混沌工程根据混沌原理定义为一门在系统上进行实验的学科，以建立对系统在生产中承受动荡条件能力的信心。为了具体解决大规模分布式系统的不确定性，混沌工程提供了一种基于实验的方法，包括四个步骤：第一个步骤包括定义稳定状态，这是系统的一个可测量的输出，表示正常行为。第二步是与假设相关的，它提出了一个改变稳态的后果的句子。有了这个假设，就该引入现实世界的事件，如服务器崩溃或硬盘故障，以证实或反驳这个假设。最后，目标是建立控制组和实验组之间稳定状态的差异分析。&lt;/p&gt;
&lt;p&gt;可观测性是指能够完全理解一个系统。在控制理论中，它被定义为衡量一个系统的内部状态可以从其外部输出的知识中推断出来的程度。特别是在软件工程中，可观测性可以被描述为提出适当的问题、提供正确的答案以及用收集到的数据建立知识的艺术。&lt;/p&gt;
&lt;p&gt;监控与可观测性是不同的，理解两者的区别很重要。监控是关于收集、处理、汇总和显示系统的实时定量数据；而可观测性是关于处理和分析这些数据，让团队主动理解和调试系统的行为。对于现代软件系统来说，可观测性不是关于数学公式。它是关于人们如何与复杂的系统互动并试图理解它们。&lt;/p&gt;
&lt;p&gt;在这个意义上，监控涉及到通过数字读取系统发出的信号，这些数字被命名为度量。指标是一个单一的数字，可以选择附加标签进行分组和搜索，比如查询次数和类型、错误次数和类型、处理时间或服务器寿命。这些数值在仪表盘中被可视化，仪表盘是提供服务核心指标的摘要视图的应用程序。&lt;/p&gt;
&lt;p&gt;传统的仪表盘是建立在折线图、饼图或柱状图上的。考虑到可观测性取决于系统发出的信号以及这些信号被可视化和解释的质量，提供最好的工具和设计是很重要的。如果颜色、图例和比例使用不当，一些可视化可能会对操作者造成限制和困惑。下一节提供了监控和可观测性的技术状况，并更详细地描述了其中的一些限制。&lt;/p&gt;
&lt;h2 id=&#34;监控和可观测性&#34;&gt;监控和可观测性&lt;/h2&gt;
&lt;p&gt;监控和可观测性已经成为工程团队和一般现代数字企业最基本的能力之一，他们希望在他们的解决方案中提供卓越。由于监控和观察系统有很多原因，谷歌记录了四个黄金信号或指标，它们定义了系统健康的含义，是可观测性和监控平台现状的基础。这四个指标描述如下。&lt;/p&gt;
&lt;p&gt;延迟（Latency）是指一个服务为一个请求提供服务所需的时间。它包括由于与数据库或其他关键后端失去连接而触发的 HTTP 500 错误，这些错误可能不会很快得到服务。延迟是一个基本指标，因为慢的错误甚至比快的错误更糟糕。&lt;/p&gt;
&lt;p&gt;流量（Traffic）是衡量对系统的需求有多大。它决定了系统在某一特定时间内从用户或通过服务运行的事务中承受多大的压力。以网络服务为例，这种测量通常是每秒的 HTTP 请求。通过监控应用程序或服务中的真实用户互动和流量，工程团队可以看到系统如何支持需求的变化，以及他们应该如何扩展资源以满足需求。&lt;/p&gt;
&lt;p&gt;错误（Error）与请求失败的比率有关，无论是显性的还是隐性的。根据系统和发生故障的组件，监控错误情况可能会有很大的不同。这就是为什么工程团队需要监控整个系统的错误发生率，但也需要监控单个服务层面的错误发生率的原因。同样重要的是，要优先考虑哪些错误是关键的，哪些错误是不太危险的。&lt;/p&gt;
&lt;p&gt;最后，饱和度（Saturation）是系统对资源利用的信号，如内存、I/O 或 CPU。考虑到许多系统在达到 100% 的利用率之前就会出现性能下降的情况，拥有一个饱和度目标是非常重要的。它允许我们回答这样的问题：服务还有多少容量？什么水平的饱和度能保证客户的服务性能和可用性？&lt;/p&gt;
&lt;h2 id=&#34;用于监控的传统可视化方法&#34;&gt;用于监控的传统可视化方法&lt;/h2&gt;
&lt;p&gt;现在，上一节所述的四个黄金信号是用传统方法监控的，如折线图、柱状图或饼状图。&lt;/p&gt;
&lt;p&gt;如图 2 所示，折线图是将系统的四个黄金信号的行为在时间上可视化的最常用策略。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-2-虚构项目中的折线图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 2. 虚构项目中的折线图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_a7071667ac1f1e2b91f04ef67672971c.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_0c8c4496e612c4a2c59bdf77da85218f.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f2_hu88aeb9acab18176e9eb3c67caa5e4d41_26588_a7071667ac1f1e2b91f04ef67672971c.webp&#34;
               width=&#34;760&#34;
               height=&#34;362&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 2. 虚构项目中的折线图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;线形图在颜色、图例、轴和系列的标题方面提出了不同的挑战，因为变量会聚、交叉，而且通常会纠缠在一起。如果仪表盘的创建者没有使用适当的视觉资产，这种类型的图形可能会变成最令人困惑的图表之一。&lt;/p&gt;
&lt;p&gt;另一个常见的图表是柱状图，它是用高度或长度与所代表的数值成正比的矩形条来表示分类数据。如图 3 所示，一些云供应商用它们来表示日志的分类数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-3-一个虚构的项目中的柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 3. 一个虚构的项目中的柱状图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_f171ab2438faaf52e91c84f8323a02f9.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_5bb59c44a456b6ffb7869609155d97d6.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f3_huec1427940dfdc13893b83265e8be3044_20366_f171ab2438faaf52e91c84f8323a02f9.webp&#34;
               width=&#34;760&#34;
               height=&#34;315&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 3. 一个虚构的项目中的柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，尽管较少使用，饼图是表示和比较数据分布中的比例的一种简单方法。当一个比例占主导地位——一半或四分之三时，它们是最有效的。超过几种颜色的楔形图会在楔形图之间产生同一性，使其难以比较数值。&lt;/p&gt;
&lt;p&gt;考虑到这些局限性，下一节将介绍一种不同的方式来可视化这四个黄金指标。由于本文是关于混沌工程的，这种技术是在报告事件的情况下进行分析的。&lt;/p&gt;
&lt;h2 id=&#34;视觉隐喻作为视觉化混沌的一种建议&#34;&gt;视觉隐喻作为视觉化混沌的一种建议&lt;/h2&gt;
&lt;p&gt;为了克服前面提到的局限性，本文提出了一种新的策略，将生产中的混乱现象可视化。这个建议是基于其他科学领域的一个概念：视觉隐喻。视觉隐喻是一种策略，将一个应用领域的概念和对象映射到一个相似性和类比的系统中。计算机隐喻是交互式视觉对象和模型对象之间同化的基本思想。它的作用是促进对对象的语义的更好理解。一个熟悉的例子可以是在跑车的图片前使用一只豹子，暗示该产品具有速度、力量和耐力等可比性。&lt;/p&gt;
&lt;p&gt;一些例子包括：地图、城市和几何场景，如图 3 所示。该图显示了城市隐喻，这是一种用于可视化程序代码属性的流行方法。许多项目都采用了这种隐喻来可视化软件库的属性，比如说。现有的研究已经被用来用包来映射街区，用建筑来映射类。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-4-一个虚构项目中的城市隐喻来自-这里&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 4. 一个虚构项目中的城市隐喻，来自 &amp;lt;a href=&amp;#34;https://www.researchgate.net/publication/224503826_Visual_Exploration_of_Large-Scale_Evolving_Software&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;这里&amp;lt;/a&amp;gt;&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_639d60ca309b4fa0a9f1d6248f19003d.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_aa172a266c11157371240586a8a2dc60.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f4_hu88c9b151cfdb4b13fa315b0869397f32_20182_639d60ca309b4fa0a9f1d6248f19003d.webp&#34;
               width=&#34;500&#34;
               height=&#34;384&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 4. 一个虚构项目中的城市隐喻，来自 &amp;lt;a href=&amp;#34;https://www.researchgate.net/publication/224503826_Visual_Exploration_of_Large-Scale_Evolving_Software&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;noopener&amp;#34;&amp;gt;这里&amp;lt;/a&amp;gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在这种情况下，这个隐喻把类表示为建筑物，把包表示为建筑物所处的邻域。建筑物的每个边缘都被用来映射类的属性。&lt;/p&gt;
&lt;h2 id=&#34;提出一个将事件可视化的实验&#34;&gt;提出一个将事件可视化的实验&lt;/h2&gt;
&lt;p&gt;为了确定参与运营活动的工程团队的看法，我们对他们中的 28 人进行了关于传统仪表盘和视觉隐喻的调查。具体来说，他们被问及使用经典仪表盘和视觉隐喻对四个黄金指标（错误、延迟、流量和饱和度）进行可视化的事件。&lt;/p&gt;
&lt;p&gt;这项研究由关于一个事件的具体问题组成，其中提供了两种可视化：一种是传统的图表，另一种是视觉隐喻。对于每一种情况，都分析了每种可视化的价值。在接下来的段落中，将介绍每个问题和分析。&lt;/p&gt;
&lt;p&gt;关于人口统计学，共有 28 名参与者，其背景分布在后端、前端和全栈工程师、软件架构师、数据工程师和网站可靠性工程师。如图 5 所示，参与人数最多的是后端开发工程师。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-5-人口统计学数据&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 5. 人口统计学数据&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_6fc1f3923bd515b4cb18185818326384.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_ca77edf6b3ca05bf5b1d10acd1c83280.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f5_hud694102797a2daf59095aa51e0491a3e_41428_6fc1f3923bd515b4cb18185818326384.webp&#34;
               width=&#34;760&#34;
               height=&#34;424&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 5. 人口统计学数据
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;第一个问题是关于 饱和信号。基本上，使用了两个仪表盘——一个折线图和一个城市隐喻来询问五个微服务的状态：&lt;code&gt;ms_authentication&lt;/code&gt;、&lt;code&gt;ms_patients&lt;/code&gt;、&lt;code&gt;ms_payments&lt;/code&gt;、&lt;code&gt;ms_medications&lt;/code&gt; 和 &lt;code&gt;ms_appointments&lt;/code&gt;。这些微服务是一个虚构的医疗系统的一部分。&lt;/p&gt;
&lt;p&gt;具体来说，问题是：使用传统的仪表板（见图 6）和视觉隐喻（见图 7），哪个微服务受到影响？正确答案是 &lt;code&gt;ms_authentication&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-6-传统的折线图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 6. 传统的折线图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1ee9e729212ec6cb4d9f654db74dd193.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_13da0e1ea8b702da78230414f4c32386.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f6_hu5590d6aeee985513de58bd4f08a66814_30036_1ee9e729212ec6cb4d9f654db74dd193.webp&#34;
               width=&#34;760&#34;
               height=&#34;470&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 6. 传统的折线图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-7-可视化的城市比喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 7. 可视化的城市比喻&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_849a632ac66913cbb50b1d54977118c9.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_f5caa61c40cac053a9e8748f658fc86b.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f7_hu06c9486b33bb5f5571cb6cfa8753345a_53008_849a632ac66913cbb50b1d54977118c9.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 7. 可视化的城市比喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;如图 8 所示，当他们使用视觉隐喻时，一些参与者的答案改变了，选择了正确的答案。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-8-使用传统图表与视觉隐喻的参与者的回答&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 8. 使用传统图表与视觉隐喻的参与者的回答&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_ca0ae0f9fd58663980ac08bb34025b9a.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_179f3b49e5d007a9cd7dd4c0e446ddbe.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f8_hu5bcc871e02eba00554a68ce49cf38a36_18330_ca0ae0f9fd58663980ac08bb34025b9a.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 8. 使用传统图表与视觉隐喻的参与者的回答
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;所有参与者都认为，受 CPU 高利用率影响的微服务是认证。在这种情况下，视觉隐喻比传统的图表更有用，因为图表线很混乱，而且颜色、形状和大小都不好，改变了参与者的看法。&lt;/p&gt;
&lt;p&gt;关于错误信号，我们用经典的柱状图和树状图来要求参与者计算每个微服务的平均错误，如图 9 所示。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-9-用于可视化误差的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 9. 用于可视化误差的传统柱状图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_971d7e48c9f2a61b10d467821226c341.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_b77ff086fff6e5f915ee9a79adec1483.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f9_hu559d840f31751b1167744030403ab852_30166_971d7e48c9f2a61b10d467821226c341.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 9. 用于可视化误差的传统柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-10-用于可视化错误的可视化树状图隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 10. 用于可视化错误的可视化树状图隐喻&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_ddc62a921dc2aff3227ae56fdc16329d.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_fb541186e99cf3cc9b08ae4cfe7f652b.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f10_hua3195c7c96c70dd3c846b12d78cb14a9_18716_ddc62a921dc2aff3227ae56fdc16329d.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 10. 用于可视化错误的可视化树状图隐喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;正确的答案是 &lt;code&gt;ms_appointments&lt;/code&gt;，虽然有些参与者没有选择它，但当他们使用视觉隐喻时，许多人改变了他们的答案。图 11 说明了这一点。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-11-参与者使用传统图表与视觉隐喻来可视化错误的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 11. 参与者使用传统图表与视觉隐喻来可视化错误的答案&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1872b7f97e3073fc67fc96da84d3ebef.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_9eeb70bde9ec5d18ae643d93f31f345f.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f11_hufb52c87f4f746414a891e3a6678ca879_17740_1872b7f97e3073fc67fc96da84d3ebef.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 11. 参与者使用传统图表与视觉隐喻来可视化错误的答案
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;关于流量信号，我们用一个经典的柱状图和一个地理中心的隐喻来询问参与者哪个第三方服务的流量更大。在这种情况下，原有的微服务和新的四个第三方服务：&lt;code&gt;srv_ldap&lt;/code&gt;、&lt;code&gt;srv_goverment&lt;/code&gt;、&lt;code&gt;srv_assurance&lt;/code&gt; 和 &lt;code&gt;srv_authentication&lt;/code&gt; 之间的互动被分析了。图 12 用柱状图显示了这种整合，图 13 用地理中心的隐喻显示了相同的流量值。在这个比喻中，圆圈代表服务和微服务，线条连接它们之间的关系。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-12-用于可视化微服务和第三方服务之间流量的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 12. 用于可视化微服务和第三方服务之间流量的传统柱状图&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_6dd60bbb299279159e708431f5278dc5.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_5e76b95d1820fd6044312887fa31e2e6.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f12_hu1e2b96f432e1eb414b09ea0182bcbb6b_16406_6dd60bbb299279159e708431f5278dc5.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 12. 用于可视化微服务和第三方服务之间流量的传统柱状图
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-13-用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 13. 用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_dd7b9d20afbc634fbd73d38f1b50ac84.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_fc95584fa2e09b78c209d0382eebdaa5.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f13_hua57f5e5c08bf33cf890b28d0bdfb0e25_21180_dd7b9d20afbc634fbd73d38f1b50ac84.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 13. 用于可视化微服务和第三方服务之间流量的可视化地理中心隐喻
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;尽管有线条和大小来代表微服务和第三方服务之间的连接和流量负载，但这个比喻对参与者来说是混乱的。圆圈的大小可能与 &lt;code&gt;srv_ldap&lt;/code&gt; 的最小百分比有关，而 &lt;code&gt;srv_ldap&lt;/code&gt; 是正确的答案，它在饼中由绿色部分表示（见图 14）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-14-参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 14. 参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_775bfa66179990f0526e69b01cceb5a9.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_5f79a6e8736454681951a1a343353fde.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f14_hu1b3794456f447f451be1b6c121834963_14664_775bfa66179990f0526e69b01cceb5a9.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 14. 参与者使用传统图表与视觉隐喻对微服务和第三方服务之间的流量进行可视化的答案。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;最后，我们用柱状图的视觉化和仪表的比喻来分析&lt;strong&gt;延迟信号&lt;/strong&gt;。图 15 和图 16 分别说明了这两种可视化方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-15-用于可视化延迟信号的传统柱状图&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 15. 用于可视化延迟信号的传统柱状图。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_a7a2aa61d99536a844016d68f20d893e.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_4e9ed215760e368102e54b9329ea069e.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f15_hu6c80e74a88a6647574d6d6d203cf39b3_12496_a7a2aa61d99536a844016d68f20d893e.webp&#34;
               width=&#34;760&#34;
               height=&#34;570&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 15. 用于可视化延迟信号的传统柱状图。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-16-用于可视化微服务的延迟的可视化仪表隐喻&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 16. 用于可视化微服务的延迟的可视化仪表隐喻。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_2ca0bbcf6f7b32d0e1594dd7c8ba72ac.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_b5edc29fe68b56aa6464afa5dbba7c14.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f16_hu4d6fbb306e89aee71862c91585351943_13066_2ca0bbcf6f7b32d0e1594dd7c8ba72ac.webp&#34;
               width=&#34;500&#34;
               height=&#34;375&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 16. 用于可视化微服务的延迟的可视化仪表隐喻。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;对于这种情况，这个隐喻肯定没有为参与者提供价值，因为正确的答案是 &lt;code&gt;ms_patients&lt;/code&gt;，这在图 17 中有说明。&lt;/p&gt;
&lt;p&gt;















&lt;figure  id=&#34;figure-图-17-参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;图 17. 参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案。&#34; srcset=&#34;
               /blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_e9e4644b5b090d4ff1d18293e733753e.webp 400w,
               /blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_b34fee8578d57da90b06724ec34cabfd.webp 760w,
               /blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_1200x1200_fit_q75_h2_lanczos_2.webp 1200w&#34;
               src=&#34;https://lib.jimmysong.io/blog/chaos-engineering-observability-visual-metaphors/f17_huf3269a68215f055f9e1d893057adf56a_15438_e9e4644b5b090d4ff1d18293e733753e.webp&#34;
               width=&#34;760&#34;
               height=&#34;320&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      图 17. 参与者使用传统图表与视觉隐喻来可视化微服务和第三方服务之间的延迟的答案。
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;引入视觉隐喻的结论&#34;&gt;引入视觉隐喻的结论&lt;/h2&gt;
&lt;p&gt;混沌的可视化，特别是生产事故的可视化，给专注于可观测性的工业和学术界带来了一些挑战。正如我们在这篇文章中所展示的，由于混沌工程、可观测性和可视化涉及到人与机器的互动，解释中的偏差是一个持续的风险。通过一项研究，28 位工程师回答了与经典仪表盘和视觉隐喻有关的 12 个问题，可以得出结论，可观测性不仅受到这些信号的数量和质量的限制，而且受到这些信号的可视化和解释方式的限制。结论是，视觉隐喻可能比传统的仪表盘表现得更好，然而，由于两者都涉及到人，所以都不能保证操作人员以正确的方式解释事故中的数据。&lt;/p&gt;
&lt;h2 id=&#34;有兴趣了解更多关于混沌工程中的可观测性吗&#34;&gt;有兴趣了解更多关于混沌工程中的可观测性吗？&lt;/h2&gt;
&lt;p&gt;我想推荐这三本书。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我的第一个推荐是 Russ Miles 的《&lt;a href=&#34;https://www.humio.com/chaos-observability/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程可观测性&lt;/a&gt;》一书。在这本书中，作者演示了如何将你的混沌实验带入系统可观测性的世界。混沌可观测性能够使整个系统的混沌实验实时地浮现、调试和可视化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个很好的参考是 Charity Majors、Liz Fong-Jones 和 George
Miranda 的《&lt;a href=&#34;https://learning.oreilly.com/library/view/observability-engineering/9781492076438/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;可观测性工程&lt;/a&gt;》一书，他们在一家名为 Honeycomb 的公司工作，正是专门从事可观测性的工作。我喜欢这本书，因为在书中，可观测性被当作一个工程领域。如你所知，可观测性对于工程、管理和改进复杂的关键业务系统至关重要，所以它应该被视为一门学科，甚至是一个组织内部的角色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，我想提到一本专注于 &lt;a href=&#34;https://www.manning.com/books/chaos-engineering&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;混沌工程&lt;/a&gt; 的参考书。我说的是 Mikolaj
Pawlikowski 的一本实用书，由曼宁公司出版。该书记录了模拟现实生活中的失败的实验室和实际实验。作者通过学习像混沌工程师那样思考，最大限度地发挥了混沌工程的优势，提供了涵盖整个软件领域的例子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
